{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar counterRegex = require('../../lib/regex').counter;\n\nvar domainAttrs = require('../../plots/domain').attributes;\n\nvar cartesianIdRegex = require('../../plots/cartesian/constants').idRegex;\n\nvar Template = require('../../plot_api/plot_template');\n\nvar gridAttrs = {\n  rows: {\n    valType: 'integer',\n    min: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['The number of rows in the grid. If you provide a 2D `subplots`', 'array or a `yaxes` array, its length is used as the default.', 'But it\\'s also possible to have a different length, if you', 'want to leave a row at the end for non-cartesian subplots.'].join(' ')\n  },\n  roworder: {\n    valType: 'enumerated',\n    values: ['top to bottom', 'bottom to top'],\n    dflt: 'top to bottom',\n    role: 'info',\n    editType: 'plot',\n    description: ['Is the first row the top or the bottom? Note that columns', 'are always enumerated from left to right.'].join(' ')\n  },\n  columns: {\n    valType: 'integer',\n    min: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['The number of columns in the grid. If you provide a 2D `subplots`', 'array, the length of its longest row is used as the default.', 'If you give an `xaxes` array, its length is used as the default.', 'But it\\'s also possible to have a different length, if you', 'want to leave a row at the end for non-cartesian subplots.'].join(' ')\n  },\n  subplots: {\n    valType: 'info_array',\n    freeLength: true,\n    dimensions: 2,\n    items: {\n      valType: 'enumerated',\n      values: [counterRegex('xy').toString(), ''],\n      editType: 'plot'\n    },\n    role: 'info',\n    editType: 'plot',\n    description: ['Used for freeform grids, where some axes may be shared across subplots', 'but others are not. Each entry should be a cartesian subplot id, like', '*xy* or *x3y2*, or ** to leave that cell empty. You may reuse x axes', 'within the same column, and y axes within the same row.', 'Non-cartesian subplots and traces that support `domain` can place themselves', 'in this grid separately using the `gridcell` attribute.'].join(' ')\n  },\n  xaxes: {\n    valType: 'info_array',\n    freeLength: true,\n    items: {\n      valType: 'enumerated',\n      values: [cartesianIdRegex.x.toString(), ''],\n      editType: 'plot'\n    },\n    role: 'info',\n    editType: 'plot',\n    description: ['Used with `yaxes` when the x and y axes are shared across columns and rows.', 'Each entry should be an x axis id like *x*, *x2*, etc., or ** to', 'not put an x axis in that column. Entries other than ** must be unique.', 'Ignored if `subplots` is present. If missing but `yaxes` is present,', 'will generate consecutive IDs.'].join(' ')\n  },\n  yaxes: {\n    valType: 'info_array',\n    freeLength: true,\n    items: {\n      valType: 'enumerated',\n      values: [cartesianIdRegex.y.toString(), ''],\n      editType: 'plot'\n    },\n    role: 'info',\n    editType: 'plot',\n    description: ['Used with `yaxes` when the x and y axes are shared across columns and rows.', 'Each entry should be an y axis id like *y*, *y2*, etc., or ** to', 'not put a y axis in that row. Entries other than ** must be unique.', 'Ignored if `subplots` is present. If missing but `xaxes` is present,', 'will generate consecutive IDs.'].join(' ')\n  },\n  pattern: {\n    valType: 'enumerated',\n    values: ['independent', 'coupled'],\n    dflt: 'coupled',\n    role: 'info',\n    editType: 'plot',\n    description: ['If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`,', 'we can generate defaults using consecutive axis IDs, in two ways:', '*coupled* gives one x axis per column and one y axis per row.', '*independent* uses a new xy pair for each cell, left-to-right across each row', 'then iterating rows according to `roworder`.'].join(' ')\n  },\n  xgap: {\n    valType: 'number',\n    min: 0,\n    max: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['Horizontal space between grid cells, expressed as a fraction', 'of the total width available to one cell. Defaults to 0.1', 'for coupled-axes grids and 0.2 for independent grids.'].join(' ')\n  },\n  ygap: {\n    valType: 'number',\n    min: 0,\n    max: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['Vertical space between grid cells, expressed as a fraction', 'of the total height available to one cell. Defaults to 0.1', 'for coupled-axes grids and 0.3 for independent grids.'].join(' ')\n  },\n  domain: domainAttrs({\n    name: 'grid',\n    editType: 'plot',\n    noGridCell: true\n  }, {\n    description: ['The first and last cells end exactly at the domain', 'edges, with no grout around the edges.'].join(' ')\n  }),\n  xside: {\n    valType: 'enumerated',\n    values: ['bottom', 'bottom plot', 'top plot', 'top'],\n    dflt: 'bottom plot',\n    role: 'info',\n    editType: 'plot',\n    description: ['Sets where the x axis labels and titles go. *bottom* means', 'the very bottom of the grid. *bottom plot* is the lowest plot', 'that each x axis is used in. *top* and *top plot* are similar.'].join(' ')\n  },\n  yside: {\n    valType: 'enumerated',\n    values: ['left', 'left plot', 'right plot', 'right'],\n    dflt: 'left plot',\n    role: 'info',\n    editType: 'plot',\n    description: ['Sets where the y axis labels and titles go. *left* means', 'the very left edge of the grid. *left plot* is the leftmost plot', 'that each y axis is used in. *right* and *right plot* are similar.'].join(' ')\n  },\n  editType: 'plot'\n};\n\nfunction getAxes(layout, grid, axLetter) {\n  var gridVal = grid[axLetter + 'axes'];\n  var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});\n  if (Array.isArray(gridVal)) return gridVal;\n  if (splomVal.length) return splomVal;\n} // the shape of the grid - this needs to be done BEFORE supplyDataDefaults\n// so that non-subplot traces can place themselves in the grid\n\n\nfunction sizeDefaults(layoutIn, layoutOut) {\n  var gridIn = layoutIn.grid || {};\n  var xAxes = getAxes(layoutOut, gridIn, 'x');\n  var yAxes = getAxes(layoutOut, gridIn, 'y');\n  if (!layoutIn.grid && !xAxes && !yAxes) return;\n  var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);\n  var hasXaxes = Array.isArray(xAxes);\n  var hasYaxes = Array.isArray(yAxes);\n  var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;\n  var dfltRows, dfltColumns;\n\n  if (hasSubplotGrid) {\n    dfltRows = gridIn.subplots.length;\n    dfltColumns = gridIn.subplots[0].length;\n  } else {\n    if (hasYaxes) dfltRows = yAxes.length;\n    if (hasXaxes) dfltColumns = xAxes.length;\n  }\n\n  var gridOut = Template.newContainer(layoutOut, 'grid');\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);\n  }\n\n  var rows = coerce('rows', dfltRows);\n  var columns = coerce('columns', dfltColumns);\n\n  if (!(rows * columns > 1)) {\n    delete layoutOut.grid;\n    return;\n  }\n\n  if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {\n    var useDefaultSubplots = coerce('pattern') === 'independent';\n    if (useDefaultSubplots) hasSubplotGrid = true;\n  }\n\n  gridOut._hasSubplotGrid = hasSubplotGrid;\n  var rowOrder = coerce('roworder');\n  var reversed = rowOrder === 'top to bottom';\n  var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;\n  var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;\n  var dfltSideX, dfltSideY;\n\n  if (isSplomGenerated && layoutOut._splomGridDflt) {\n    dfltSideX = layoutOut._splomGridDflt.xside;\n    dfltSideY = layoutOut._splomGridDflt.yside;\n  }\n\n  gridOut._domains = {\n    x: fillGridPositions('x', coerce, dfltGapX, dfltSideX, columns),\n    y: fillGridPositions('y', coerce, dfltGapY, dfltSideY, rows, reversed)\n  };\n} // coerce x or y sizing attributes and return an array of domains for this direction\n\n\nfunction fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {\n  var dirGap = coerce(axLetter + 'gap', dfltGap);\n  var domain = coerce('domain.' + axLetter);\n  coerce(axLetter + 'side', dfltSide);\n  var out = new Array(len);\n  var start = domain[0];\n  var step = (domain[1] - start) / (len - dirGap);\n  var cellDomain = step * (1 - dirGap);\n\n  for (var i = 0; i < len; i++) {\n    var cellStart = start + step * i;\n    out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];\n  }\n\n  return out;\n} // the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults\n// so that we know what cartesian subplots are available\n\n\nfunction contentDefaults(layoutIn, layoutOut) {\n  var gridOut = layoutOut.grid; // make sure we got to the end of handleGridSizing\n\n  if (!gridOut || !gridOut._domains) return;\n  var gridIn = layoutIn.grid || {};\n  var subplots = layoutOut._subplots;\n  var hasSubplotGrid = gridOut._hasSubplotGrid;\n  var rows = gridOut.rows;\n  var columns = gridOut.columns;\n  var useDefaultSubplots = gridOut.pattern === 'independent';\n  var i, j, xId, yId, subplotId, subplotsOut, yPos;\n  var axisMap = gridOut._axisMap = {};\n\n  if (hasSubplotGrid) {\n    var subplotsIn = gridIn.subplots || [];\n    subplotsOut = gridOut.subplots = new Array(rows);\n    var index = 1;\n\n    for (i = 0; i < rows; i++) {\n      var rowOut = subplotsOut[i] = new Array(columns);\n      var rowIn = subplotsIn[i] || [];\n\n      for (j = 0; j < columns; j++) {\n        if (useDefaultSubplots) {\n          subplotId = index === 1 ? 'xy' : 'x' + index + 'y' + index;\n          index++;\n        } else subplotId = rowIn[j];\n\n        rowOut[j] = '';\n\n        if (subplots.cartesian.indexOf(subplotId) !== -1) {\n          yPos = subplotId.indexOf('y');\n          xId = subplotId.slice(0, yPos);\n          yId = subplotId.slice(yPos);\n\n          if (axisMap[xId] !== undefined && axisMap[xId] !== j || axisMap[yId] !== undefined && axisMap[yId] !== i) {\n            continue;\n          }\n\n          rowOut[j] = subplotId;\n          axisMap[xId] = j;\n          axisMap[yId] = i;\n        }\n      }\n    }\n  } else {\n    var xAxes = getAxes(layoutOut, gridIn, 'x');\n    var yAxes = getAxes(layoutOut, gridIn, 'y');\n    gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, 'x');\n    gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, 'y');\n  }\n\n  var anchors = gridOut._anchors = {};\n  var reversed = gridOut.roworder === 'top to bottom';\n\n  for (var axisId in axisMap) {\n    var axLetter = axisId.charAt(0);\n    var side = gridOut[axLetter + 'side'];\n    var i0, inc, iFinal;\n\n    if (side.length < 8) {\n      // grid edge -  ie not \"* plot\" - make these as free axes\n      // since we're not guaranteed to have a subplot there at all\n      anchors[axisId] = 'free';\n    } else if (axLetter === 'x') {\n      if (side.charAt(0) === 't' === reversed) {\n        i0 = 0;\n        inc = 1;\n        iFinal = rows;\n      } else {\n        i0 = rows - 1;\n        inc = -1;\n        iFinal = -1;\n      }\n\n      if (hasSubplotGrid) {\n        var column = axisMap[axisId];\n\n        for (i = i0; i !== iFinal; i += inc) {\n          subplotId = subplotsOut[i][column];\n          if (!subplotId) continue;\n          yPos = subplotId.indexOf('y');\n\n          if (subplotId.slice(0, yPos) === axisId) {\n            anchors[axisId] = subplotId.slice(yPos);\n            break;\n          }\n        }\n      } else {\n        for (i = i0; i !== iFinal; i += inc) {\n          yId = gridOut.yaxes[i];\n\n          if (subplots.cartesian.indexOf(axisId + yId) !== -1) {\n            anchors[axisId] = yId;\n            break;\n          }\n        }\n      }\n    } else {\n      if (side.charAt(0) === 'l') {\n        i0 = 0;\n        inc = 1;\n        iFinal = columns;\n      } else {\n        i0 = columns - 1;\n        inc = -1;\n        iFinal = -1;\n      }\n\n      if (hasSubplotGrid) {\n        var row = axisMap[axisId];\n\n        for (i = i0; i !== iFinal; i += inc) {\n          subplotId = subplotsOut[row][i];\n          if (!subplotId) continue;\n          yPos = subplotId.indexOf('y');\n\n          if (subplotId.slice(yPos) === axisId) {\n            anchors[axisId] = subplotId.slice(0, yPos);\n            break;\n          }\n        }\n      } else {\n        for (i = i0; i !== iFinal; i += inc) {\n          xId = gridOut.xaxes[i];\n\n          if (subplots.cartesian.indexOf(xId + axisId) !== -1) {\n            anchors[axisId] = xId;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {\n  var out = new Array(len);\n  var i;\n\n  function fillOneAxis(i, axisId) {\n    if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === undefined) {\n      out[i] = axisId;\n      axisMap[axisId] = i;\n    } else out[i] = '';\n  }\n\n  if (Array.isArray(axesIn)) {\n    for (i = 0; i < len; i++) {\n      fillOneAxis(i, axesIn[i]);\n    }\n  } else {\n    // default axis list is the first `len` axis ids\n    fillOneAxis(0, axLetter);\n\n    for (i = 1; i < len; i++) {\n      fillOneAxis(i, axLetter + (i + 1));\n    }\n  }\n\n  return out;\n}\n\nmodule.exports = {\n  moduleType: 'component',\n  name: 'grid',\n  schema: {\n    layout: {\n      grid: gridAttrs\n    }\n  },\n  layoutAttributes: gridAttrs,\n  sizeDefaults: sizeDefaults,\n  contentDefaults: contentDefaults\n};","map":null,"metadata":{},"sourceType":"script"}