{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar interactConstants = require('../../constants/interactions');\n\nvar OPPOSITE_SIDE = require('../../constants/alignment').OPPOSITE_SIDE;\n\nvar numStripRE = / [XY][0-9]* /;\n/**\n * Titles - (re)draw titles on the axes and plot:\n * @param {DOM element} gd - the graphDiv\n * @param {string} titleClass - the css class of this title\n * @param {object} options - how and what to draw\n *      propContainer - the layout object containing `title` and `titlefont`\n *          attributes that apply to this title\n *      propName - the full name of the title property (for Plotly.relayout)\n *      [traceIndex] - include only if this property applies to one trace\n *          (such as a colorbar title) - then editing pipes to Plotly.restyle\n *          instead of Plotly.relayout\n *      placeholder - placeholder text for an empty editable title\n *      [avoid] {object} - include if this title should move to avoid other elements\n *          selection - d3 selection of elements to avoid\n *          side - which direction to move if there is a conflict\n *          [offsetLeft] - if these elements are subject to a translation\n *              wrt the title element\n *          [offsetTop]\n *      attributes {object} - position and alignment attributes\n *          x - pixels\n *          y - pixels\n *          text-anchor - start|middle|end\n *      transform {object} - how to transform the title after positioning\n *          rotate - degrees\n *          offset - shift up/down in the rotated frame (unused?)\n *      containerGroup - if an svg <g> element already exists to hold this\n *          title, include here. Otherwise it will go in fullLayout._infolayer\n *      _meta {object (optional} - meta key-value to for title with\n *          Lib.templateString, default to fullLayout._meta, if not provided\n *\n *  @return {selection} d3 selection of title container group\n */\n\nfunction draw(gd, titleClass, options) {\n  var cont = options.propContainer;\n  var prop = options.propName;\n  var placeholder = options.placeholder;\n  var traceIndex = options.traceIndex;\n  var avoid = options.avoid || {};\n  var attributes = options.attributes;\n  var transform = options.transform;\n  var group = options.containerGroup;\n  var fullLayout = gd._fullLayout;\n  var opacity = 1;\n  var isplaceholder = false;\n  var title = cont.title;\n  var txt = (title && title.text ? title.text : '').trim();\n  var font = title && title.font ? title.font : {};\n  var fontFamily = font.family;\n  var fontSize = font.size;\n  var fontColor = font.color; // only make this title editable if we positively identify its property\n  // as one that has editing enabled.\n\n  var editAttr;\n  if (prop === 'title.text') editAttr = 'titleText';else if (prop.indexOf('axis') !== -1) editAttr = 'axisTitleText';else if (prop.indexOf('colorbar' !== -1)) editAttr = 'colorbarTitleText';\n  var editable = gd._context.edits[editAttr];\n  if (txt === '') opacity = 0; // look for placeholder text while stripping out numbers from eg X2, Y3\n  // this is just for backward compatibility with the old version that had\n  // \"Click to enter X2 title\" and may have gotten saved in some old plots,\n  // we don't want this to show up when these are displayed.\n  else if (txt.replace(numStripRE, ' % ') === placeholder.replace(numStripRE, ' % ')) {\n      opacity = 0.2;\n      isplaceholder = true;\n      if (!editable) txt = '';\n    }\n\n  if (options._meta) {\n    txt = Lib.templateString(txt, options._meta);\n  } else if (fullLayout._meta) {\n    txt = Lib.templateString(txt, fullLayout._meta);\n  }\n\n  var elShouldExist = txt || editable;\n\n  if (!group) {\n    group = Lib.ensureSingle(fullLayout._infolayer, 'g', 'g-' + titleClass);\n  }\n\n  var el = group.selectAll('text').data(elShouldExist ? [0] : []);\n  el.enter().append('text');\n  el.text(txt) // this is hacky, but convertToTspans uses the class\n  // to determine whether to rotate mathJax...\n  // so we need to clear out any old class and put the\n  // correct one (only relevant for colorbars, at least\n  // for now) - ie don't use .classed\n  .attr('class', titleClass);\n  el.exit().remove();\n  if (!elShouldExist) return group;\n\n  function titleLayout(titleEl) {\n    Lib.syncOrAsync([drawTitle, scootTitle], titleEl);\n  }\n\n  function drawTitle(titleEl) {\n    var transformVal;\n\n    if (transform) {\n      transformVal = '';\n\n      if (transform.rotate) {\n        transformVal += 'rotate(' + [transform.rotate, attributes.x, attributes.y] + ')';\n      }\n\n      if (transform.offset) {\n        transformVal += 'translate(0, ' + transform.offset + ')';\n      }\n    } else {\n      transformVal = null;\n    }\n\n    titleEl.attr('transform', transformVal);\n    titleEl.style({\n      'font-family': fontFamily,\n      'font-size': d3.round(fontSize, 2) + 'px',\n      fill: Color.rgb(fontColor),\n      opacity: opacity * Color.opacity(fontColor),\n      'font-weight': Plots.fontWeight\n    }).attr(attributes).call(svgTextUtils.convertToTspans, gd);\n    return Plots.previousPromises(gd);\n  }\n\n  function scootTitle(titleElIn) {\n    var titleGroup = d3.select(titleElIn.node().parentNode);\n\n    if (avoid && avoid.selection && avoid.side && txt) {\n      titleGroup.attr('transform', null); // move toward avoid.side (= left, right, top, bottom) if needed\n      // can include pad (pixels, default 2)\n\n      var backside = OPPOSITE_SIDE[avoid.side];\n      var shiftSign = avoid.side === 'left' || avoid.side === 'top' ? -1 : 1;\n      var pad = isNumeric(avoid.pad) ? avoid.pad : 2;\n      var titlebb = Drawing.bBox(titleGroup.node());\n      var paperbb = {\n        left: 0,\n        top: 0,\n        right: fullLayout.width,\n        bottom: fullLayout.height\n      };\n      var maxshift = avoid.maxShift || shiftSign * (paperbb[avoid.side] - titlebb[avoid.side]);\n      var shift = 0; // Prevent the title going off the paper\n\n      if (maxshift < 0) {\n        shift = maxshift;\n      } else {\n        // so we don't have to offset each avoided element,\n        // give the title the opposite offset\n        var offsetLeft = avoid.offsetLeft || 0;\n        var offsetTop = avoid.offsetTop || 0;\n        titlebb.left -= offsetLeft;\n        titlebb.right -= offsetLeft;\n        titlebb.top -= offsetTop;\n        titlebb.bottom -= offsetTop; // iterate over a set of elements (avoid.selection)\n        // to avoid collisions with\n\n        avoid.selection.each(function () {\n          var avoidbb = Drawing.bBox(this);\n\n          if (Lib.bBoxIntersect(titlebb, avoidbb, pad)) {\n            shift = Math.max(shift, shiftSign * (avoidbb[avoid.side] - titlebb[backside]) + pad);\n          }\n        });\n        shift = Math.min(maxshift, shift);\n      }\n\n      if (shift > 0 || maxshift < 0) {\n        var shiftTemplate = {\n          left: [-shift, 0],\n          right: [shift, 0],\n          top: [0, -shift],\n          bottom: [0, shift]\n        }[avoid.side];\n        titleGroup.attr('transform', 'translate(' + shiftTemplate + ')');\n      }\n    }\n  }\n\n  el.call(titleLayout);\n\n  function setPlaceholder() {\n    opacity = 0;\n    isplaceholder = true;\n    el.text(placeholder).on('mouseover.opacity', function () {\n      d3.select(this).transition().duration(interactConstants.SHOW_PLACEHOLDER).style('opacity', 1);\n    }).on('mouseout.opacity', function () {\n      d3.select(this).transition().duration(interactConstants.HIDE_PLACEHOLDER).style('opacity', 0);\n    });\n  }\n\n  if (editable) {\n    if (!txt) setPlaceholder();else el.on('.opacity', null);\n    el.call(svgTextUtils.makeEditable, {\n      gd: gd\n    }).on('edit', function (text) {\n      if (traceIndex !== undefined) {\n        Registry.call('_guiRestyle', gd, prop, text, traceIndex);\n      } else {\n        Registry.call('_guiRelayout', gd, prop, text);\n      }\n    }).on('cancel', function () {\n      this.text(this.attr('data-unformatted')).call(titleLayout);\n    }).on('input', function (d) {\n      this.text(d || ' ').call(svgTextUtils.positionText, attributes.x, attributes.y);\n    });\n  }\n\n  el.classed('js-placeholder', isplaceholder);\n  return group;\n}\n\nmodule.exports = {\n  draw: draw\n};","map":null,"metadata":{},"sourceType":"script"}