{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Drawing = require('../drawing');\n\nvar subTypes = require('../../traces/scatter/subtypes');\n\nmodule.exports = function plot(gd, traces, plotinfo, transitionOpts) {\n  var isNew;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var hasAnimation = transitionOpts && transitionOpts.duration > 0;\n  traces.each(function (d) {\n    var trace = d[0].trace; // || {} is in case the trace (specifically scatterternary)\n    // doesn't support error bars at all, but does go through\n    // the scatter.plot mechanics, which calls ErrorBars.plot\n    // internally\n\n    var xObj = trace.error_x || {};\n    var yObj = trace.error_y || {};\n    var keyFunc;\n\n    if (trace.ids) {\n      keyFunc = function (d) {\n        return d.id;\n      };\n    }\n\n    var sparse = subTypes.hasMarkers(trace) && trace.marker.maxdisplayed > 0;\n    if (!yObj.visible && !xObj.visible) d = [];\n    var errorbars = d3.select(this).selectAll('g.errorbar').data(d, keyFunc);\n    errorbars.exit().remove();\n    if (!d.length) return;\n    if (!xObj.visible) errorbars.selectAll('path.xerror').remove();\n    if (!yObj.visible) errorbars.selectAll('path.yerror').remove();\n    errorbars.style('opacity', 1);\n    var enter = errorbars.enter().append('g').classed('errorbar', true);\n\n    if (hasAnimation) {\n      enter.style('opacity', 0).transition().duration(transitionOpts.duration).style('opacity', 1);\n    }\n\n    Drawing.setClipUrl(errorbars, plotinfo.layerClipId, gd);\n    errorbars.each(function (d) {\n      var errorbar = d3.select(this);\n      var coords = errorCoords(d, xa, ya);\n      if (sparse && !d.vis) return;\n      var path;\n      var yerror = errorbar.select('path.yerror');\n\n      if (yObj.visible && isNumeric(coords.x) && isNumeric(coords.yh) && isNumeric(coords.ys)) {\n        var yw = yObj.width;\n        path = 'M' + (coords.x - yw) + ',' + coords.yh + 'h' + 2 * yw + // hat\n        'm-' + yw + ',0V' + coords.ys; // bar\n\n        if (!coords.noYS) path += 'm-' + yw + ',0h' + 2 * yw; // shoe\n\n        isNew = !yerror.size();\n\n        if (isNew) {\n          yerror = errorbar.append('path').style('vector-effect', 'non-scaling-stroke').classed('yerror', true);\n        } else if (hasAnimation) {\n          yerror = yerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);\n        }\n\n        yerror.attr('d', path);\n      } else yerror.remove();\n\n      var xerror = errorbar.select('path.xerror');\n\n      if (xObj.visible && isNumeric(coords.y) && isNumeric(coords.xh) && isNumeric(coords.xs)) {\n        var xw = (xObj.copy_ystyle ? yObj : xObj).width;\n        path = 'M' + coords.xh + ',' + (coords.y - xw) + 'v' + 2 * xw + // hat\n        'm0,-' + xw + 'H' + coords.xs; // bar\n\n        if (!coords.noXS) path += 'm0,-' + xw + 'v' + 2 * xw; // shoe\n\n        isNew = !xerror.size();\n\n        if (isNew) {\n          xerror = errorbar.append('path').style('vector-effect', 'non-scaling-stroke').classed('xerror', true);\n        } else if (hasAnimation) {\n          xerror = xerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);\n        }\n\n        xerror.attr('d', path);\n      } else xerror.remove();\n    });\n  });\n}; // compute the coordinates of the error-bar objects\n\n\nfunction errorCoords(d, xa, ya) {\n  var out = {\n    x: xa.c2p(d.x),\n    y: ya.c2p(d.y)\n  }; // calculate the error bar size and hat and shoe locations\n\n  if (d.yh !== undefined) {\n    out.yh = ya.c2p(d.yh);\n    out.ys = ya.c2p(d.ys); // if the shoes go off-scale (ie log scale, error bars past zero)\n    // clip the bar and hide the shoes\n\n    if (!isNumeric(out.ys)) {\n      out.noYS = true;\n      out.ys = ya.c2p(d.ys, true);\n    }\n  }\n\n  if (d.xh !== undefined) {\n    out.xh = xa.c2p(d.xh);\n    out.xs = xa.c2p(d.xs);\n\n    if (!isNumeric(out.xs)) {\n      out.noXS = true;\n      out.xs = xa.c2p(d.xs, true);\n    }\n  }\n\n  return out;\n}","map":null,"metadata":{},"sourceType":"script"}