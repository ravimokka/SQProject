{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar m4FromQuat = require('gl-mat4/fromQuat');\n\nvar Registry = require('../registry');\n\nvar Lib = require('../lib');\n\nvar Plots = require('../plots/plots');\n\nvar AxisIds = require('../plots/cartesian/axis_ids');\n\nvar Color = require('../components/color');\n\nvar cleanId = AxisIds.cleanId;\nvar getFromTrace = AxisIds.getFromTrace;\nvar traceIs = Registry.traceIs; // clear the promise queue if one of them got rejected\n\nexports.clearPromiseQueue = function (gd) {\n  if (Array.isArray(gd._promises) && gd._promises.length > 0) {\n    Lib.log('Clearing previous rejected promises from queue.');\n  }\n\n  gd._promises = [];\n}; // make a few changes to the layout right away\n// before it gets used for anything\n// backward compatibility and cleanup of nonstandard options\n\n\nexports.cleanLayout = function (layout) {\n  var i, j;\n  if (!layout) layout = {}; // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\n\n  if (layout.xaxis1) {\n    if (!layout.xaxis) layout.xaxis = layout.xaxis1;\n    delete layout.xaxis1;\n  }\n\n  if (layout.yaxis1) {\n    if (!layout.yaxis) layout.yaxis = layout.yaxis1;\n    delete layout.yaxis1;\n  }\n\n  if (layout.scene1) {\n    if (!layout.scene) layout.scene = layout.scene1;\n    delete layout.scene1;\n  }\n\n  var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;\n  var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;\n  var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;\n  var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;\n  var keys = Object.keys(layout);\n\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (axisAttrRegex && axisAttrRegex.test(key)) {\n      // modifications to cartesian axes\n      var ax = layout[key];\n\n      if (ax.anchor && ax.anchor !== 'free') {\n        ax.anchor = cleanId(ax.anchor);\n      }\n\n      if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying); // old method of axis type - isdate and islog (before category existed)\n\n      if (!ax.type) {\n        if (ax.isdate) ax.type = 'date';else if (ax.islog) ax.type = 'log';else if (ax.isdate === false && ax.islog === false) ax.type = 'linear';\n      }\n\n      if (ax.autorange === 'withzero' || ax.autorange === 'tozero') {\n        ax.autorange = true;\n        ax.rangemode = 'tozero';\n      }\n\n      delete ax.islog;\n      delete ax.isdate;\n      delete ax.categories; // replaced by _categories\n      // prune empty domain arrays made before the new nestedProperty\n\n      if (emptyContainer(ax, 'domain')) delete ax.domain; // autotick -> tickmode\n\n      if (ax.autotick !== undefined) {\n        if (ax.tickmode === undefined) {\n          ax.tickmode = ax.autotick ? 'auto' : 'linear';\n        }\n\n        delete ax.autotick;\n      }\n\n      cleanTitle(ax);\n    } else if (polarAttrRegex && polarAttrRegex.test(key)) {\n      // modifications for polar\n      var polar = layout[key];\n      cleanTitle(polar.radialaxis);\n    } else if (ternaryAttrRegex && ternaryAttrRegex.test(key)) {\n      // modifications for ternary\n      var ternary = layout[key];\n      cleanTitle(ternary.aaxis);\n      cleanTitle(ternary.baxis);\n      cleanTitle(ternary.caxis);\n    } else if (sceneAttrRegex && sceneAttrRegex.test(key)) {\n      // modifications for 3D scenes\n      var scene = layout[key]; // clean old Camera coords\n\n      var cameraposition = scene.cameraposition;\n\n      if (Array.isArray(cameraposition) && cameraposition[0].length === 4) {\n        var rotation = cameraposition[0];\n        var center = cameraposition[1];\n        var radius = cameraposition[2];\n        var mat = m4FromQuat([], rotation);\n        var eye = [];\n\n        for (j = 0; j < 3; ++j) {\n          eye[j] = center[j] + radius * mat[2 + 4 * j];\n        }\n\n        scene.camera = {\n          eye: {\n            x: eye[0],\n            y: eye[1],\n            z: eye[2]\n          },\n          center: {\n            x: center[0],\n            y: center[1],\n            z: center[2]\n          },\n          up: {\n            x: 0,\n            y: 0,\n            z: 1 // we just ignore calculating camera z up in this case\n\n          }\n        };\n        delete scene.cameraposition;\n      } // clean axis titles\n\n\n      cleanTitle(scene.xaxis);\n      cleanTitle(scene.yaxis);\n      cleanTitle(scene.zaxis);\n    }\n  }\n\n  var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;\n\n  for (i = 0; i < annotationsLen; i++) {\n    var ann = layout.annotations[i];\n    if (!Lib.isPlainObject(ann)) continue;\n\n    if (ann.ref) {\n      if (ann.ref === 'paper') {\n        ann.xref = 'paper';\n        ann.yref = 'paper';\n      } else if (ann.ref === 'data') {\n        ann.xref = 'x';\n        ann.yref = 'y';\n      }\n\n      delete ann.ref;\n    }\n\n    cleanAxRef(ann, 'xref');\n    cleanAxRef(ann, 'yref');\n  }\n\n  var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;\n\n  for (i = 0; i < shapesLen; i++) {\n    var shape = layout.shapes[i];\n    if (!Lib.isPlainObject(shape)) continue;\n    cleanAxRef(shape, 'xref');\n    cleanAxRef(shape, 'yref');\n  }\n\n  var legend = layout.legend;\n\n  if (legend) {\n    // check for old-style legend positioning (x or y is +/- 100)\n    if (legend.x > 3) {\n      legend.x = 1.02;\n      legend.xanchor = 'left';\n    } else if (legend.x < -2) {\n      legend.x = -0.02;\n      legend.xanchor = 'right';\n    }\n\n    if (legend.y > 3) {\n      legend.y = 1.02;\n      legend.yanchor = 'bottom';\n    } else if (legend.y < -2) {\n      legend.y = -0.02;\n      legend.yanchor = 'top';\n    }\n  } // clean plot title\n\n\n  cleanTitle(layout);\n  /*\n   * Moved from rotate -> orbit for dragmode\n   */\n\n  if (layout.dragmode === 'rotate') layout.dragmode = 'orbit'; // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n  // supported, but new tinycolor does not because they're not valid css\n\n  Color.clean(layout); // clean the layout container in layout.template\n\n  if (layout.template && layout.template.layout) {\n    exports.cleanLayout(layout.template.layout);\n  }\n\n  return layout;\n};\n\nfunction cleanAxRef(container, attr) {\n  var valIn = container[attr];\n  var axLetter = attr.charAt(0);\n\n  if (valIn && valIn !== 'paper') {\n    container[attr] = cleanId(valIn, axLetter);\n  }\n}\n/**\n * Cleans up old title attribute structure (flat) in favor of the new one (nested).\n *\n * @param {Object} titleContainer - an object potentially including deprecated title attributes\n */\n\n\nfunction cleanTitle(titleContainer) {\n  if (titleContainer) {\n    // title -> title.text\n    // (although title used to be a string attribute,\n    // numbers are accepted as well)\n    if (typeof titleContainer.title === 'string' || typeof titleContainer.title === 'number') {\n      titleContainer.title = {\n        text: titleContainer.title\n      };\n    }\n\n    rewireAttr('titlefont', 'font');\n    rewireAttr('titleposition', 'position');\n    rewireAttr('titleside', 'side');\n    rewireAttr('titleoffset', 'offset');\n  }\n\n  function rewireAttr(oldAttrName, newAttrName) {\n    var oldAttrSet = titleContainer[oldAttrName];\n    var newAttrSet = titleContainer.title && titleContainer.title[newAttrName];\n\n    if (oldAttrSet && !newAttrSet) {\n      // Ensure title object exists\n      if (!titleContainer.title) {\n        titleContainer.title = {};\n      }\n\n      titleContainer.title[newAttrName] = titleContainer[oldAttrName];\n      delete titleContainer[oldAttrName];\n    }\n  }\n}\n/*\n * cleanData: Make a few changes to the data for backward compatibility\n * before it gets used for anything. Modifies the data traces users provide.\n *\n * Important: if you're going to add something here that modifies a data array,\n * update it in place so the new array === the old one.\n */\n\n\nexports.cleanData = function (data) {\n  for (var tracei = 0; tracei < data.length; tracei++) {\n    var trace = data[tracei];\n    var i; // use xbins to bin data in x, and ybins to bin data in y\n\n    if (trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {\n      trace.ybins = trace.xbins;\n      delete trace.xbins;\n    } // error_y.opacity is obsolete - merge into color\n\n\n    if (trace.error_y && 'opacity' in trace.error_y) {\n      var dc = Color.defaults;\n      var yeColor = trace.error_y.color || (traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);\n      trace.error_y.color = Color.addOpacity(Color.rgb(yeColor), Color.opacity(yeColor) * trace.error_y.opacity);\n      delete trace.error_y.opacity;\n    } // convert bardir to orientation, and put the data into\n    // the axes it's eventually going to be used with\n\n\n    if ('bardir' in trace) {\n      if (trace.bardir === 'h' && (traceIs(trace, 'bar') || trace.type.substr(0, 9) === 'histogram')) {\n        trace.orientation = 'h';\n        exports.swapXYData(trace);\n      }\n\n      delete trace.bardir;\n    } // now we have only one 1D histogram type, and whether\n    // it uses x or y data depends on trace.orientation\n\n\n    if (trace.type === 'histogramy') exports.swapXYData(trace);\n\n    if (trace.type === 'histogramx' || trace.type === 'histogramy') {\n      trace.type = 'histogram';\n    } // scl->scale, reversescl->reversescale\n\n\n    if ('scl' in trace && !('colorscale' in trace)) {\n      trace.colorscale = trace.scl;\n      delete trace.scl;\n    }\n\n    if ('reversescl' in trace && !('reversescale' in trace)) {\n      trace.reversescale = trace.reversescl;\n      delete trace.reversescl;\n    } // axis ids x1 -> x, y1-> y\n\n\n    if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, 'x');\n    if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, 'y'); // scene ids scene1 -> scene\n\n    if (traceIs(trace, 'gl3d') && trace.scene) {\n      trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);\n    }\n\n    if (!traceIs(trace, 'pie-like') && !traceIs(trace, 'bar-like')) {\n      if (Array.isArray(trace.textposition)) {\n        for (i = 0; i < trace.textposition.length; i++) {\n          trace.textposition[i] = cleanTextPosition(trace.textposition[i]);\n        }\n      } else if (trace.textposition) {\n        trace.textposition = cleanTextPosition(trace.textposition);\n      }\n    } // fix typo in colorscale definition\n\n\n    var _module = Registry.getModule(trace);\n\n    if (_module && _module.colorbar) {\n      var containerName = _module.colorbar.container;\n      var container = containerName ? trace[containerName] : trace;\n\n      if (container && container.colorscale) {\n        if (container.colorscale === 'YIGnBu') container.colorscale = 'YlGnBu';\n        if (container.colorscale === 'YIOrRd') container.colorscale = 'YlOrRd';\n      }\n    } // fix typo in surface 'highlight*' definitions\n\n\n    if (trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {\n      var dims = ['x', 'y', 'z'];\n\n      for (i = 0; i < dims.length; i++) {\n        var opts = trace.contours[dims[i]];\n        if (!Lib.isPlainObject(opts)) continue;\n\n        if (opts.highlightColor) {\n          opts.highlightcolor = opts.highlightColor;\n          delete opts.highlightColor;\n        }\n\n        if (opts.highlightWidth) {\n          opts.highlightwidth = opts.highlightWidth;\n          delete opts.highlightWidth;\n        }\n      }\n    } // fixes from converting finance from transforms to real trace types\n\n\n    if (trace.type === 'candlestick' || trace.type === 'ohlc') {\n      var increasingShowlegend = (trace.increasing || {}).showlegend !== false;\n      var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;\n      var increasingName = cleanFinanceDir(trace.increasing);\n      var decreasingName = cleanFinanceDir(trace.decreasing); // now figure out something smart to do with the separate direction\n      // names we removed\n\n      if (increasingName !== false && decreasingName !== false) {\n        // both sub-names existed: base name previously had no effect\n        // so ignore it and try to find a shared part of the sub-names\n        var newName = commonPrefix(increasingName, decreasingName, increasingShowlegend, decreasingShowlegend); // if no common part, leave whatever name was (or wasn't) there\n\n        if (newName) trace.name = newName;\n      } else if ((increasingName || decreasingName) && !trace.name) {\n        // one sub-name existed but not the base name - just use the sub-name\n        trace.name = increasingName || decreasingName;\n      }\n    } // transforms backward compatibility fixes\n\n\n    if (Array.isArray(trace.transforms)) {\n      var transforms = trace.transforms;\n\n      for (i = 0; i < transforms.length; i++) {\n        var transform = transforms[i];\n        if (!Lib.isPlainObject(transform)) continue;\n\n        switch (transform.type) {\n          case 'filter':\n            if (transform.filtersrc) {\n              transform.target = transform.filtersrc;\n              delete transform.filtersrc;\n            }\n\n            if (transform.calendar) {\n              if (!transform.valuecalendar) {\n                transform.valuecalendar = transform.calendar;\n              }\n\n              delete transform.calendar;\n            }\n\n            break;\n\n          case 'groupby':\n            // Name has changed from `style` to `styles`, so use `style` but prefer `styles`:\n            transform.styles = transform.styles || transform.style;\n\n            if (transform.styles && !Array.isArray(transform.styles)) {\n              var prevStyles = transform.styles;\n              var styleKeys = Object.keys(prevStyles);\n              transform.styles = [];\n\n              for (var j = 0; j < styleKeys.length; j++) {\n                transform.styles.push({\n                  target: styleKeys[j],\n                  value: prevStyles[styleKeys[j]]\n                });\n              }\n            }\n\n            break;\n        }\n      }\n    } // prune empty containers made before the new nestedProperty\n\n\n    if (emptyContainer(trace, 'line')) delete trace.line;\n\n    if ('marker' in trace) {\n      if (emptyContainer(trace.marker, 'line')) delete trace.marker.line;\n      if (emptyContainer(trace, 'marker')) delete trace.marker;\n    } // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n    // supported, but new tinycolor does not because they're not valid css\n\n\n    Color.clean(trace); // remove obsolete autobin(x|y) attributes, but only if true\n    // if false, this needs to happen in Histogram.calc because it\n    // can be a one-time autobin so we need to know the results before\n    // we can push them back into the trace.\n\n    if (trace.autobinx) {\n      delete trace.autobinx;\n      delete trace.xbins;\n    }\n\n    if (trace.autobiny) {\n      delete trace.autobiny;\n      delete trace.ybins;\n    }\n\n    cleanTitle(trace);\n    if (trace.colorbar) cleanTitle(trace.colorbar);\n    if (trace.marker && trace.marker.colorbar) cleanTitle(trace.marker.colorbar);\n    if (trace.line && trace.line.colorbar) cleanTitle(trace.line.colorbar);\n    if (trace.aaxis) cleanTitle(trace.aaxis);\n    if (trace.baxis) cleanTitle(trace.baxis);\n  }\n};\n\nfunction cleanFinanceDir(dirContainer) {\n  if (!Lib.isPlainObject(dirContainer)) return false;\n  var dirName = dirContainer.name;\n  delete dirContainer.name;\n  delete dirContainer.showlegend;\n  return (typeof dirName === 'string' || typeof dirName === 'number') && String(dirName);\n}\n\nfunction commonPrefix(name1, name2, show1, show2) {\n  // if only one is shown in the legend, use that\n  if (show1 && !show2) return name1;\n  if (show2 && !show1) return name2; // if both or neither are in the legend, check if one is blank (or whitespace)\n  // and use the other one\n  // note that hover labels can still use the name even if the legend doesn't\n\n  if (!name1.trim()) return name2;\n  if (!name2.trim()) return name1;\n  var minLen = Math.min(name1.length, name2.length);\n  var i;\n\n  for (i = 0; i < minLen; i++) {\n    if (name1.charAt(i) !== name2.charAt(i)) break;\n  }\n\n  var out = name1.substr(0, i);\n  return out.trim();\n} // textposition - support partial attributes (ie just 'top')\n// and incorrect use of middle / center etc.\n\n\nfunction cleanTextPosition(textposition) {\n  var posY = 'middle';\n  var posX = 'center';\n\n  if (typeof textposition === 'string') {\n    if (textposition.indexOf('top') !== -1) posY = 'top';else if (textposition.indexOf('bottom') !== -1) posY = 'bottom';\n    if (textposition.indexOf('left') !== -1) posX = 'left';else if (textposition.indexOf('right') !== -1) posX = 'right';\n  }\n\n  return posY + ' ' + posX;\n}\n\nfunction emptyContainer(outer, innerStr) {\n  return innerStr in outer && typeof outer[innerStr] === 'object' && Object.keys(outer[innerStr]).length === 0;\n} // swap all the data and data attributes associated with x and y\n\n\nexports.swapXYData = function (trace) {\n  var i;\n  Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);\n\n  if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {\n    if (trace.transpose) delete trace.transpose;else trace.transpose = true;\n  }\n\n  if (trace.error_x && trace.error_y) {\n    var errorY = trace.error_y;\n    var copyYstyle = 'copy_ystyle' in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);\n    Lib.swapAttrs(trace, ['error_?.copy_ystyle']);\n\n    if (copyYstyle) {\n      Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);\n    }\n  }\n\n  if (typeof trace.hoverinfo === 'string') {\n    var hoverInfoParts = trace.hoverinfo.split('+');\n\n    for (i = 0; i < hoverInfoParts.length; i++) {\n      if (hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';else if (hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';\n    }\n\n    trace.hoverinfo = hoverInfoParts.join('+');\n  }\n}; // coerce traceIndices input to array of trace indices\n\n\nexports.coerceTraceIndices = function (gd, traceIndices) {\n  if (isNumeric(traceIndices)) {\n    return [traceIndices];\n  } else if (!Array.isArray(traceIndices) || !traceIndices.length) {\n    return gd.data.map(function (_, i) {\n      return i;\n    });\n  } else if (Array.isArray(traceIndices)) {\n    var traceIndicesOut = [];\n\n    for (var i = 0; i < traceIndices.length; i++) {\n      if (Lib.isIndex(traceIndices[i], gd.data.length)) {\n        traceIndicesOut.push(traceIndices[i]);\n      } else {\n        Lib.warn('trace index (', traceIndices[i], ') is not a number or is out of bounds');\n      }\n    }\n\n    return traceIndicesOut;\n  }\n\n  return traceIndices;\n};\n/**\n * Manages logic around array container item creation / deletion / update\n * that nested property alone can't handle.\n *\n * @param {Object} np\n *  nested property of update attribute string about trace or layout object\n * @param {*} newVal\n *  update value passed to restyle / relayout / update\n * @param {Object} undoit\n *  undo hash (N.B. undoit may be mutated here).\n *\n */\n\n\nexports.manageArrayContainers = function (np, newVal, undoit) {\n  var obj = np.obj;\n  var parts = np.parts;\n  var pLength = parts.length;\n  var pLast = parts[pLength - 1];\n  var pLastIsNumber = isNumeric(pLast);\n\n  if (pLastIsNumber && newVal === null) {\n    // delete item\n    // Clear item in array container when new value is null\n    var contPath = parts.slice(0, pLength - 1).join('.');\n    var cont = Lib.nestedProperty(obj, contPath).get();\n    cont.splice(pLast, 1); // Note that nested property clears null / undefined at end of\n    // array container, but not within them.\n  } else if (pLastIsNumber && np.get() === undefined) {\n    // create item\n    // When adding a new item, make sure undo command will remove it\n    if (np.get() === undefined) undoit[np.astr] = null;\n    np.set(newVal);\n  } else {\n    // update item\n    // If the last part of attribute string isn't a number,\n    // np.set is all we need.\n    np.set(newVal);\n  }\n};\n/*\n * Match the part to strip off to turn an attribute into its parent\n * really it should be either '.some_characters' or '[number]'\n * but we're a little more permissive here and match either\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\n */\n\n\nvar ATTR_TAIL_RE = /(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;\n\nfunction getParent(attr) {\n  var tail = attr.search(ATTR_TAIL_RE);\n  if (tail > 0) return attr.substr(0, tail);\n}\n/*\n * hasParent: does an attribute object contain a parent of the given attribute?\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\n *\n * @param {Object} aobj\n *  update object, whose keys are attribute strings and values are their new settings\n * @param {string} attr\n *  the attribute string to test against\n * @returns {Boolean}\n *  is a parent of attr present in aobj?\n */\n\n\nexports.hasParent = function (aobj, attr) {\n  var attrParent = getParent(attr);\n\n  while (attrParent) {\n    if (attrParent in aobj) return true;\n    attrParent = getParent(attrParent);\n  }\n\n  return false;\n};\n/**\n * Empty out types for all axes containing these traces so we auto-set them again\n *\n * @param {object} gd\n * @param {[integer]} traces: trace indices to search for axes to clear the types of\n * @param {object} layoutUpdate: any update being done concurrently to the layout,\n *   which may supercede clearing the axis types\n */\n\n\nvar axLetters = ['x', 'y', 'z'];\n\nexports.clearAxisTypes = function (gd, traces, layoutUpdate) {\n  for (var i = 0; i < traces.length; i++) {\n    var trace = gd._fullData[i];\n\n    for (var j = 0; j < 3; j++) {\n      var ax = getFromTrace(gd, trace, axLetters[j]); // do not clear log type - that's never an auto result so must have been intentional\n\n      if (ax && ax.type !== 'log') {\n        var axAttr = ax._name;\n\n        var sceneName = ax._id.substr(1);\n\n        if (sceneName.substr(0, 5) === 'scene') {\n          if (layoutUpdate[sceneName] !== undefined) continue;\n          axAttr = sceneName + '.' + axAttr;\n        }\n\n        var typeAttr = axAttr + '.type';\n\n        if (layoutUpdate[axAttr] === undefined && layoutUpdate[typeAttr] === undefined) {\n          Lib.nestedProperty(gd.layout, typeAttr).set(null);\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}