{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Plots = require('../plots');\n\nvar Drawing = require('../../components/drawing');\n\nvar getModuleCalcData = require('../get_data').getModuleCalcData;\n\nvar axisIds = require('./axis_ids');\n\nvar constants = require('./constants');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nvar ensureSingle = Lib.ensureSingle;\n\nfunction ensureSingleAndAddDatum(parent, nodeType, className) {\n  return Lib.ensureSingle(parent, nodeType, className, function (s) {\n    s.datum(className);\n  });\n}\n\nexports.name = 'cartesian';\nexports.attr = ['xaxis', 'yaxis'];\nexports.idRoot = ['x', 'y'];\nexports.idRegex = constants.idRegex;\nexports.attrRegex = constants.attrRegex;\nexports.attributes = require('./attributes');\nexports.layoutAttributes = require('./layout_attributes');\nexports.supplyLayoutDefaults = require('./layout_defaults');\nexports.transitionAxes = require('./transition_axes');\n\nexports.finalizeSubplots = function (layoutIn, layoutOut) {\n  var subplots = layoutOut._subplots;\n  var xList = subplots.xaxis;\n  var yList = subplots.yaxis;\n  var spSVG = subplots.cartesian;\n  var spAll = spSVG.concat(subplots.gl2d || []);\n  var allX = {};\n  var allY = {};\n  var i, xi, yi;\n\n  for (i = 0; i < spAll.length; i++) {\n    var parts = spAll[i].split('y');\n    allX[parts[0]] = 1;\n    allY['y' + parts[1]] = 1;\n  } // check for x axes with no subplot, and make one from the anchor of that x axis\n\n\n  for (i = 0; i < xList.length; i++) {\n    xi = xList[i];\n\n    if (!allX[xi]) {\n      yi = (layoutIn[axisIds.id2name(xi)] || {}).anchor;\n      if (!constants.idRegex.y.test(yi)) yi = 'y';\n      spSVG.push(xi + yi);\n      spAll.push(xi + yi);\n\n      if (!allY[yi]) {\n        allY[yi] = 1;\n        Lib.pushUnique(yList, yi);\n      }\n    }\n  } // same for y axes with no subplot\n\n\n  for (i = 0; i < yList.length; i++) {\n    yi = yList[i];\n\n    if (!allY[yi]) {\n      xi = (layoutIn[axisIds.id2name(yi)] || {}).anchor;\n      if (!constants.idRegex.x.test(xi)) xi = 'x';\n      spSVG.push(xi + yi);\n      spAll.push(xi + yi);\n\n      if (!allX[xi]) {\n        allX[xi] = 1;\n        Lib.pushUnique(xList, xi);\n      }\n    }\n  } // finally, if we've gotten here we're supposed to show cartesian...\n  // so if there are NO subplots at all, make one from the first\n  // x & y axes in the input layout\n\n\n  if (!spAll.length) {\n    xi = '';\n    yi = '';\n\n    for (var ki in layoutIn) {\n      if (constants.attrRegex.test(ki)) {\n        var axLetter = ki.charAt(0);\n\n        if (axLetter === 'x') {\n          if (!xi || +ki.substr(5) < +xi.substr(5)) {\n            xi = ki;\n          }\n        } else if (!yi || +ki.substr(5) < +yi.substr(5)) {\n          yi = ki;\n        }\n      }\n    }\n\n    xi = xi ? axisIds.name2id(xi) : 'x';\n    yi = yi ? axisIds.name2id(yi) : 'y';\n    xList.push(xi);\n    yList.push(yi);\n    spSVG.push(xi + yi);\n  }\n};\n/**\n * Cartesian.plot\n *\n * @param {DOM div | object} gd\n * @param {array (optional)} traces\n *  array of traces indices to plot\n *  if undefined, plots all cartesian traces,\n * @param {object} (optional) transitionOpts\n *  transition option object\n * @param {function} (optional) makeOnCompleteCallback\n *  transition make callback function from Plots.transition\n */\n\n\nexports.plot = function (gd, traces, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var subplots = fullLayout._subplots.cartesian;\n  var calcdata = gd.calcdata;\n  var i;\n\n  if (!Array.isArray(traces)) {\n    // If traces is not provided, then it's a complete replot and missing\n    // traces are removed\n    traces = [];\n\n    for (i = 0; i < calcdata.length; i++) traces.push(i);\n  }\n\n  for (i = 0; i < subplots.length; i++) {\n    var subplot = subplots[i];\n    var subplotInfo = fullLayout._plots[subplot]; // Get all calcdata for this subplot:\n\n    var cdSubplot = [];\n    var pcd;\n\n    for (var j = 0; j < calcdata.length; j++) {\n      var cd = calcdata[j];\n      var trace = cd[0].trace; // Skip trace if whitelist provided and it's not whitelisted:\n      // if (Array.isArray(traces) && traces.indexOf(i) === -1) continue;\n\n      if (trace.xaxis + trace.yaxis === subplot) {\n        // XXX: Should trace carpet dependencies. Only replot all carpet plots if the carpet\n        // axis has actually changed:\n        //\n        // If this trace is specifically requested, add it to the list:\n        if (traces.indexOf(trace.index) !== -1 || trace.carpet) {\n          // Okay, so example: traces 0, 1, and 2 have fill = tonext. You animate\n          // traces 0 and 2. Trace 1 also needs to be updated, otherwise its fill\n          // is outdated. So this retroactively adds the previous trace if the\n          // traces are interdependent.\n          if (pcd && pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot && ['tonextx', 'tonexty', 'tonext'].indexOf(trace.fill) !== -1 && cdSubplot.indexOf(pcd) === -1) {\n            cdSubplot.push(pcd);\n          }\n\n          cdSubplot.push(cd);\n        } // Track the previous trace on this subplot for the retroactive-add step\n        // above:\n\n\n        pcd = cd;\n      }\n    }\n\n    plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);\n  }\n};\n\nfunction plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {\n  var traceLayerClasses = constants.traceLayerClasses;\n  var fullLayout = gd._fullLayout;\n  var modules = fullLayout._modules;\n\n  var _module, cdModuleAndOthers, cdModule;\n\n  var layerData = [];\n  var zoomScaleQueryParts = [];\n\n  for (var i = 0; i < modules.length; i++) {\n    _module = modules[i];\n    var name = _module.name;\n    var categories = Registry.modules[name].categories;\n\n    if (categories.svg) {\n      var className = _module.layerName || name + 'layer';\n      var plotMethod = _module.plot; // plot all visible traces of this type on this subplot at once\n\n      cdModuleAndOthers = getModuleCalcData(cdSubplot, plotMethod);\n      cdModule = cdModuleAndOthers[0]; // don't need to search the found traces again - in fact we need to NOT\n      // so that if two modules share the same plotter we don't double-plot\n\n      cdSubplot = cdModuleAndOthers[1];\n\n      if (cdModule.length) {\n        layerData.push({\n          i: traceLayerClasses.indexOf(className),\n          className: className,\n          plotMethod: plotMethod,\n          cdModule: cdModule\n        });\n      }\n\n      if (categories.zoomScale) {\n        zoomScaleQueryParts.push('.' + className);\n      }\n    }\n  }\n\n  layerData.sort(function (a, b) {\n    return a.i - b.i;\n  });\n  var layers = plotinfo.plot.selectAll('g.mlayer').data(layerData, function (d) {\n    return d.className;\n  });\n  layers.enter().append('g').attr('class', function (d) {\n    return d.className;\n  }).classed('mlayer', true).classed('rangeplot', plotinfo.isRangePlot);\n  layers.exit().remove();\n  layers.order();\n  layers.each(function (d) {\n    var sel = d3.select(this);\n    var className = d.className;\n    d.plotMethod(gd, plotinfo, d.cdModule, sel, transitionOpts, makeOnCompleteCallback); // layers that allow `cliponaxis: false`\n\n    if (constants.clipOnAxisFalseQuery.indexOf('.' + className) === -1) {\n      Drawing.setClipUrl(sel, plotinfo.layerClipId, gd);\n    }\n  }); // call Scattergl.plot separately\n\n  if (fullLayout._has('scattergl')) {\n    _module = Registry.getModule('scattergl');\n    cdModule = getModuleCalcData(cdSubplot, _module)[0];\n\n    _module.plot(gd, plotinfo, cdModule);\n  } // stash \"hot\" selections for faster interaction on drag and scroll\n\n\n  if (!gd._context.staticPlot) {\n    if (plotinfo._hasClipOnAxisFalse) {\n      plotinfo.clipOnAxisFalseTraces = plotinfo.plot.selectAll(constants.clipOnAxisFalseQuery.join(',')).selectAll('.trace');\n    }\n\n    if (zoomScaleQueryParts.length) {\n      var traces = plotinfo.plot.selectAll(zoomScaleQueryParts.join(',')).selectAll('.trace');\n      plotinfo.zoomScalePts = traces.selectAll('path.point');\n      plotinfo.zoomScaleTxt = traces.selectAll('.textpoint');\n    }\n  }\n}\n\nexports.clean = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var oldPlots = oldFullLayout._plots || {};\n  var newPlots = newFullLayout._plots || {};\n  var oldSubplotList = oldFullLayout._subplots || {};\n  var plotinfo;\n  var i, k; // when going from a large splom graph to something else,\n  // we need to clear <g subplot> so that the new cartesian subplot\n  // can have the correct layer ordering\n\n  if (oldFullLayout._hasOnlyLargeSploms && !newFullLayout._hasOnlyLargeSploms) {\n    for (k in oldPlots) {\n      plotinfo = oldPlots[k];\n      if (plotinfo.plotgroup) plotinfo.plotgroup.remove();\n    }\n  }\n\n  var hadGl = oldFullLayout._has && oldFullLayout._has('gl');\n\n  var hasGl = newFullLayout._has && newFullLayout._has('gl');\n\n  if (hadGl && !hasGl) {\n    for (k in oldPlots) {\n      plotinfo = oldPlots[k];\n      if (plotinfo._scene) plotinfo._scene.destroy();\n    }\n  } // delete any titles we don't need anymore\n  // check if axis list has changed, and if so clear old titles\n\n\n  if (oldSubplotList.xaxis && oldSubplotList.yaxis) {\n    var oldAxIDs = axisIds.listIds({\n      _fullLayout: oldFullLayout\n    });\n\n    for (i = 0; i < oldAxIDs.length; i++) {\n      var oldAxId = oldAxIDs[i];\n\n      if (!newFullLayout[axisIds.id2name(oldAxId)]) {\n        oldFullLayout._infolayer.selectAll('.g-' + oldAxId + 'title').remove();\n      }\n    }\n  }\n\n  var hadCartesian = oldFullLayout._has && oldFullLayout._has('cartesian');\n\n  var hasCartesian = newFullLayout._has && newFullLayout._has('cartesian');\n\n  if (hadCartesian && !hasCartesian) {\n    // if we've gotten rid of all cartesian traces, remove all the subplot svg items\n    purgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll('.subplot'), oldFullLayout);\n\n    oldFullLayout._defs.selectAll('.axesclip').remove();\n\n    delete oldFullLayout._axisConstraintGroups;\n  } else if (oldSubplotList.cartesian) {\n    // otherwise look for subplots we need to remove\n    for (i = 0; i < oldSubplotList.cartesian.length; i++) {\n      var oldSubplotId = oldSubplotList.cartesian[i];\n\n      if (!newPlots[oldSubplotId]) {\n        var selector = '.' + oldSubplotId + ',.' + oldSubplotId + '-x,.' + oldSubplotId + '-y';\n\n        oldFullLayout._cartesianlayer.selectAll(selector).remove();\n\n        removeSubplotExtras(oldSubplotId, oldFullLayout);\n      }\n    }\n  }\n};\n\nexports.drawFramework = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var subplotData = makeSubplotData(gd);\n\n  var subplotLayers = fullLayout._cartesianlayer.selectAll('.subplot').data(subplotData, String);\n\n  subplotLayers.enter().append('g').attr('class', function (d) {\n    return 'subplot ' + d[0];\n  });\n  subplotLayers.order();\n  subplotLayers.exit().call(purgeSubplotLayers, fullLayout);\n  subplotLayers.each(function (d) {\n    var id = d[0];\n    var plotinfo = fullLayout._plots[id];\n    plotinfo.plotgroup = d3.select(this);\n    makeSubplotLayer(gd, plotinfo); // make separate drag layers for each subplot,\n    // but append them to paper rather than the plot groups,\n    // so they end up on top of the rest\n\n    plotinfo.draglayer = ensureSingle(fullLayout._draggers, 'g', id);\n  });\n};\n\nexports.rangePlot = function (gd, plotinfo, cdSubplot) {\n  makeSubplotLayer(gd, plotinfo);\n  plotOne(gd, plotinfo, cdSubplot);\n  Plots.style(gd);\n};\n\nfunction makeSubplotData(gd) {\n  var fullLayout = gd._fullLayout;\n  var ids = fullLayout._subplots.cartesian;\n  var len = ids.length;\n  var i, j, id, plotinfo, xa, ya; // split 'regular' and 'overlaying' subplots\n\n  var regulars = [];\n  var overlays = [];\n\n  for (i = 0; i < len; i++) {\n    id = ids[i];\n    plotinfo = fullLayout._plots[id];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n    var xa2 = xa._mainAxis;\n    var ya2 = ya._mainAxis;\n    var mainplot = xa2._id + ya2._id;\n    var mainplotinfo = fullLayout._plots[mainplot];\n    plotinfo.overlays = [];\n\n    if (mainplot !== id && mainplotinfo) {\n      plotinfo.mainplot = mainplot;\n      plotinfo.mainplotinfo = mainplotinfo;\n      overlays.push(id);\n    } else {\n      plotinfo.mainplot = undefined;\n      plotinfo.mainPlotinfo = undefined;\n      regulars.push(id);\n    }\n  } // fill in list of overlaying subplots in 'main plot'\n\n\n  for (i = 0; i < overlays.length; i++) {\n    id = overlays[i];\n    plotinfo = fullLayout._plots[id];\n    plotinfo.mainplotinfo.overlays.push(plotinfo);\n  } // put 'regular' subplot data before 'overlaying'\n\n\n  var subplotIds = regulars.concat(overlays);\n  var subplotData = new Array(len);\n\n  for (i = 0; i < len; i++) {\n    id = subplotIds[i];\n    plotinfo = fullLayout._plots[id];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis; // use info about axis layer and overlaying pattern\n    // to clean what need to be cleaned up in exit selection\n\n    var d = [id, xa.layer, ya.layer, xa.overlaying || '', ya.overlaying || ''];\n\n    for (j = 0; j < plotinfo.overlays.length; j++) {\n      d.push(plotinfo.overlays[j].id);\n    }\n\n    subplotData[i] = d;\n  }\n\n  return subplotData;\n}\n\nfunction makeSubplotLayer(gd, plotinfo) {\n  var plotgroup = plotinfo.plotgroup;\n  var id = plotinfo.id;\n  var xLayer = constants.layerValue2layerClass[plotinfo.xaxis.layer];\n  var yLayer = constants.layerValue2layerClass[plotinfo.yaxis.layer];\n  var hasOnlyLargeSploms = gd._fullLayout._hasOnlyLargeSploms;\n\n  if (!plotinfo.mainplot) {\n    if (hasOnlyLargeSploms) {\n      // TODO could do even better\n      // - we don't need plot (but we would have to mock it in lsInner\n      //   and other places\n      // - we don't (x|y)lines and (x|y)axislayer for most subplots\n      //   usually just the bottom x and left y axes.\n      plotinfo.xlines = ensureSingle(plotgroup, 'path', 'xlines-above');\n      plotinfo.ylines = ensureSingle(plotgroup, 'path', 'ylines-above');\n      plotinfo.xaxislayer = ensureSingle(plotgroup, 'g', 'xaxislayer-above');\n      plotinfo.yaxislayer = ensureSingle(plotgroup, 'g', 'yaxislayer-above');\n    } else {\n      var backLayer = ensureSingle(plotgroup, 'g', 'layer-subplot');\n      plotinfo.shapelayer = ensureSingle(backLayer, 'g', 'shapelayer');\n      plotinfo.imagelayer = ensureSingle(backLayer, 'g', 'imagelayer');\n      plotinfo.gridlayer = ensureSingle(plotgroup, 'g', 'gridlayer');\n      plotinfo.zerolinelayer = ensureSingle(plotgroup, 'g', 'zerolinelayer');\n      ensureSingle(plotgroup, 'path', 'xlines-below');\n      ensureSingle(plotgroup, 'path', 'ylines-below');\n      plotinfo.overlinesBelow = ensureSingle(plotgroup, 'g', 'overlines-below');\n      ensureSingle(plotgroup, 'g', 'xaxislayer-below');\n      ensureSingle(plotgroup, 'g', 'yaxislayer-below');\n      plotinfo.overaxesBelow = ensureSingle(plotgroup, 'g', 'overaxes-below');\n      plotinfo.plot = ensureSingle(plotgroup, 'g', 'plot');\n      plotinfo.overplot = ensureSingle(plotgroup, 'g', 'overplot');\n      plotinfo.xlines = ensureSingle(plotgroup, 'path', 'xlines-above');\n      plotinfo.ylines = ensureSingle(plotgroup, 'path', 'ylines-above');\n      plotinfo.overlinesAbove = ensureSingle(plotgroup, 'g', 'overlines-above');\n      ensureSingle(plotgroup, 'g', 'xaxislayer-above');\n      ensureSingle(plotgroup, 'g', 'yaxislayer-above');\n      plotinfo.overaxesAbove = ensureSingle(plotgroup, 'g', 'overaxes-above'); // set refs to correct layers as determined by 'axis.layer'\n\n      plotinfo.xlines = plotgroup.select('.xlines-' + xLayer);\n      plotinfo.ylines = plotgroup.select('.ylines-' + yLayer);\n      plotinfo.xaxislayer = plotgroup.select('.xaxislayer-' + xLayer);\n      plotinfo.yaxislayer = plotgroup.select('.yaxislayer-' + yLayer);\n    }\n  } else {\n    var mainplotinfo = plotinfo.mainplotinfo;\n    var mainplotgroup = mainplotinfo.plotgroup;\n    var xId = id + '-x';\n    var yId = id + '-y'; // now make the components of overlaid subplots\n    // overlays don't have backgrounds, and append all\n    // their other components to the corresponding\n    // extra groups of their main plots.\n\n    plotinfo.gridlayer = mainplotinfo.gridlayer;\n    plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;\n    ensureSingle(mainplotinfo.overlinesBelow, 'path', xId);\n    ensureSingle(mainplotinfo.overlinesBelow, 'path', yId);\n    ensureSingle(mainplotinfo.overaxesBelow, 'g', xId);\n    ensureSingle(mainplotinfo.overaxesBelow, 'g', yId);\n    plotinfo.plot = ensureSingle(mainplotinfo.overplot, 'g', id);\n    ensureSingle(mainplotinfo.overlinesAbove, 'path', xId);\n    ensureSingle(mainplotinfo.overlinesAbove, 'path', yId);\n    ensureSingle(mainplotinfo.overaxesAbove, 'g', xId);\n    ensureSingle(mainplotinfo.overaxesAbove, 'g', yId); // set refs to correct layers as determined by 'abovetraces'\n\n    plotinfo.xlines = mainplotgroup.select('.overlines-' + xLayer).select('.' + xId);\n    plotinfo.ylines = mainplotgroup.select('.overlines-' + yLayer).select('.' + yId);\n    plotinfo.xaxislayer = mainplotgroup.select('.overaxes-' + xLayer).select('.' + xId);\n    plotinfo.yaxislayer = mainplotgroup.select('.overaxes-' + yLayer).select('.' + yId);\n  } // common attributes for all subplots, overlays or not\n\n\n  if (!hasOnlyLargeSploms) {\n    ensureSingleAndAddDatum(plotinfo.gridlayer, 'g', plotinfo.xaxis._id);\n    ensureSingleAndAddDatum(plotinfo.gridlayer, 'g', plotinfo.yaxis._id);\n    plotinfo.gridlayer.selectAll('g').map(function (d) {\n      return d[0];\n    }).sort(axisIds.idSort);\n  }\n\n  plotinfo.xlines.style('fill', 'none').classed('crisp', true);\n  plotinfo.ylines.style('fill', 'none').classed('crisp', true);\n}\n\nfunction purgeSubplotLayers(layers, fullLayout) {\n  if (!layers) return;\n  var overlayIdsToRemove = {};\n  layers.each(function (d) {\n    var id = d[0];\n    var plotgroup = d3.select(this);\n    plotgroup.remove();\n    removeSubplotExtras(id, fullLayout);\n    overlayIdsToRemove[id] = true; // do not remove individual axis <clipPath>s here\n    // as other subplots may need them\n  }); // must remove overlaid subplot trace layers 'manually'\n\n  for (var k in fullLayout._plots) {\n    var subplotInfo = fullLayout._plots[k];\n    var overlays = subplotInfo.overlays || [];\n\n    for (var j = 0; j < overlays.length; j++) {\n      var overlayInfo = overlays[j];\n\n      if (overlayIdsToRemove[overlayInfo.id]) {\n        overlayInfo.plot.selectAll('.trace').remove();\n      }\n    }\n  }\n}\n\nfunction removeSubplotExtras(subplotId, fullLayout) {\n  fullLayout._draggers.selectAll('g.' + subplotId).remove();\n\n  fullLayout._defs.select('#clip' + fullLayout._uid + subplotId + 'plot').remove();\n}\n\nexports.toSVG = function (gd) {\n  var imageRoot = gd._fullLayout._glimages;\n  var root = d3.select(gd).selectAll('.svg-container');\n  var canvases = root.filter(function (d, i) {\n    return i === root.size() - 1;\n  }).selectAll('.gl-canvas-context, .gl-canvas-focus');\n\n  function canvasToImage() {\n    var canvas = this;\n    var imageData = canvas.toDataURL('image/png');\n    var image = imageRoot.append('svg:image');\n    image.attr({\n      xmlns: xmlnsNamespaces.svg,\n      'xlink:href': imageData,\n      preserveAspectRatio: 'none',\n      x: 0,\n      y: 0,\n      width: canvas.width,\n      height: canvas.height\n    });\n  }\n\n  canvases.each(canvasToImage);\n};\n\nexports.updateFx = require('./graph_interact').updateFx;","map":null,"metadata":{},"sourceType":"script"}