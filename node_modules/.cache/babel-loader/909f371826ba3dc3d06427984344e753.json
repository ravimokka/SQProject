{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\n\n\nfunction copyArgArray(gd, args) {\n  var copy = [];\n  var arg;\n\n  for (var i = 0; i < args.length; i++) {\n    arg = args[i];\n    if (arg === gd) copy[i] = arg;else if (typeof arg === 'object') {\n      copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);\n    } else copy[i] = arg;\n  }\n\n  return copy;\n} // -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {}; // TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\n\nqueue.add = function (gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n  var queueObj, queueIndex; // make sure we have the queue and our position in it\n\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  queueIndex = gd.undoQueue.index; // if we're already playing an undo or redo, or if this is an auto operation\n  // (like pane resize... any others?) then we don't save this to the undo queue\n\n  if (gd.autoplay) {\n    if (!gd.undoQueue.inSequence) gd.autoplay = false;\n    return;\n  } // if we're not in a sequence or are just starting, we need a new queue item\n\n\n  if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n    queueObj = {\n      undo: {\n        calls: [],\n        args: []\n      },\n      redo: {\n        calls: [],\n        args: []\n      }\n    };\n    gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n    gd.undoQueue.index += 1;\n  } else {\n    queueObj = gd.undoQueue.queue[queueIndex - 1];\n  }\n\n  gd.undoQueue.beginSequence = false; // we unshift to handle calls for undo in a forward for loop later\n\n  if (queueObj) {\n    queueObj.undo.calls.unshift(undoFunc);\n    queueObj.undo.args.unshift(undoArgs);\n    queueObj.redo.calls.push(redoFunc);\n    queueObj.redo.args.push(redoArgs);\n  }\n\n  if (gd.undoQueue.queue.length > dfltConfig.queueLength) {\n    gd.undoQueue.queue.shift();\n    gd.undoQueue.index--;\n  }\n};\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\n\n\nqueue.startSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = true;\n  gd.undoQueue.beginSequence = true;\n};\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\n\n\nqueue.stopSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = false;\n  gd.undoQueue.beginSequence = false;\n};\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\n\n\nqueue.undo = function undo(gd) {\n  var queueObj, i;\n\n  if (gd.framework && gd.framework.isPolar) {\n    gd.framework.undo();\n    return;\n  }\n\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {\n    return;\n  } // index is pointing to next *forward* queueObj, point to the one we're undoing\n\n\n  gd.undoQueue.index--; // get the queueObj for instructions on how to undo\n\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index]; // this sequence keeps things from adding to the queue during undo/redo\n\n  gd.undoQueue.inSequence = true;\n\n  for (i = 0; i < queueObj.undo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n  }\n\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false;\n};\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\n\n\nqueue.redo = function redo(gd) {\n  var queueObj, i;\n\n  if (gd.framework && gd.framework.isPolar) {\n    gd.framework.redo();\n    return;\n  }\n\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {\n    return;\n  } // get the queueObj for instructions on how to undo\n\n\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index]; // this sequence keeps things from adding to the queue during undo/redo\n\n  gd.undoQueue.inSequence = true;\n\n  for (i = 0; i < queueObj.redo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n  }\n\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false; // index is pointing to the thing we just redid, move it\n\n  gd.undoQueue.index++;\n};\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\n\n\nqueue.plotDo = function (gd, func, args) {\n  gd.autoplay = true; // this *won't* copy gd and it preserves `undefined` properties!\n\n  args = copyArgArray(gd, args); // call the supplied function\n\n  func.apply(null, args);\n};\n\nmodule.exports = queue;","map":null,"metadata":{},"sourceType":"script"}