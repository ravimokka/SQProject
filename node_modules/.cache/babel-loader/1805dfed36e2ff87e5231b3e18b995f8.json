{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar maxRowLength = require('../../lib').maxRowLength;\n/* Return a list of empty points in 2D array z\n * each empty point z[i][j] gives an array [i, j, neighborCount]\n * neighborCount is the count of 4 nearest neighbors that DO exist\n * this is to give us an order of points to evaluate for interpolation.\n * if no neighbors exist, we iteratively look for neighbors that HAVE\n * neighbors, and add a fractional neighborCount\n */\n\n\nmodule.exports = function findEmpties(z) {\n  var empties = [];\n  var neighborHash = {};\n  var noNeighborList = [];\n  var nextRow = z[0];\n  var row = [];\n  var blank = [0, 0, 0];\n  var rowLength = maxRowLength(z);\n  var prevRow;\n  var i;\n  var j;\n  var thisPt;\n  var p;\n  var neighborCount;\n  var newNeighborHash;\n  var foundNewNeighbors;\n\n  for (i = 0; i < z.length; i++) {\n    prevRow = row;\n    row = nextRow;\n    nextRow = z[i + 1] || [];\n\n    for (j = 0; j < rowLength; j++) {\n      if (row[j] === undefined) {\n        neighborCount = (row[j - 1] !== undefined ? 1 : 0) + (row[j + 1] !== undefined ? 1 : 0) + (prevRow[j] !== undefined ? 1 : 0) + (nextRow[j] !== undefined ? 1 : 0);\n\n        if (neighborCount) {\n          // for this purpose, don't count off-the-edge points\n          // as undefined neighbors\n          if (i === 0) neighborCount++;\n          if (j === 0) neighborCount++;\n          if (i === z.length - 1) neighborCount++;\n          if (j === row.length - 1) neighborCount++; // if all neighbors that could exist do, we don't\n          // need this for finding farther neighbors\n\n          if (neighborCount < 4) {\n            neighborHash[[i, j]] = [i, j, neighborCount];\n          }\n\n          empties.push([i, j, neighborCount]);\n        } else noNeighborList.push([i, j]);\n      }\n    }\n  }\n\n  while (noNeighborList.length) {\n    newNeighborHash = {};\n    foundNewNeighbors = false; // look for cells that now have neighbors but didn't before\n\n    for (p = noNeighborList.length - 1; p >= 0; p--) {\n      thisPt = noNeighborList[p];\n      i = thisPt[0];\n      j = thisPt[1];\n      neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] + (neighborHash[[i + 1, j]] || blank)[2] + (neighborHash[[i, j - 1]] || blank)[2] + (neighborHash[[i, j + 1]] || blank)[2]) / 20;\n\n      if (neighborCount) {\n        newNeighborHash[thisPt] = [i, j, neighborCount];\n        noNeighborList.splice(p, 1);\n        foundNewNeighbors = true;\n      }\n    }\n\n    if (!foundNewNeighbors) {\n      throw 'findEmpties iterated with no new neighbors';\n    } // put these new cells into the main neighbor list\n\n\n    for (thisPt in newNeighborHash) {\n      neighborHash[thisPt] = newNeighborHash[thisPt];\n      empties.push(newNeighborHash[thisPt]);\n    }\n  } // sort the full list in descending order of neighbor count\n\n\n  return empties.sort(function (a, b) {\n    return b[2] - a[2];\n  });\n};","map":null,"metadata":{},"sourceType":"script"}