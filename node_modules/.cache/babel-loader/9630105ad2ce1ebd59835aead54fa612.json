{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\n/**\n * convert a string s (such as 'xaxis.range[0]')\n * representing a property of nested object into set and get methods\n * also return the string and object so we don't have to keep track of them\n * allows [-1] for an array index, to set a property inside all elements\n * of an array\n * eg if obj = {arr: [{a: 1}, {a: 2}]}\n * you can do p = nestedProperty(obj, 'arr[-1].a')\n * but you cannot set the array itself this way, to do that\n * just set the whole array.\n * eg if obj = {arr: [1, 2, 3]}\n * you can't do nestedProperty(obj, 'arr[-1]').set(5)\n * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])\n */\n\n\nmodule.exports = function nestedProperty(container, propStr) {\n  if (isNumeric(propStr)) propStr = String(propStr);else if (typeof propStr !== 'string' || propStr.substr(propStr.length - 4) === '[-1]') {\n    throw 'bad property string';\n  }\n  var j = 0;\n  var propParts = propStr.split('.');\n  var indexed;\n  var indices;\n  var i; // check for parts of the nesting hierarchy that are numbers (ie array elements)\n\n  while (j < propParts.length) {\n    // look for non-bracket chars, then any number of [##] blocks\n    indexed = String(propParts[j]).match(/^([^\\[\\]]*)((\\[\\-?[0-9]*\\])+)$/);\n\n    if (indexed) {\n      if (indexed[1]) propParts[j] = indexed[1]; // allow propStr to start with bracketed array indices\n      else if (j === 0) propParts.splice(0, 1);else throw 'bad property string';\n      indices = indexed[2].substr(1, indexed[2].length - 2).split('][');\n\n      for (i = 0; i < indices.length; i++) {\n        j++;\n        propParts.splice(j, 0, Number(indices[i]));\n      }\n    }\n\n    j++;\n  }\n\n  if (typeof container !== 'object') {\n    return badContainer(container, propStr, propParts);\n  }\n\n  return {\n    set: npSet(container, propParts, propStr),\n    get: npGet(container, propParts),\n    astr: propStr,\n    parts: propParts,\n    obj: container\n  };\n};\n\nfunction npGet(cont, parts) {\n  return function () {\n    var curCont = cont;\n    var curPart;\n    var allSame;\n    var out;\n    var i;\n    var j;\n\n    for (i = 0; i < parts.length - 1; i++) {\n      curPart = parts[i];\n\n      if (curPart === -1) {\n        allSame = true;\n        out = [];\n\n        for (j = 0; j < curCont.length; j++) {\n          out[j] = npGet(curCont[j], parts.slice(i + 1))();\n          if (out[j] !== out[0]) allSame = false;\n        }\n\n        return allSame ? out[0] : out;\n      }\n\n      if (typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {\n        return undefined;\n      }\n\n      curCont = curCont[curPart];\n\n      if (typeof curCont !== 'object' || curCont === null) {\n        return undefined;\n      }\n    } // only hit this if parts.length === 1\n\n\n    if (typeof curCont !== 'object' || curCont === null) return undefined;\n    out = curCont[parts[i]];\n    if (out === null) return undefined;\n    return out;\n  };\n}\n/*\n * Can this value be deleted? We can delete `undefined`, and `null` except INSIDE an\n * *args* array.\n *\n * Previously we also deleted some `{}` and `[]`, in order to try and make set/unset\n * a net noop; but this causes far more complication than it's worth, and still had\n * lots of exceptions. See https://github.com/plotly/plotly.js/issues/1410\n *\n * *args* arrays get passed directly to API methods and we should respect null if\n * the user put it there, but otherwise null is deleted as we use it as code\n * in restyle/relayout/update for \"delete this value\" whereas undefined means\n * \"ignore this edit\"\n */\n\n\nvar ARGS_PATTERN = /(^|\\.)args\\[/;\n\nfunction isDeletable(val, propStr) {\n  return val === undefined || val === null && !propStr.match(ARGS_PATTERN);\n}\n\nfunction npSet(cont, parts, propStr) {\n  return function (val) {\n    var curCont = cont;\n    var propPart = '';\n    var containerLevels = [[cont, propPart]];\n    var toDelete = isDeletable(val, propStr);\n    var curPart;\n    var i;\n\n    for (i = 0; i < parts.length - 1; i++) {\n      curPart = parts[i];\n\n      if (typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {\n        throw 'array index but container is not an array';\n      } // handle special -1 array index\n\n\n      if (curPart === -1) {\n        toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);\n        if (toDelete) break;else return;\n      }\n\n      if (!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {\n        break;\n      }\n\n      curCont = curCont[curPart];\n\n      if (typeof curCont !== 'object' || curCont === null) {\n        throw 'container is not an object';\n      }\n\n      propPart = joinPropStr(propPart, curPart);\n      containerLevels.push([curCont, propPart]);\n    }\n\n    if (toDelete) {\n      if (i === parts.length - 1) {\n        delete curCont[parts[i]]; // The one bit of pruning we still do: drop `undefined` from the end of arrays.\n        // In case someone has already unset previous items, continue until we hit a\n        // non-undefined value.\n\n        if (Array.isArray(curCont) && +parts[i] === curCont.length - 1) {\n          while (curCont.length && curCont[curCont.length - 1] === undefined) {\n            curCont.pop();\n          }\n        }\n      }\n    } else curCont[parts[i]] = val;\n  };\n}\n\nfunction joinPropStr(propStr, newPart) {\n  var toAdd = newPart;\n  if (isNumeric(newPart)) toAdd = '[' + newPart + ']';else if (propStr) toAdd = '.' + newPart;\n  return propStr + toAdd;\n} // handle special -1 array index\n\n\nfunction setArrayAll(containerArray, innerParts, val, propStr) {\n  var arrayVal = isArrayOrTypedArray(val);\n  var allSet = true;\n  var thisVal = val;\n  var thisPropStr = propStr.replace('-1', 0);\n  var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);\n  var firstPart = innerParts[0];\n  var i;\n\n  for (i = 0; i < containerArray.length; i++) {\n    thisPropStr = propStr.replace('-1', i);\n\n    if (arrayVal) {\n      thisVal = val[i % val.length];\n      deleteThis = isDeletable(thisVal, thisPropStr);\n    }\n\n    if (deleteThis) allSet = false;\n\n    if (!checkNewContainer(containerArray, i, firstPart, deleteThis)) {\n      continue;\n    }\n\n    npSet(containerArray[i], innerParts, propStr.replace('-1', i))(thisVal);\n  }\n\n  return allSet;\n}\n/**\n * make new sub-container as needed.\n * returns false if there's no container and none is needed\n * because we're only deleting an attribute\n */\n\n\nfunction checkNewContainer(container, part, nextPart, toDelete) {\n  if (container[part] === undefined) {\n    if (toDelete) return false;\n    if (typeof nextPart === 'number') container[part] = [];else container[part] = {};\n  }\n\n  return true;\n}\n\nfunction badContainer(container, propStr, propParts) {\n  return {\n    set: function () {\n      throw 'bad container';\n    },\n    get: function () {},\n    astr: propStr,\n    parts: propParts,\n    obj: container\n  };\n}","map":null,"metadata":{},"sourceType":"script"}