{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\n\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\n\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\n\nvar PlotSchema = require('./plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar Polar = require('../plots/polar/legacy');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar Drawing = require('../components/drawing');\n\nvar Color = require('../components/color');\n\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\n\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\n\nvar svgTextUtils = require('../lib/svg_text_utils');\n\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar manageArrays = require('./manage_arrays');\n\nvar helpers = require('./helpers');\n\nvar subroutines = require('./subroutines');\n\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\n\nfunction plot(gd, data, layout, config) {\n  var frames;\n  gd = Lib.getGraphDiv(gd); // Events.init is idempotent and bails early if gd has already been init'd\n\n  Events.init(gd);\n\n  if (Lib.isPlainObject(data)) {\n    var obj = data;\n    data = obj.data;\n    layout = obj.layout;\n    config = obj.config;\n    frames = obj.frames;\n  }\n\n  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n  if (okToPlot === false) return Promise.reject(); // if there's no data or layout, and this isn't yet a plotly plot\n  // container, log a warning to help plotly.js users debug\n\n  if (!data && !layout && !Lib.isPlotDiv(gd)) {\n    Lib.warn('Calling Plotly.plot as if redrawing ' + 'but this container doesn\\'t yet have a plot.', gd);\n  }\n\n  function addFrames() {\n    if (frames) {\n      return exports.addFrames(gd, frames);\n    }\n  } // transfer configuration options to gd until we move over to\n  // a more OO like model\n\n\n  setPlotContext(gd, config);\n  if (!layout) layout = {}; // hook class for plots main container (in case of plotly.js\n  // this won't be #embedded-graph or .js-tab-contents)\n\n  d3.select(gd).classed('js-plotly-plot', true); // off-screen getBoundingClientRect testing space,\n  // in #js-plotly-tester (and stored as Drawing.tester)\n  // so we can share cached text across tabs\n\n  Drawing.makeTester(); // collect promises for any async actions during plotting\n  // any part of the plotting code can push to gd._promises, then\n  // before we move to the next step, we check that they're all\n  // complete, and empty out the promise list again.\n\n  if (!Array.isArray(gd._promises)) gd._promises = [];\n  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data); // if there is already data on the graph, append the new data\n  // if you only want to redraw, pass a non-array for data\n\n  if (Array.isArray(data)) {\n    helpers.cleanData(data);\n    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data); // for routines outside graph_obj that want a clean tab\n    // (rather than appending to an existing one) gd.empty\n    // is used to determine whether to make a new tab\n\n    gd.empty = false;\n  }\n\n  if (!gd.layout || graphWasEmpty) {\n    gd.layout = helpers.cleanLayout(layout);\n  }\n\n  Plots.supplyDefaults(gd);\n  var fullLayout = gd._fullLayout;\n\n  var hasCartesian = fullLayout._has('cartesian'); // Legacy polar plots\n\n\n  if (!fullLayout._has('polar') && data && data[0] && data[0].r) {\n    Lib.log('Legacy polar charts are deprecated!');\n    return plotLegacyPolar(gd, data, layout);\n  } // so we don't try to re-call Plotly.plot from inside\n  // legend and colorbar, if margins changed\n\n\n  fullLayout._replotting = true; // make or remake the framework if we need to\n\n  if (graphWasEmpty) makePlotFramework(gd); // polar need a different framework\n\n  if (gd.framework !== makePlotFramework) {\n    gd.framework = makePlotFramework;\n    makePlotFramework(gd);\n  } // clear gradient defs on each .plot call, because we know we'll loop through all traces\n\n\n  Drawing.initGradients(gd); // save initial show spikes once per graph\n\n  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd); // prepare the data and find the autorange\n  // generate calcdata, if we need to\n  // to force redoing calcdata, just delete it before calling Plotly.plot\n\n  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n  if (recalc) Plots.doCalcdata(gd); // in case it has changed, attach fullData traces to calcdata\n\n  for (var i = 0; i < gd.calcdata.length; i++) {\n    gd.calcdata[i][0].trace = gd._fullData[i];\n  } // make the figure responsive\n\n\n  if (gd._context.responsive) {\n    if (!gd._responsiveChartHandler) {\n      // Keep a reference to the resize handler to purge it down the road\n      gd._responsiveChartHandler = function () {\n        if (!Lib.isHidden(gd)) Plots.resize(gd);\n      }; // Listen to window resize\n\n\n      window.addEventListener('resize', gd._responsiveChartHandler);\n    }\n  } else {\n    Lib.clearResponsive(gd);\n  }\n  /*\n   * start async-friendly code - now we're actually drawing things\n   */\n\n\n  var oldMargins = Lib.extendFlat({}, fullLayout._size); // draw framework first so that margin-pushing\n  // components can position themselves correctly\n\n  var drawFrameworkCalls = 0;\n\n  function drawFramework() {\n    var basePlotModules = fullLayout._basePlotModules;\n\n    for (var i = 0; i < basePlotModules.length; i++) {\n      if (basePlotModules[i].drawFramework) {\n        basePlotModules[i].drawFramework(gd);\n      }\n    }\n\n    if (!fullLayout._glcanvas && fullLayout._has('gl')) {\n      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n        key: 'contextLayer',\n        context: true,\n        pick: false\n      }, {\n        key: 'focusLayer',\n        context: false,\n        pick: false\n      }, {\n        key: 'pickLayer',\n        context: false,\n        pick: true\n      }], function (d) {\n        return d.key;\n      });\n\n      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {\n        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n      }).style({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'visible',\n        'pointer-events': 'none'\n      });\n    }\n\n    if (fullLayout._glcanvas) {\n      fullLayout._glcanvas.attr('width', fullLayout.width).attr('height', fullLayout.height);\n\n      var regl = fullLayout._glcanvas.data()[0].regl;\n\n      if (regl) {\n        // Unfortunately, this can happen when relayouting to large\n        // width/height on some browsers.\n        if (Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight) {\n          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n\n          if (drawFrameworkCalls) {\n            Lib.error(msg);\n          } else {\n            Lib.log(msg + ' Clearing graph and plotting again.');\n            Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n            Plots.supplyDefaults(gd);\n            fullLayout = gd._fullLayout;\n            Plots.doCalcdata(gd);\n            drawFrameworkCalls++;\n            return drawFramework();\n          }\n        }\n      }\n    }\n\n    if (fullLayout.modebar.orientation === 'h') {\n      fullLayout._modebardiv.style('height', null).style('width', '100%');\n    } else {\n      fullLayout._modebardiv.style('width', null).style('height', fullLayout.height + 'px');\n    }\n\n    return Plots.previousPromises(gd);\n  } // draw anything that can affect margins.\n\n\n  function marginPushers() {\n    // First reset the list of things that are allowed to change the margins\n    // So any deleted traces or components will be wiped out of the\n    // automargin calculation.\n    // This means *every* margin pusher must be listed here, even if it\n    // doesn't actually try to push the margins until later.\n    Plots.clearAutoMarginIds(gd);\n    subroutines.drawMarginPushers(gd);\n    Axes.allowAutoMargin(gd); // TODO can this be moved elsewhere?\n\n    if (fullLayout._has('pie')) {\n      var fullData = gd._fullData;\n\n      for (var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if (trace.type === 'pie' && trace.automargin) {\n          Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n        }\n      }\n    }\n\n    Plots.doAutoMargin(gd);\n    return Plots.previousPromises(gd);\n  } // in case the margins changed, draw margin pushers again\n\n\n  function marginPushersAgain() {\n    if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);\n  }\n\n  function positionAndAutorange() {\n    if (!recalc) {\n      doAutoRangeAndConstraints();\n      return;\n    } // TODO: autosize extra for text markers and images\n    // see https://github.com/plotly/plotly.js/issues/1111\n\n\n    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);\n  }\n\n  function doAutoRangeAndConstraints() {\n    if (gd._transitioning) return;\n    subroutines.doAutoRangeAndConstraints(gd); // store initial ranges *after* enforcing constraints, otherwise\n    // we will never look like we're at the initial ranges\n\n    if (graphWasEmpty) Axes.saveRangeInitial(gd); // this one is different from shapes/annotations calcAutorange\n    // the others incorporate those components into ax._extremes,\n    // this one actually sets the ranges in rangesliders.\n\n    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n  } // draw ticks, titles, and calculate axis scaling (._b, ._m)\n\n\n  function drawAxes() {\n    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n  }\n\n  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];\n  if (hasCartesian) seq.push(positionAndAutorange);\n  seq.push(subroutines.layoutStyles);\n  if (hasCartesian) seq.push(drawAxes);\n  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover, Plots.redrag, // TODO: doAutoMargin is only needed here for axis automargin, which\n  // happens outside of marginPushers where all the other automargins are\n  // calculated. Would be much better to separate margin calculations from\n  // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n  Plots.doAutoMargin, Plots.previousPromises); // even if everything we did was synchronous, return a promise\n  // so that the caller doesn't care which route we took\n\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    emitAfterPlot(gd);\n    return gd;\n  });\n}\n\nfunction emitAfterPlot(gd) {\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._redrawFromAutoMarginCount) {\n    fullLayout._redrawFromAutoMarginCount--;\n  } else {\n    gd.emit('plotly_afterplot');\n  }\n}\n\nfunction setPlotConfig(obj) {\n  return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n  try {\n    gd._fullLayout._paper.style('background', bgColor);\n  } catch (e) {\n    Lib.error(e);\n  }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n  var blend = Color.combine(bgColor, 'white');\n  setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n  if (!gd._context) {\n    gd._context = Lib.extendDeep({}, dfltConfig); // stash <base> href, used to make robust clipPath URLs\n\n    var base = d3.select('base');\n    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';\n  }\n\n  var context = gd._context;\n  var i, keys, key;\n\n  if (config) {\n    keys = Object.keys(config);\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      if (key === 'editable' || key === 'edits') continue;\n\n      if (key in context) {\n        if (key === 'setBackground' && config[key] === 'opaque') {\n          context[key] = opaqueSetBackground;\n        } else {\n          context[key] = config[key];\n        }\n      }\n    } // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n\n\n    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n      context.plotGlPixelRatio = context.plot3dPixelRatio;\n    } // now deal with editable and edits - first editable overrides\n    // everything, then edits refines\n\n\n    var editable = config.editable;\n\n    if (editable !== undefined) {\n      // we're not going to *use* context.editable, we're only going to\n      // use context.edits... but keep it for the record\n      context.editable = editable;\n      keys = Object.keys(context.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        context.edits[keys[i]] = editable;\n      }\n    }\n\n    if (config.edits) {\n      keys = Object.keys(config.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n\n        if (key in context.edits) {\n          context.edits[key] = config.edits[key];\n        }\n      }\n    } // not part of the user-facing config options\n\n\n    context._exportedPlot = config._exportedPlot;\n  } // staticPlot forces a bunch of others:\n\n\n  if (context.staticPlot) {\n    context.editable = false;\n    context.edits = {};\n    context.autosizable = false;\n    context.scrollZoom = false;\n    context.doubleClick = false;\n    context.showTips = false;\n    context.showLink = false;\n    context.displayModeBar = false;\n  } // make sure hover-only devices have mode bar visible\n\n\n  if (context.displayModeBar === 'hover' && !hasHover) {\n    context.displayModeBar = true;\n  } // default and fallback for setBackground\n\n\n  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n    context.setBackground = setBackground;\n  } // Check if gd has a specified widht/height to begin with\n\n\n  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0; // fill context._scrollZoom helper to help manage scrollZoom flaglist\n\n  var szIn = context.scrollZoom;\n  var szOut = context._scrollZoom = {};\n\n  if (szIn === true) {\n    szOut.cartesian = 1;\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  } else if (typeof szIn === 'string') {\n    var parts = szIn.split('+');\n\n    for (i = 0; i < parts.length; i++) {\n      szOut[parts[i]] = 1;\n    }\n  } else if (szIn !== false) {\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  }\n}\n\nfunction plotLegacyPolar(gd, data, layout) {\n  // build or reuse the container skeleton\n  var plotContainer = d3.select(gd).selectAll('.plot-container').data([0]);\n  plotContainer.enter().insert('div', ':first-child').classed('plot-container plotly', true);\n  var paperDiv = plotContainer.selectAll('.svg-container').data([0]);\n  paperDiv.enter().append('div').classed('svg-container', true).style('position', 'relative'); // empty it everytime for now\n\n  paperDiv.html(''); // fulfill gd requirements\n\n  if (data) gd.data = data;\n  if (layout) gd.layout = layout;\n  Polar.manager.fillLayout(gd); // resize canvas\n\n  paperDiv.style({\n    width: gd._fullLayout.width + 'px',\n    height: gd._fullLayout.height + 'px'\n  }); // instantiate framework\n\n  gd.framework = Polar.manager.framework(gd); // plot\n\n  gd.framework({\n    data: gd.data,\n    layout: gd.layout\n  }, paperDiv.node()); // set undo point\n\n  gd.framework.setUndoPoint(); // get the resulting svg for extending it\n\n  var polarPlotSVG = gd.framework.svg(); // editable title\n\n  var opacity = 1;\n  var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n  if (txt === '' || !txt) opacity = 0;\n\n  var titleLayout = function titleLayout() {\n    this.call(svgTextUtils.convertToTspans, gd); // TODO: html/mathjax\n    // TODO: center title\n  };\n\n  var title = polarPlotSVG.select('.title-group text').call(titleLayout);\n\n  if (gd._context.edits.titleText) {\n    var placeholderText = Lib._(gd, 'Click to enter Plot title');\n\n    if (!txt || txt === placeholderText) {\n      opacity = 0.2; // placeholder is not going through convertToTspans\n      // so needs explicit data-unformatted\n\n      title.attr({\n        'data-unformatted': placeholderText\n      }).text(placeholderText).style({\n        opacity: opacity\n      }).on('mouseover.opacity', function () {\n        d3.select(this).transition().duration(100).style('opacity', 1);\n      }).on('mouseout.opacity', function () {\n        d3.select(this).transition().duration(1000).style('opacity', 0);\n      });\n    }\n\n    var setContenteditable = function setContenteditable() {\n      this.call(svgTextUtils.makeEditable, {\n        gd: gd\n      }).on('edit', function (text) {\n        gd.framework({\n          layout: {\n            title: {\n              text: text\n            }\n          }\n        });\n        this.text(text).call(titleLayout);\n        this.call(setContenteditable);\n      }).on('cancel', function () {\n        var txt = this.attr('data-unformatted');\n        this.text(txt).call(titleLayout);\n      });\n    };\n\n    title.call(setContenteditable);\n  }\n\n  gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n\n  Plots.addLinks(gd);\n  return Promise.resolve();\n} // convenience function to force a full redraw, mostly for use by plotly.js\n\n\nfunction redraw(gd) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  helpers.cleanData(gd.data);\n  helpers.cleanLayout(gd.layout);\n  gd.calcdata = undefined;\n  return exports.plot(gd).then(function () {\n    gd.emit('plotly_redraw');\n    return gd;\n  });\n}\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\n\n\nfunction newPlot(gd, data, layout, config) {\n  gd = Lib.getGraphDiv(gd); // remove gl contexts\n\n  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n  Plots.purge(gd);\n  return exports.plot(gd, data, layout, config);\n}\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\n\n\nfunction positivifyIndices(indices, maxIndex) {\n  var parentLength = maxIndex + 1;\n  var positiveIndices = [];\n  var i;\n  var index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n\n    if (index < 0) {\n      positiveIndices.push(parentLength + index);\n    } else {\n      positiveIndices.push(index);\n    }\n  }\n\n  return positiveIndices;\n}\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\n\n\nfunction assertIndexArray(gd, indices, arrayName) {\n  var i, index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i]; // validate that indices are indeed integers\n\n    if (index !== parseInt(index, 10)) {\n      throw new Error('all values in ' + arrayName + ' must be integers');\n    } // check that all indices are in bounds for given gd.data array length\n\n\n    if (index >= gd.data.length || index < -gd.data.length) {\n      throw new Error(arrayName + ' must be valid indices for gd.data.');\n    } // check that indices aren't repeated\n\n\n    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n      throw new Error('each index in ' + arrayName + ' must be unique.');\n    }\n  }\n}\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\n\n\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // validate currentIndices array\n\n\n  if (typeof currentIndices === 'undefined') {\n    throw new Error('currentIndices is a required argument.');\n  } else if (!Array.isArray(currentIndices)) {\n    currentIndices = [currentIndices];\n  }\n\n  assertIndexArray(gd, currentIndices, 'currentIndices'); // validate newIndices array if it exists\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined') {\n    assertIndexArray(gd, newIndices, 'newIndices');\n  } // check currentIndices and newIndices are the same length if newIdices exists\n\n\n  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n    throw new Error('current and new indices must be of equal length.');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\n\n\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n  var i, value; // check that gd has attribute 'data' and 'data' is array\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // make sure traces exists\n\n\n  if (typeof traces === 'undefined') {\n    throw new Error('traces must be defined.');\n  } // make sure traces is an array\n\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure each value in traces is an object\n\n\n  for (i = 0; i < traces.length; i++) {\n    value = traces[i];\n\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n      throw new Error('all values in traces array must be non-array objects');\n    }\n  } // make sure we have an index for each trace\n\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n    throw new Error('if indices is specified, traces.length must equal indices.length');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\n\n\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array');\n  }\n\n  if (!Lib.isPlainObject(update)) {\n    throw new Error('update must be a key:value object');\n  }\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers');\n  }\n\n  assertIndexArray(gd, indices, 'indices');\n\n  for (var key in update) {\n    /*\n     * Verify that the attribute to be updated contains as many trace updates\n     * as indices. Failure must result in throw and no-op\n     */\n    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {\n      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n    }\n    /*\n     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n     */\n\n\n    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {\n      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');\n    }\n  }\n}\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\n\n\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  var updateProps = [];\n  var trace, target, prop, insert, maxp; // allow scalar index to represent a single trace position\n\n  if (!Array.isArray(indices)) indices = [indices]; // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // loop through all update keys and traces and harvest validated data.\n\n  for (var key in update) {\n    for (var j = 0; j < indices.length; j++) {\n      /*\n       * Choose the trace indexed by the indices map argument and get the prop setter-getter\n       * instance that references the key and value for this particular trace.\n       */\n      trace = gd.data[indices[j]];\n      prop = nestedProperty(trace, key);\n      /*\n       * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n       * Target must exist as an Array to allow the extend operation to be performed.\n       */\n\n      target = prop.get();\n      insert = update[key][j];\n\n      if (!Lib.isArrayOrTypedArray(insert)) {\n        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n      }\n\n      if (!Lib.isArrayOrTypedArray(target)) {\n        throw new Error('cannot extend missing or non-array attribute: ' + key);\n      }\n\n      if (target.constructor !== insert.constructor) {\n        throw new Error('cannot extend array with an array of a different type: ' + key);\n      }\n      /*\n       * maxPoints may be an object map or a scalar. If object select the key:value, else\n       * Use the scalar maxPoints for all key and trace combinations.\n       */\n\n\n      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints; // could have chosen null here, -1 just tells us to not take a window\n\n      if (!isNumeric(maxp)) maxp = -1;\n      /*\n       * Wrap the nestedProperty in an object containing required data\n       * for lengthening and windowing this particular trace - key combination.\n       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n       */\n\n      updateProps.push({\n        prop: prop,\n        target: target,\n        insert: insert,\n        maxp: Math.floor(maxp)\n      });\n    }\n  } // all target and insertion data now validated\n\n\n  return updateProps;\n}\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\n\n\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n  assertExtendTracesArgs(gd, update, indices, maxPoints);\n  var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n  var undoUpdate = {};\n  var undoPoints = {};\n\n  for (var i = 0; i < updateProps.length; i++) {\n    var prop = updateProps[i].prop;\n    var maxp = updateProps[i].maxp; // return new array and remainder\n\n    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n    prop.set(out[0]); // build the inverse update object for the undo operation\n\n    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n    undoUpdate[prop.astr].push(out[1]); // build the matching maxPoints undo object containing original trace lengths\n\n    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n    undoPoints[prop.astr].push(updateProps[i].target.length);\n  }\n\n  return {\n    update: undoUpdate,\n    maxPoints: undoPoints\n  };\n}\n\nfunction concatTypedArray(arr0, arr1) {\n  var arr2 = new arr0.constructor(arr0.length + arr1.length);\n  arr2.set(arr0);\n  arr2.set(arr1, arr0.length);\n  return arr2;\n}\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\n\n\nfunction extendTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp < 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(target, insert);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target);\n          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          var targetBegin = target.length - numberOfItemsFromTarget;\n          newArray.set(target.subarray(targetBegin));\n          newArray.set(insert, numberOfItemsFromTarget);\n          remainder.set(target.subarray(0, targetBegin));\n        }\n      }\n    } else {\n      newArray = target.concat(insert);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n  return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp <= 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(insert, target);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n          remainder.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target, numberOfItemsFromInsert);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          newArray.set(insert);\n          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n          remainder.set(target.subarray(numberOfItemsFromTarget));\n        }\n      }\n    } else {\n      newArray = insert.concat(target);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n  return promise;\n}\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\n\n\nfunction addTraces(gd, traces, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var currentIndices = [];\n  var undoFunc = exports.deleteTraces;\n  var redoFunc = addTraces;\n  var undoArgs = [gd, currentIndices];\n  var redoArgs = [gd, traces]; // no newIndices here\n\n  var i;\n  var promise; // all validation is done elsewhere to remove clutter here\n\n  checkAddTracesArgs(gd, traces, newIndices); // make sure traces is an array\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure traces do not repeat existing ones\n\n\n  traces = traces.map(function (trace) {\n    return Lib.extendFlat({}, trace);\n  });\n  helpers.cleanData(traces); // add the traces to gd.data (no redrawing yet!)\n\n  for (i = 0; i < traces.length; i++) {\n    gd.data.push(traces[i]);\n  } // to continue, we need to call moveTraces which requires currentIndices\n\n\n  for (i = 0; i < traces.length; i++) {\n    currentIndices.push(-traces.length + i);\n  } // if the user didn't define newIndices, they just want the traces appended\n  // i.e., we can simply redraw and be done\n\n\n  if (typeof newIndices === 'undefined') {\n    promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    return promise;\n  } // make sure indices is property defined\n\n\n  if (!Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  try {\n    // this is redundant, but necessary to not catch later possible errors!\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n  } catch (error) {\n    // something went wrong, reset gd to be safe and rethrow error\n    gd.data.splice(gd.data.length - traces.length, traces.length);\n    throw error;\n  } // if we're here, the user has defined specific places to place the new traces\n  // this requires some extra work that moveTraces will do\n\n\n  Queue.startSequence(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  promise = exports.moveTraces(gd, currentIndices, newIndices);\n  Queue.stopSequence(gd);\n  return promise;\n}\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\n\n\nfunction deleteTraces(gd, indices) {\n  gd = Lib.getGraphDiv(gd);\n  var traces = [];\n  var undoFunc = exports.addTraces;\n  var redoFunc = deleteTraces;\n  var undoArgs = [gd, traces, indices];\n  var redoArgs = [gd, indices];\n  var i;\n  var deletedTrace; // make sure indices are defined\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers.');\n  } else if (!Array.isArray(indices)) {\n    indices = [indices];\n  }\n\n  assertIndexArray(gd, indices, 'indices'); // convert negative indices to positive indices\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // we want descending here so that splicing later doesn't affect indexing\n\n  indices.sort(Lib.sorterDes);\n\n  for (i = 0; i < indices.length; i += 1) {\n    deletedTrace = gd.data.splice(indices[i], 1)[0];\n    traces.push(deletedTrace);\n  }\n\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\n\n\nfunction moveTraces(gd, currentIndices, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var newData = [];\n  var movingTraceMap = [];\n  var undoFunc = moveTraces;\n  var redoFunc = moveTraces;\n  var undoArgs = [gd, newIndices, currentIndices];\n  var redoArgs = [gd, currentIndices, newIndices];\n  var i; // to reduce complexity here, check args elsewhere\n  // this throws errors where appropriate\n\n  checkMoveTracesArgs(gd, currentIndices, newIndices); // make sure currentIndices is an array\n\n  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices]; // if undefined, define newIndices to point to the end of gd.data array\n\n  if (typeof newIndices === 'undefined') {\n    newIndices = [];\n\n    for (i = 0; i < currentIndices.length; i++) {\n      newIndices.push(-currentIndices.length + i);\n    }\n  } // make sure newIndices is an array if it's user-defined\n\n\n  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices]; // convert negative indices to positive indices (they're the same length)\n\n  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n  newIndices = positivifyIndices(newIndices, gd.data.length - 1); // at this point, we've coerced the index arrays into predictable forms\n  // get the traces that aren't being moved around\n\n  for (i = 0; i < gd.data.length; i++) {\n    // if index isn't in currentIndices, include it in ignored!\n    if (currentIndices.indexOf(i) === -1) {\n      newData.push(gd.data[i]);\n    }\n  } // get a mapping of indices to moving traces\n\n\n  for (i = 0; i < currentIndices.length; i++) {\n    movingTraceMap.push({\n      newIndex: newIndices[i],\n      trace: gd.data[currentIndices[i]]\n    });\n  } // reorder this mapping by newIndex, ascending\n\n\n  movingTraceMap.sort(function (a, b) {\n    return a.newIndex - b.newIndex;\n  }); // now, add the moving traces back in, in order!\n\n  for (i = 0; i < movingTraceMap.length; i += 1) {\n    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n  }\n\n  gd.data = newData;\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\n\n\nfunction restyle(gd, astr, val, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = Lib.extendFlat({}, astr);\n    if (_traces === undefined) _traces = val;\n  } else {\n    Lib.warn('Restyle fail.', astr, val, _traces);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var specs = _restyle(gd, aobj, traces);\n\n  var flags = specs.flags; // clear calcdata and/or axis types if required so they get regenerated\n\n  if (flags.calc) gd.calcdata = undefined;\n  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {}); // fill in redraw sequence\n\n  var seq = [];\n\n  if (flags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises); // maybe only call Plots.supplyDataDefaults in the splom case,\n    // to skip over long and slow axes defaults\n\n    Plots.supplyDefaults(gd);\n\n    if (flags.markerSize) {\n      Plots.doCalcdata(gd);\n      addAxRangeSequence(seq); // TODO\n      // if all axes have autorange:false, then\n      // proceed to subroutines.doTraceStyle(),\n      // otherwise we must go through addAxRangeSequence,\n      // which in general must redraws 'all' axes\n    }\n\n    if (flags.style) seq.push(subroutines.doTraceStyle);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    gd.emit('plotly_restyle', specs.eventData);\n    return gd;\n  });\n} // for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\n\n\nfunction undefinedToNull(val) {\n  if (val === undefined) return null;\n  return val;\n}\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\n\n\nfunction makeNP(preGUI, guiEditFlag) {\n  if (!guiEditFlag) return nestedProperty;\n  return function (container, attr, prefix) {\n    var np = nestedProperty(container, attr);\n    var npSet = np.set;\n\n    np.set = function (val) {\n      var fullAttr = (prefix || '') + attr;\n      storeCurrent(fullAttr, np.get(), val, preGUI);\n      npSet(val);\n    };\n\n    return np;\n  };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n  if (Array.isArray(val) || Array.isArray(newVal)) {\n    var arrayVal = Array.isArray(val) ? val : [];\n    var arrayNew = Array.isArray(newVal) ? newVal : [];\n    var maxLen = Math.max(arrayVal.length, arrayNew.length);\n\n    for (var i = 0; i < maxLen; i++) {\n      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n    }\n  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n    var objVal = Lib.isPlainObject(val) ? val : {};\n    var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n    var objBoth = Lib.extendFlat({}, objVal, objNew);\n\n    for (var key in objBoth) {\n      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n    }\n  } else if (preGUI[attr] === undefined) {\n    preGUI[attr] = undefinedToNull(val);\n  }\n}\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\n\n\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n  for (var attr in edits) {\n    var np = nestedProperty(container, attr);\n    storeCurrent(attr, np.get(), edits[attr], preGUI);\n  }\n}\n\nfunction _restyle(gd, aobj, traces) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var data = gd.data;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var i;\n  cleanDeprecatedAttributeKeys(aobj); // initialize flags\n\n  var flags = editTypes.traceFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {};\n  var axlist; // make a new empty vals array for undoit\n\n  function a0() {\n    return traces.map(function () {\n      return undefined;\n    });\n  } // for autoranging multiple axes\n\n\n  function addToAxlist(axid) {\n    var axName = Axes.id2name(axid);\n    if (axlist.indexOf(axName) === -1) axlist.push(axName);\n  }\n\n  function autorangeAttr(axName) {\n    return 'LAYOUT' + axName + '.autorange';\n  }\n\n  function rangeAttr(axName) {\n    return 'LAYOUT' + axName + '.range';\n  }\n\n  function getFullTrace(traceIndex) {\n    // usually fullData maps 1:1 onto data, but with groupby transforms\n    // the fullData index can be greater. Take the *first* matching trace.\n    for (var j = traceIndex; j < fullData.length; j++) {\n      if (fullData[j]._input === data[traceIndex]) return fullData[j];\n    } // should never get here - and if we *do* it should cause an error\n    // later on undefined fullTrace is passed to nestedProperty.\n\n  } // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // val=null will delete the attribute\n  // attr can be an array to set several at once (all to the same val)\n\n\n  function doextra(attr, val, i) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val, i);\n      });\n      return;\n    } // quit if explicitly setting this elsewhere\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var extraparam;\n\n    if (attr.substr(0, 6) === 'LAYOUT') {\n      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n    } else {\n      var tracei = traces[i];\n\n      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n\n      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n    }\n\n    if (!(attr in undoit)) {\n      undoit[attr] = a0();\n    }\n\n    if (undoit[attr][i] === undefined) {\n      undoit[attr][i] = undefinedToNull(extraparam.get());\n    }\n\n    if (val !== undefined) {\n      extraparam.set(val);\n    }\n  }\n\n  function allBins(binAttr) {\n    return function (j) {\n      return fullData[j][binAttr];\n    };\n  }\n\n  function arrayBins(binAttr) {\n    return function (vij, j) {\n      return vij === false ? fullData[traces[j]][binAttr] : null;\n    };\n  } // now make the changes to gd.data (and occasionally gd.layout)\n  // and figure out what kind of graphics update we need to do\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var vi = aobj[ai];\n    var cont;\n    var contFull;\n    var param;\n    var oldVal;\n    var newVal;\n    var valObject; // Backward compatibility shim for turning histogram autobin on,\n    // or freezing previous autobinned values.\n    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n\n    if (ai === 'autobinx' || ai === 'autobiny') {\n      ai = ai.charAt(ai.length - 1) + 'bins';\n      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;\n    }\n\n    redoit[ai] = vi;\n\n    if (ai.substr(0, 6) === 'LAYOUT') {\n      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n      undoit[ai] = [undefinedToNull(param.get())]; // since we're allowing val to be an array, allow it here too,\n      // even though that's meaningless\n\n      param.set(Array.isArray(vi) ? vi[0] : vi); // ironically, the layout attrs in restyle only require replot,\n      // not relayout\n\n      flags.calc = true;\n      continue;\n    } // set attribute in gd.data\n\n\n    undoit[ai] = a0();\n\n    for (i = 0; i < traces.length; i++) {\n      cont = data[traces[i]];\n      contFull = getFullTrace(traces[i]);\n      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n      param = makeNP(preGUI, guiEditFlag)(cont, ai);\n      oldVal = param.get();\n      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n      if (newVal === undefined) continue;\n      var finalPart = param.parts[param.parts.length - 1];\n      var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n      var prefixDot = prefix ? prefix + '.' : '';\n      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;\n      valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n      if (valObject && valObject.impliedEdits && newVal !== null) {\n        for (var impliedKey in valObject.impliedEdits) {\n          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n        }\n      } else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {\n        // changing colorbar size modes,\n        // make the resulting size not change\n        // note that colorbar fractional sizing is based on the\n        // original plot size, before anything (like a colorbar)\n        // increases the margins\n        var gs = fullLayout._size;\n        var orient = innerContFull.orient;\n        var topOrBottom = orient === 'top' || orient === 'bottom';\n\n        if (finalPart === 'thicknessmode') {\n          var thicknorm = topOrBottom ? gs.h : gs.w;\n          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n        } else {\n          var lennorm = topOrBottom ? gs.w : gs.h;\n          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n        }\n      } else if (ai === 'type' && (newVal === 'pie' !== (oldVal === 'pie') || newVal === 'funnelarea' !== (oldVal === 'funnelarea'))) {\n        var labelsTo = 'x';\n        var valuesTo = 'y';\n\n        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n          labelsTo = 'y';\n          valuesTo = 'x';\n        }\n\n        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n        if (oldVal === 'pie' || oldVal === 'funnelarea') {\n          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get()); // super kludgy - but if all pies are gone we won't remove them otherwise\n\n          fullLayout._pielayer.selectAll('g.trace').remove();\n        } else if (Registry.traceIs(cont, 'cartesian')) {\n          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());\n        }\n      }\n\n      undoit[ai][i] = undefinedToNull(oldVal); // set the new value - if val is an array, it's one el per trace\n      // first check for attributes that get more complex alterations\n\n      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];\n\n      if (swapAttrs.indexOf(ai) !== -1) {\n        // setting an orientation: make sure it's changing\n        // before we swap everything else\n        if (ai === 'orientation') {\n          param.set(newVal); // obnoxious that we need this level of coupling... but in order to\n          // properly handle setting orientation to `null` we need to mimic\n          // the logic inside Bars.supplyDefaults for default orientation\n\n          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';\n\n          if ((param.get() || defaultOrientation) === contFull.orientation) {\n            continue;\n          }\n        } else if (ai === 'orientationaxes') {\n          // orientationaxes has no value,\n          // it flips everything and the axes\n          cont.orientation = {\n            v: 'h',\n            h: 'v'\n          }[contFull.orientation];\n        }\n\n        helpers.swapXYData(cont);\n        flags.calc = flags.clearAxisTypes = true;\n      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n        // TODO: use manageArrays.applyContainerArrayChanges here too\n        helpers.manageArrayContainers(param, newVal, undoit);\n        flags.calc = true;\n      } else {\n        if (valObject) {\n          // must redo calcdata when restyling array values of arrayOk attributes\n          // ... but no need to this for regl-based traces\n          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {\n            flags.calc = true;\n          } else editTypes.update(flags, valObject);\n        } else {\n          /*\n           * if we couldn't find valObject,  assume a full recalc.\n           * This can happen if you're changing type and making\n           * some other edits too, so the modules we're\n           * looking at don't have these attributes in them.\n           */\n          flags.calc = true;\n        } // all the other ones, just modify that one attribute\n\n\n        param.set(newVal);\n      }\n    } // swap the data attributes of the relevant x and y axes?\n\n\n    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n      Axes.swap(gd, traces);\n    } // swap hovermode if set to \"compare x/y data\"\n\n\n    if (ai === 'orientationaxes') {\n      var hovermode = nestedProperty(gd.layout, 'hovermode');\n\n      if (hovermode.get() === 'x') {\n        hovermode.set('y');\n      } else if (hovermode.get() === 'y') {\n        hovermode.set('x');\n      }\n    } // Major enough changes deserve autoscale and\n    // non-reversed axes so people don't get confused\n    //\n    // Note: autobin (or its new analog bin clearing) is not included here\n    // since we're not pushing bins back to gd.data, so if we have bin\n    // info it was explicitly provided by the user.\n\n\n    if (['orientation', 'type'].indexOf(ai) !== -1) {\n      axlist = [];\n\n      for (i = 0; i < traces.length; i++) {\n        var trace = data[traces[i]];\n\n        if (Registry.traceIs(trace, 'cartesian')) {\n          addToAxlist(trace.xaxis || 'x');\n          addToAxlist(trace.yaxis || 'y');\n        }\n      }\n\n      doextra(axlist.map(autorangeAttr), true, 0);\n      doextra(axlist.map(rangeAttr), [0, 1], 0);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  return {\n    flags: flags,\n    undoit: undoit,\n    redoit: redoit,\n    traces: traces,\n    eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n  };\n}\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\n\n\nfunction cleanDeprecatedAttributeKeys(aobj) {\n  var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n  var colorbarRegex = /colorbar\\.title$/;\n  var keys = Object.keys(aobj);\n  var i, key, value;\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    value = aobj[key];\n\n    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {\n      replace(key, key.replace('title', 'title.text'));\n    } else if (key.indexOf('titlefont') > -1) {\n      replace(key, key.replace('titlefont', 'title.font'));\n    } else if (key.indexOf('titleposition') > -1) {\n      replace(key, key.replace('titleposition', 'title.position'));\n    } else if (key.indexOf('titleside') > -1) {\n      replace(key, key.replace('titleside', 'title.side'));\n    } else if (key.indexOf('titleoffset') > -1) {\n      replace(key, key.replace('titleoffset', 'title.offset'));\n    }\n  }\n\n  function replace(oldAttrStr, newAttrStr) {\n    aobj[newAttrStr] = aobj[oldAttrStr];\n    delete aobj[oldAttrStr];\n  }\n}\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\n\n\nfunction relayout(gd, astr, val) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = Lib.extendFlat({}, astr);\n  } else {\n    Lib.warn('Relayout fail.', astr, val);\n    return Promise.reject();\n  }\n\n  if (Object.keys(aobj).length) gd.changed = true;\n\n  var specs = _relayout(gd, aobj);\n\n  var flags = specs.flags; // clear calcdata if required\n\n  if (flags.calc) gd.calcdata = undefined; // fill in redraw sequence\n  // even if we don't have anything left in aobj,\n  // something may have happened within relayout that we\n  // need to wait for\n\n  var seq = [Plots.previousPromises];\n\n  if (flags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else if (Object.keys(aobj).length) {\n    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n    if (flags.legend) seq.push(subroutines.doLegend);\n    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n    if (flags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (flags.modebar) seq.push(subroutines.doModeBar);\n    if (flags.camera) seq.push(subroutines.doCamera);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_relayout', specs.eventData);\n    return gd;\n  });\n} // Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\n\n\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n  var fullLayout = gd._fullLayout;\n  if (!flags.axrange) return false;\n\n  for (var k in flags) {\n    if (k !== 'axrange' && flags[k]) return false;\n  }\n\n  for (var axId in specs.rangesAltered) {\n    var axName = Axes.id2name(axId);\n    var axIn = gd.layout[axName];\n    var axOut = fullLayout[axName];\n    axOut.autorange = axIn.autorange;\n    axOut.range = axIn.range.slice();\n    axOut.cleanRange();\n\n    if (axOut._matchGroup) {\n      for (var axId2 in axOut._matchGroup) {\n        if (axId2 !== axId) {\n          var ax2 = fullLayout[Axes.id2name(axId2)];\n          ax2.autorange = axOut.autorange;\n          ax2.range = axOut.range.slice();\n          ax2._input.range = axOut.range.slice();\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n  // N.B. leave as sequence of subroutines (for now) instead of\n  // subroutine of its own so that finalDraw always gets\n  // executed after drawData\n  var drawAxes = rangesAltered ? function (gd) {\n    var axIds = [];\n    var skipTitle = true;\n\n    for (var id in rangesAltered) {\n      var ax = Axes.getFromId(gd, id);\n      axIds.push(id);\n\n      if (ax._matchGroup) {\n        for (var id2 in ax._matchGroup) {\n          if (!rangesAltered[id2]) {\n            axIds.push(id2);\n          }\n        }\n      }\n\n      if (ax.automargin) skipTitle = false;\n    }\n\n    return Axes.draw(gd, axIds, {\n      skipTitle: skipTitle\n    });\n  } : function (gd) {\n    return Axes.draw(gd, 'redraw');\n  };\n  seq.push(clearSelect, subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var keys = Object.keys(aobj);\n  var axes = Axes.list(gd);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var arrayEdits = {};\n  var arrayStr, i, j;\n  cleanDeprecatedAttributeKeys(aobj);\n  keys = Object.keys(aobj); // look for 'allaxes', split out into all axes\n  // in case of 3D the axis are nested within a scene which is held in _id\n\n  for (i = 0; i < keys.length; i++) {\n    if (keys[i].indexOf('allaxes') === 0) {\n      for (j = 0; j < axes.length; j++) {\n        var scene = axes[j]._id.substr(1);\n\n        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';\n        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n      }\n\n      delete aobj[keys[i]];\n    }\n  } // initialize flags\n\n\n  var flags = editTypes.layoutFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {}; // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // attr can be an array to set several at once (all to the same val)\n\n  function doextra(attr, val) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val);\n      });\n      return;\n    } // if we have another value for this attribute (explicitly or\n    // via a parent) do not override with this auto-generated extra\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var p = layoutNP(layout, attr);\n\n    if (!(attr in undoit)) {\n      undoit[attr] = undefinedToNull(p.get());\n    }\n\n    if (val !== undefined) p.set(val);\n  } // for constraint enforcement: keep track of all axes (as {id: name})\n  // we're editing the (auto)range of, so we can tell the others constrained\n  // to scale with them that it's OK for them to shrink\n\n\n  var rangesAltered = {};\n  var axId;\n\n  function recordAlteredAxis(pleafPlus) {\n    var axId = Axes.name2id(pleafPlus.split('.')[0]);\n    rangesAltered[axId] = 1;\n    return axId;\n  } // alter gd.layout\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var p = layoutNP(layout, ai);\n    var vi = aobj[ai];\n    var plen = p.parts.length; // p.parts may end with an index integer if the property is an array\n\n    var pend = plen - 1;\n\n    while (pend > 0 && typeof p.parts[pend] !== 'string') {\n      pend--;\n    } // last property in chain (leaf node)\n\n\n    var pleaf = p.parts[pend]; // leaf plus immediate parent\n\n    var pleafPlus = p.parts[pend - 1] + '.' + pleaf; // trunk nodes (everything except the leaf)\n\n    var ptrunk = p.parts.slice(0, pend).join('.');\n    var parentIn = nestedProperty(gd.layout, ptrunk).get();\n    var parentFull = nestedProperty(fullLayout, ptrunk).get();\n    var vOld = p.get();\n    if (vi === undefined) continue;\n    redoit[ai] = vi; // axis reverse is special - it is its own inverse\n    // op and has no flag.\n\n    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);\n    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n    if (valObject && valObject.impliedEdits && vi !== null) {\n      for (var impliedKey in valObject.impliedEdits) {\n        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n      }\n    } // Setting width or height to null must reset the graph's width / height\n    // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    //\n    // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // can't use impliedEdits for this because behavior depends on vi\n\n\n    if (['width', 'height'].indexOf(ai) !== -1) {\n      if (vi) {\n        doextra('autosize', null); // currently we don't support autosize one dim only - so\n        // explicitly set the other one. Note that doextra will\n        // ignore this if the same relayout call also provides oppositeAttr\n\n        var oppositeAttr = ai === 'height' ? 'width' : 'height';\n        doextra(oppositeAttr, fullLayout[oppositeAttr]);\n      } else {\n        fullLayout[ai] = gd._initialAutoSize[ai];\n      }\n    } else if (ai === 'autosize') {\n      // depends on vi here too, so again can't use impliedEdits\n      doextra('width', vi ? null : fullLayout.width);\n      doextra('height', vi ? null : fullLayout.height);\n    } else if (pleafPlus.match(AX_RANGE_RE)) {\n      // check autorange vs range\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n      var axFull = nestedProperty(fullLayout, ptrunk).get();\n\n      if (axFull._inputDomain) {\n        // if we're autoranging and this axis has a constrained domain,\n        // reset it so we don't get locked into a shrunken size\n        axFull._input.domain = axFull._inputDomain.slice();\n      }\n    } else if (pleafPlus.match(AX_DOMAIN_RE)) {\n      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n    } // toggling axis type between log and linear: we need to convert\n    // positions for components that are still using linearized values,\n    // not data values like newer components.\n    // previously we did this for log <-> not-log, but now only do it\n    // for log <-> linear\n\n\n    if (pleaf === 'type') {\n      var ax = parentIn;\n      var toLog = parentFull.type === 'linear' && vi === 'log';\n      var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n      if (toLog || fromLog) {\n        if (!ax || !ax.range) {\n          // 2D never gets here, but 3D does\n          // I don't think this is needed, but left here in case there\n          // are edge cases I'm not thinking of.\n          doextra(ptrunk + '.autorange', true);\n        } else if (!parentFull.autorange) {\n          // toggling log without autorange: need to also recalculate ranges\n          // because log axes use linearized values for range endpoints\n          var r0 = ax.range[0];\n          var r1 = ax.range[1];\n\n          if (toLog) {\n            // if both limits are negative, autorange\n            if (r0 <= 0 && r1 <= 0) {\n              doextra(ptrunk + '.autorange', true);\n            } // if one is negative, set it 6 orders below the other.\n\n\n            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6; // now set the range values as appropriate\n\n            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n          } else {\n            doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n            doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n          }\n        } else if (toLog) {\n          // just make sure the range is positive and in the right\n          // order, it'll get recalculated later\n          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];\n        } // clear polar view initial stash for radial range so that\n        // value get recomputed in correct units\n\n\n        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {\n          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n        } // Annotations and images also need to convert to/from linearized coords\n        // Shapes do not need this :)\n\n\n        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n      } else {\n        // any other type changes: the range from the previous type\n        // will not make sense, so autorange it.\n        doextra(ptrunk + '.autorange', true);\n        doextra(ptrunk + '.range', null);\n      }\n\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleaf.match(AX_NAME_PATTERN)) {\n      var fullProp = nestedProperty(fullLayout, ai).get();\n      var newType = (vi || {}).type; // This can potentially cause strange behavior if the autotype is not\n      // numeric (linear, because we don't auto-log) but the previous type\n      // was log. That's a very strange edge case though\n\n      if (!newType || newType === '-') newType = 'linear';\n      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n    } // alter gd.layout\n    // collect array component edits for execution all together\n    // so we can ensure consistent behavior adding/removing items\n    // and order-independence for add/remove/edit all together in\n    // one relayout call\n\n\n    var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n\n    if (containerArrayMatch) {\n      arrayStr = containerArrayMatch.array;\n      i = containerArrayMatch.index;\n      var propStr = containerArrayMatch.property;\n      var updateValObject = valObject || {\n        editType: 'calc'\n      };\n\n      if (i !== '' && propStr === '') {\n        // special handling of undoit if we're adding or removing an element\n        // ie 'annotations[2]' which can be {...} (add) or null,\n        // does not work when replacing the entire array\n        if (manageArrays.isAddVal(vi)) {\n          undoit[ai] = null;\n        } else if (manageArrays.isRemoveVal(vi)) {\n          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n        } else {\n          Lib.warn('unrecognized full object value', aobj);\n        }\n      }\n\n      editTypes.update(flags, updateValObject); // prepare the edits object we'll send to applyContainerArrayChanges\n\n      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n      var objEdits = arrayEdits[arrayStr][i];\n      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n      objEdits[propStr] = vi;\n      delete aobj[ai];\n    } else if (pleaf === 'reverse') {\n      // handle axis reversal explicitly, as there's no 'reverse' attribute\n      if (parentIn.range) parentIn.range.reverse();else {\n        doextra(ptrunk + '.autorange', true);\n        parentIn.range = [1, 0];\n      }\n      if (parentFull.autorange) flags.calc = true;else flags.plot = true;\n    } else {\n      if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {\n        flags.plot = true;\n      } else if (fullLayout._has('gl2d')) {\n        flags.plot = true;\n      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;\n\n      p.set(vi);\n    }\n  } // now we've collected component edits - execute them all together\n\n\n  for (arrayStr in arrayEdits) {\n    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n    if (!finished) flags.plot = true;\n  } // figure out if we need to recalculate axis constraints\n\n\n  var constraints = fullLayout._axisConstraintGroups || [];\n\n  for (axId in rangesAltered) {\n    for (i = 0; i < constraints.length; i++) {\n      var group = constraints[i];\n\n      if (group[axId]) {\n        // Always recalc if we're changing constrained ranges.\n        // Otherwise it's possible to violate the constraints by\n        // specifying arbitrary ranges for all axes in the group.\n        // this way some ranges may expand beyond what's specified,\n        // as they do at first draw, to satisfy the constraints.\n        flags.calc = true;\n\n        for (var groupAxId in group) {\n          if (!rangesAltered[groupAxId]) {\n            Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n          }\n        }\n      }\n    }\n  } // If the autosize changed or height or width was explicitly specified,\n  // this triggers a redraw\n  // TODO: do we really need special aobj.height/width handling here?\n  // couldn't editType do this?\n\n\n  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  } // now all attribute mods are done, as are\n  // redo and undo so we can save them\n\n\n  return {\n    flags: flags,\n    rangesAltered: rangesAltered,\n    undoit: undoit,\n    redoit: redoit,\n    eventData: eventData\n  };\n}\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\n\n\nfunction updateAutosize(gd) {\n  var fullLayout = gd._fullLayout;\n  var oldWidth = fullLayout.width;\n  var oldHeight = fullLayout.height; // calculate autosizing\n\n  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;\n}\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\n\n\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n\n  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n  if (Object.keys(traceUpdate).length) gd.changed = true;\n  if (Object.keys(layoutUpdate).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n\n  var restyleFlags = restyleSpecs.flags;\n\n  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n\n  var relayoutFlags = relayoutSpecs.flags; // clear calcdata and/or axis types if required\n\n  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate); // fill in redraw sequence\n\n  var seq = [];\n\n  if (relayoutFlags.layoutReplot) {\n    // N.B. works fine when both\n    // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n    seq.push(subroutines.layoutReplot);\n  } else if (restyleFlags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises);\n    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n    if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n    if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n    if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_update', {\n      data: restyleSpecs.eventData,\n      layout: relayoutSpecs.eventData\n    });\n    return gd;\n  });\n}\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\n\n\nfunction guiEdit(func) {\n  return function wrappedEdit(gd) {\n    gd._fullLayout._guiEditing = true;\n    var p = func.apply(null, arguments);\n    gd._fullLayout._guiEditing = false;\n    return p;\n  };\n} // For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\n\n\nvar layoutUIControlPatterns = [{\n  pattern: /^hiddenlabels/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/\n}, // showspikes and modes include those nested inside scenes\n{\n  pattern: /axis\\d*\\.showspikes$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /(hover|drag)mode$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /^(scene\\d*)\\.camera/\n}, {\n  pattern: /^(geo\\d*)\\.(projection|center)/\n}, {\n  pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/\n}, {\n  pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/\n}, {\n  pattern: /^(polar\\d*\\.angularaxis)\\.rotation/\n}, {\n  pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^legend\\.(x|y)$/,\n  attr: 'editrevision'\n}, {\n  pattern: /^(shapes|annotations)/,\n  attr: 'editrevision'\n}, {\n  pattern: /^title\\.text$/,\n  attr: 'editrevision'\n}]; // same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\n\nvar traceUIControlPatterns = [{\n  pattern: /^selectedpoints$/,\n  attr: 'selectionrevision'\n}, // \"visible\" includes trace.transforms[i].styles[j].value.visible\n{\n  pattern: /(^|value\\.)visible$/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^dimensions\\[\\d+\\]\\.constraintrange/\n}, {\n  pattern: /^node\\.(x|y|groups)/\n}, // for Sankey nodes\n{\n  pattern: /^level$/\n}, // for Sunburst & Treemap traces\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n// \"name\" also includes transform.styles\n{\n  pattern: /(^|value\\.)name$/\n}, // including nested colorbar attributes (ie marker.colorbar)\n{\n  pattern: /colorbar\\.title\\.text$/\n}, {\n  pattern: /colorbar\\.(x|y)$/,\n  attr: 'editrevision'\n}];\n\nfunction findUIPattern(key, patternSpecs) {\n  for (var i = 0; i < patternSpecs.length; i++) {\n    var spec = patternSpecs[i];\n    var match = key.match(spec.pattern);\n\n    if (match) {\n      return {\n        head: match[1],\n        attr: spec.attr\n      };\n    }\n  }\n} // We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\n\n\nfunction getNewRev(revAttr, container) {\n  var newRev = nestedProperty(container, revAttr).get();\n  if (newRev !== undefined) return newRev;\n  var parts = revAttr.split('.');\n  parts.pop();\n\n  while (parts.length > 1) {\n    parts.pop();\n    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n    if (newRev !== undefined) return newRev;\n  }\n\n  return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (fullData[i]._fullInput.uid === uid) return i;\n  }\n\n  return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].uid === uid) return i;\n  } // fall back on trace order, but only if user didn't provide a uid for that trace\n\n\n  return !data[tracei] || data[tracei].uid ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n  var v1IsObj = Lib.isPlainObject(v1);\n  var v1IsArray = Array.isArray(v1);\n\n  if (v1IsObj || v1IsArray) {\n    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);\n  }\n\n  return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n  var layoutPreGUI = oldFullLayout._preGUI;\n  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n  var bothInheritAutorange = [];\n  var newRangeAccepted = {};\n\n  for (key in layoutPreGUI) {\n    match = findUIPattern(key, layoutUIControlPatterns);\n\n    if (match) {\n      revAttr = match.attr || match.head + '.uirevision';\n      oldRev = nestedProperty(oldFullLayout, revAttr).get();\n      newRev = oldRev && getNewRev(revAttr, layout);\n\n      if (newRev && newRev === oldRev) {\n        preGUIVal = layoutPreGUI[key];\n        if (preGUIVal === null) preGUIVal = undefined;\n        newNP = nestedProperty(layout, key);\n        newVal = newNP.get();\n\n        if (valsMatch(newVal, preGUIVal)) {\n          if (newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n            bothInheritAutorange.push(key.substr(0, key.length - 10));\n          }\n\n          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n          continue;\n        }\n      }\n    } else {\n      Lib.warn('unrecognized GUI edit: ' + key);\n    } // if we got this far, the new value was accepted as the new starting\n    // point (either because it changed or revision changed)\n    // so remove it from _preGUI for next time.\n\n\n    delete layoutPreGUI[key];\n\n    if (key.substr(key.length - 8, 6) === 'range[') {\n      newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n    }\n  } // Special logic for `autorange`, since it interacts with `range`:\n  // If the new figure's matching `range` was kept, and `autorange`\n  // wasn't supplied explicitly in either the original or the new figure,\n  // we shouldn't alter that - but we may just have done that, so fix it.\n\n\n  for (var i = 0; i < bothInheritAutorange.length; i++) {\n    var axAttr = bothInheritAutorange[i];\n\n    if (newRangeAccepted[axAttr]) {\n      var newAx = nestedProperty(layout, axAttr).get();\n      if (newAx) delete newAx.autorange;\n    }\n  } // Now traces - try to match them up by uid (in case we added/deleted in\n  // the middle), then fall back on index.\n\n\n  var allTracePreGUI = oldFullLayout._tracePreGUI;\n\n  for (var uid in allTracePreGUI) {\n    var tracePreGUI = allTracePreGUI[uid];\n    var newTrace = null;\n    var fullInput;\n\n    for (key in tracePreGUI) {\n      // wait until we know we have preGUI values to look for traces\n      // but if we don't find both, stop looking at this uid\n      if (!newTrace) {\n        var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n\n        if (fulli < 0) {\n          // Somehow we didn't even have this trace in oldFullData...\n          // I guess this could happen with `deleteTraces` or something\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        var fullTrace = oldFullData[fulli];\n        fullInput = fullTrace._fullInput;\n        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n\n        if (newTracei < 0) {\n          // No match in new data\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        newTrace = data[newTracei];\n      }\n\n      match = findUIPattern(key, traceUIControlPatterns);\n\n      if (match) {\n        if (match.attr) {\n          oldRev = nestedProperty(oldFullLayout, match.attr).get();\n          newRev = oldRev && getNewRev(match.attr, layout);\n        } else {\n          oldRev = fullInput.uirevision; // inheritance for trace.uirevision is simple, just layout.uirevision\n\n          newRev = newTrace.uirevision;\n          if (newRev === undefined) newRev = layout.uirevision;\n        }\n\n        if (newRev && newRev === oldRev) {\n          preGUIVal = tracePreGUI[key];\n          if (preGUIVal === null) preGUIVal = undefined;\n          newNP = nestedProperty(newTrace, key);\n          newVal = newNP.get();\n\n          if (valsMatch(newVal, preGUIVal)) {\n            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n            continue;\n          }\n        }\n      } else {\n        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n      }\n\n      delete tracePreGUI[key];\n    }\n  }\n}\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\n\n\nfunction react(gd, data, layout, config) {\n  var frames, plotDone;\n\n  function addFrames() {\n    return exports.addFrames(gd, frames);\n  }\n\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var oldFullData = gd._fullData;\n  var oldFullLayout = gd._fullLayout; // you can use this as the initial draw as well as to update\n\n  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n    plotDone = exports.newPlot(gd, data, layout, config);\n  } else {\n    if (Lib.isPlainObject(data)) {\n      var obj = data;\n      data = obj.data;\n      layout = obj.layout;\n      config = obj.config;\n      frames = obj.frames;\n    }\n\n    var configChanged = false; // assume that if there's a config at all, we're reacting to it too,\n    // and completely replace the previous config\n\n    if (config) {\n      var oldConfig = Lib.extendDeep({}, gd._context);\n      gd._context = undefined;\n      setPlotContext(gd, config);\n      configChanged = diffConfig(oldConfig, gd._context);\n    }\n\n    gd.data = data || [];\n    helpers.cleanData(gd.data);\n    gd.layout = layout || {};\n    helpers.cleanLayout(gd.layout);\n    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout); // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n    // which supplyDefaults usually does at the end, but we may need to NOT do\n    // if the diff (which we haven't determined yet) says we'll recalc\n\n    Plots.supplyDefaults(gd, {\n      skipUpdateCalc: true\n    });\n    var newFullData = gd._fullData;\n    var newFullLayout = gd._fullLayout;\n    var immutable = newFullLayout.datarevision === undefined;\n    var transition = newFullLayout.transition;\n    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n    var newDataRevision = relayoutFlags.newDataRevision;\n    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision); // TODO: how to translate this part of relayout to Plotly.react?\n    // // Setting width or height to null must reset the graph's width / height\n    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    // //\n    // // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n    //     fullLayout[ai] = gd._initialAutoSize[ai];\n    // }\n\n    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true; // clear calcdata if required\n\n    if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined; // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n    else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData); // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n    // must be handled by the user when using Plotly.react.\n    // fill in redraw sequence\n\n    var seq = [];\n\n    if (frames) {\n      gd._transitionData = {};\n      Plots.createTransitionData(gd);\n      seq.push(addFrames);\n    } // Transition pathway,\n    // only used when 'transition' is set by user and\n    // when at least one animatable attribute has changed,\n    // N.B. config changed aren't animatable\n\n\n    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n      Plots.doCalcdata(gd);\n      subroutines.doAutoRangeAndConstraints(gd);\n      seq.push(function () {\n        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n      });\n    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n      gd._fullLayout._skipDefaults = true;\n      seq.push(exports.plot);\n    } else {\n      for (var componentType in relayoutFlags.arrays) {\n        var indices = relayoutFlags.arrays[componentType];\n\n        if (indices.length) {\n          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n\n          if (drawOne !== Lib.noop) {\n            for (var i = 0; i < indices.length; i++) {\n              drawOne(gd, indices[i]);\n            }\n          } else {\n            var draw = Registry.getComponentMethod(componentType, 'draw');\n\n            if (draw === Lib.noop) {\n              throw new Error('cannot draw components: ' + componentType);\n            }\n\n            draw(gd);\n          }\n        }\n      }\n\n      seq.push(Plots.previousPromises);\n      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n      if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n      if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n      if (relayoutFlags.axrange) addAxRangeSequence(seq);\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n      if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n      seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n    plotDone = Lib.syncOrAsync(seq, gd);\n    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  }\n\n  return plotDone.then(function () {\n    gd.emit('plotly_react', {\n      data: data,\n      layout: layout\n    });\n    return gd;\n  });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n  var sameTraceLength = oldFullData.length === newFullData.length;\n\n  if (!transition && !sameTraceLength) {\n    return {\n      fullReplot: true,\n      calc: true\n    };\n  }\n\n  var flags = editTypes.traceFlags();\n  flags.arrays = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  var i, trace;\n\n  function getTraceValObject(parts) {\n    var out = PlotSchema.getTraceValObject(trace, parts);\n\n    if (!trace._module.animatable && out.anim) {\n      out.anim = false;\n    }\n\n    return out;\n  }\n\n  var diffOpts = {\n    getValObject: getTraceValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    newDataRevision: newDataRevision,\n    gd: gd\n  };\n  var seenUIDs = {};\n\n  for (i = 0; i < oldFullData.length; i++) {\n    if (newFullData[i]) {\n      trace = newFullData[i]._fullInput;\n      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n      if (seenUIDs[trace.uid]) continue;\n      seenUIDs[trace.uid] = 1;\n      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n  var flags = editTypes.layoutFlags();\n  flags.arrays = {};\n  flags.rangesAltered = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n\n  function getLayoutValObject(parts) {\n    return PlotSchema.getLayoutValObject(newFullLayout, parts);\n  }\n\n  var diffOpts = {\n    getValObject: getLayoutValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    gd: gd\n  };\n  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n  var valObject, key, astr;\n  var getValObject = opts.getValObject;\n  var flags = opts.flags;\n  var immutable = opts.immutable;\n  var inArray = opts.inArray;\n  var arrayIndex = opts.arrayIndex;\n\n  function changed() {\n    var editType = valObject.editType;\n\n    if (inArray && editType.indexOf('arraydraw') !== -1) {\n      Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n      return;\n    }\n\n    editTypes.update(flags, valObject);\n\n    if (editType !== 'none') {\n      flags.nChanges++;\n    } // track animatable changes\n\n\n    if (opts.transition && valObject.anim) {\n      flags.nChangesAnim++;\n    } // track cartesian axes with altered ranges\n\n\n    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n      flags.rangesAltered[outerparts[0]] = 1;\n    } // clear _inputDomain on cartesian axes with altered domains\n\n\n    if (AX_DOMAIN_RE.test(astr)) {\n      nestedProperty(newContainer, '_inputDomain').set(null);\n    } // track datarevision changes\n\n\n    if (key === 'datarevision') {\n      flags.newDataRevision = 1;\n    }\n  }\n\n  function valObjectCanBeDataArray(valObject) {\n    return valObject.valType === 'data_array' || valObject.arrayOk;\n  }\n\n  for (key in oldContainer) {\n    // short-circuit based on previous calls or previous keys that already maximized the pathway\n    if (flags.calc && !opts.transition) return;\n    var oldVal = oldContainer[key];\n    var newVal = newContainer[key];\n    var parts = outerparts.concat(key);\n    astr = parts.join('.');\n    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue; // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n    // and unlike other auto values they don't make it back into the input,\n    // so newContainer won't have them.\n\n    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n      var tickMode = newContainer.tickmode;\n      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n    } // FIXME: Similarly for axis ranges for 3D\n    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n\n\n    if (key === 'range' && newContainer.autorange) continue;\n    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n    valObject = getValObject(parts); // in case type changed, we may not even *have* a valObject.\n\n    if (!valObject) continue;\n    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n    var valType = valObject.valType;\n    var i;\n    var canBeDataArray = valObjectCanBeDataArray(valObject);\n    var wasArray = Array.isArray(oldVal);\n    var nowArray = Array.isArray(newVal); // hack for traces that modify the data in supplyDefaults, like\n    // converting 1D to 2D arrays, which will always create new objects\n\n    if (wasArray && nowArray) {\n      var inputKey = '_input_' + key;\n      var oldValIn = oldContainer[inputKey];\n      var newValIn = newContainer[inputKey];\n      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n    }\n\n    if (newVal === undefined) {\n      if (canBeDataArray && wasArray) flags.calc = true;else changed();\n    } else if (valObject._isLinkedToArray) {\n      var arrayEditIndices = [];\n      var extraIndices = false;\n      if (!inArray) flags.arrays[key] = arrayEditIndices;\n      var minLen = Math.min(oldVal.length, newVal.length);\n      var maxLen = Math.max(oldVal.length, newVal.length);\n\n      if (minLen !== maxLen) {\n        if (valObject.editType === 'arraydraw') {\n          extraIndices = true;\n        } else {\n          changed();\n          continue;\n        }\n      }\n\n      for (i = 0; i < minLen; i++) {\n        getDiffFlags(oldVal[i], newVal[i], parts.concat(i), // add array indices, but not if we're already in an array\n        Lib.extendFlat({\n          inArray: key,\n          arrayIndex: i\n        }, opts));\n      } // put this at the end so that we know our collected array indices are sorted\n      // but the check for length changes happens up front so we can short-circuit\n      // diffing if appropriate\n\n\n      if (extraIndices) {\n        for (i = minLen; i < maxLen; i++) {\n          arrayEditIndices.push(i);\n        }\n      }\n    } else if (!valType && Lib.isPlainObject(oldVal)) {\n      getDiffFlags(oldVal, newVal, parts, opts);\n    } else if (canBeDataArray) {\n      if (wasArray && nowArray) {\n        // don't try to diff two data arrays. If immutable we know the data changed,\n        // if not, assume it didn't and let `layout.datarevision` tell us if it did\n        if (immutable) {\n          flags.calc = true;\n        } // look for animatable attributes when the data changed\n\n\n        if (immutable || opts.newDataRevision) {\n          changed();\n        }\n      } else if (wasArray !== nowArray) {\n        flags.calc = true;\n      } else changed();\n    } else if (wasArray && nowArray) {\n      // info array, colorscale, 'any' - these are short, just stringify.\n      // I don't *think* that covers up any real differences post-validation, does it?\n      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n      // all elements.\n      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n        changed();\n      }\n    } else {\n      changed();\n    }\n  }\n\n  for (key in newContainer) {\n    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n      valObject = getValObject(outerparts.concat(key));\n\n      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n        flags.calc = true;\n        return;\n      } else changed();\n    }\n  }\n}\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\n\n\nfunction diffConfig(oldConfig, newConfig) {\n  var key;\n\n  for (key in oldConfig) {\n    if (key.charAt(0) === '_') continue;\n    var oldVal = oldConfig[key];\n    var newVal = newConfig[key];\n\n    if (oldVal !== newVal) {\n      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n        if (diffConfig(oldVal, newVal)) {\n          return true;\n        }\n      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {\n        if (oldVal.length !== newVal.length) {\n          return true;\n        }\n\n        for (var i = 0; i < oldVal.length; i++) {\n          if (oldVal[i] !== newVal[i]) {\n            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n              if (diffConfig(oldVal[i], newVal[i])) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n}\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\n\n\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plot.ly/javascript/animations/');\n  }\n\n  var trans = gd._transitionData; // This is the queue of frames that will be animated as soon as possible. They\n  // are popped immediately upon the *start* of a transition:\n\n  if (!trans._frameQueue) {\n    trans._frameQueue = [];\n  }\n\n  animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n  var transitionOpts = animationOpts.transition;\n  var frameOpts = animationOpts.frame; // Since frames are popped immediately, an empty queue only means all frames have\n  // *started* to transition, not that the animation is complete. To solve that,\n  // track a separate counter that increments at the same time as frames are added\n  // to the queue, but decrements only when the transition is complete.\n\n  if (trans._frameWaitingCnt === undefined) {\n    trans._frameWaitingCnt = 0;\n  }\n\n  function getTransitionOpts(i) {\n    if (Array.isArray(transitionOpts)) {\n      if (i >= transitionOpts.length) {\n        return transitionOpts[0];\n      } else {\n        return transitionOpts[i];\n      }\n    } else {\n      return transitionOpts;\n    }\n  }\n\n  function getFrameOpts(i) {\n    if (Array.isArray(frameOpts)) {\n      if (i >= frameOpts.length) {\n        return frameOpts[0];\n      } else {\n        return frameOpts[i];\n      }\n    } else {\n      return frameOpts;\n    }\n  } // Execute a callback after the wrapper function has been called n times.\n  // This is used to defer the resolution until a transition has resovled *and*\n  // the frame has completed. If it's not done this way, then we get a race\n  // condition in which the animation might resolve before a transition is complete\n  // or vice versa.\n\n\n  function callbackOnNthTime(cb, n) {\n    var cnt = 0;\n    return function () {\n      if (cb && ++cnt === n) {\n        return cb();\n      }\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    function discardExistingFrames() {\n      if (trans._frameQueue.length === 0) {\n        return;\n      }\n\n      while (trans._frameQueue.length) {\n        var next = trans._frameQueue.pop();\n\n        if (next.onInterrupt) {\n          next.onInterrupt();\n        }\n      }\n\n      gd.emit('plotly_animationinterrupted', []);\n    }\n\n    function queueFrames(frameList) {\n      if (frameList.length === 0) return;\n\n      for (var i = 0; i < frameList.length; i++) {\n        var computedFrame;\n\n        if (frameList[i].type === 'byname') {\n          // If it's a named frame, compute it:\n          computedFrame = Plots.computeFrame(gd, frameList[i].name);\n        } else {\n          // Otherwise we must have been given a simple object, so treat\n          // the input itself as the computed frame.\n          computedFrame = frameList[i].data;\n        }\n\n        var frameOpts = getFrameOpts(i);\n        var transitionOpts = getTransitionOpts(i); // It doesn't make much sense for the transition duration to be greater than\n        // the frame duration, so limit it:\n\n        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n        var nextFrame = {\n          frame: computedFrame,\n          name: frameList[i].name,\n          frameOpts: frameOpts,\n          transitionOpts: transitionOpts\n        };\n\n        if (i === frameList.length - 1) {\n          // The last frame in this .animate call stores the promise resolve\n          // and reject callbacks. This is how we ensure that the animation\n          // loop (which may exist as a result of a *different* .animate call)\n          // still resolves or rejecdts this .animate call's promise. once it's\n          // complete.\n          nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n          nextFrame.onInterrupt = reject;\n        }\n\n        trans._frameQueue.push(nextFrame);\n      } // Set it as never having transitioned to a frame. This will cause the animation\n      // loop to immediately transition to the next frame (which, for immediate mode,\n      // is the first frame in the list since all others would have been discarded\n      // below)\n\n\n      if (animationOpts.mode === 'immediate') {\n        trans._lastFrameAt = -Infinity;\n      } // Only it's not already running, start a RAF loop. This could be avoided in the\n      // case that there's only one frame, but it significantly complicated the logic\n      // and only sped things up by about 5% or so for a lorenz attractor simulation.\n      // It would be a fine thing to implement, but the benefit of that optimization\n      // doesn't seem worth the extra complexity.\n\n\n      if (!trans._animationRaf) {\n        beginAnimationLoop();\n      }\n    }\n\n    function stopAnimationLoop() {\n      gd.emit('plotly_animated'); // Be sure to unset also since it's how we know whether a loop is already running:\n\n      window.cancelAnimationFrame(trans._animationRaf);\n      trans._animationRaf = null;\n    }\n\n    function nextFrame() {\n      if (trans._currentFrame && trans._currentFrame.onComplete) {\n        // Execute the callback and unset it to ensure it doesn't\n        // accidentally get called twice\n        trans._currentFrame.onComplete();\n      }\n\n      var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n      if (newFrame) {\n        // Since it's sometimes necessary to do deep digging into frame data,\n        // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n        // so check when casting the name, just to be absolutely certain:\n        var stringName = newFrame.name ? newFrame.name.toString() : null;\n        gd._fullLayout._currentFrame = stringName;\n        trans._lastFrameAt = Date.now();\n        trans._timeToNext = newFrame.frameOpts.duration; // This is simply called and it's left to .transition to decide how to manage\n        // interrupting current transitions. That means we don't need to worry about\n        // how it resolves or what happens after this:\n\n        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {\n          if (newFrame.onComplete) {\n            newFrame.onComplete();\n          }\n        });\n        gd.emit('plotly_animatingframe', {\n          name: stringName,\n          frame: newFrame.frame,\n          animation: {\n            frame: newFrame.frameOpts,\n            transition: newFrame.transitionOpts\n          }\n        });\n      } else {\n        // If there are no more frames, then stop the RAF loop:\n        stopAnimationLoop();\n      }\n    }\n\n    function beginAnimationLoop() {\n      gd.emit('plotly_animating'); // If no timer is running, then set last frame = long ago so that the next\n      // frame is immediately transitioned:\n\n      trans._lastFrameAt = -Infinity;\n      trans._timeToNext = 0;\n      trans._runningTransitions = 0;\n      trans._currentFrame = null;\n\n      var doFrame = function doFrame() {\n        // This *must* be requested before nextFrame since nextFrame may decide\n        // to cancel it if there's nothing more to animated:\n        trans._animationRaf = window.requestAnimationFrame(doFrame); // Check if we're ready for a new frame:\n\n        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {\n          nextFrame();\n        }\n      };\n\n      doFrame();\n    } // This is an animate-local counter that helps match up option input list\n    // items with the particular frame.\n\n\n    var configCounter = 0;\n\n    function setTransitionConfig(frame) {\n      if (Array.isArray(transitionOpts)) {\n        if (configCounter >= transitionOpts.length) {\n          frame.transitionOpts = transitionOpts[configCounter];\n        } else {\n          frame.transitionOpts = transitionOpts[0];\n        }\n      } else {\n        frame.transitionOpts = transitionOpts;\n      }\n\n      configCounter++;\n      return frame;\n    } // Disambiguate what's sort of frames have been received\n\n\n    var i, frame;\n    var frameList = [];\n    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n    if (isSingleFrame) {\n      // In this case, a simple object has been passed to animate.\n      frameList.push({\n        type: 'object',\n        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n      });\n    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n      // In this case, null or undefined has been passed so that we want to\n      // animate *all* currently defined frames\n      for (i = 0; i < trans._frames.length; i++) {\n        frame = trans._frames[i];\n        if (!frame) continue;\n\n        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n          frameList.push({\n            type: 'byname',\n            name: String(frame.name),\n            data: setTransitionConfig({\n              name: frame.name\n            })\n          });\n        }\n      }\n    } else if (isFrameArray) {\n      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n        var frameOrName = frameOrGroupNameOrFrameList[i];\n\n        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n          frameOrName = String(frameOrName); // In this case, there's an array and this frame is a string name:\n\n          frameList.push({\n            type: 'byname',\n            name: frameOrName,\n            data: setTransitionConfig({\n              name: frameOrName\n            })\n          });\n        } else if (Lib.isPlainObject(frameOrName)) {\n          frameList.push({\n            type: 'object',\n            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n          });\n        }\n      }\n    } // Verify that all of these frames actually exist; return and reject if not:\n\n\n    for (i = 0; i < frameList.length; i++) {\n      frame = frameList[i];\n\n      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n        Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n        reject();\n        return;\n      }\n    } // If the mode is either next or immediate, then all currently queued frames must\n    // be dumped and the corresponding .animate promises rejected.\n\n\n    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n      discardExistingFrames();\n    }\n\n    if (animationOpts.direction === 'reverse') {\n      frameList.reverse();\n    }\n\n    var currentFrame = gd._fullLayout._currentFrame;\n\n    if (currentFrame && animationOpts.fromcurrent) {\n      var idx = -1;\n\n      for (i = 0; i < frameList.length; i++) {\n        frame = frameList[i];\n\n        if (frame.type === 'byname' && frame.name === currentFrame) {\n          idx = i;\n          break;\n        }\n      }\n\n      if (idx > 0 && idx < frameList.length - 1) {\n        var filteredFrameList = [];\n\n        for (i = 0; i < frameList.length; i++) {\n          frame = frameList[i];\n\n          if (frameList[i].type !== 'byname' || i > idx) {\n            filteredFrameList.push(frame);\n          }\n        }\n\n        frameList = filteredFrameList;\n      }\n    }\n\n    if (frameList.length > 0) {\n      queueFrames(frameList);\n    } else {\n      // This is the case where there were simply no frames. It's a little strange\n      // since there's not much to do:\n      gd.emit('plotly_animated');\n      resolve();\n    }\n  });\n}\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\n\n\nfunction addFrames(gd, frameList, indices) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (frameList === null || frameList === undefined) {\n    return Promise.resolve();\n  }\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plot.ly/javascript/animations/');\n  }\n\n  var i, frame, j, idx;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n\n  if (!Array.isArray(frameList)) {\n    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n  } // Create a sorted list of insertions since we run into lots of problems if these\n  // aren't in ascending order of index:\n  //\n  // Strictly for sorting. Make sure this is guaranteed to never collide with any\n  // already-exisisting indices:\n\n\n  var bigIndex = _frames.length + frameList.length * 2;\n  var insertions = [];\n  var _frameHashLocal = {};\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    if (!Lib.isPlainObject(frameList[i])) continue; // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n    // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n\n    var lookupName = frameList[i].name;\n    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n    var newName = frameList[i].name;\n    var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n      numericNameWarningCount++;\n      Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name + '\" with a frame whose name of type \"number\" also equates to \"' + name + '\". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');\n\n      if (numericNameWarningCount === numericNameWarningCountLimit) {\n        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');\n      }\n    }\n\n    _frameHashLocal[lookupName] = {\n      name: lookupName\n    };\n    insertions.push({\n      frame: Plots.supplyFrameDefaults(frameList[i]),\n      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i\n    });\n  } // Sort this, taking note that undefined insertions end up at the end:\n\n\n  insertions.sort(function (a, b) {\n    if (a.index > b.index) return -1;\n    if (a.index < b.index) return 1;\n    return 0;\n  });\n  var ops = [];\n  var revops = [];\n  var frameCount = _frames.length;\n\n  for (i = insertions.length - 1; i >= 0; i--) {\n    frame = insertions[i].frame;\n\n    if (typeof frame.name === 'number') {\n      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');\n    }\n\n    if (!frame.name) {\n      // Repeatedly assign a default name, incrementing the counter each time until\n      // we get a name that's not in the hashed lookup table:\n      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]) {\n        ;\n      }\n    }\n\n    if (_frameHash[frame.name]) {\n      // If frame is present, overwrite its definition:\n      for (j = 0; j < _frames.length; j++) {\n        if ((_frames[j] || {}).name === frame.name) break;\n      }\n\n      ops.push({\n        type: 'replace',\n        index: j,\n        value: frame\n      });\n      revops.unshift({\n        type: 'replace',\n        index: j,\n        value: _frames[j]\n      });\n    } else {\n      // Otherwise insert it at the end of the list:\n      idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n      ops.push({\n        type: 'insert',\n        index: idx,\n        value: frame\n      });\n      revops.unshift({\n        type: 'delete',\n        index: idx\n      });\n      frameCount++;\n    }\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\n\n\nfunction deleteFrames(gd, frameList) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  var i, idx;\n  var _frames = gd._transitionData._frames;\n  var ops = [];\n  var revops = [];\n\n  if (!frameList) {\n    frameList = [];\n\n    for (i = 0; i < _frames.length; i++) {\n      frameList.push(i);\n    }\n  }\n\n  frameList = frameList.slice();\n  frameList.sort();\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    idx = frameList[i];\n    ops.push({\n      type: 'delete',\n      index: idx\n    });\n    revops.unshift({\n      type: 'insert',\n      index: idx,\n      value: _frames[idx]\n    });\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\n\n\nfunction purge(gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n  var fullData = gd._fullData || []; // remove gl contexts\n\n  Plots.cleanPlot([], {}, fullData, fullLayout); // purge properties\n\n  Plots.purge(gd); // purge event emitter methods\n\n  Events.purge(gd); // remove plot container\n\n  if (fullLayout._container) fullLayout._container.remove(); // in contrast to Plotly.Plots.purge which does NOT clear _context!\n\n  delete gd._context;\n  return gd;\n} // -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\n\n\nfunction makePlotFramework(gd) {\n  var gd3 = d3.select(gd);\n  var fullLayout = gd._fullLayout; // Plot container\n\n  fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n\n  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true); // Make the svg container\n\n\n  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n\n  fullLayout._paperdiv.enter().append('div').classed('svg-container', true).style('position', 'relative'); // Make the graph containers\n  // start fresh each time we get here, so we know the order comes out\n  // right, rather than enter/exit which can muck up the order\n  // TODO: sort out all the ordering so we don't have to\n  // explicitly delete anything\n  // FIXME: parcoords reuses this object, not the best pattern\n\n\n  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);\n\n  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);\n\n  fullLayout._paperdiv.selectAll('.main-svg').remove();\n\n  fullLayout._paperdiv.select('.modebar-container').remove();\n\n  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);\n  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n  fullLayout._hoverpaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n\n  if (!fullLayout._uid) {\n    var otherUids = {};\n    d3.selectAll('defs').each(function () {\n      if (this.id) otherUids[this.id.split('-')[1]] = 1;\n    });\n    fullLayout._uid = Lib.randstr(otherUids);\n  }\n\n  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);\n\n  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);\n  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);\n  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);\n  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);\n  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);\n  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true); // lower shape/image layer - note that this is behind\n  // all subplots data/grids but above the backgrounds\n  // except inset subplots, whose backgrounds are drawn\n  // inside their own group so that they appear above\n  // the data for the main subplot\n  // lower shapes and images which are fully referenced to\n  // a subplot still get drawn within the subplot's group\n  // so they will work correctly on insets\n\n  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);\n\n  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);\n  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true); // single cartesian layer for the whole plot\n\n  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true); // single polar layer for the whole plot\n\n  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true); // single ternary layer for the whole plot\n\n  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true); // single geo layer for the whole plot\n\n  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true); // single funnelarea layer for the whole plot\n\n  fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true); // single pie layer for the whole plot\n\n  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true); // single treemap layer for the whole plot\n\n  fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true); // single sunburst layer for the whole plot\n\n  fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true); // single indicator layer for the whole plot\n\n  fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true); // fill in image server scrape-svg\n\n  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true); // lastly upper shapes, info (legend, annotations) and hover layers go on top\n  // these are in a different svg element normally, but get collapsed into a single\n  // svg when exporting (after inserting 3D)\n  // upper shapes/images are only those drawn above the whole plot, including subplots\n\n  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);\n\n  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);\n  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);\n  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n  fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true); // Make the modebar container\n\n  fullLayout._modebardiv.classed('modebar-container', true).style('position', 'absolute').style('top', '0px').style('right', '0px');\n\n  gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\nexports.newPlot = newPlot;\nexports.plot = plot;\nexports.purge = purge;\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\nexports.setPlotConfig = setPlotConfig;\nexports.update = update;\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/plot_api/plot_api.js"],"names":["d3","require","isNumeric","hasHover","Lib","nestedProperty","Events","Queue","Registry","PlotSchema","Plots","Polar","Axes","Drawing","Color","initInteractions","xmlnsNamespaces","svgTextUtils","clearSelect","dfltConfig","manageArrays","helpers","subroutines","editTypes","AX_NAME_PATTERN","numericNameWarningCount","numericNameWarningCountLimit","plot","gd","data","layout","config","frames","getGraphDiv","init","isPlainObject","obj","okToPlot","triggerHandler","Promise","reject","isPlotDiv","warn","addFrames","exports","setPlotContext","select","classed","makeTester","Array","isArray","_promises","graphWasEmpty","length","cleanData","push","apply","empty","cleanLayout","supplyDefaults","fullLayout","_fullLayout","hasCartesian","_has","r","log","plotLegacyPolar","_replotting","makePlotFramework","framework","initGradients","saveShowSpikeInitial","recalc","calcdata","_fullData","doCalcdata","i","trace","_context","responsive","_responsiveChartHandler","isHidden","resize","window","addEventListener","clearResponsive","oldMargins","extendFlat","_size","drawFrameworkCalls","drawFramework","basePlotModules","_basePlotModules","_glcanvas","_glcontainer","selectAll","key","context","pick","d","enter","append","attr","replace","style","position","top","left","overflow","width","height","regl","Math","floor","_gl","drawingBufferWidth","drawingBufferHeight","msg","error","cleanPlot","modebar","orientation","_modebardiv","previousPromises","marginPushers","clearAutoMarginIds","drawMarginPushers","allowAutoMargin","fullData","type","automargin","uid","doAutoMargin","marginPushersAgain","didMarginChange","syncOrAsync","layoutStyles","positionAndAutorange","doAutoRangeAndConstraints","getComponentMethod","_transitioning","saveRangeInitial","drawAxes","draw","seq","drawData","finalDraw","addLinks","rehover","redrag","plotDone","then","resolve","emitAfterPlot","_redrawFromAutoMarginCount","emit","setPlotConfig","setBackground","bgColor","_paper","e","opaqueSetBackground","blend","combine","extendDeep","base","_baseUrl","size","location","href","split","keys","Object","plot3dPixelRatio","plotGlPixelRatio","editable","undefined","edits","_exportedPlot","staticPlot","autosizable","scrollZoom","doubleClick","showTips","showLink","displayModeBar","_hasZeroHeight","clientHeight","_hasZeroWidth","clientWidth","szIn","szOut","_scrollZoom","cartesian","gl3d","geo","mapbox","parts","plotContainer","insert","paperDiv","html","manager","fillLayout","node","setUndoPoint","polarPlotSVG","svg","opacity","txt","title","text","titleLayout","call","convertToTspans","titleText","placeholderText","_","on","transition","duration","setContenteditable","makeEditable","paper_bgcolor","redraw","Error","newPlot","purge","positivifyIndices","indices","maxIndex","parentLength","positiveIndices","index","assertIndexArray","arrayName","parseInt","indexOf","checkMoveTracesArgs","currentIndices","newIndices","checkAddTracesArgs","traces","value","assertExtendTracesArgs","update","maxPoints","maxPointsIsObject","getExtendProperties","updateProps","target","prop","maxp","j","get","isArrayOrTypedArray","constructor","spliceTraces","updateArray","undoUpdate","undoPoints","out","set","astr","concatTypedArray","arr0","arr1","arr2","extendTraces","newArray","remainder","isTypedArray","none","both","numberOfItemsFromInsert","subarray","numberOfItemsFromTarget","targetBegin","concat","splice","undo","promise","undoArgs","add","prependTraces","arguments","addTraces","undoFunc","deleteTraces","redoFunc","redoArgs","map","startSequence","moveTraces","stopSequence","deletedTrace","sort","sorterDes","newData","movingTraceMap","newIndex","a","b","restyle","val","_traces","clearPromiseQueue","aobj","changed","coerceTraceIndices","specs","_restyle","flags","calc","clearAxisTypes","fullReplot","markerSize","addAxRangeSequence","doTraceStyle","colorbars","doColorBars","undoit","redoit","eventData","undefinedToNull","makeNP","preGUI","guiEditFlag","container","prefix","np","npSet","fullAttr","storeCurrent","newVal","arrayVal","arrayNew","maxLen","max","objVal","objNew","objBoth","_storeDirectGUIEdit","_guiEditing","layoutNP","_preGUI","extendDeepAll","cleanDeprecatedAttributeKeys","traceFlags","axlist","a0","addToAxlist","axid","axName","id2name","autorangeAttr","rangeAttr","getFullTrace","traceIndex","_input","doextra","forEach","hasParent","extraparam","substr","tracei","_tracePreGUI","_fullInput","allBins","binAttr","arrayBins","vij","ai","vi","cont","contFull","param","oldVal","valObject","charAt","finalPart","prefixDot","innerContFull","getTraceValObject","impliedEdits","impliedKey","relativeAttr","gs","orient","topOrBottom","thicknorm","h","w","thickness","lennorm","len","labelsTo","valuesTo","swapAttrs","_pielayer","remove","traceIs","defaultOrientation","x","y","v","swapXYData","dataArrayContainers","manageArrayContainers","arrayOk","swap","hovermode","xaxis","yaxis","extendDeepNoArrays","oldAxisTitleRegex","counterRegex","colorbarRegex","test","oldAttrStr","newAttrStr","relayout","isPolar","_relayout","layoutReplot","axRangeSupplyDefaultsByPass","legend","doLegend","layoutstyle","axrange","rangesAltered","ticks","doTicksRelayout","doModeBar","camera","doCamera","k","axId","axIn","axOut","autorange","range","slice","cleanRange","_matchGroup","axId2","ax2","axIds","skipTitle","id","ax","getFromId","id2","AX_RANGE_RE","AX_AUTORANGE_RE","AX_DOMAIN_RE","axes","list","arrayEdits","arrayStr","scene","_id","axisAttr","newkey","_name","layoutFlags","p","recordAlteredAxis","pleafPlus","name2id","plen","pend","pleaf","ptrunk","join","parentIn","parentFull","vOld","getLayoutValObject","oppositeAttr","_initialAutoSize","match","axFull","_inputDomain","domain","toLog","fromLog","r0","r1","LN10","pow","_subplots","polar","_subplot","viewInitial","fullProp","newType","containerArrayMatch","array","propStr","property","updateValObject","editType","isAddVal","isRemoveVal","objEdits","reverse","finished","applyContainerArrayChanges","constraints","_axisConstraintGroups","group","groupAxId","_constraintShrinkable","updateAutosize","oldWidth","oldHeight","autosize","plotAutoSize","traceUpdate","layoutUpdate","restyleSpecs","restyleFlags","relayoutSpecs","relayoutFlags","guiEdit","func","wrappedEdit","layoutUIControlPatterns","pattern","traceUIControlPatterns","findUIPattern","patternSpecs","spec","head","getNewRev","revAttr","newRev","pop","uirevision","getFullTraceIndexFromUid","getTraceIndexFromUid","valsMatch","v1","v2","v1IsObj","v1IsArray","JSON","stringify","applyUIRevisions","oldFullData","oldFullLayout","layoutPreGUI","oldRev","preGUIVal","newNP","bothInheritAutorange","newRangeAccepted","axAttr","newAx","allTracePreGUI","tracePreGUI","newTrace","fullInput","fulli","fullTrace","newTracei","react","configChanged","oldConfig","diffConfig","skipUpdateCalc","newFullData","newFullLayout","immutable","datarevision","diffLayout","newDataRevision","diffData","supplyDefaultsUpdateCalc","_transitionData","createTransitionData","anim","transitionFromReact","_skipDefaults","componentType","arrays","drawOne","noop","sameTraceLength","nChanges","nChangesAnim","_module","animatable","diffOpts","getValObject","seenUIDs","hasMakesDataTransform","getDiffFlags","oldContainer","newContainer","outerparts","opts","inArray","arrayIndex","pushUnique","valObjectCanBeDataArray","valType","tickMode","tickmode","_compareAsJSON","canBeDataArray","wasArray","nowArray","inputKey","oldValIn","newValIn","_isLinkedToArray","arrayEditIndices","extraIndices","minLen","min","String","newConfig","animate","frameOrGroupNameOrFrameList","animationOpts","trans","_frameQueue","supplyAnimationDefaults","transitionOpts","frameOpts","frame","_frameWaitingCnt","getTransitionOpts","getFrameOpts","callbackOnNthTime","cb","n","cnt","discardExistingFrames","next","onInterrupt","queueFrames","frameList","computedFrame","computeFrame","name","nextFrame","onComplete","mode","_lastFrameAt","Infinity","_animationRaf","beginAnimationLoop","stopAnimationLoop","cancelAnimationFrame","_currentFrame","newFrame","shift","stringName","toString","Date","now","_timeToNext","animation","_runningTransitions","doFrame","requestAnimationFrame","configCounter","setTransitionConfig","allFrames","isFrameArray","isSingleFrame","_frames","frameOrName","_frameHash","direction","currentFrame","fromcurrent","idx","filteredFrameList","bigIndex","insertions","_frameHashLocal","lookupName","newName","collisionPresent","supplyFrameDefaults","ops","revops","frameCount","_counter","unshift","modifyFrames","deleteFrames","_container","gd3","_paperdiv","_toppaper","_hoverpaper","_uid","otherUids","each","randstr","svgAttrs","_defs","_clips","_topdefs","_topclips","_bgLayer","_draggers","layerBelow","_imageLowerLayer","_shapeLowerLayer","_cartesianlayer","_polarlayer","_ternarylayer","_geolayer","_funnelarealayer","_treemaplayer","_sunburstlayer","_indicatorlayer","_glimages","layerAbove","_imageUpperLayer","_shapeUpperLayer","_infolayer","_menulayer","_zoomlayer","_hoverlayer","_guiRelayout","_guiRestyle","_guiUpdate"],"mappings":"AAAA;;;;;;;AAQA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAD,CAAvB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AAEA,IAAIG,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAII,cAAc,GAAGD,GAAG,CAACC,cAAzB;;AAEA,IAAIC,MAAM,GAAGL,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIM,KAAK,GAAGN,OAAO,CAAC,cAAD,CAAnB;;AAEA,IAAIO,QAAQ,GAAGP,OAAO,CAAC,aAAD,CAAtB;;AACA,IAAIQ,UAAU,GAAGR,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIS,KAAK,GAAGT,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIU,KAAK,GAAGV,OAAO,CAAC,uBAAD,CAAnB;;AAEA,IAAIW,IAAI,GAAGX,OAAO,CAAC,yBAAD,CAAlB;;AACA,IAAIY,OAAO,GAAGZ,OAAO,CAAC,uBAAD,CAArB;;AACA,IAAIa,KAAK,GAAGb,OAAO,CAAC,qBAAD,CAAnB;;AACA,IAAIc,gBAAgB,GAAGd,OAAO,CAAC,mCAAD,CAAP,CAA6Cc,gBAApE;;AACA,IAAIC,eAAe,GAAGf,OAAO,CAAC,+BAAD,CAA7B;;AACA,IAAIgB,YAAY,GAAGhB,OAAO,CAAC,uBAAD,CAA1B;;AACA,IAAIiB,WAAW,GAAGjB,OAAO,CAAC,2BAAD,CAAP,CAAqCiB,WAAvD;;AAEA,IAAIC,UAAU,GAAGlB,OAAO,CAAC,eAAD,CAAP,CAAyBkB,UAA1C;;AACA,IAAIC,YAAY,GAAGnB,OAAO,CAAC,iBAAD,CAA1B;;AACA,IAAIoB,OAAO,GAAGpB,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIqB,WAAW,GAAGrB,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIsB,SAAS,GAAGtB,OAAO,CAAC,cAAD,CAAvB;;AAEA,IAAIuB,eAAe,GAAGvB,OAAO,CAAC,8BAAD,CAAP,CAAwCuB,eAA9D;;AAEA,IAAIC,uBAAuB,GAAG,CAA9B;AACA,IAAIC,4BAA4B,GAAG,CAAnC;AAEA;;;;;;;;;;;;;;;;;;;;;;AAqBA,SAASC,IAAT,CAAcC,EAAd,EAAkBC,IAAlB,EAAwBC,MAAxB,EAAgCC,MAAhC,EAAwC;AACpC,MAAIC,MAAJ;AAEAJ,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL,CAHoC,CAKpC;;AACAtB,EAAAA,MAAM,CAAC4B,IAAP,CAAYN,EAAZ;;AAEA,MAAGxB,GAAG,CAAC+B,aAAJ,CAAkBN,IAAlB,CAAH,EAA4B;AACxB,QAAIO,GAAG,GAAGP,IAAV;AACAA,IAAAA,IAAI,GAAGO,GAAG,CAACP,IAAX;AACAC,IAAAA,MAAM,GAAGM,GAAG,CAACN,MAAb;AACAC,IAAAA,MAAM,GAAGK,GAAG,CAACL,MAAb;AACAC,IAAAA,MAAM,GAAGI,GAAG,CAACJ,MAAb;AACH;;AAED,MAAIK,QAAQ,GAAG/B,MAAM,CAACgC,cAAP,CAAsBV,EAAtB,EAA0B,mBAA1B,EAA+C,CAACC,IAAD,EAAOC,MAAP,EAAeC,MAAf,CAA/C,CAAf;AACA,MAAGM,QAAQ,KAAK,KAAhB,EAAuB,OAAOE,OAAO,CAACC,MAAR,EAAP,CAjBa,CAmBpC;AACA;;AACA,MAAG,CAACX,IAAD,IAAS,CAACC,MAAV,IAAoB,CAAC1B,GAAG,CAACqC,SAAJ,CAAcb,EAAd,CAAxB,EAA2C;AACvCxB,IAAAA,GAAG,CAACsC,IAAJ,CAAS,yCACL,8CADJ,EACoDd,EADpD;AAEH;;AAED,WAASe,SAAT,GAAqB;AACjB,QAAGX,MAAH,EAAW;AACP,aAAOY,OAAO,CAACD,SAAR,CAAkBf,EAAlB,EAAsBI,MAAtB,CAAP;AACH;AACJ,GA9BmC,CAgCpC;AACA;;;AACAa,EAAAA,cAAc,CAACjB,EAAD,EAAKG,MAAL,CAAd;AAEA,MAAG,CAACD,MAAJ,EAAYA,MAAM,GAAG,EAAT,CApCwB,CAsCpC;AACA;;AACA9B,EAAAA,EAAE,CAAC8C,MAAH,CAAUlB,EAAV,EAAcmB,OAAd,CAAsB,gBAAtB,EAAwC,IAAxC,EAxCoC,CA0CpC;AACA;AACA;;AACAlC,EAAAA,OAAO,CAACmC,UAAR,GA7CoC,CA+CpC;AACA;AACA;AACA;;AACA,MAAG,CAACC,KAAK,CAACC,OAAN,CAActB,EAAE,CAACuB,SAAjB,CAAJ,EAAiCvB,EAAE,CAACuB,SAAH,GAAe,EAAf;AAEjC,MAAIC,aAAa,GAAI,CAACxB,EAAE,CAACC,IAAH,IAAW,EAAZ,EAAgBwB,MAAhB,KAA2B,CAA3B,IAAgCJ,KAAK,CAACC,OAAN,CAAcrB,IAAd,CAArD,CArDoC,CAuDpC;AACA;;AACA,MAAGoB,KAAK,CAACC,OAAN,CAAcrB,IAAd,CAAH,EAAwB;AACpBR,IAAAA,OAAO,CAACiC,SAAR,CAAkBzB,IAAlB;AAEA,QAAGuB,aAAH,EAAkBxB,EAAE,CAACC,IAAH,GAAUA,IAAV,CAAlB,KACKD,EAAE,CAACC,IAAH,CAAQ0B,IAAR,CAAaC,KAAb,CAAmB5B,EAAE,CAACC,IAAtB,EAA4BA,IAA5B,EAJe,CAMpB;AACA;AACA;;AACAD,IAAAA,EAAE,CAAC6B,KAAH,GAAW,KAAX;AACH;;AAED,MAAG,CAAC7B,EAAE,CAACE,MAAJ,IAAcsB,aAAjB,EAAgC;AAC5BxB,IAAAA,EAAE,CAACE,MAAH,GAAYT,OAAO,CAACqC,WAAR,CAAoB5B,MAApB,CAAZ;AACH;;AAEDpB,EAAAA,KAAK,CAACiD,cAAN,CAAqB/B,EAArB;AAEA,MAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAApB;;AACA,MAAIC,YAAY,GAAGF,UAAU,CAACG,IAAX,CAAgB,WAAhB,CAAnB,CA5EoC,CA8EpC;;;AACA,MAAG,CAACH,UAAU,CAACG,IAAX,CAAgB,OAAhB,CAAD,IAA6BlC,IAA7B,IAAqCA,IAAI,CAAC,CAAD,CAAzC,IAAgDA,IAAI,CAAC,CAAD,CAAJ,CAAQmC,CAA3D,EAA8D;AAC1D5D,IAAAA,GAAG,CAAC6D,GAAJ,CAAQ,qCAAR;AACA,WAAOC,eAAe,CAACtC,EAAD,EAAKC,IAAL,EAAWC,MAAX,CAAtB;AACH,GAlFmC,CAoFpC;AACA;;;AACA8B,EAAAA,UAAU,CAACO,WAAX,GAAyB,IAAzB,CAtFoC,CAwFpC;;AACA,MAAGf,aAAH,EAAkBgB,iBAAiB,CAACxC,EAAD,CAAjB,CAzFkB,CA2FpC;;AACA,MAAGA,EAAE,CAACyC,SAAH,KAAiBD,iBAApB,EAAuC;AACnCxC,IAAAA,EAAE,CAACyC,SAAH,GAAeD,iBAAf;AACAA,IAAAA,iBAAiB,CAACxC,EAAD,CAAjB;AACH,GA/FmC,CAiGpC;;;AACAf,EAAAA,OAAO,CAACyD,aAAR,CAAsB1C,EAAtB,EAlGoC,CAoGpC;;AACA,MAAGwB,aAAH,EAAkBxC,IAAI,CAAC2D,oBAAL,CAA0B3C,EAA1B,EArGkB,CAuGpC;AAEA;AACA;;AACA,MAAI4C,MAAM,GAAG,CAAC5C,EAAE,CAAC6C,QAAJ,IAAgB7C,EAAE,CAAC6C,QAAH,CAAYpB,MAAZ,KAAuB,CAACzB,EAAE,CAAC8C,SAAH,IAAgB,EAAjB,EAAqBrB,MAAzE;AACA,MAAGmB,MAAH,EAAW9D,KAAK,CAACiE,UAAN,CAAiB/C,EAAjB,EA5GyB,CA8GpC;;AACA,OAAI,IAAIgD,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGhD,EAAE,CAAC6C,QAAH,CAAYpB,MAA/B,EAAuCuB,CAAC,EAAxC,EAA4C;AACxChD,IAAAA,EAAE,CAAC6C,QAAH,CAAYG,CAAZ,EAAe,CAAf,EAAkBC,KAAlB,GAA0BjD,EAAE,CAAC8C,SAAH,CAAaE,CAAb,CAA1B;AACH,GAjHmC,CAmHpC;;;AACA,MAAGhD,EAAE,CAACkD,QAAH,CAAYC,UAAf,EAA2B;AACvB,QAAG,CAACnD,EAAE,CAACoD,uBAAP,EAAgC;AAC5B;AACApD,MAAAA,EAAE,CAACoD,uBAAH,GAA6B,YAAW;AAAE,YAAG,CAAC5E,GAAG,CAAC6E,QAAJ,CAAarD,EAAb,CAAJ,EAAsBlB,KAAK,CAACwE,MAAN,CAAatD,EAAb;AAAmB,OAAnF,CAF4B,CAI5B;;;AACAuD,MAAAA,MAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkCxD,EAAE,CAACoD,uBAArC;AACH;AACJ,GARD,MAQO;AACH5E,IAAAA,GAAG,CAACiF,eAAJ,CAAoBzD,EAApB;AACH;AAED;;;;;AAIA,MAAI0D,UAAU,GAAGlF,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmB3B,UAAU,CAAC4B,KAA9B,CAAjB,CApIoC,CAsIpC;AACA;;AACA,MAAIC,kBAAkB,GAAG,CAAzB;;AACA,WAASC,aAAT,GAAyB;AACrB,QAAIC,eAAe,GAAG/B,UAAU,CAACgC,gBAAjC;;AAEA,SAAI,IAAIhB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGe,eAAe,CAACtC,MAAnC,EAA2CuB,CAAC,EAA5C,EAAgD;AAC5C,UAAGe,eAAe,CAACf,CAAD,CAAf,CAAmBc,aAAtB,EAAqC;AACjCC,QAAAA,eAAe,CAACf,CAAD,CAAf,CAAmBc,aAAnB,CAAiC9D,EAAjC;AACH;AACJ;;AAED,QAAG,CAACgC,UAAU,CAACiC,SAAZ,IAAyBjC,UAAU,CAACG,IAAX,CAAgB,IAAhB,CAA5B,EAAmD;AAC/CH,MAAAA,UAAU,CAACiC,SAAX,GAAuBjC,UAAU,CAACkC,YAAX,CAAwBC,SAAxB,CAAkC,YAAlC,EAAgDlE,IAAhD,CAAqD,CAAC;AACzEmE,QAAAA,GAAG,EAAE,cADoE;AAEzEC,QAAAA,OAAO,EAAE,IAFgE;AAGzEC,QAAAA,IAAI,EAAE;AAHmE,OAAD,EAIzE;AACCF,QAAAA,GAAG,EAAE,YADN;AAECC,QAAAA,OAAO,EAAE,KAFV;AAGCC,QAAAA,IAAI,EAAE;AAHP,OAJyE,EAQzE;AACCF,QAAAA,GAAG,EAAE,WADN;AAECC,QAAAA,OAAO,EAAE,KAFV;AAGCC,QAAAA,IAAI,EAAE;AAHP,OARyE,CAArD,EAYnB,UAASC,CAAT,EAAY;AAAE,eAAOA,CAAC,CAACH,GAAT;AAAe,OAZV,CAAvB;;AAcApC,MAAAA,UAAU,CAACiC,SAAX,CAAqBO,KAArB,GAA6BC,MAA7B,CAAoC,QAApC,EACKC,IADL,CACU,OADV,EACmB,UAASH,CAAT,EAAY;AACvB,eAAO,yBAAyBA,CAAC,CAACH,GAAF,CAAMO,OAAN,CAAc,OAAd,EAAuB,EAAvB,CAAhC;AACH,OAHL,EAIKC,KAJL,CAIW;AACHC,QAAAA,QAAQ,EAAE,UADP;AAEHC,QAAAA,GAAG,EAAE,CAFF;AAGHC,QAAAA,IAAI,EAAE,CAHH;AAIHC,QAAAA,QAAQ,EAAE,SAJP;AAKH,0BAAkB;AALf,OAJX;AAWH;;AAED,QAAGhD,UAAU,CAACiC,SAAd,EAAyB;AACrBjC,MAAAA,UAAU,CAACiC,SAAX,CACKS,IADL,CACU,OADV,EACmB1C,UAAU,CAACiD,KAD9B,EAEKP,IAFL,CAEU,QAFV,EAEoB1C,UAAU,CAACkD,MAF/B;;AAIA,UAAIC,IAAI,GAAGnD,UAAU,CAACiC,SAAX,CAAqBhE,IAArB,GAA4B,CAA5B,EAA+BkF,IAA1C;;AACA,UAAGA,IAAH,EAAS;AACL;AACA;AACA,YAAGC,IAAI,CAACC,KAAL,CAAWrD,UAAU,CAACiD,KAAtB,MAAiCE,IAAI,CAACG,GAAL,CAASC,kBAA1C,IACCH,IAAI,CAACC,KAAL,CAAWrD,UAAU,CAACkD,MAAtB,MAAkCC,IAAI,CAACG,GAAL,CAASE,mBAD/C,EAEG;AACC,cAAIC,GAAG,GAAG,mFAAV;;AACA,cAAG5B,kBAAH,EAAuB;AACnBrF,YAAAA,GAAG,CAACkH,KAAJ,CAAUD,GAAV;AACH,WAFD,MAEO;AACHjH,YAAAA,GAAG,CAAC6D,GAAJ,CAAQoD,GAAG,GAAG,qCAAd;AACA3G,YAAAA,KAAK,CAAC6G,SAAN,CAAgB,EAAhB,EAAoB,EAApB,EAAwB3F,EAAE,CAAC8C,SAA3B,EAAsCd,UAAtC;AACAlD,YAAAA,KAAK,CAACiD,cAAN,CAAqB/B,EAArB;AACAgC,YAAAA,UAAU,GAAGhC,EAAE,CAACiC,WAAhB;AACAnD,YAAAA,KAAK,CAACiE,UAAN,CAAiB/C,EAAjB;AACA6D,YAAAA,kBAAkB;AAClB,mBAAOC,aAAa,EAApB;AACH;AACJ;AACJ;AACJ;;AAED,QAAG9B,UAAU,CAAC4D,OAAX,CAAmBC,WAAnB,KAAmC,GAAtC,EAA2C;AACvC7D,MAAAA,UAAU,CAAC8D,WAAX,CACGlB,KADH,CACS,QADT,EACmB,IADnB,EAEGA,KAFH,CAES,OAFT,EAEkB,MAFlB;AAGH,KAJD,MAIO;AACH5C,MAAAA,UAAU,CAAC8D,WAAX,CACGlB,KADH,CACS,OADT,EACkB,IADlB,EAEGA,KAFH,CAES,QAFT,EAEmB5C,UAAU,CAACkD,MAAX,GAAoB,IAFvC;AAGH;;AAED,WAAOpG,KAAK,CAACiH,gBAAN,CAAuB/F,EAAvB,CAAP;AACH,GArNmC,CAuNpC;;;AACA,WAASgG,aAAT,GAAyB;AACrB;AACA;AACA;AACA;AACA;AACAlH,IAAAA,KAAK,CAACmH,kBAAN,CAAyBjG,EAAzB;AAEAN,IAAAA,WAAW,CAACwG,iBAAZ,CAA8BlG,EAA9B;AACAhB,IAAAA,IAAI,CAACmH,eAAL,CAAqBnG,EAArB,EATqB,CAWrB;;AACA,QAAGgC,UAAU,CAACG,IAAX,CAAgB,KAAhB,CAAH,EAA2B;AACvB,UAAIiE,QAAQ,GAAGpG,EAAE,CAAC8C,SAAlB;;AACA,WAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoD,QAAQ,CAAC3E,MAA5B,EAAoCuB,CAAC,EAArC,EAAyC;AACrC,YAAIC,KAAK,GAAGmD,QAAQ,CAACpD,CAAD,CAApB;;AACA,YAAGC,KAAK,CAACoD,IAAN,KAAe,KAAf,IAAwBpD,KAAK,CAACqD,UAAjC,EAA6C;AACzCxH,UAAAA,KAAK,CAACqH,eAAN,CAAsBnG,EAAtB,EAA0B,SAASiD,KAAK,CAACsD,GAAf,GAAqB,aAA/C;AACH;AACJ;AACJ;;AAEDzH,IAAAA,KAAK,CAAC0H,YAAN,CAAmBxG,EAAnB;AACA,WAAOlB,KAAK,CAACiH,gBAAN,CAAuB/F,EAAvB,CAAP;AACH,GAhPmC,CAkPpC;;;AACA,WAASyG,kBAAT,GAA8B;AAC1B,QAAG,CAAC3H,KAAK,CAAC4H,eAAN,CAAsBhD,UAAtB,EAAkC1B,UAAU,CAAC4B,KAA7C,CAAJ,EAAyD;AAEzD,WAAOpF,GAAG,CAACmI,WAAJ,CAAgB,CACnBX,aADmB,EAEnBtG,WAAW,CAACkH,YAFO,CAAhB,EAGJ5G,EAHI,CAAP;AAIH;;AAED,WAAS6G,oBAAT,GAAgC;AAC5B,QAAG,CAACjE,MAAJ,EAAY;AACRkE,MAAAA,yBAAyB;AACzB;AACH,KAJ2B,CAM5B;AACA;;;AACA,WAAOtI,GAAG,CAACmI,WAAJ,CAAgB,CACnB/H,QAAQ,CAACmI,kBAAT,CAA4B,QAA5B,EAAsC,eAAtC,CADmB,EAEnBnI,QAAQ,CAACmI,kBAAT,CAA4B,aAA5B,EAA2C,eAA3C,CAFmB,EAGnBD,yBAHmB,CAAhB,EAIJ9G,EAJI,CAAP;AAKH;;AAED,WAAS8G,yBAAT,GAAqC;AACjC,QAAG9G,EAAE,CAACgH,cAAN,EAAsB;AAEtBtH,IAAAA,WAAW,CAACoH,yBAAZ,CAAsC9G,EAAtC,EAHiC,CAKjC;AACA;;AACA,QAAGwB,aAAH,EAAkBxC,IAAI,CAACiI,gBAAL,CAAsBjH,EAAtB,EAPe,CASjC;AACA;AACA;;AACApB,IAAAA,QAAQ,CAACmI,kBAAT,CAA4B,aAA5B,EAA2C,eAA3C,EAA4D/G,EAA5D;AACH,GAxRmC,CA0RpC;;;AACA,WAASkH,QAAT,GAAoB;AAChB,WAAOlI,IAAI,CAACmI,IAAL,CAAUnH,EAAV,EAAcwB,aAAa,GAAG,EAAH,GAAQ,QAAnC,CAAP;AACH;;AAED,MAAI4F,GAAG,GAAG,CACNtI,KAAK,CAACiH,gBADA,EAENhF,SAFM,EAGN+C,aAHM,EAINkC,aAJM,EAKNS,kBALM,CAAV;AAQA,MAAGvE,YAAH,EAAiBkF,GAAG,CAACzF,IAAJ,CAASkF,oBAAT;AAEjBO,EAAAA,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACkH,YAArB;AACA,MAAG1E,YAAH,EAAiBkF,GAAG,CAACzF,IAAJ,CAASuF,QAAT;AAEjBE,EAAAA,GAAG,CAACzF,IAAJ,CACIjC,WAAW,CAAC2H,QADhB,EAEI3H,WAAW,CAAC4H,SAFhB,EAGInI,gBAHJ,EAIIL,KAAK,CAACyI,QAJV,EAKIzI,KAAK,CAAC0I,OALV,EAMI1I,KAAK,CAAC2I,MANV,EAOI;AACA;AACA;AACA;AACA3I,EAAAA,KAAK,CAAC0H,YAXV,EAYI1H,KAAK,CAACiH,gBAZV,EA5SoC,CA2TpC;AACA;;AACA,MAAI2B,QAAQ,GAAGlJ,GAAG,CAACmI,WAAJ,CAAgBS,GAAhB,EAAqBpH,EAArB,CAAf;AACA,MAAG,CAAC0H,QAAD,IAAa,CAACA,QAAQ,CAACC,IAA1B,EAAgCD,QAAQ,GAAG/G,OAAO,CAACiH,OAAR,EAAX;AAEhC,SAAOF,QAAQ,CAACC,IAAT,CAAc,YAAW;AAC5BE,IAAAA,aAAa,CAAC7H,EAAD,CAAb;AACA,WAAOA,EAAP;AACH,GAHM,CAAP;AAIH;;AAED,SAAS6H,aAAT,CAAuB7H,EAAvB,EAA2B;AACvB,MAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAApB;;AAEA,MAAGD,UAAU,CAAC8F,0BAAd,EAA0C;AACtC9F,IAAAA,UAAU,CAAC8F,0BAAX;AACH,GAFD,MAEO;AACH9H,IAAAA,EAAE,CAAC+H,IAAH,CAAQ,kBAAR;AACH;AACJ;;AAED,SAASC,aAAT,CAAuBxH,GAAvB,EAA4B;AACxB,SAAOhC,GAAG,CAACmF,UAAJ,CAAepE,UAAf,EAA2BiB,GAA3B,CAAP;AACH;;AAED,SAASyH,aAAT,CAAuBjI,EAAvB,EAA2BkI,OAA3B,EAAoC;AAChC,MAAI;AACAlI,IAAAA,EAAE,CAACiC,WAAH,CAAekG,MAAf,CAAsBvD,KAAtB,CAA4B,YAA5B,EAA0CsD,OAA1C;AACH,GAFD,CAEE,OAAME,CAAN,EAAS;AACP5J,IAAAA,GAAG,CAACkH,KAAJ,CAAU0C,CAAV;AACH;AACJ;;AAED,SAASC,mBAAT,CAA6BrI,EAA7B,EAAiCkI,OAAjC,EAA0C;AACtC,MAAII,KAAK,GAAGpJ,KAAK,CAACqJ,OAAN,CAAcL,OAAd,EAAuB,OAAvB,CAAZ;AACAD,EAAAA,aAAa,CAACjI,EAAD,EAAKsI,KAAL,CAAb;AACH;;AAED,SAASrH,cAAT,CAAwBjB,EAAxB,EAA4BG,MAA5B,EAAoC;AAChC,MAAG,CAACH,EAAE,CAACkD,QAAP,EAAiB;AACblD,IAAAA,EAAE,CAACkD,QAAH,GAAc1E,GAAG,CAACgK,UAAJ,CAAe,EAAf,EAAmBjJ,UAAnB,CAAd,CADa,CAGb;;AACA,QAAIkJ,IAAI,GAAGrK,EAAE,CAAC8C,MAAH,CAAU,MAAV,CAAX;AACAlB,IAAAA,EAAE,CAACkD,QAAH,CAAYwF,QAAZ,GAAuBD,IAAI,CAACE,IAAL,MAAeF,IAAI,CAAC/D,IAAL,CAAU,MAAV,CAAf,GACnBnB,MAAM,CAACqF,QAAP,CAAgBC,IAAhB,CAAqBC,KAArB,CAA2B,GAA3B,EAAgC,CAAhC,CADmB,GAEnB,EAFJ;AAGH;;AAED,MAAIzE,OAAO,GAAGrE,EAAE,CAACkD,QAAjB;AAEA,MAAIF,CAAJ,EAAO+F,IAAP,EAAa3E,GAAb;;AAEA,MAAGjE,MAAH,EAAW;AACP4I,IAAAA,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY5I,MAAZ,CAAP;;AACA,SAAI6C,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG+F,IAAI,CAACtH,MAApB,EAA4BuB,CAAC,EAA7B,EAAiC;AAC7BoB,MAAAA,GAAG,GAAG2E,IAAI,CAAC/F,CAAD,CAAV;AACA,UAAGoB,GAAG,KAAK,UAAR,IAAsBA,GAAG,KAAK,OAAjC,EAA0C;;AAC1C,UAAGA,GAAG,IAAIC,OAAV,EAAmB;AACf,YAAGD,GAAG,KAAK,eAAR,IAA2BjE,MAAM,CAACiE,GAAD,CAAN,KAAgB,QAA9C,EAAwD;AACpDC,UAAAA,OAAO,CAACD,GAAD,CAAP,GAAeiE,mBAAf;AACH,SAFD,MAEO;AACHhE,UAAAA,OAAO,CAACD,GAAD,CAAP,GAAejE,MAAM,CAACiE,GAAD,CAArB;AACH;AACJ;AACJ,KAZM,CAcP;;;AACA,QAAGjE,MAAM,CAAC8I,gBAAP,IAA2B,CAAC5E,OAAO,CAAC6E,gBAAvC,EAAyD;AACrD7E,MAAAA,OAAO,CAAC6E,gBAAR,GAA2B7E,OAAO,CAAC4E,gBAAnC;AACH,KAjBM,CAmBP;AACA;;;AACA,QAAIE,QAAQ,GAAGhJ,MAAM,CAACgJ,QAAtB;;AACA,QAAGA,QAAQ,KAAKC,SAAhB,EAA2B;AACvB;AACA;AACA/E,MAAAA,OAAO,CAAC8E,QAAR,GAAmBA,QAAnB;AAEAJ,MAAAA,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY1E,OAAO,CAACgF,KAApB,CAAP;;AACA,WAAIrG,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG+F,IAAI,CAACtH,MAApB,EAA4BuB,CAAC,EAA7B,EAAiC;AAC7BqB,QAAAA,OAAO,CAACgF,KAAR,CAAcN,IAAI,CAAC/F,CAAD,CAAlB,IAAyBmG,QAAzB;AACH;AACJ;;AACD,QAAGhJ,MAAM,CAACkJ,KAAV,EAAiB;AACbN,MAAAA,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY5I,MAAM,CAACkJ,KAAnB,CAAP;;AACA,WAAIrG,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG+F,IAAI,CAACtH,MAApB,EAA4BuB,CAAC,EAA7B,EAAiC;AAC7BoB,QAAAA,GAAG,GAAG2E,IAAI,CAAC/F,CAAD,CAAV;;AACA,YAAGoB,GAAG,IAAIC,OAAO,CAACgF,KAAlB,EAAyB;AACrBhF,UAAAA,OAAO,CAACgF,KAAR,CAAcjF,GAAd,IAAqBjE,MAAM,CAACkJ,KAAP,CAAajF,GAAb,CAArB;AACH;AACJ;AACJ,KAxCM,CA0CP;;;AACAC,IAAAA,OAAO,CAACiF,aAAR,GAAwBnJ,MAAM,CAACmJ,aAA/B;AACH,GA3D+B,CA6DhC;;;AACA,MAAGjF,OAAO,CAACkF,UAAX,EAAuB;AACnBlF,IAAAA,OAAO,CAAC8E,QAAR,GAAmB,KAAnB;AACA9E,IAAAA,OAAO,CAACgF,KAAR,GAAgB,EAAhB;AACAhF,IAAAA,OAAO,CAACmF,WAAR,GAAsB,KAAtB;AACAnF,IAAAA,OAAO,CAACoF,UAAR,GAAqB,KAArB;AACApF,IAAAA,OAAO,CAACqF,WAAR,GAAsB,KAAtB;AACArF,IAAAA,OAAO,CAACsF,QAAR,GAAmB,KAAnB;AACAtF,IAAAA,OAAO,CAACuF,QAAR,GAAmB,KAAnB;AACAvF,IAAAA,OAAO,CAACwF,cAAR,GAAyB,KAAzB;AACH,GAvE+B,CAyEhC;;;AACA,MAAGxF,OAAO,CAACwF,cAAR,KAA2B,OAA3B,IAAsC,CAACtL,QAA1C,EAAoD;AAChD8F,IAAAA,OAAO,CAACwF,cAAR,GAAyB,IAAzB;AACH,GA5E+B,CA8EhC;;;AACA,MAAGxF,OAAO,CAAC4D,aAAR,KAA0B,aAA1B,IAA2C,OAAO5D,OAAO,CAAC4D,aAAf,KAAiC,UAA/E,EAA2F;AACvF5D,IAAAA,OAAO,CAAC4D,aAAR,GAAwBA,aAAxB;AACH,GAjF+B,CAmFhC;;;AACA5D,EAAAA,OAAO,CAACyF,cAAR,GAAyBzF,OAAO,CAACyF,cAAR,IAA0B9J,EAAE,CAAC+J,YAAH,KAAoB,CAAvE;AACA1F,EAAAA,OAAO,CAAC2F,aAAR,GAAwB3F,OAAO,CAAC2F,aAAR,IAAyBhK,EAAE,CAACiK,WAAH,KAAmB,CAApE,CArFgC,CAuFhC;;AACA,MAAIC,IAAI,GAAG7F,OAAO,CAACoF,UAAnB;AACA,MAAIU,KAAK,GAAG9F,OAAO,CAAC+F,WAAR,GAAsB,EAAlC;;AACA,MAAGF,IAAI,KAAK,IAAZ,EAAkB;AACdC,IAAAA,KAAK,CAACE,SAAN,GAAkB,CAAlB;AACAF,IAAAA,KAAK,CAACG,IAAN,GAAa,CAAb;AACAH,IAAAA,KAAK,CAACI,GAAN,GAAY,CAAZ;AACAJ,IAAAA,KAAK,CAACK,MAAN,GAAe,CAAf;AACH,GALD,MAKO,IAAG,OAAON,IAAP,KAAgB,QAAnB,EAA6B;AAChC,QAAIO,KAAK,GAAGP,IAAI,CAACpB,KAAL,CAAW,GAAX,CAAZ;;AACA,SAAI9F,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyH,KAAK,CAAChJ,MAArB,EAA6BuB,CAAC,EAA9B,EAAkC;AAC9BmH,MAAAA,KAAK,CAACM,KAAK,CAACzH,CAAD,CAAN,CAAL,GAAkB,CAAlB;AACH;AACJ,GALM,MAKA,IAAGkH,IAAI,KAAK,KAAZ,EAAmB;AACtBC,IAAAA,KAAK,CAACG,IAAN,GAAa,CAAb;AACAH,IAAAA,KAAK,CAACI,GAAN,GAAY,CAAZ;AACAJ,IAAAA,KAAK,CAACK,MAAN,GAAe,CAAf;AACH;AACJ;;AAED,SAASlI,eAAT,CAAyBtC,EAAzB,EAA6BC,IAA7B,EAAmCC,MAAnC,EAA2C;AACvC;AACA,MAAIwK,aAAa,GAAGtM,EAAE,CAAC8C,MAAH,CAAUlB,EAAV,EAAcmE,SAAd,CAAwB,iBAAxB,EACflE,IADe,CACV,CAAC,CAAD,CADU,CAApB;AAEAyK,EAAAA,aAAa,CAAClG,KAAd,GACKmG,MADL,CACY,KADZ,EACmB,cADnB,EAEKxJ,OAFL,CAEa,uBAFb,EAEsC,IAFtC;AAGA,MAAIyJ,QAAQ,GAAGF,aAAa,CAACvG,SAAd,CAAwB,gBAAxB,EACVlE,IADU,CACL,CAAC,CAAD,CADK,CAAf;AAEA2K,EAAAA,QAAQ,CAACpG,KAAT,GAAiBC,MAAjB,CAAwB,KAAxB,EACKtD,OADL,CACa,eADb,EAC8B,IAD9B,EAEKyD,KAFL,CAEW,UAFX,EAEuB,UAFvB,EATuC,CAavC;;AACAgG,EAAAA,QAAQ,CAACC,IAAT,CAAc,EAAd,EAduC,CAgBvC;;AACA,MAAG5K,IAAH,EAASD,EAAE,CAACC,IAAH,GAAUA,IAAV;AACT,MAAGC,MAAH,EAAWF,EAAE,CAACE,MAAH,GAAYA,MAAZ;AACXnB,EAAAA,KAAK,CAAC+L,OAAN,CAAcC,UAAd,CAAyB/K,EAAzB,EAnBuC,CAqBvC;;AACA4K,EAAAA,QAAQ,CAAChG,KAAT,CAAe;AACXK,IAAAA,KAAK,EAAEjF,EAAE,CAACiC,WAAH,CAAegD,KAAf,GAAuB,IADnB;AAEXC,IAAAA,MAAM,EAAElF,EAAE,CAACiC,WAAH,CAAeiD,MAAf,GAAwB;AAFrB,GAAf,EAtBuC,CA2BvC;;AACAlF,EAAAA,EAAE,CAACyC,SAAH,GAAe1D,KAAK,CAAC+L,OAAN,CAAcrI,SAAd,CAAwBzC,EAAxB,CAAf,CA5BuC,CA8BvC;;AACAA,EAAAA,EAAE,CAACyC,SAAH,CAAa;AAACxC,IAAAA,IAAI,EAAED,EAAE,CAACC,IAAV;AAAgBC,IAAAA,MAAM,EAAEF,EAAE,CAACE;AAA3B,GAAb,EAAiD0K,QAAQ,CAACI,IAAT,EAAjD,EA/BuC,CAiCvC;;AACAhL,EAAAA,EAAE,CAACyC,SAAH,CAAawI,YAAb,GAlCuC,CAoCvC;;AACA,MAAIC,YAAY,GAAGlL,EAAE,CAACyC,SAAH,CAAa0I,GAAb,EAAnB,CArCuC,CAuCvC;;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,GAAG,GAAGrL,EAAE,CAACiC,WAAH,CAAeqJ,KAAf,GAAuBtL,EAAE,CAACiC,WAAH,CAAeqJ,KAAf,CAAqBC,IAA5C,GAAmD,EAA7D;AACA,MAAGF,GAAG,KAAK,EAAR,IAAc,CAACA,GAAlB,EAAuBD,OAAO,GAAG,CAAV;;AAEvB,MAAII,WAAW,GAAG,SAAdA,WAAc,GAAW;AACzB,SAAKC,IAAL,CAAUpM,YAAY,CAACqM,eAAvB,EAAwC1L,EAAxC,EADyB,CAEzB;AACA;AACH,GAJD;;AAMA,MAAIsL,KAAK,GAAGJ,YAAY,CAAChK,MAAb,CAAoB,mBAApB,EACPuK,IADO,CACFD,WADE,CAAZ;;AAGA,MAAGxL,EAAE,CAACkD,QAAH,CAAYmG,KAAZ,CAAkBsC,SAArB,EAAgC;AAC5B,QAAIC,eAAe,GAAGpN,GAAG,CAACqN,CAAJ,CAAM7L,EAAN,EAAU,2BAAV,CAAtB;;AACA,QAAG,CAACqL,GAAD,IAAQA,GAAG,KAAKO,eAAnB,EAAoC;AAChCR,MAAAA,OAAO,GAAG,GAAV,CADgC,CAEhC;AACA;;AACAE,MAAAA,KAAK,CAAC5G,IAAN,CAAW;AAAC,4BAAoBkH;AAArB,OAAX,EACKL,IADL,CACUK,eADV,EAEKhH,KAFL,CAEW;AAACwG,QAAAA,OAAO,EAAEA;AAAV,OAFX,EAGKU,EAHL,CAGQ,mBAHR,EAG6B,YAAW;AAChC1N,QAAAA,EAAE,CAAC8C,MAAH,CAAU,IAAV,EAAgB6K,UAAhB,GAA6BC,QAA7B,CAAsC,GAAtC,EACKpH,KADL,CACW,SADX,EACsB,CADtB;AAEH,OANL,EAOKkH,EAPL,CAOQ,kBAPR,EAO4B,YAAW;AAC/B1N,QAAAA,EAAE,CAAC8C,MAAH,CAAU,IAAV,EAAgB6K,UAAhB,GAA6BC,QAA7B,CAAsC,IAAtC,EACKpH,KADL,CACW,SADX,EACsB,CADtB;AAEH,OAVL;AAWH;;AAED,QAAIqH,kBAAkB,GAAG,SAArBA,kBAAqB,GAAW;AAChC,WAAKR,IAAL,CAAUpM,YAAY,CAAC6M,YAAvB,EAAqC;AAAClM,QAAAA,EAAE,EAAEA;AAAL,OAArC,EACK8L,EADL,CACQ,MADR,EACgB,UAASP,IAAT,EAAe;AACvBvL,QAAAA,EAAE,CAACyC,SAAH,CAAa;AAACvC,UAAAA,MAAM,EAAE;AAACoL,YAAAA,KAAK,EAAE;AAACC,cAAAA,IAAI,EAAEA;AAAP;AAAR;AAAT,SAAb;AACA,aAAKA,IAAL,CAAUA,IAAV,EACKE,IADL,CACUD,WADV;AAEA,aAAKC,IAAL,CAAUQ,kBAAV;AACH,OANL,EAOKH,EAPL,CAOQ,QAPR,EAOkB,YAAW;AACrB,YAAIT,GAAG,GAAG,KAAK3G,IAAL,CAAU,kBAAV,CAAV;AACA,aAAK6G,IAAL,CAAUF,GAAV,EAAeI,IAAf,CAAoBD,WAApB;AACH,OAVL;AAWH,KAZD;;AAaAF,IAAAA,KAAK,CAACG,IAAN,CAAWQ,kBAAX;AACH;;AAEDjM,EAAAA,EAAE,CAACkD,QAAH,CAAY+E,aAAZ,CAA0BjI,EAA1B,EAA8BA,EAAE,CAACiC,WAAH,CAAekK,aAA7C;;AACArN,EAAAA,KAAK,CAACyI,QAAN,CAAevH,EAAf;AAEA,SAAOW,OAAO,CAACiH,OAAR,EAAP;AACH,C,CAED;;;AACA,SAASwE,MAAT,CAAgBpM,EAAhB,EAAoB;AAChBA,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;;AAEA,MAAG,CAACxB,GAAG,CAACqC,SAAJ,CAAcb,EAAd,CAAJ,EAAuB;AACnB,UAAM,IAAIqM,KAAJ,CAAU,wCAAwCrM,EAAlD,CAAN;AACH;;AAEDP,EAAAA,OAAO,CAACiC,SAAR,CAAkB1B,EAAE,CAACC,IAArB;AACAR,EAAAA,OAAO,CAACqC,WAAR,CAAoB9B,EAAE,CAACE,MAAvB;AAEAF,EAAAA,EAAE,CAAC6C,QAAH,GAAcuG,SAAd;AACA,SAAOpI,OAAO,CAACjB,IAAR,CAAaC,EAAb,EAAiB2H,IAAjB,CAAsB,YAAW;AACpC3H,IAAAA,EAAE,CAAC+H,IAAH,CAAQ,eAAR;AACA,WAAO/H,EAAP;AACH,GAHM,CAAP;AAIH;AAED;;;;;;;;;;AAQA,SAASsM,OAAT,CAAiBtM,EAAjB,EAAqBC,IAArB,EAA2BC,MAA3B,EAAmCC,MAAnC,EAA2C;AACvCH,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL,CADuC,CAGvC;;AACAlB,EAAAA,KAAK,CAAC6G,SAAN,CAAgB,EAAhB,EAAoB,EAApB,EAAwB3F,EAAE,CAAC8C,SAAH,IAAgB,EAAxC,EAA4C9C,EAAE,CAACiC,WAAH,IAAkB,EAA9D;AAEAnD,EAAAA,KAAK,CAACyN,KAAN,CAAYvM,EAAZ;AACA,SAAOgB,OAAO,CAACjB,IAAR,CAAaC,EAAb,EAAiBC,IAAjB,EAAuBC,MAAvB,EAA+BC,MAA/B,CAAP;AACH;AAED;;;;;;;;AAMA,SAASqM,iBAAT,CAA2BC,OAA3B,EAAoCC,QAApC,EAA8C;AAC1C,MAAIC,YAAY,GAAGD,QAAQ,GAAG,CAA9B;AACA,MAAIE,eAAe,GAAG,EAAtB;AACA,MAAI5J,CAAJ;AACA,MAAI6J,KAAJ;;AAEA,OAAI7J,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyJ,OAAO,CAAChL,MAAvB,EAA+BuB,CAAC,EAAhC,EAAoC;AAChC6J,IAAAA,KAAK,GAAGJ,OAAO,CAACzJ,CAAD,CAAf;;AACA,QAAG6J,KAAK,GAAG,CAAX,EAAc;AACVD,MAAAA,eAAe,CAACjL,IAAhB,CAAqBgL,YAAY,GAAGE,KAApC;AACH,KAFD,MAEO;AACHD,MAAAA,eAAe,CAACjL,IAAhB,CAAqBkL,KAArB;AACH;AACJ;;AACD,SAAOD,eAAP;AACH;AAED;;;;;;;;;;;AASA,SAASE,gBAAT,CAA0B9M,EAA1B,EAA8ByM,OAA9B,EAAuCM,SAAvC,EAAkD;AAC9C,MAAI/J,CAAJ,EACI6J,KADJ;;AAGA,OAAI7J,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyJ,OAAO,CAAChL,MAAvB,EAA+BuB,CAAC,EAAhC,EAAoC;AAChC6J,IAAAA,KAAK,GAAGJ,OAAO,CAACzJ,CAAD,CAAf,CADgC,CAGhC;;AACA,QAAG6J,KAAK,KAAKG,QAAQ,CAACH,KAAD,EAAQ,EAAR,CAArB,EAAkC;AAC9B,YAAM,IAAIR,KAAJ,CAAU,mBAAmBU,SAAnB,GAA+B,mBAAzC,CAAN;AACH,KAN+B,CAQhC;;;AACA,QAAGF,KAAK,IAAI7M,EAAE,CAACC,IAAH,CAAQwB,MAAjB,IAA2BoL,KAAK,GAAG,CAAC7M,EAAE,CAACC,IAAH,CAAQwB,MAA/C,EAAuD;AACnD,YAAM,IAAI4K,KAAJ,CAAUU,SAAS,GAAG,qCAAtB,CAAN;AACH,KAX+B,CAahC;;;AACA,QAAGN,OAAO,CAACQ,OAAR,CAAgBJ,KAAhB,EAAuB7J,CAAC,GAAG,CAA3B,IAAgC,CAAC,CAAjC,IACK6J,KAAK,IAAI,CAAT,IAAcJ,OAAO,CAACQ,OAAR,CAAgB,CAACjN,EAAE,CAACC,IAAH,CAAQwB,MAAT,GAAkBoL,KAAlC,IAA2C,CAAC,CAD/D,IAEKA,KAAK,GAAG,CAAR,IAAaJ,OAAO,CAACQ,OAAR,CAAgBjN,EAAE,CAACC,IAAH,CAAQwB,MAAR,GAAiBoL,KAAjC,IAA0C,CAAC,CAFhE,EAEmE;AAC/D,YAAM,IAAIR,KAAJ,CAAU,mBAAmBU,SAAnB,GAA+B,kBAAzC,CAAN;AACH;AACJ;AACJ;AAED;;;;;;;;;AAOA,SAASG,mBAAT,CAA6BlN,EAA7B,EAAiCmN,cAAjC,EAAiDC,UAAjD,EAA6D;AACzD;AACA,MAAG,CAAC/L,KAAK,CAACC,OAAN,CAActB,EAAE,CAACC,IAAjB,CAAJ,EAA4B;AACxB,UAAM,IAAIoM,KAAJ,CAAU,2BAAV,CAAN;AACH,GAJwD,CAMzD;;;AACA,MAAG,OAAOc,cAAP,KAA0B,WAA7B,EAA0C;AACtC,UAAM,IAAId,KAAJ,CAAU,wCAAV,CAAN;AACH,GAFD,MAEO,IAAG,CAAChL,KAAK,CAACC,OAAN,CAAc6L,cAAd,CAAJ,EAAmC;AACtCA,IAAAA,cAAc,GAAG,CAACA,cAAD,CAAjB;AACH;;AACDL,EAAAA,gBAAgB,CAAC9M,EAAD,EAAKmN,cAAL,EAAqB,gBAArB,CAAhB,CAZyD,CAczD;;AACA,MAAG,OAAOC,UAAP,KAAsB,WAAtB,IAAqC,CAAC/L,KAAK,CAACC,OAAN,CAAc8L,UAAd,CAAzC,EAAoE;AAChEA,IAAAA,UAAU,GAAG,CAACA,UAAD,CAAb;AACH;;AACD,MAAG,OAAOA,UAAP,KAAsB,WAAzB,EAAsC;AAClCN,IAAAA,gBAAgB,CAAC9M,EAAD,EAAKoN,UAAL,EAAiB,YAAjB,CAAhB;AACH,GApBwD,CAsBzD;;;AACA,MAAG,OAAOA,UAAP,KAAsB,WAAtB,IAAqCD,cAAc,CAAC1L,MAAf,KAA0B2L,UAAU,CAAC3L,MAA7E,EAAqF;AACjF,UAAM,IAAI4K,KAAJ,CAAU,kDAAV,CAAN;AACH;AACJ;AACD;;;;;;;;;AAOA,SAASgB,kBAAT,CAA4BrN,EAA5B,EAAgCsN,MAAhC,EAAwCF,UAAxC,EAAoD;AAChD,MAAIpK,CAAJ,EAAOuK,KAAP,CADgD,CAGhD;;AACA,MAAG,CAAClM,KAAK,CAACC,OAAN,CAActB,EAAE,CAACC,IAAjB,CAAJ,EAA4B;AACxB,UAAM,IAAIoM,KAAJ,CAAU,2BAAV,CAAN;AACH,GAN+C,CAQhD;;;AACA,MAAG,OAAOiB,MAAP,KAAkB,WAArB,EAAkC;AAC9B,UAAM,IAAIjB,KAAJ,CAAU,yBAAV,CAAN;AACH,GAX+C,CAahD;;;AACA,MAAG,CAAChL,KAAK,CAACC,OAAN,CAAcgM,MAAd,CAAJ,EAA2B;AACvBA,IAAAA,MAAM,GAAG,CAACA,MAAD,CAAT;AACH,GAhB+C,CAkBhD;;;AACA,OAAItK,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsK,MAAM,CAAC7L,MAAtB,EAA8BuB,CAAC,EAA/B,EAAmC;AAC/BuK,IAAAA,KAAK,GAAGD,MAAM,CAACtK,CAAD,CAAd;;AACA,QAAG,OAAOuK,KAAP,KAAiB,QAAjB,IAA8BlM,KAAK,CAACC,OAAN,CAAciM,KAAd,KAAwBA,KAAK,KAAK,IAAnE,EAA0E;AACtE,YAAM,IAAIlB,KAAJ,CAAU,sDAAV,CAAN;AACH;AACJ,GAxB+C,CA0BhD;;;AACA,MAAG,OAAOe,UAAP,KAAsB,WAAtB,IAAqC,CAAC/L,KAAK,CAACC,OAAN,CAAc8L,UAAd,CAAzC,EAAoE;AAChEA,IAAAA,UAAU,GAAG,CAACA,UAAD,CAAb;AACH;;AACD,MAAG,OAAOA,UAAP,KAAsB,WAAtB,IAAqCA,UAAU,CAAC3L,MAAX,KAAsB6L,MAAM,CAAC7L,MAArE,EAA6E;AACzE,UAAM,IAAI4K,KAAJ,CACF,kEADE,CAAN;AAGH;AACJ;AAED;;;;;;;;;;;;AAUA,SAASmB,sBAAT,CAAgCxN,EAAhC,EAAoCyN,MAApC,EAA4ChB,OAA5C,EAAqDiB,SAArD,EAAgE;AAC5D,MAAIC,iBAAiB,GAAGnP,GAAG,CAAC+B,aAAJ,CAAkBmN,SAAlB,CAAxB;;AAEA,MAAG,CAACrM,KAAK,CAACC,OAAN,CAActB,EAAE,CAACC,IAAjB,CAAJ,EAA4B;AACxB,UAAM,IAAIoM,KAAJ,CAAU,0BAAV,CAAN;AACH;;AACD,MAAG,CAAC7N,GAAG,CAAC+B,aAAJ,CAAkBkN,MAAlB,CAAJ,EAA+B;AAC3B,UAAM,IAAIpB,KAAJ,CAAU,mCAAV,CAAN;AACH;;AAED,MAAG,OAAOI,OAAP,KAAmB,WAAtB,EAAmC;AAC/B,UAAM,IAAIJ,KAAJ,CAAU,iDAAV,CAAN;AACH;;AAEDS,EAAAA,gBAAgB,CAAC9M,EAAD,EAAKyM,OAAL,EAAc,SAAd,CAAhB;;AAEA,OAAI,IAAIrI,GAAR,IAAeqJ,MAAf,EAAuB;AACnB;;;;AAIA,QAAG,CAACpM,KAAK,CAACC,OAAN,CAAcmM,MAAM,CAACrJ,GAAD,CAApB,CAAD,IAA+BqJ,MAAM,CAACrJ,GAAD,CAAN,CAAY3C,MAAZ,KAAuBgL,OAAO,CAAChL,MAAjE,EAAyE;AACrE,YAAM,IAAI4K,KAAJ,CAAU,eAAejI,GAAf,GAAqB,2DAA/B,CAAN;AACH;AAED;;;;;AAGA,QAAGuJ,iBAAiB,KACf,EAAEvJ,GAAG,IAAIsJ,SAAT,KAAuB,CAACrM,KAAK,CAACC,OAAN,CAAcoM,SAAS,CAACtJ,GAAD,CAAvB,CAAxB,IACDsJ,SAAS,CAACtJ,GAAD,CAAT,CAAe3C,MAAf,KAA0BgM,MAAM,CAACrJ,GAAD,CAAN,CAAY3C,MAFtB,CAApB,EAEmD;AAC/C,YAAM,IAAI4K,KAAJ,CAAU,uEACA,wEADV,CAAN;AAEH;AACJ;AACJ;AAED;;;;;;;;;;;AASA,SAASuB,mBAAT,CAA6B5N,EAA7B,EAAiCyN,MAAjC,EAAyChB,OAAzC,EAAkDiB,SAAlD,EAA6D;AACzD,MAAIC,iBAAiB,GAAGnP,GAAG,CAAC+B,aAAJ,CAAkBmN,SAAlB,CAAxB;AACA,MAAIG,WAAW,GAAG,EAAlB;AACA,MAAI5K,KAAJ,EAAW6K,MAAX,EAAmBC,IAAnB,EAAyBpD,MAAzB,EAAiCqD,IAAjC,CAHyD,CAKzD;;AACA,MAAG,CAAC3M,KAAK,CAACC,OAAN,CAAcmL,OAAd,CAAJ,EAA4BA,OAAO,GAAG,CAACA,OAAD,CAAV,CAN6B,CAQzD;;AACAA,EAAAA,OAAO,GAAGD,iBAAiB,CAACC,OAAD,EAAUzM,EAAE,CAACC,IAAH,CAAQwB,MAAR,GAAiB,CAA3B,CAA3B,CATyD,CAWzD;;AACA,OAAI,IAAI2C,GAAR,IAAeqJ,MAAf,EAAuB;AACnB,SAAI,IAAIQ,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGxB,OAAO,CAAChL,MAA3B,EAAmCwM,CAAC,EAApC,EAAwC;AACpC;;;;AAIAhL,MAAAA,KAAK,GAAGjD,EAAE,CAACC,IAAH,CAAQwM,OAAO,CAACwB,CAAD,CAAf,CAAR;AACAF,MAAAA,IAAI,GAAGtP,cAAc,CAACwE,KAAD,EAAQmB,GAAR,CAArB;AAEA;;;;;AAIA0J,MAAAA,MAAM,GAAGC,IAAI,CAACG,GAAL,EAAT;AACAvD,MAAAA,MAAM,GAAG8C,MAAM,CAACrJ,GAAD,CAAN,CAAY6J,CAAZ,CAAT;;AAEA,UAAG,CAACzP,GAAG,CAAC2P,mBAAJ,CAAwBxD,MAAxB,CAAJ,EAAqC;AACjC,cAAM,IAAI0B,KAAJ,CAAU,gBAAgBjI,GAAhB,GAAsB,UAAtB,GAAmC6J,CAAnC,GAAuC,mBAAjD,CAAN;AACH;;AACD,UAAG,CAACzP,GAAG,CAAC2P,mBAAJ,CAAwBL,MAAxB,CAAJ,EAAqC;AACjC,cAAM,IAAIzB,KAAJ,CAAU,mDAAmDjI,GAA7D,CAAN;AACH;;AACD,UAAG0J,MAAM,CAACM,WAAP,KAAuBzD,MAAM,CAACyD,WAAjC,EAA8C;AAC1C,cAAM,IAAI/B,KAAJ,CAAU,4DAA4DjI,GAAtE,CAAN;AACH;AAED;;;;;;AAIA4J,MAAAA,IAAI,GAAGL,iBAAiB,GAAGD,SAAS,CAACtJ,GAAD,CAAT,CAAe6J,CAAf,CAAH,GAAuBP,SAA/C,CA7BoC,CA+BpC;;AACA,UAAG,CAACpP,SAAS,CAAC0P,IAAD,CAAb,EAAqBA,IAAI,GAAG,CAAC,CAAR;AAErB;;;;;;AAKAH,MAAAA,WAAW,CAAClM,IAAZ,CAAiB;AACboM,QAAAA,IAAI,EAAEA,IADO;AAEbD,QAAAA,MAAM,EAAEA,MAFK;AAGbnD,QAAAA,MAAM,EAAEA,MAHK;AAIbqD,QAAAA,IAAI,EAAE5I,IAAI,CAACC,KAAL,CAAW2I,IAAX;AAJO,OAAjB;AAMH;AACJ,GA3DwD,CA6DzD;;;AACA,SAAOH,WAAP;AACH;AAED;;;;;;;;;;;;AAUA,SAASQ,YAAT,CAAsBrO,EAAtB,EAA0ByN,MAA1B,EAAkChB,OAAlC,EAA2CiB,SAA3C,EAAsDY,WAAtD,EAAmE;AAC/Dd,EAAAA,sBAAsB,CAACxN,EAAD,EAAKyN,MAAL,EAAahB,OAAb,EAAsBiB,SAAtB,CAAtB;AAEA,MAAIG,WAAW,GAAGD,mBAAmB,CAAC5N,EAAD,EAAKyN,MAAL,EAAahB,OAAb,EAAsBiB,SAAtB,CAArC;AACA,MAAIa,UAAU,GAAG,EAAjB;AACA,MAAIC,UAAU,GAAG,EAAjB;;AAEA,OAAI,IAAIxL,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG6K,WAAW,CAACpM,MAA/B,EAAuCuB,CAAC,EAAxC,EAA4C;AACxC,QAAI+K,IAAI,GAAGF,WAAW,CAAC7K,CAAD,CAAX,CAAe+K,IAA1B;AACA,QAAIC,IAAI,GAAGH,WAAW,CAAC7K,CAAD,CAAX,CAAegL,IAA1B,CAFwC,CAIxC;;AACA,QAAIS,GAAG,GAAGH,WAAW,CAACT,WAAW,CAAC7K,CAAD,CAAX,CAAe8K,MAAhB,EAAwBD,WAAW,CAAC7K,CAAD,CAAX,CAAe2H,MAAvC,EAA+CqD,IAA/C,CAArB;AACAD,IAAAA,IAAI,CAACW,GAAL,CAASD,GAAG,CAAC,CAAD,CAAZ,EANwC,CAQxC;;AACA,QAAG,CAACpN,KAAK,CAACC,OAAN,CAAciN,UAAU,CAACR,IAAI,CAACY,IAAN,CAAxB,CAAJ,EAA0CJ,UAAU,CAACR,IAAI,CAACY,IAAN,CAAV,GAAwB,EAAxB;AAC1CJ,IAAAA,UAAU,CAACR,IAAI,CAACY,IAAN,CAAV,CAAsBhN,IAAtB,CAA2B8M,GAAG,CAAC,CAAD,CAA9B,EAVwC,CAYvC;;AACD,QAAG,CAACpN,KAAK,CAACC,OAAN,CAAckN,UAAU,CAACT,IAAI,CAACY,IAAN,CAAxB,CAAJ,EAA0CH,UAAU,CAACT,IAAI,CAACY,IAAN,CAAV,GAAwB,EAAxB;AAC1CH,IAAAA,UAAU,CAACT,IAAI,CAACY,IAAN,CAAV,CAAsBhN,IAAtB,CAA2BkM,WAAW,CAAC7K,CAAD,CAAX,CAAe8K,MAAf,CAAsBrM,MAAjD;AACH;;AAED,SAAO;AAACgM,IAAAA,MAAM,EAAEc,UAAT;AAAqBb,IAAAA,SAAS,EAAEc;AAAhC,GAAP;AACH;;AAED,SAASI,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAhC,EAAsC;AAClC,MAAIC,IAAI,GAAG,IAAIF,IAAI,CAACT,WAAT,CAAqBS,IAAI,CAACpN,MAAL,GAAcqN,IAAI,CAACrN,MAAxC,CAAX;AACAsN,EAAAA,IAAI,CAACL,GAAL,CAASG,IAAT;AACAE,EAAAA,IAAI,CAACL,GAAL,CAASI,IAAT,EAAeD,IAAI,CAACpN,MAApB;AACA,SAAOsN,IAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;AAiBA,SAASC,YAAT,CAAsBhP,EAAtB,EAA0ByN,MAA1B,EAAkChB,OAAlC,EAA2CiB,SAA3C,EAAsD;AAClD1N,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;;AAEA,WAASsO,WAAT,CAAqBR,MAArB,EAA6BnD,MAA7B,EAAqCqD,IAArC,EAA2C;AACvC,QAAIiB,QAAJ,EAAcC,SAAd;;AAEA,QAAG1Q,GAAG,CAAC2Q,YAAJ,CAAiBrB,MAAjB,CAAH,EAA6B;AACzB,UAAGE,IAAI,GAAG,CAAV,EAAa;AACT,YAAIoB,IAAI,GAAG,IAAItB,MAAM,CAACM,WAAX,CAAuB,CAAvB,CAAX;AACA,YAAIiB,IAAI,GAAGT,gBAAgB,CAACd,MAAD,EAASnD,MAAT,CAA3B;;AAEA,YAAGqD,IAAI,GAAG,CAAV,EAAa;AACTiB,UAAAA,QAAQ,GAAGI,IAAX;AACAH,UAAAA,SAAS,GAAGE,IAAZ;AACH,SAHD,MAGO;AACHH,UAAAA,QAAQ,GAAGG,IAAX;AACAF,UAAAA,SAAS,GAAGG,IAAZ;AACH;AACJ,OAXD,MAWO;AACHJ,QAAAA,QAAQ,GAAG,IAAInB,MAAM,CAACM,WAAX,CAAuBJ,IAAvB,CAAX;AACAkB,QAAAA,SAAS,GAAG,IAAIpB,MAAM,CAACM,WAAX,CAAuBN,MAAM,CAACrM,MAAP,GAAgBkJ,MAAM,CAAClJ,MAAvB,GAAgCuM,IAAvD,CAAZ;;AAEA,YAAGA,IAAI,KAAKrD,MAAM,CAAClJ,MAAnB,EAA2B;AACvBwN,UAAAA,QAAQ,CAACP,GAAT,CAAa/D,MAAb;AACAuE,UAAAA,SAAS,CAACR,GAAV,CAAcZ,MAAd;AACH,SAHD,MAGO,IAAGE,IAAI,GAAGrD,MAAM,CAAClJ,MAAjB,EAAyB;AAC5B,cAAI6N,uBAAuB,GAAG3E,MAAM,CAAClJ,MAAP,GAAgBuM,IAA9C;AAEAiB,UAAAA,QAAQ,CAACP,GAAT,CAAa/D,MAAM,CAAC4E,QAAP,CAAgBD,uBAAhB,CAAb;AACAJ,UAAAA,SAAS,CAACR,GAAV,CAAcZ,MAAd;AACAoB,UAAAA,SAAS,CAACR,GAAV,CAAc/D,MAAM,CAAC4E,QAAP,CAAgB,CAAhB,EAAmBD,uBAAnB,CAAd,EAA2DxB,MAAM,CAACrM,MAAlE;AACH,SANM,MAMA;AACH,cAAI+N,uBAAuB,GAAGxB,IAAI,GAAGrD,MAAM,CAAClJ,MAA5C;AACA,cAAIgO,WAAW,GAAG3B,MAAM,CAACrM,MAAP,GAAgB+N,uBAAlC;AAEAP,UAAAA,QAAQ,CAACP,GAAT,CAAaZ,MAAM,CAACyB,QAAP,CAAgBE,WAAhB,CAAb;AACAR,UAAAA,QAAQ,CAACP,GAAT,CAAa/D,MAAb,EAAqB6E,uBAArB;AACAN,UAAAA,SAAS,CAACR,GAAV,CAAcZ,MAAM,CAACyB,QAAP,CAAgB,CAAhB,EAAmBE,WAAnB,CAAd;AACH;AACJ;AACJ,KAlCD,MAkCO;AACHR,MAAAA,QAAQ,GAAGnB,MAAM,CAAC4B,MAAP,CAAc/E,MAAd,CAAX;AACAuE,MAAAA,SAAS,GAAIlB,IAAI,IAAI,CAAR,IAAaA,IAAI,GAAGiB,QAAQ,CAACxN,MAA9B,GACRwN,QAAQ,CAACU,MAAT,CAAgB,CAAhB,EAAmBV,QAAQ,CAACxN,MAAT,GAAkBuM,IAArC,CADQ,GAER,EAFJ;AAGH;;AAED,WAAO,CAACiB,QAAD,EAAWC,SAAX,CAAP;AACH;;AAED,MAAIU,IAAI,GAAGvB,YAAY,CAACrO,EAAD,EAAKyN,MAAL,EAAahB,OAAb,EAAsBiB,SAAtB,EAAiCY,WAAjC,CAAvB;AACA,MAAIuB,OAAO,GAAG7O,OAAO,CAACoL,MAAR,CAAepM,EAAf,CAAd;AACA,MAAI8P,QAAQ,GAAG,CAAC9P,EAAD,EAAK4P,IAAI,CAACnC,MAAV,EAAkBhB,OAAlB,EAA2BmD,IAAI,CAAClC,SAAhC,CAAf;AACA/O,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcgB,OAAO,CAACgP,aAAtB,EAAqCF,QAArC,EAA+Cd,YAA/C,EAA6DiB,SAA7D;AAEA,SAAOJ,OAAP;AACH;;AAED,SAASG,aAAT,CAAuBhQ,EAAvB,EAA2ByN,MAA3B,EAAmChB,OAAnC,EAA4CiB,SAA5C,EAAuD;AACnD1N,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;;AAEA,WAASsO,WAAT,CAAqBR,MAArB,EAA6BnD,MAA7B,EAAqCqD,IAArC,EAA2C;AACvC,QAAIiB,QAAJ,EAAcC,SAAd;;AAEA,QAAG1Q,GAAG,CAAC2Q,YAAJ,CAAiBrB,MAAjB,CAAH,EAA6B;AACzB,UAAGE,IAAI,IAAI,CAAX,EAAc;AACV,YAAIoB,IAAI,GAAG,IAAItB,MAAM,CAACM,WAAX,CAAuB,CAAvB,CAAX;AACA,YAAIiB,IAAI,GAAGT,gBAAgB,CAACjE,MAAD,EAASmD,MAAT,CAA3B;;AAEA,YAAGE,IAAI,GAAG,CAAV,EAAa;AACTiB,UAAAA,QAAQ,GAAGI,IAAX;AACAH,UAAAA,SAAS,GAAGE,IAAZ;AACH,SAHD,MAGO;AACHH,UAAAA,QAAQ,GAAGG,IAAX;AACAF,UAAAA,SAAS,GAAGG,IAAZ;AACH;AACJ,OAXD,MAWO;AACHJ,QAAAA,QAAQ,GAAG,IAAInB,MAAM,CAACM,WAAX,CAAuBJ,IAAvB,CAAX;AACAkB,QAAAA,SAAS,GAAG,IAAIpB,MAAM,CAACM,WAAX,CAAuBN,MAAM,CAACrM,MAAP,GAAgBkJ,MAAM,CAAClJ,MAAvB,GAAgCuM,IAAvD,CAAZ;;AAEA,YAAGA,IAAI,KAAKrD,MAAM,CAAClJ,MAAnB,EAA2B;AACvBwN,UAAAA,QAAQ,CAACP,GAAT,CAAa/D,MAAb;AACAuE,UAAAA,SAAS,CAACR,GAAV,CAAcZ,MAAd;AACH,SAHD,MAGO,IAAGE,IAAI,GAAGrD,MAAM,CAAClJ,MAAjB,EAAyB;AAC5B,cAAI6N,uBAAuB,GAAG3E,MAAM,CAAClJ,MAAP,GAAgBuM,IAA9C;AAEAiB,UAAAA,QAAQ,CAACP,GAAT,CAAa/D,MAAM,CAAC4E,QAAP,CAAgB,CAAhB,EAAmBD,uBAAnB,CAAb;AACAJ,UAAAA,SAAS,CAACR,GAAV,CAAc/D,MAAM,CAAC4E,QAAP,CAAgBD,uBAAhB,CAAd;AACAJ,UAAAA,SAAS,CAACR,GAAV,CAAcZ,MAAd,EAAsBwB,uBAAtB;AACH,SANM,MAMA;AACH,cAAIE,uBAAuB,GAAGxB,IAAI,GAAGrD,MAAM,CAAClJ,MAA5C;AAEAwN,UAAAA,QAAQ,CAACP,GAAT,CAAa/D,MAAb;AACAsE,UAAAA,QAAQ,CAACP,GAAT,CAAaZ,MAAM,CAACyB,QAAP,CAAgB,CAAhB,EAAmBC,uBAAnB,CAAb,EAA0D7E,MAAM,CAAClJ,MAAjE;AACAyN,UAAAA,SAAS,CAACR,GAAV,CAAcZ,MAAM,CAACyB,QAAP,CAAgBC,uBAAhB,CAAd;AACH;AACJ;AACJ,KAjCD,MAiCO;AACHP,MAAAA,QAAQ,GAAGtE,MAAM,CAAC+E,MAAP,CAAc5B,MAAd,CAAX;AACAoB,MAAAA,SAAS,GAAIlB,IAAI,IAAI,CAAR,IAAaA,IAAI,GAAGiB,QAAQ,CAACxN,MAA9B,GACRwN,QAAQ,CAACU,MAAT,CAAgB3B,IAAhB,EAAsBiB,QAAQ,CAACxN,MAA/B,CADQ,GAER,EAFJ;AAGH;;AAED,WAAO,CAACwN,QAAD,EAAWC,SAAX,CAAP;AACH;;AAED,MAAIU,IAAI,GAAGvB,YAAY,CAACrO,EAAD,EAAKyN,MAAL,EAAahB,OAAb,EAAsBiB,SAAtB,EAAiCY,WAAjC,CAAvB;AACA,MAAIuB,OAAO,GAAG7O,OAAO,CAACoL,MAAR,CAAepM,EAAf,CAAd;AACA,MAAI8P,QAAQ,GAAG,CAAC9P,EAAD,EAAK4P,IAAI,CAACnC,MAAV,EAAkBhB,OAAlB,EAA2BmD,IAAI,CAAClC,SAAhC,CAAf;AACA/O,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcgB,OAAO,CAACgO,YAAtB,EAAoCc,QAApC,EAA8CE,aAA9C,EAA6DC,SAA7D;AAEA,SAAOJ,OAAP;AACH;AAED;;;;;;;;;;;AASA,SAASK,SAAT,CAAmBlQ,EAAnB,EAAuBsN,MAAvB,EAA+BF,UAA/B,EAA2C;AACvCpN,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AAEA,MAAImN,cAAc,GAAG,EAArB;AACA,MAAIgD,QAAQ,GAAGnP,OAAO,CAACoP,YAAvB;AACA,MAAIC,QAAQ,GAAGH,SAAf;AACA,MAAIJ,QAAQ,GAAG,CAAC9P,EAAD,EAAKmN,cAAL,CAAf;AACA,MAAImD,QAAQ,GAAG,CAACtQ,EAAD,EAAKsN,MAAL,CAAf,CAPuC,CAOT;;AAC9B,MAAItK,CAAJ;AACA,MAAI6M,OAAJ,CATuC,CAWvC;;AACAxC,EAAAA,kBAAkB,CAACrN,EAAD,EAAKsN,MAAL,EAAaF,UAAb,CAAlB,CAZuC,CAcvC;;AACA,MAAG,CAAC/L,KAAK,CAACC,OAAN,CAAcgM,MAAd,CAAJ,EAA2B;AACvBA,IAAAA,MAAM,GAAG,CAACA,MAAD,CAAT;AACH,GAjBsC,CAmBvC;;;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACiD,GAAP,CAAW,UAAStN,KAAT,EAAgB;AAChC,WAAOzE,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmBV,KAAnB,CAAP;AACH,GAFQ,CAAT;AAIAxD,EAAAA,OAAO,CAACiC,SAAR,CAAkB4L,MAAlB,EAxBuC,CA0BvC;;AACA,OAAItK,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsK,MAAM,CAAC7L,MAAtB,EAA8BuB,CAAC,EAA/B,EAAmC;AAC/BhD,IAAAA,EAAE,CAACC,IAAH,CAAQ0B,IAAR,CAAa2L,MAAM,CAACtK,CAAD,CAAnB;AACH,GA7BsC,CA+BvC;;;AACA,OAAIA,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsK,MAAM,CAAC7L,MAAtB,EAA8BuB,CAAC,EAA/B,EAAmC;AAC/BmK,IAAAA,cAAc,CAACxL,IAAf,CAAoB,CAAC2L,MAAM,CAAC7L,MAAR,GAAiBuB,CAArC;AACH,GAlCsC,CAoCvC;AACA;;;AACA,MAAG,OAAOoK,UAAP,KAAsB,WAAzB,EAAsC;AAClCyC,IAAAA,OAAO,GAAG7O,OAAO,CAACoL,MAAR,CAAepM,EAAf,CAAV;AACArB,IAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcmQ,QAAd,EAAwBL,QAAxB,EAAkCO,QAAlC,EAA4CC,QAA5C;AACA,WAAOT,OAAP;AACH,GA1CsC,CA4CvC;;;AACA,MAAG,CAACxO,KAAK,CAACC,OAAN,CAAc8L,UAAd,CAAJ,EAA+B;AAC3BA,IAAAA,UAAU,GAAG,CAACA,UAAD,CAAb;AACH;;AAED,MAAI;AACA;AACAF,IAAAA,mBAAmB,CAAClN,EAAD,EAAKmN,cAAL,EAAqBC,UAArB,CAAnB;AACH,GAHD,CAGE,OAAM1H,KAAN,EAAa;AACX;AACA1F,IAAAA,EAAE,CAACC,IAAH,CAAQ0P,MAAR,CAAe3P,EAAE,CAACC,IAAH,CAAQwB,MAAR,GAAiB6L,MAAM,CAAC7L,MAAvC,EAA+C6L,MAAM,CAAC7L,MAAtD;AACA,UAAMiE,KAAN;AACH,GAxDsC,CA0DvC;AACA;;;AACA/G,EAAAA,KAAK,CAAC6R,aAAN,CAAoBxQ,EAApB;AACArB,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcmQ,QAAd,EAAwBL,QAAxB,EAAkCO,QAAlC,EAA4CC,QAA5C;AACAT,EAAAA,OAAO,GAAG7O,OAAO,CAACyP,UAAR,CAAmBzQ,EAAnB,EAAuBmN,cAAvB,EAAuCC,UAAvC,CAAV;AACAzO,EAAAA,KAAK,CAAC+R,YAAN,CAAmB1Q,EAAnB;AACA,SAAO6P,OAAP;AACH;AAED;;;;;;;;;AAOA,SAASO,YAAT,CAAsBpQ,EAAtB,EAA0ByM,OAA1B,EAAmC;AAC/BzM,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AAEA,MAAIsN,MAAM,GAAG,EAAb;AACA,MAAI6C,QAAQ,GAAGnP,OAAO,CAACkP,SAAvB;AACA,MAAIG,QAAQ,GAAGD,YAAf;AACA,MAAIN,QAAQ,GAAG,CAAC9P,EAAD,EAAKsN,MAAL,EAAab,OAAb,CAAf;AACA,MAAI6D,QAAQ,GAAG,CAACtQ,EAAD,EAAKyM,OAAL,CAAf;AACA,MAAIzJ,CAAJ;AACA,MAAI2N,YAAJ,CAT+B,CAW/B;;AACA,MAAG,OAAOlE,OAAP,KAAmB,WAAtB,EAAmC;AAC/B,UAAM,IAAIJ,KAAJ,CAAU,kDAAV,CAAN;AACH,GAFD,MAEO,IAAG,CAAChL,KAAK,CAACC,OAAN,CAAcmL,OAAd,CAAJ,EAA4B;AAC/BA,IAAAA,OAAO,GAAG,CAACA,OAAD,CAAV;AACH;;AACDK,EAAAA,gBAAgB,CAAC9M,EAAD,EAAKyM,OAAL,EAAc,SAAd,CAAhB,CAjB+B,CAmB/B;;AACAA,EAAAA,OAAO,GAAGD,iBAAiB,CAACC,OAAD,EAAUzM,EAAE,CAACC,IAAH,CAAQwB,MAAR,GAAiB,CAA3B,CAA3B,CApB+B,CAsB/B;;AACAgL,EAAAA,OAAO,CAACmE,IAAR,CAAapS,GAAG,CAACqS,SAAjB;;AACA,OAAI7N,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyJ,OAAO,CAAChL,MAAvB,EAA+BuB,CAAC,IAAI,CAApC,EAAuC;AACnC2N,IAAAA,YAAY,GAAG3Q,EAAE,CAACC,IAAH,CAAQ0P,MAAR,CAAelD,OAAO,CAACzJ,CAAD,CAAtB,EAA2B,CAA3B,EAA8B,CAA9B,CAAf;AACAsK,IAAAA,MAAM,CAAC3L,IAAP,CAAYgP,YAAZ;AACH;;AAED,MAAId,OAAO,GAAG7O,OAAO,CAACoL,MAAR,CAAepM,EAAf,CAAd;AACArB,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcmQ,QAAd,EAAwBL,QAAxB,EAAkCO,QAAlC,EAA4CC,QAA5C;AAEA,SAAOT,OAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAASY,UAAT,CAAoBzQ,EAApB,EAAwBmN,cAAxB,EAAwCC,UAAxC,EAAoD;AAChDpN,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AAEA,MAAI8Q,OAAO,GAAG,EAAd;AACA,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIZ,QAAQ,GAAGM,UAAf;AACA,MAAIJ,QAAQ,GAAGI,UAAf;AACA,MAAIX,QAAQ,GAAG,CAAC9P,EAAD,EAAKoN,UAAL,EAAiBD,cAAjB,CAAf;AACA,MAAImD,QAAQ,GAAG,CAACtQ,EAAD,EAAKmN,cAAL,EAAqBC,UAArB,CAAf;AACA,MAAIpK,CAAJ,CATgD,CAWhD;AACA;;AACAkK,EAAAA,mBAAmB,CAAClN,EAAD,EAAKmN,cAAL,EAAqBC,UAArB,CAAnB,CAbgD,CAehD;;AACAD,EAAAA,cAAc,GAAG9L,KAAK,CAACC,OAAN,CAAc6L,cAAd,IAAgCA,cAAhC,GAAiD,CAACA,cAAD,CAAlE,CAhBgD,CAkBhD;;AACA,MAAG,OAAOC,UAAP,KAAsB,WAAzB,EAAsC;AAClCA,IAAAA,UAAU,GAAG,EAAb;;AACA,SAAIpK,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGmK,cAAc,CAAC1L,MAA9B,EAAsCuB,CAAC,EAAvC,EAA2C;AACvCoK,MAAAA,UAAU,CAACzL,IAAX,CAAgB,CAACwL,cAAc,CAAC1L,MAAhB,GAAyBuB,CAAzC;AACH;AACJ,GAxB+C,CA0BhD;;;AACAoK,EAAAA,UAAU,GAAG/L,KAAK,CAACC,OAAN,CAAc8L,UAAd,IAA4BA,UAA5B,GAAyC,CAACA,UAAD,CAAtD,CA3BgD,CA6BhD;;AACAD,EAAAA,cAAc,GAAGX,iBAAiB,CAACW,cAAD,EAAiBnN,EAAE,CAACC,IAAH,CAAQwB,MAAR,GAAiB,CAAlC,CAAlC;AACA2L,EAAAA,UAAU,GAAGZ,iBAAiB,CAACY,UAAD,EAAapN,EAAE,CAACC,IAAH,CAAQwB,MAAR,GAAiB,CAA9B,CAA9B,CA/BgD,CAiChD;AAEA;;AACA,OAAIuB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGhD,EAAE,CAACC,IAAH,CAAQwB,MAAvB,EAA+BuB,CAAC,EAAhC,EAAoC;AAChC;AACA,QAAGmK,cAAc,CAACF,OAAf,CAAuBjK,CAAvB,MAA8B,CAAC,CAAlC,EAAqC;AACjC8N,MAAAA,OAAO,CAACnP,IAAR,CAAa3B,EAAE,CAACC,IAAH,CAAQ+C,CAAR,CAAb;AACH;AACJ,GAzC+C,CA2ChD;;;AACA,OAAIA,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGmK,cAAc,CAAC1L,MAA9B,EAAsCuB,CAAC,EAAvC,EAA2C;AACvC+N,IAAAA,cAAc,CAACpP,IAAf,CAAoB;AAACqP,MAAAA,QAAQ,EAAE5D,UAAU,CAACpK,CAAD,CAArB;AAA0BC,MAAAA,KAAK,EAAEjD,EAAE,CAACC,IAAH,CAAQkN,cAAc,CAACnK,CAAD,CAAtB;AAAjC,KAApB;AACH,GA9C+C,CAgDhD;;;AACA+N,EAAAA,cAAc,CAACH,IAAf,CAAoB,UAASK,CAAT,EAAYC,CAAZ,EAAe;AAC/B,WAAOD,CAAC,CAACD,QAAF,GAAaE,CAAC,CAACF,QAAtB;AACH,GAFD,EAjDgD,CAqDhD;;AACA,OAAIhO,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG+N,cAAc,CAACtP,MAA9B,EAAsCuB,CAAC,IAAI,CAA3C,EAA8C;AAC1C8N,IAAAA,OAAO,CAACnB,MAAR,CAAeoB,cAAc,CAAC/N,CAAD,CAAd,CAAkBgO,QAAjC,EAA2C,CAA3C,EAA8CD,cAAc,CAAC/N,CAAD,CAAd,CAAkBC,KAAhE;AACH;;AAEDjD,EAAAA,EAAE,CAACC,IAAH,GAAU6Q,OAAV;AAEA,MAAIjB,OAAO,GAAG7O,OAAO,CAACoL,MAAR,CAAepM,EAAf,CAAd;AACArB,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcmQ,QAAd,EAAwBL,QAAxB,EAAkCO,QAAlC,EAA4CC,QAA5C;AAEA,SAAOT,OAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,SAASsB,OAAT,CAAiBnR,EAAjB,EAAqB2O,IAArB,EAA2ByC,GAA3B,EAAgCC,OAAhC,EAAyC;AACrCrR,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AACAP,EAAAA,OAAO,CAAC6R,iBAAR,CAA0BtR,EAA1B;AAEA,MAAIuR,IAAI,GAAG,EAAX;AACA,MAAG,OAAO5C,IAAP,KAAgB,QAAnB,EAA6B4C,IAAI,CAAC5C,IAAD,CAAJ,GAAayC,GAAb,CAA7B,KACK,IAAG5S,GAAG,CAAC+B,aAAJ,CAAkBoO,IAAlB,CAAH,EAA4B;AAC7B;AACA4C,IAAAA,IAAI,GAAG/S,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmBgL,IAAnB,CAAP;AACA,QAAG0C,OAAO,KAAKjI,SAAf,EAA0BiI,OAAO,GAAGD,GAAV;AAC7B,GAJI,MAIE;AACH5S,IAAAA,GAAG,CAACsC,IAAJ,CAAS,eAAT,EAA0B6N,IAA1B,EAAgCyC,GAAhC,EAAqCC,OAArC;AACA,WAAO1Q,OAAO,CAACC,MAAR,EAAP;AACH;AAED,MAAGoI,MAAM,CAACD,IAAP,CAAYwI,IAAZ,EAAkB9P,MAArB,EAA6BzB,EAAE,CAACwR,OAAH,GAAa,IAAb;AAE7B,MAAIlE,MAAM,GAAG7N,OAAO,CAACgS,kBAAR,CAA2BzR,EAA3B,EAA+BqR,OAA/B,CAAb;;AAEA,MAAIK,KAAK,GAAGC,QAAQ,CAAC3R,EAAD,EAAKuR,IAAL,EAAWjE,MAAX,CAApB;;AACA,MAAIsE,KAAK,GAAGF,KAAK,CAACE,KAAlB,CApBqC,CAsBrC;;AACA,MAAGA,KAAK,CAACC,IAAT,EAAe7R,EAAE,CAAC6C,QAAH,GAAcuG,SAAd;AACf,MAAGwI,KAAK,CAACE,cAAT,EAAyBrS,OAAO,CAACqS,cAAR,CAAuB9R,EAAvB,EAA2BsN,MAA3B,EAAmC,EAAnC,EAxBY,CA0BrC;;AACA,MAAIlG,GAAG,GAAG,EAAV;;AAEA,MAAGwK,KAAK,CAACG,UAAT,EAAqB;AACjB3K,IAAAA,GAAG,CAACzF,IAAJ,CAASX,OAAO,CAACjB,IAAjB;AACH,GAFD,MAEO;AACHqH,IAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAACiH,gBAAf,EADG,CAGH;AACA;;AACAjH,IAAAA,KAAK,CAACiD,cAAN,CAAqB/B,EAArB;;AAEA,QAAG4R,KAAK,CAACI,UAAT,EAAqB;AACjBlT,MAAAA,KAAK,CAACiE,UAAN,CAAiB/C,EAAjB;AACAiS,MAAAA,kBAAkB,CAAC7K,GAAD,CAAlB,CAFiB,CAIjB;AACA;AACA;AACA;AACA;AACH;;AAED,QAAGwK,KAAK,CAAChN,KAAT,EAAgBwC,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACwS,YAArB;AAChB,QAAGN,KAAK,CAACO,SAAT,EAAoB/K,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0S,WAArB;AAEpBhL,IAAAA,GAAG,CAACzF,IAAJ,CAASkG,aAAT;AACH;;AAEDT,EAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAAC0I,OAAf,EAAwB1I,KAAK,CAAC2I,MAA9B;AAEA9I,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EACImR,OADJ,EACa,CAACnR,EAAD,EAAK0R,KAAK,CAACW,MAAX,EAAmBX,KAAK,CAACpE,MAAzB,CADb,EAEI6D,OAFJ,EAEa,CAACnR,EAAD,EAAK0R,KAAK,CAACY,MAAX,EAAmBZ,KAAK,CAACpE,MAAzB,CAFb;AAKA,MAAI5F,QAAQ,GAAGlJ,GAAG,CAACmI,WAAJ,CAAgBS,GAAhB,EAAqBpH,EAArB,CAAf;AACA,MAAG,CAAC0H,QAAD,IAAa,CAACA,QAAQ,CAACC,IAA1B,EAAgCD,QAAQ,GAAG/G,OAAO,CAACiH,OAAR,EAAX;AAEhC,SAAOF,QAAQ,CAACC,IAAT,CAAc,YAAW;AAC5B3H,IAAAA,EAAE,CAAC+H,IAAH,CAAQ,gBAAR,EAA0B2J,KAAK,CAACa,SAAhC;AACA,WAAOvS,EAAP;AACH,GAHM,CAAP;AAIH,C,CAED;AACA;;;AACA,SAASwS,eAAT,CAAyBpB,GAAzB,EAA8B;AAC1B,MAAGA,GAAG,KAAKhI,SAAX,EAAsB,OAAO,IAAP;AACtB,SAAOgI,GAAP;AACH;AAED;;;;;;;AAKA,SAASqB,MAAT,CAAgBC,MAAhB,EAAwBC,WAAxB,EAAqC;AACjC,MAAG,CAACA,WAAJ,EAAiB,OAAOlU,cAAP;AAEjB,SAAO,UAASmU,SAAT,EAAoBlO,IAApB,EAA0BmO,MAA1B,EAAkC;AACrC,QAAIC,EAAE,GAAGrU,cAAc,CAACmU,SAAD,EAAYlO,IAAZ,CAAvB;AACA,QAAIqO,KAAK,GAAGD,EAAE,CAACpE,GAAf;;AACAoE,IAAAA,EAAE,CAACpE,GAAH,GAAS,UAAS0C,GAAT,EAAc;AACnB,UAAI4B,QAAQ,GAAG,CAACH,MAAM,IAAI,EAAX,IAAiBnO,IAAhC;AACAuO,MAAAA,YAAY,CAACD,QAAD,EAAWF,EAAE,CAAC5E,GAAH,EAAX,EAAqBkD,GAArB,EAA0BsB,MAA1B,CAAZ;AACAK,MAAAA,KAAK,CAAC3B,GAAD,CAAL;AACH,KAJD;;AAKA,WAAO0B,EAAP;AACH,GATD;AAUH;;AAED,SAASG,YAAT,CAAsBvO,IAAtB,EAA4B0M,GAA5B,EAAiC8B,MAAjC,EAAyCR,MAAzC,EAAiD;AAC7C,MAAGrR,KAAK,CAACC,OAAN,CAAc8P,GAAd,KAAsB/P,KAAK,CAACC,OAAN,CAAc4R,MAAd,CAAzB,EAAgD;AAC5C,QAAIC,QAAQ,GAAG9R,KAAK,CAACC,OAAN,CAAc8P,GAAd,IAAqBA,GAArB,GAA2B,EAA1C;AACA,QAAIgC,QAAQ,GAAG/R,KAAK,CAACC,OAAN,CAAc4R,MAAd,IAAwBA,MAAxB,GAAiC,EAAhD;AACA,QAAIG,MAAM,GAAGjO,IAAI,CAACkO,GAAL,CAASH,QAAQ,CAAC1R,MAAlB,EAA0B2R,QAAQ,CAAC3R,MAAnC,CAAb;;AACA,SAAI,IAAIuB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqQ,MAAnB,EAA2BrQ,CAAC,EAA5B,EAAgC;AAC5BiQ,MAAAA,YAAY,CAACvO,IAAI,GAAG,GAAP,GAAa1B,CAAb,GAAiB,GAAlB,EAAuBmQ,QAAQ,CAACnQ,CAAD,CAA/B,EAAoCoQ,QAAQ,CAACpQ,CAAD,CAA5C,EAAiD0P,MAAjD,CAAZ;AACH;AACJ,GAPD,MAOO,IAAGlU,GAAG,CAAC+B,aAAJ,CAAkB6Q,GAAlB,KAA0B5S,GAAG,CAAC+B,aAAJ,CAAkB2S,MAAlB,CAA7B,EAAwD;AAC3D,QAAIK,MAAM,GAAG/U,GAAG,CAAC+B,aAAJ,CAAkB6Q,GAAlB,IAAyBA,GAAzB,GAA+B,EAA5C;AACA,QAAIoC,MAAM,GAAGhV,GAAG,CAAC+B,aAAJ,CAAkB2S,MAAlB,IAA4BA,MAA5B,GAAqC,EAAlD;AACA,QAAIO,OAAO,GAAGjV,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmB4P,MAAnB,EAA2BC,MAA3B,CAAd;;AACA,SAAI,IAAIpP,GAAR,IAAeqP,OAAf,EAAwB;AACpBR,MAAAA,YAAY,CAACvO,IAAI,GAAG,GAAP,GAAaN,GAAd,EAAmBmP,MAAM,CAACnP,GAAD,CAAzB,EAAgCoP,MAAM,CAACpP,GAAD,CAAtC,EAA6CsO,MAA7C,CAAZ;AACH;AACJ,GAPM,MAOA,IAAGA,MAAM,CAAChO,IAAD,CAAN,KAAiB0E,SAApB,EAA+B;AAClCsJ,IAAAA,MAAM,CAAChO,IAAD,CAAN,GAAe8N,eAAe,CAACpB,GAAD,CAA9B;AACH;AACJ;AAED;;;;;;;;;;;;;;AAYA,SAASsC,mBAAT,CAA6Bd,SAA7B,EAAwCF,MAAxC,EAAgDrJ,KAAhD,EAAuD;AACnD,OAAI,IAAI3E,IAAR,IAAgB2E,KAAhB,EAAuB;AACnB,QAAIyJ,EAAE,GAAGrU,cAAc,CAACmU,SAAD,EAAYlO,IAAZ,CAAvB;AACAuO,IAAAA,YAAY,CAACvO,IAAD,EAAOoO,EAAE,CAAC5E,GAAH,EAAP,EAAiB7E,KAAK,CAAC3E,IAAD,CAAtB,EAA8BgO,MAA9B,CAAZ;AACH;AACJ;;AAED,SAASf,QAAT,CAAkB3R,EAAlB,EAAsBuR,IAAtB,EAA4BjE,MAA5B,EAAoC;AAChC,MAAItL,UAAU,GAAGhC,EAAE,CAACiC,WAApB;AACA,MAAImE,QAAQ,GAAGpG,EAAE,CAAC8C,SAAlB;AACA,MAAI7C,IAAI,GAAGD,EAAE,CAACC,IAAd;AACA,MAAI0S,WAAW,GAAG3Q,UAAU,CAAC2R,WAA7B;AACA,MAAIC,QAAQ,GAAGnB,MAAM,CAACzQ,UAAU,CAAC6R,OAAZ,EAAqBlB,WAArB,CAArB;AACA,MAAIJ,SAAS,GAAG/T,GAAG,CAACsV,aAAJ,CAAkB,EAAlB,EAAsBvC,IAAtB,CAAhB;AACA,MAAIvO,CAAJ;AAEA+Q,EAAAA,4BAA4B,CAACxC,IAAD,CAA5B,CATgC,CAWhC;;AACA,MAAIK,KAAK,GAAGjS,SAAS,CAACqU,UAAV,EAAZ,CAZgC,CAchC;AACA;;AACA,MAAI1B,MAAM,GAAG,EAAb;AACA,MAAID,MAAM,GAAG,EAAb;AACA,MAAI4B,MAAJ,CAlBgC,CAoBhC;;AACA,WAASC,EAAT,GAAc;AAAE,WAAO5G,MAAM,CAACiD,GAAP,CAAW,YAAW;AAAE,aAAOnH,SAAP;AAAmB,KAA3C,CAAP;AAAsD,GArBtC,CAuBhC;;;AACA,WAAS+K,WAAT,CAAqBC,IAArB,EAA2B;AACvB,QAAIC,MAAM,GAAGrV,IAAI,CAACsV,OAAL,CAAaF,IAAb,CAAb;AACA,QAAGH,MAAM,CAAChH,OAAP,CAAeoH,MAAf,MAA2B,CAAC,CAA/B,EAAkCJ,MAAM,CAACtS,IAAP,CAAY0S,MAAZ;AACrC;;AAED,WAASE,aAAT,CAAuBF,MAAvB,EAA+B;AAAE,WAAO,WAAWA,MAAX,GAAoB,YAA3B;AAA0C;;AAE3E,WAASG,SAAT,CAAmBH,MAAnB,EAA2B;AAAE,WAAO,WAAWA,MAAX,GAAoB,QAA3B;AAAsC;;AAEnE,WAASI,YAAT,CAAsBC,UAAtB,EAAkC;AAC9B;AACA;AACA,SAAI,IAAIzG,CAAC,GAAGyG,UAAZ,EAAwBzG,CAAC,GAAG7H,QAAQ,CAAC3E,MAArC,EAA6CwM,CAAC,EAA9C,EAAkD;AAC9C,UAAG7H,QAAQ,CAAC6H,CAAD,CAAR,CAAY0G,MAAZ,KAAuB1U,IAAI,CAACyU,UAAD,CAA9B,EAA4C,OAAOtO,QAAQ,CAAC6H,CAAD,CAAf;AAC/C,KAL6B,CAM9B;AACA;;AACH,GAzC+B,CA2ChC;AACA;AACA;AACA;AACA;;;AACA,WAAS2G,OAAT,CAAiBlQ,IAAjB,EAAuB0M,GAAvB,EAA4BpO,CAA5B,EAA+B;AAC3B,QAAG3B,KAAK,CAACC,OAAN,CAAcoD,IAAd,CAAH,EAAwB;AACpBA,MAAAA,IAAI,CAACmQ,OAAL,CAAa,UAAS5D,CAAT,EAAY;AAAE2D,QAAAA,OAAO,CAAC3D,CAAD,EAAIG,GAAJ,EAASpO,CAAT,CAAP;AAAqB,OAAhD;AACA;AACH,KAJ0B,CAK3B;;;AACA,QAAG0B,IAAI,IAAI6M,IAAR,IAAgB9R,OAAO,CAACqV,SAAR,CAAkBvD,IAAlB,EAAwB7M,IAAxB,CAAnB,EAAkD;AAElD,QAAIqQ,UAAJ;;AACA,QAAGrQ,IAAI,CAACsQ,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,QAAzB,EAAmC;AAC/BD,MAAAA,UAAU,GAAGnB,QAAQ,CAAC5T,EAAE,CAACE,MAAJ,EAAYwE,IAAI,CAACC,OAAL,CAAa,QAAb,EAAuB,EAAvB,CAAZ,CAArB;AACH,KAFD,MAEO;AACH,UAAIsQ,MAAM,GAAG3H,MAAM,CAACtK,CAAD,CAAnB;;AACA,UAAI0P,MAAM,GAAG1Q,UAAU,CAACkT,YAAX,CAAwBT,YAAY,CAACQ,MAAD,CAAZ,CAAqBE,UAArB,CAAgC5O,GAAxD,CAAb;;AACAwO,MAAAA,UAAU,GAAGtC,MAAM,CAACC,MAAD,EAASC,WAAT,CAAN,CAA4B1S,IAAI,CAACgV,MAAD,CAAhC,EAA0CvQ,IAA1C,CAAb;AACH;;AAED,QAAG,EAAEA,IAAI,IAAI2N,MAAV,CAAH,EAAsB;AAClBA,MAAAA,MAAM,CAAC3N,IAAD,CAAN,GAAewP,EAAE,EAAjB;AACH;;AACD,QAAG7B,MAAM,CAAC3N,IAAD,CAAN,CAAa1B,CAAb,MAAoBoG,SAAvB,EAAkC;AAC9BiJ,MAAAA,MAAM,CAAC3N,IAAD,CAAN,CAAa1B,CAAb,IAAkBwP,eAAe,CAACuC,UAAU,CAAC7G,GAAX,EAAD,CAAjC;AACH;;AACD,QAAGkD,GAAG,KAAKhI,SAAX,EAAsB;AAClB2L,MAAAA,UAAU,CAACrG,GAAX,CAAe0C,GAAf;AACH;AACJ;;AAED,WAASgE,OAAT,CAAiBC,OAAjB,EAA0B;AACtB,WAAO,UAASpH,CAAT,EAAY;AACf,aAAO7H,QAAQ,CAAC6H,CAAD,CAAR,CAAYoH,OAAZ,CAAP;AACH,KAFD;AAGH;;AAED,WAASC,SAAT,CAAmBD,OAAnB,EAA4B;AACxB,WAAO,UAASE,GAAT,EAActH,CAAd,EAAiB;AACpB,aAAOsH,GAAG,KAAK,KAAR,GAAgBnP,QAAQ,CAACkH,MAAM,CAACW,CAAD,CAAP,CAAR,CAAoBoH,OAApB,CAAhB,GAA+C,IAAtD;AACH,KAFD;AAGH,GAtF+B,CAwFhC;AACA;;;AACA,OAAI,IAAIG,EAAR,IAAcjE,IAAd,EAAoB;AAChB,QAAG9R,OAAO,CAACqV,SAAR,CAAkBvD,IAAlB,EAAwBiE,EAAxB,CAAH,EAAgC;AAC5B,YAAM,IAAInJ,KAAJ,CAAU,gBAAgBmJ,EAAhB,GAAqB,wCAA/B,CAAN;AACH;;AAED,QAAIC,EAAE,GAAGlE,IAAI,CAACiE,EAAD,CAAb;AACA,QAAIE,IAAJ;AACA,QAAIC,QAAJ;AACA,QAAIC,KAAJ;AACA,QAAIC,MAAJ;AACA,QAAI3C,MAAJ;AACA,QAAI4C,SAAJ,CAXgB,CAahB;AACA;AACA;AACA;;AACA,QAAGN,EAAE,KAAK,UAAP,IAAqBA,EAAE,KAAK,UAA/B,EAA2C;AACvCA,MAAAA,EAAE,GAAGA,EAAE,CAACO,MAAH,CAAUP,EAAE,CAAC/T,MAAH,GAAY,CAAtB,IAA2B,MAAhC;AACA,UAAGJ,KAAK,CAACC,OAAN,CAAcmU,EAAd,CAAH,EAAsBA,EAAE,GAAGA,EAAE,CAAClF,GAAH,CAAO+E,SAAS,CAACE,EAAD,CAAhB,CAAL,CAAtB,KACK,IAAGC,EAAE,KAAK,KAAV,EAAiBA,EAAE,GAAGnI,MAAM,CAACiD,GAAP,CAAW6E,OAAO,CAACI,EAAD,CAAlB,CAAL,CAAjB,KACAC,EAAE,GAAG,IAAL;AACR;;AAEDnD,IAAAA,MAAM,CAACkD,EAAD,CAAN,GAAaC,EAAb;;AAEA,QAAGD,EAAE,CAACR,MAAH,CAAU,CAAV,EAAa,CAAb,MAAoB,QAAvB,EAAiC;AAC7BY,MAAAA,KAAK,GAAGhC,QAAQ,CAAC5T,EAAE,CAACE,MAAJ,EAAYsV,EAAE,CAAC7Q,OAAH,CAAW,QAAX,EAAqB,EAArB,CAAZ,CAAhB;AACA0N,MAAAA,MAAM,CAACmD,EAAD,CAAN,GAAa,CAAChD,eAAe,CAACoD,KAAK,CAAC1H,GAAN,EAAD,CAAhB,CAAb,CAF6B,CAG7B;AACA;;AACA0H,MAAAA,KAAK,CAAClH,GAAN,CAAUrN,KAAK,CAACC,OAAN,CAAcmU,EAAd,IAAoBA,EAAE,CAAC,CAAD,CAAtB,GAA4BA,EAAtC,EAL6B,CAM7B;AACA;;AACA7D,MAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACA;AACH,KApCe,CAsChB;;;AACAQ,IAAAA,MAAM,CAACmD,EAAD,CAAN,GAAatB,EAAE,EAAf;;AACA,SAAIlR,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsK,MAAM,CAAC7L,MAAtB,EAA8BuB,CAAC,EAA/B,EAAmC;AAC/B0S,MAAAA,IAAI,GAAGzV,IAAI,CAACqN,MAAM,CAACtK,CAAD,CAAP,CAAX;AACA2S,MAAAA,QAAQ,GAAGlB,YAAY,CAACnH,MAAM,CAACtK,CAAD,CAAP,CAAvB;AACA,UAAI0P,MAAM,GAAG1Q,UAAU,CAACkT,YAAX,CAAwBS,QAAQ,CAACR,UAAT,CAAoB5O,GAA5C,CAAb;AACAqP,MAAAA,KAAK,GAAGnD,MAAM,CAACC,MAAD,EAASC,WAAT,CAAN,CAA4B+C,IAA5B,EAAkCF,EAAlC,CAAR;AACAK,MAAAA,MAAM,GAAGD,KAAK,CAAC1H,GAAN,EAAT;AACAgF,MAAAA,MAAM,GAAG7R,KAAK,CAACC,OAAN,CAAcmU,EAAd,IAAoBA,EAAE,CAACzS,CAAC,GAAGyS,EAAE,CAAChU,MAAR,CAAtB,GAAwCgU,EAAjD;AAEA,UAAGvC,MAAM,KAAK9J,SAAd,EAAyB;AAEzB,UAAI4M,SAAS,GAAGJ,KAAK,CAACnL,KAAN,CAAYmL,KAAK,CAACnL,KAAN,CAAYhJ,MAAZ,GAAqB,CAAjC,CAAhB;AACA,UAAIoR,MAAM,GAAG2C,EAAE,CAACR,MAAH,CAAU,CAAV,EAAaQ,EAAE,CAAC/T,MAAH,GAAYuU,SAAS,CAACvU,MAAtB,GAA+B,CAA5C,CAAb;AACA,UAAIwU,SAAS,GAAGpD,MAAM,GAAGA,MAAM,GAAG,GAAZ,GAAkB,EAAxC;AACA,UAAIqD,aAAa,GAAGrD,MAAM,GACtBpU,cAAc,CAACkX,QAAD,EAAW9C,MAAX,CAAd,CAAiC3E,GAAjC,EADsB,GACmByH,QAD7C;AAGAG,MAAAA,SAAS,GAAGjX,UAAU,CAACsX,iBAAX,CAA6BR,QAA7B,EAAuCC,KAAK,CAACnL,KAA7C,CAAZ;;AAEA,UAAGqL,SAAS,IAAIA,SAAS,CAACM,YAAvB,IAAuClD,MAAM,KAAK,IAArD,EAA2D;AACvD,aAAI,IAAImD,UAAR,IAAsBP,SAAS,CAACM,YAAhC,EAA8C;AAC1CxB,UAAAA,OAAO,CAACpW,GAAG,CAAC8X,YAAJ,CAAiBd,EAAjB,EAAqBa,UAArB,CAAD,EAAmCP,SAAS,CAACM,YAAV,CAAuBC,UAAvB,CAAnC,EAAuErT,CAAvE,CAAP;AACH;AACJ,OAJD,MAIO,IAAG,CAACgT,SAAS,KAAK,eAAd,IAAiCA,SAAS,KAAK,SAAhD,KACFH,MAAM,KAAK3C,MADT,KAEDA,MAAM,KAAK,UAAX,IAAyBA,MAAM,KAAK,QAFnC,KAGFgD,aAHD,EAIL;AACE;AACA;AACA;AACA;AACA;AAEA,YAAIK,EAAE,GAAGvU,UAAU,CAAC4B,KAApB;AACA,YAAI4S,MAAM,GAAGN,aAAa,CAACM,MAA3B;AACA,YAAIC,WAAW,GAAID,MAAM,KAAK,KAAZ,IAAuBA,MAAM,KAAK,QAApD;;AACA,YAAGR,SAAS,KAAK,eAAjB,EAAkC;AAC9B,cAAIU,SAAS,GAAGD,WAAW,GAAGF,EAAE,CAACI,CAAN,GAAUJ,EAAE,CAACK,CAAxC;AACAhC,UAAAA,OAAO,CAACqB,SAAS,GAAG,WAAb,EAA0BC,aAAa,CAACW,SAAd,IAC5B3D,MAAM,KAAK,UAAX,GAAwB,IAAIwD,SAA5B,GAAwCA,SADZ,CAA1B,EACkD1T,CADlD,CAAP;AAEH,SAJD,MAIO;AACH,cAAI8T,OAAO,GAAGL,WAAW,GAAGF,EAAE,CAACK,CAAN,GAAUL,EAAE,CAACI,CAAtC;AACA/B,UAAAA,OAAO,CAACqB,SAAS,GAAG,KAAb,EAAoBC,aAAa,CAACa,GAAd,IACtB7D,MAAM,KAAK,UAAX,GAAwB,IAAI4D,OAA5B,GAAsCA,OADhB,CAApB,EAC8C9T,CAD9C,CAAP;AAEH;AACJ,OAvBM,MAuBA,IAAGwS,EAAE,KAAK,MAAP,KACLtC,MAAM,KAAK,KAAZ,MAAwB2C,MAAM,KAAK,KAAnC,KACC3C,MAAM,KAAK,YAAZ,MAA+B2C,MAAM,KAAK,YAA1C,CAFM,CAAH,EAGJ;AACC,YAAImB,QAAQ,GAAG,GAAf;AACA,YAAIC,QAAQ,GAAG,GAAf;;AACA,YAAG,CAAC/D,MAAM,KAAK,KAAX,IAAoB2C,MAAM,KAAK,KAAhC,KAA0CH,IAAI,CAAC7P,WAAL,KAAqB,GAAlE,EAAuE;AACnEmR,UAAAA,QAAQ,GAAG,GAAX;AACAC,UAAAA,QAAQ,GAAG,GAAX;AACH;;AACDzY,QAAAA,GAAG,CAAC0Y,SAAJ,CAAcxB,IAAd,EAAoB,CAAC,GAAD,EAAM,MAAN,CAApB,EAAmC,QAAnC,EAA6CsB,QAA7C;AACAxY,QAAAA,GAAG,CAAC0Y,SAAJ,CAAcxB,IAAd,EAAoB,CAAC,IAAD,EAAO,IAAP,CAApB,EAAkC,OAAlC,EAA2CsB,QAA3C;AACAxY,QAAAA,GAAG,CAAC0Y,SAAJ,CAAcxB,IAAd,EAAoB,CAAC,GAAD,EAAM,MAAN,CAApB,EAAmC,QAAnC,EAA6CuB,QAA7C;;AAEA,YAAGpB,MAAM,KAAK,KAAX,IAAoBA,MAAM,KAAK,YAAlC,EAAgD;AAC5CpX,UAAAA,cAAc,CAACiX,IAAD,EAAO,cAAP,CAAd,CACKhH,GADL,CACSjQ,cAAc,CAACiX,IAAD,EAAO,eAAP,CAAd,CAAsCxH,GAAtC,EADT,EAD4C,CAI5C;;AACAlM,UAAAA,UAAU,CAACmV,SAAX,CAAqBhT,SAArB,CAA+B,SAA/B,EAA0CiT,MAA1C;AACH,SAND,MAMO,IAAGxY,QAAQ,CAACyY,OAAT,CAAiB3B,IAAjB,EAAuB,WAAvB,CAAH,EAAwC;AAC3CjX,UAAAA,cAAc,CAACiX,IAAD,EAAO,eAAP,CAAd,CACKhH,GADL,CACSjQ,cAAc,CAACiX,IAAD,EAAO,cAAP,CAAd,CAAqCxH,GAArC,EADT;AAEH;AACJ;;AAEDmE,MAAAA,MAAM,CAACmD,EAAD,CAAN,CAAWxS,CAAX,IAAgBwP,eAAe,CAACqD,MAAD,CAA/B,CAvE+B,CAwE/B;AACA;;AACA,UAAIqB,SAAS,GAAG,CACZ,QADY,EACF,YADE,EACY,aADZ,EAC2B,iBAD3B,CAAhB;;AAGA,UAAGA,SAAS,CAACjK,OAAV,CAAkBuI,EAAlB,MAA0B,CAAC,CAA9B,EAAiC;AAC7B;AACA;AACA,YAAGA,EAAE,KAAK,aAAV,EAAyB;AACrBI,UAAAA,KAAK,CAAClH,GAAN,CAAUwE,MAAV,EADqB,CAErB;AACA;AACA;;AACA,cAAIoE,kBAAkB,GAAI5B,IAAI,CAAC6B,CAAL,IAAU,CAAC7B,IAAI,CAAC8B,CAAjB,GAAsB,GAAtB,GAA4B,GAArD;;AACA,cAAG,CAAC5B,KAAK,CAAC1H,GAAN,MAAeoJ,kBAAhB,MAAwC3B,QAAQ,CAAC9P,WAApD,EAAiE;AAC7D;AACH;AACJ,SATD,MASO,IAAG2P,EAAE,KAAK,iBAAV,EAA6B;AAChC;AACA;AAEAE,UAAAA,IAAI,CAAC7P,WAAL,GACI;AAAC4R,YAAAA,CAAC,EAAE,GAAJ;AAASd,YAAAA,CAAC,EAAE;AAAZ,YAAiBhB,QAAQ,CAAC9P,WAA1B,CADJ;AAEH;;AACDpG,QAAAA,OAAO,CAACiY,UAAR,CAAmBhC,IAAnB;AACA9D,QAAAA,KAAK,CAACC,IAAN,GAAaD,KAAK,CAACE,cAAN,GAAuB,IAApC;AACH,OArBD,MAqBO,IAAGhT,KAAK,CAAC6Y,mBAAN,CAA0B1K,OAA1B,CAAkC2I,KAAK,CAACnL,KAAN,CAAY,CAAZ,CAAlC,MAAsD,CAAC,CAA1D,EAA6D;AAChE;AACAhL,QAAAA,OAAO,CAACmY,qBAAR,CAA8BhC,KAA9B,EAAqC1C,MAArC,EAA6Cb,MAA7C;AACAT,QAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACH,OAJM,MAIA;AACH,YAAGiE,SAAH,EAAc;AACV;AACA;AACA,cAAGA,SAAS,CAAC+B,OAAV,IACC,CAACjZ,QAAQ,CAACyY,OAAT,CAAiB1B,QAAjB,EAA2B,MAA3B,CADF,KAEEnX,GAAG,CAAC2P,mBAAJ,CAAwB+E,MAAxB,KAAmC1U,GAAG,CAAC2P,mBAAJ,CAAwB0H,MAAxB,CAFrC,CAAH,EAGE;AACEjE,YAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACH,WALD,MAKOlS,SAAS,CAAC8N,MAAV,CAAiBmE,KAAjB,EAAwBkE,SAAxB;AACV,SATD,MASO;AACH;;;;;;AAMAlE,UAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACH,SAlBE,CAoBH;;;AACA+D,QAAAA,KAAK,CAAClH,GAAN,CAAUwE,MAAV;AACH;AACJ,KArKe,CAuKhB;;;AACA,QAAG,CAAC,YAAD,EAAe,iBAAf,EAAkCjG,OAAlC,CAA0CuI,EAA1C,MAAkD,CAAC,CAAtD,EAAyD;AACrDxW,MAAAA,IAAI,CAAC8Y,IAAL,CAAU9X,EAAV,EAAcsN,MAAd;AACH,KA1Ke,CA4KhB;;;AACA,QAAGkI,EAAE,KAAK,iBAAV,EAA6B;AACzB,UAAIuC,SAAS,GAAGtZ,cAAc,CAACuB,EAAE,CAACE,MAAJ,EAAY,WAAZ,CAA9B;;AACA,UAAG6X,SAAS,CAAC7J,GAAV,OAAoB,GAAvB,EAA4B;AACxB6J,QAAAA,SAAS,CAACrJ,GAAV,CAAc,GAAd;AACH,OAFD,MAEO,IAAGqJ,SAAS,CAAC7J,GAAV,OAAoB,GAAvB,EAA4B;AAC/B6J,QAAAA,SAAS,CAACrJ,GAAV,CAAc,GAAd;AACH;AACJ,KApLe,CAsLhB;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAG,CAAC,aAAD,EAAgB,MAAhB,EAAwBzB,OAAxB,CAAgCuI,EAAhC,MAAwC,CAAC,CAA5C,EAA+C;AAC3CvB,MAAAA,MAAM,GAAG,EAAT;;AACA,WAAIjR,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsK,MAAM,CAAC7L,MAAtB,EAA8BuB,CAAC,EAA/B,EAAmC;AAC/B,YAAIC,KAAK,GAAGhD,IAAI,CAACqN,MAAM,CAACtK,CAAD,CAAP,CAAhB;;AAEA,YAAGpE,QAAQ,CAACyY,OAAT,CAAiBpU,KAAjB,EAAwB,WAAxB,CAAH,EAAyC;AACrCkR,UAAAA,WAAW,CAAClR,KAAK,CAAC+U,KAAN,IAAe,GAAhB,CAAX;AACA7D,UAAAA,WAAW,CAAClR,KAAK,CAACgV,KAAN,IAAe,GAAhB,CAAX;AACH;AACJ;;AAEDrD,MAAAA,OAAO,CAACX,MAAM,CAAC1D,GAAP,CAAWgE,aAAX,CAAD,EAA4B,IAA5B,EAAkC,CAAlC,CAAP;AACAK,MAAAA,OAAO,CAACX,MAAM,CAAC1D,GAAP,CAAWiE,SAAX,CAAD,EAAwB,CAAC,CAAD,EAAI,CAAJ,CAAxB,EAAgC,CAAhC,CAAP;AACH;AACJ;;AAED,MAAG5C,KAAK,CAACC,IAAN,IAAcD,KAAK,CAAC7R,IAAvB,EAA6B;AACzB6R,IAAAA,KAAK,CAACG,UAAN,GAAmB,IAAnB;AACH;;AAED,SAAO;AACHH,IAAAA,KAAK,EAAEA,KADJ;AAEHS,IAAAA,MAAM,EAAEA,MAFL;AAGHC,IAAAA,MAAM,EAAEA,MAHL;AAIHhF,IAAAA,MAAM,EAAEA,MAJL;AAKHiF,IAAAA,SAAS,EAAE/T,GAAG,CAAC0Z,kBAAJ,CAAuB,EAAvB,EAA2B,CAAC3F,SAAD,EAAYjF,MAAZ,CAA3B;AALR,GAAP;AAOH;AAED;;;;;;;;;;;;;;;AAaA,SAASyG,4BAAT,CAAsCxC,IAAtC,EAA4C;AACxC,MAAI4G,iBAAiB,GAAG3Z,GAAG,CAAC4Z,YAAJ,CAAiB,MAAjB,EAAyB,SAAzB,EAAoC,KAApC,EAA2C,KAA3C,CAAxB;AACA,MAAIC,aAAa,GAAG,kBAApB;AACA,MAAItP,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYwI,IAAZ,CAAX;AACA,MAAIvO,CAAJ,EAAOoB,GAAP,EAAYmJ,KAAZ;;AAEA,OAAIvK,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG+F,IAAI,CAACtH,MAApB,EAA4BuB,CAAC,EAA7B,EAAiC;AAC7BoB,IAAAA,GAAG,GAAG2E,IAAI,CAAC/F,CAAD,CAAV;AACAuK,IAAAA,KAAK,GAAGgE,IAAI,CAACnN,GAAD,CAAZ;;AAEA,QAAG,CAACA,GAAG,KAAK,OAAR,IAAmB+T,iBAAiB,CAACG,IAAlB,CAAuBlU,GAAvB,CAAnB,IAAkDiU,aAAa,CAACC,IAAd,CAAmBlU,GAAnB,CAAnD,MACA,OAAOmJ,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAD9C,CAAH,EAC4D;AACxD5I,MAAAA,OAAO,CAACP,GAAD,EAAMA,GAAG,CAACO,OAAJ,CAAY,OAAZ,EAAqB,YAArB,CAAN,CAAP;AACH,KAHD,MAGO,IAAGP,GAAG,CAAC6I,OAAJ,CAAY,WAAZ,IAA2B,CAAC,CAA/B,EAAkC;AACrCtI,MAAAA,OAAO,CAACP,GAAD,EAAMA,GAAG,CAACO,OAAJ,CAAY,WAAZ,EAAyB,YAAzB,CAAN,CAAP;AACH,KAFM,MAEA,IAAGP,GAAG,CAAC6I,OAAJ,CAAY,eAAZ,IAA+B,CAAC,CAAnC,EAAsC;AACzCtI,MAAAA,OAAO,CAACP,GAAD,EAAMA,GAAG,CAACO,OAAJ,CAAY,eAAZ,EAA6B,gBAA7B,CAAN,CAAP;AACH,KAFM,MAEA,IAAGP,GAAG,CAAC6I,OAAJ,CAAY,WAAZ,IAA2B,CAAC,CAA/B,EAAkC;AACrCtI,MAAAA,OAAO,CAACP,GAAD,EAAMA,GAAG,CAACO,OAAJ,CAAY,WAAZ,EAAyB,YAAzB,CAAN,CAAP;AACH,KAFM,MAEA,IAAGP,GAAG,CAAC6I,OAAJ,CAAY,aAAZ,IAA6B,CAAC,CAAjC,EAAoC;AACvCtI,MAAAA,OAAO,CAACP,GAAD,EAAMA,GAAG,CAACO,OAAJ,CAAY,aAAZ,EAA2B,cAA3B,CAAN,CAAP;AACH;AACJ;;AAED,WAASA,OAAT,CAAiB4T,UAAjB,EAA6BC,UAA7B,EAAyC;AACrCjH,IAAAA,IAAI,CAACiH,UAAD,CAAJ,GAAmBjH,IAAI,CAACgH,UAAD,CAAvB;AACA,WAAOhH,IAAI,CAACgH,UAAD,CAAX;AACH;AACJ;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAASE,QAAT,CAAkBzY,EAAlB,EAAsB2O,IAAtB,EAA4ByC,GAA5B,EAAiC;AAC7BpR,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AACAP,EAAAA,OAAO,CAAC6R,iBAAR,CAA0BtR,EAA1B;;AAEA,MAAGA,EAAE,CAACyC,SAAH,IAAgBzC,EAAE,CAACyC,SAAH,CAAaiW,OAAhC,EAAyC;AACrC,WAAO/X,OAAO,CAACiH,OAAR,CAAgB5H,EAAhB,CAAP;AACH;;AAED,MAAIuR,IAAI,GAAG,EAAX;;AACA,MAAG,OAAO5C,IAAP,KAAgB,QAAnB,EAA6B;AACzB4C,IAAAA,IAAI,CAAC5C,IAAD,CAAJ,GAAayC,GAAb;AACH,GAFD,MAEO,IAAG5S,GAAG,CAAC+B,aAAJ,CAAkBoO,IAAlB,CAAH,EAA4B;AAC/B4C,IAAAA,IAAI,GAAG/S,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmBgL,IAAnB,CAAP;AACH,GAFM,MAEA;AACHnQ,IAAAA,GAAG,CAACsC,IAAJ,CAAS,gBAAT,EAA2B6N,IAA3B,EAAiCyC,GAAjC;AACA,WAAOzQ,OAAO,CAACC,MAAR,EAAP;AACH;;AAED,MAAGoI,MAAM,CAACD,IAAP,CAAYwI,IAAZ,EAAkB9P,MAArB,EAA6BzB,EAAE,CAACwR,OAAH,GAAa,IAAb;;AAE7B,MAAIE,KAAK,GAAGiH,SAAS,CAAC3Y,EAAD,EAAKuR,IAAL,CAArB;;AACA,MAAIK,KAAK,GAAGF,KAAK,CAACE,KAAlB,CArB6B,CAuB7B;;AACA,MAAGA,KAAK,CAACC,IAAT,EAAe7R,EAAE,CAAC6C,QAAH,GAAcuG,SAAd,CAxBc,CA0B7B;AAEA;AACA;AACA;;AACA,MAAIhC,GAAG,GAAG,CAACtI,KAAK,CAACiH,gBAAP,CAAV;;AAEA,MAAG6L,KAAK,CAACgH,YAAT,EAAuB;AACnBxR,IAAAA,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACkZ,YAArB;AACH,GAFD,MAEO,IAAG5P,MAAM,CAACD,IAAP,CAAYwI,IAAZ,EAAkB9P,MAArB,EAA6B;AAChCoX,IAAAA,2BAA2B,CAAC7Y,EAAD,EAAK4R,KAAL,EAAYF,KAAZ,CAA3B,IAAiD5S,KAAK,CAACiD,cAAN,CAAqB/B,EAArB,CAAjD;AAEA,QAAG4R,KAAK,CAACkH,MAAT,EAAiB1R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACqZ,QAArB;AACjB,QAAGnH,KAAK,CAACoH,WAAT,EAAsB5R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACkH,YAArB;AACtB,QAAGgL,KAAK,CAACqH,OAAT,EAAkBhH,kBAAkB,CAAC7K,GAAD,EAAMsK,KAAK,CAACwH,aAAZ,CAAlB;AAClB,QAAGtH,KAAK,CAACuH,KAAT,EAAgB/R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0Z,eAArB;AAChB,QAAGxH,KAAK,CAAChM,OAAT,EAAkBwB,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC2Z,SAArB;AAClB,QAAGzH,KAAK,CAAC0H,MAAT,EAAiBlS,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC6Z,QAArB;AACjB,QAAG3H,KAAK,CAACO,SAAT,EAAoB/K,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0S,WAArB;AAEpBhL,IAAAA,GAAG,CAACzF,IAAJ,CAASkG,aAAT;AACH;;AAEDT,EAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAAC0I,OAAf,EAAwB1I,KAAK,CAAC2I,MAA9B;AAEA9I,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EACIyY,QADJ,EACc,CAACzY,EAAD,EAAK0R,KAAK,CAACW,MAAX,CADd,EAEIoG,QAFJ,EAEc,CAACzY,EAAD,EAAK0R,KAAK,CAACY,MAAX,CAFd;AAKA,MAAI5K,QAAQ,GAAGlJ,GAAG,CAACmI,WAAJ,CAAgBS,GAAhB,EAAqBpH,EAArB,CAAf;AACA,MAAG,CAAC0H,QAAD,IAAa,CAACA,QAAQ,CAACC,IAA1B,EAAgCD,QAAQ,GAAG/G,OAAO,CAACiH,OAAR,CAAgB5H,EAAhB,CAAX;AAEhC,SAAO0H,QAAQ,CAACC,IAAT,CAAc,YAAW;AAC5B3H,IAAAA,EAAE,CAAC+H,IAAH,CAAQ,iBAAR,EAA2B2J,KAAK,CAACa,SAAjC;AACA,WAAOvS,EAAP;AACH,GAHM,CAAP;AAIH,C,CAED;AACA;;;AACA,SAAS6Y,2BAAT,CAAqC7Y,EAArC,EAAyC4R,KAAzC,EAAgDF,KAAhD,EAAuD;AACnD,MAAI1P,UAAU,GAAGhC,EAAE,CAACiC,WAApB;AAEA,MAAG,CAAC2P,KAAK,CAACqH,OAAV,EAAmB,OAAO,KAAP;;AAEnB,OAAI,IAAIO,CAAR,IAAa5H,KAAb,EAAoB;AAChB,QAAG4H,CAAC,KAAK,SAAN,IAAmB5H,KAAK,CAAC4H,CAAD,CAA3B,EAAgC,OAAO,KAAP;AACnC;;AAED,OAAI,IAAIC,IAAR,IAAgB/H,KAAK,CAACwH,aAAtB,EAAqC;AACjC,QAAI7E,MAAM,GAAGrV,IAAI,CAACsV,OAAL,CAAamF,IAAb,CAAb;AACA,QAAIC,IAAI,GAAG1Z,EAAE,CAACE,MAAH,CAAUmU,MAAV,CAAX;AACA,QAAIsF,KAAK,GAAG3X,UAAU,CAACqS,MAAD,CAAtB;AACAsF,IAAAA,KAAK,CAACC,SAAN,GAAkBF,IAAI,CAACE,SAAvB;AACAD,IAAAA,KAAK,CAACE,KAAN,GAAcH,IAAI,CAACG,KAAL,CAAWC,KAAX,EAAd;AACAH,IAAAA,KAAK,CAACI,UAAN;;AAEA,QAAGJ,KAAK,CAACK,WAAT,EAAsB;AAClB,WAAI,IAAIC,KAAR,IAAiBN,KAAK,CAACK,WAAvB,EAAoC;AAChC,YAAGC,KAAK,KAAKR,IAAb,EAAmB;AACf,cAAIS,GAAG,GAAGlY,UAAU,CAAChD,IAAI,CAACsV,OAAL,CAAa2F,KAAb,CAAD,CAApB;AACAC,UAAAA,GAAG,CAACN,SAAJ,GAAgBD,KAAK,CAACC,SAAtB;AACAM,UAAAA,GAAG,CAACL,KAAJ,GAAYF,KAAK,CAACE,KAAN,CAAYC,KAAZ,EAAZ;AACAI,UAAAA,GAAG,CAACvF,MAAJ,CAAWkF,KAAX,GAAmBF,KAAK,CAACE,KAAN,CAAYC,KAAZ,EAAnB;AACH;AACJ;AACJ;AACJ;;AAED,SAAO,IAAP;AACH;;AAED,SAAS7H,kBAAT,CAA4B7K,GAA5B,EAAiC8R,aAAjC,EAAgD;AAC5C;AACA;AACA;AACA,MAAIhS,QAAQ,GAAGgS,aAAa,GACxB,UAASlZ,EAAT,EAAa;AACT,QAAIma,KAAK,GAAG,EAAZ;AACA,QAAIC,SAAS,GAAG,IAAhB;;AAEA,SAAI,IAAIC,EAAR,IAAcnB,aAAd,EAA6B;AACzB,UAAIoB,EAAE,GAAGtb,IAAI,CAACub,SAAL,CAAeva,EAAf,EAAmBqa,EAAnB,CAAT;AACAF,MAAAA,KAAK,CAACxY,IAAN,CAAW0Y,EAAX;;AAEA,UAAGC,EAAE,CAACN,WAAN,EAAmB;AACf,aAAI,IAAIQ,GAAR,IAAeF,EAAE,CAACN,WAAlB,EAA+B;AAC3B,cAAG,CAACd,aAAa,CAACsB,GAAD,CAAjB,EAAwB;AACpBL,YAAAA,KAAK,CAACxY,IAAN,CAAW6Y,GAAX;AACH;AACJ;AACJ;;AAED,UAAGF,EAAE,CAAChU,UAAN,EAAkB8T,SAAS,GAAG,KAAZ;AACrB;;AAED,WAAOpb,IAAI,CAACmI,IAAL,CAAUnH,EAAV,EAAcma,KAAd,EAAqB;AAACC,MAAAA,SAAS,EAAEA;AAAZ,KAArB,CAAP;AACH,GArBuB,GAsBxB,UAASpa,EAAT,EAAa;AACT,WAAOhB,IAAI,CAACmI,IAAL,CAAUnH,EAAV,EAAc,QAAd,CAAP;AACH,GAxBL;AA0BAoH,EAAAA,GAAG,CAACzF,IAAJ,CACIrC,WADJ,EAEII,WAAW,CAACoH,yBAFhB,EAGII,QAHJ,EAIIxH,WAAW,CAAC2H,QAJhB,EAKI3H,WAAW,CAAC4H,SALhB;AAOH;;AAED,IAAImT,WAAW,GAAG,sCAAlB;AACA,IAAIC,eAAe,GAAG,8BAAtB;AACA,IAAIC,YAAY,GAAG,uCAAnB;;AAEA,SAAShC,SAAT,CAAmB3Y,EAAnB,EAAuBuR,IAAvB,EAA6B;AACzB,MAAIrR,MAAM,GAAGF,EAAE,CAACE,MAAhB;AACA,MAAI8B,UAAU,GAAGhC,EAAE,CAACiC,WAApB;AACA,MAAI0Q,WAAW,GAAG3Q,UAAU,CAAC2R,WAA7B;AACA,MAAIC,QAAQ,GAAGnB,MAAM,CAACzQ,UAAU,CAAC6R,OAAZ,EAAqBlB,WAArB,CAArB;AACA,MAAI5J,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYwI,IAAZ,CAAX;AACA,MAAIqJ,IAAI,GAAG5b,IAAI,CAAC6b,IAAL,CAAU7a,EAAV,CAAX;AACA,MAAIuS,SAAS,GAAG/T,GAAG,CAACsV,aAAJ,CAAkB,EAAlB,EAAsBvC,IAAtB,CAAhB;AACA,MAAIuJ,UAAU,GAAG,EAAjB;AAEA,MAAIC,QAAJ,EAAc/X,CAAd,EAAiBiL,CAAjB;AAEA8F,EAAAA,4BAA4B,CAACxC,IAAD,CAA5B;AACAxI,EAAAA,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYwI,IAAZ,CAAP,CAbyB,CAezB;AACA;;AACA,OAAIvO,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG+F,IAAI,CAACtH,MAApB,EAA4BuB,CAAC,EAA7B,EAAiC;AAC7B,QAAG+F,IAAI,CAAC/F,CAAD,CAAJ,CAAQiK,OAAR,CAAgB,SAAhB,MAA+B,CAAlC,EAAqC;AACjC,WAAIgB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG2M,IAAI,CAACnZ,MAApB,EAA4BwM,CAAC,EAA7B,EAAiC;AAC7B,YAAI+M,KAAK,GAAGJ,IAAI,CAAC3M,CAAD,CAAJ,CAAQgN,GAAR,CAAYjG,MAAZ,CAAmB,CAAnB,CAAZ;;AACA,YAAIkG,QAAQ,GAAIF,KAAK,CAAC/N,OAAN,CAAc,OAAd,MAA2B,CAAC,CAA7B,GAAmC+N,KAAK,GAAG,GAA3C,GAAkD,EAAjE;AACA,YAAIG,MAAM,GAAGpS,IAAI,CAAC/F,CAAD,CAAJ,CAAQ2B,OAAR,CAAgB,SAAhB,EAA2BuW,QAAQ,GAAGN,IAAI,CAAC3M,CAAD,CAAJ,CAAQmN,KAA9C,CAAb;AAEA,YAAG,CAAC7J,IAAI,CAAC4J,MAAD,CAAR,EAAkB5J,IAAI,CAAC4J,MAAD,CAAJ,GAAe5J,IAAI,CAACxI,IAAI,CAAC/F,CAAD,CAAL,CAAnB;AACrB;;AAED,aAAOuO,IAAI,CAACxI,IAAI,CAAC/F,CAAD,CAAL,CAAX;AACH;AACJ,GA7BwB,CA+BzB;;;AACA,MAAI4O,KAAK,GAAGjS,SAAS,CAAC0b,WAAV,EAAZ,CAhCyB,CAkCzB;AACA;;AACA,MAAI/I,MAAM,GAAG,EAAb;AACA,MAAID,MAAM,GAAG,EAAb,CArCyB,CAuCzB;AACA;AACA;AACA;;AACA,WAASuC,OAAT,CAAiBlQ,IAAjB,EAAuB0M,GAAvB,EAA4B;AACxB,QAAG/P,KAAK,CAACC,OAAN,CAAcoD,IAAd,CAAH,EAAwB;AACpBA,MAAAA,IAAI,CAACmQ,OAAL,CAAa,UAAS5D,CAAT,EAAY;AAAE2D,QAAAA,OAAO,CAAC3D,CAAD,EAAIG,GAAJ,CAAP;AAAkB,OAA7C;AACA;AACH,KAJuB,CAMxB;AACA;;;AACA,QAAG1M,IAAI,IAAI6M,IAAR,IAAgB9R,OAAO,CAACqV,SAAR,CAAkBvD,IAAlB,EAAwB7M,IAAxB,CAAnB,EAAkD;AAElD,QAAI4W,CAAC,GAAG1H,QAAQ,CAAC1T,MAAD,EAASwE,IAAT,CAAhB;;AACA,QAAG,EAAEA,IAAI,IAAI2N,MAAV,CAAH,EAAsB;AAClBA,MAAAA,MAAM,CAAC3N,IAAD,CAAN,GAAe8N,eAAe,CAAC8I,CAAC,CAACpN,GAAF,EAAD,CAA9B;AACH;;AACD,QAAGkD,GAAG,KAAKhI,SAAX,EAAsBkS,CAAC,CAAC5M,GAAF,CAAM0C,GAAN;AACzB,GA1DwB,CA4DzB;AACA;AACA;;;AACA,MAAI8H,aAAa,GAAG,EAApB;AACA,MAAIO,IAAJ;;AAEA,WAAS8B,iBAAT,CAA2BC,SAA3B,EAAsC;AAClC,QAAI/B,IAAI,GAAGza,IAAI,CAACyc,OAAL,CAAaD,SAAS,CAAC1S,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAb,CAAX;AACAoQ,IAAAA,aAAa,CAACO,IAAD,CAAb,GAAsB,CAAtB;AACA,WAAOA,IAAP;AACH,GAtEwB,CAwEzB;;;AACA,OAAI,IAAIjE,EAAR,IAAcjE,IAAd,EAAoB;AAChB,QAAG9R,OAAO,CAACqV,SAAR,CAAkBvD,IAAlB,EAAwBiE,EAAxB,CAAH,EAAgC;AAC5B,YAAM,IAAInJ,KAAJ,CAAU,gBAAgBmJ,EAAhB,GAAqB,wCAA/B,CAAN;AACH;;AAED,QAAI8F,CAAC,GAAG1H,QAAQ,CAAC1T,MAAD,EAASsV,EAAT,CAAhB;AACA,QAAIC,EAAE,GAAGlE,IAAI,CAACiE,EAAD,CAAb;AACA,QAAIkG,IAAI,GAAGJ,CAAC,CAAC7Q,KAAF,CAAQhJ,MAAnB,CAPgB,CAQhB;;AACA,QAAIka,IAAI,GAAGD,IAAI,GAAG,CAAlB;;AACA,WAAMC,IAAI,GAAG,CAAP,IAAY,OAAOL,CAAC,CAAC7Q,KAAF,CAAQkR,IAAR,CAAP,KAAyB,QAA3C;AAAqDA,MAAAA,IAAI;AAAzD,KAVgB,CAWhB;;;AACA,QAAIC,KAAK,GAAGN,CAAC,CAAC7Q,KAAF,CAAQkR,IAAR,CAAZ,CAZgB,CAahB;;AACA,QAAIH,SAAS,GAAGF,CAAC,CAAC7Q,KAAF,CAAQkR,IAAI,GAAG,CAAf,IAAoB,GAApB,GAA0BC,KAA1C,CAdgB,CAehB;;AACA,QAAIC,MAAM,GAAGP,CAAC,CAAC7Q,KAAF,CAAQqP,KAAR,CAAc,CAAd,EAAiB6B,IAAjB,EAAuBG,IAAvB,CAA4B,GAA5B,CAAb;AACA,QAAIC,QAAQ,GAAGtd,cAAc,CAACuB,EAAE,CAACE,MAAJ,EAAY2b,MAAZ,CAAd,CAAkC3N,GAAlC,EAAf;AACA,QAAI8N,UAAU,GAAGvd,cAAc,CAACuD,UAAD,EAAa6Z,MAAb,CAAd,CAAmC3N,GAAnC,EAAjB;AACA,QAAI+N,IAAI,GAAGX,CAAC,CAACpN,GAAF,EAAX;AAEA,QAAGuH,EAAE,KAAKrM,SAAV,EAAqB;AAErBkJ,IAAAA,MAAM,CAACkD,EAAD,CAAN,GAAaC,EAAb,CAvBgB,CAyBhB;AACA;;AACApD,IAAAA,MAAM,CAACmD,EAAD,CAAN,GAAcoG,KAAK,KAAK,SAAX,GAAwBnG,EAAxB,GAA6BjD,eAAe,CAACyJ,IAAD,CAAzD;AAEA,QAAInG,SAAS,GAAGjX,UAAU,CAACqd,kBAAX,CAA8Bla,UAA9B,EAA0CsZ,CAAC,CAAC7Q,KAA5C,CAAhB;;AAEA,QAAGqL,SAAS,IAAIA,SAAS,CAACM,YAAvB,IAAuCX,EAAE,KAAK,IAAjD,EAAuD;AACnD,WAAI,IAAIY,UAAR,IAAsBP,SAAS,CAACM,YAAhC,EAA8C;AAC1CxB,QAAAA,OAAO,CAACpW,GAAG,CAAC8X,YAAJ,CAAiBd,EAAjB,EAAqBa,UAArB,CAAD,EAAmCP,SAAS,CAACM,YAAV,CAAuBC,UAAvB,CAAnC,CAAP;AACH;AACJ,KAnCe,CAqChB;AACA;AACA;AACA;AACA;;;AACA,QAAG,CAAC,OAAD,EAAU,QAAV,EAAoBpJ,OAApB,CAA4BuI,EAA5B,MAAoC,CAAC,CAAxC,EAA2C;AACvC,UAAGC,EAAH,EAAO;AACHb,QAAAA,OAAO,CAAC,UAAD,EAAa,IAAb,CAAP,CADG,CAEH;AACA;AACA;;AACA,YAAIuH,YAAY,GAAG3G,EAAE,KAAK,QAAP,GAAkB,OAAlB,GAA4B,QAA/C;AACAZ,QAAAA,OAAO,CAACuH,YAAD,EAAena,UAAU,CAACma,YAAD,CAAzB,CAAP;AACH,OAPD,MAOO;AACHna,QAAAA,UAAU,CAACwT,EAAD,CAAV,GAAiBxV,EAAE,CAACoc,gBAAH,CAAoB5G,EAApB,CAAjB;AACH;AACJ,KAXD,MAWO,IAAGA,EAAE,KAAK,UAAV,EAAsB;AACzB;AACAZ,MAAAA,OAAO,CAAC,OAAD,EAAUa,EAAE,GAAG,IAAH,GAAUzT,UAAU,CAACiD,KAAjC,CAAP;AACA2P,MAAAA,OAAO,CAAC,QAAD,EAAWa,EAAE,GAAG,IAAH,GAAUzT,UAAU,CAACkD,MAAlC,CAAP;AACH,KAJM,MAIA,IAAGsW,SAAS,CAACa,KAAV,CAAgB5B,WAAhB,CAAH,EAAiC;AACpC;AAEAc,MAAAA,iBAAiB,CAACC,SAAD,CAAjB;AACA/c,MAAAA,cAAc,CAACuD,UAAD,EAAa6Z,MAAM,GAAG,cAAtB,CAAd,CAAoDnN,GAApD,CAAwD,IAAxD;AACH,KALM,MAKA,IAAG8M,SAAS,CAACa,KAAV,CAAgB3B,eAAhB,CAAH,EAAqC;AACxCa,MAAAA,iBAAiB,CAACC,SAAD,CAAjB;AACA/c,MAAAA,cAAc,CAACuD,UAAD,EAAa6Z,MAAM,GAAG,cAAtB,CAAd,CAAoDnN,GAApD,CAAwD,IAAxD;AACA,UAAI4N,MAAM,GAAG7d,cAAc,CAACuD,UAAD,EAAa6Z,MAAb,CAAd,CAAmC3N,GAAnC,EAAb;;AACA,UAAGoO,MAAM,CAACC,YAAV,EAAwB;AACpB;AACA;AACAD,QAAAA,MAAM,CAAC3H,MAAP,CAAc6H,MAAd,GAAuBF,MAAM,CAACC,YAAP,CAAoBzC,KAApB,EAAvB;AACH;AACJ,KATM,MASA,IAAG0B,SAAS,CAACa,KAAV,CAAgB1B,YAAhB,CAAH,EAAkC;AACrClc,MAAAA,cAAc,CAACuD,UAAD,EAAa6Z,MAAM,GAAG,eAAtB,CAAd,CAAqDnN,GAArD,CAAyD,IAAzD;AACH,KAzEe,CA2EhB;AACA;AACA;AACA;AACA;;;AACA,QAAGkN,KAAK,KAAK,MAAb,EAAqB;AACjB,UAAItB,EAAE,GAAGyB,QAAT;AACA,UAAIU,KAAK,GAAGT,UAAU,CAAC3V,IAAX,KAAoB,QAApB,IAAgCoP,EAAE,KAAK,KAAnD;AACA,UAAIiH,OAAO,GAAGV,UAAU,CAAC3V,IAAX,KAAoB,KAApB,IAA6BoP,EAAE,KAAK,QAAlD;;AAEA,UAAGgH,KAAK,IAAIC,OAAZ,EAAqB;AACjB,YAAG,CAACpC,EAAD,IAAO,CAACA,EAAE,CAACT,KAAd,EAAqB;AACjB;AACA;AACA;AACAjF,UAAAA,OAAO,CAACiH,MAAM,GAAG,YAAV,EAAwB,IAAxB,CAAP;AACH,SALD,MAKO,IAAG,CAACG,UAAU,CAACpC,SAAf,EAA0B;AAC7B;AACA;AACA,cAAI+C,EAAE,GAAGrC,EAAE,CAACT,KAAH,CAAS,CAAT,CAAT;AACA,cAAI+C,EAAE,GAAGtC,EAAE,CAACT,KAAH,CAAS,CAAT,CAAT;;AACA,cAAG4C,KAAH,EAAU;AACN;AACA,gBAAGE,EAAE,IAAI,CAAN,IAAWC,EAAE,IAAI,CAApB,EAAuB;AACnBhI,cAAAA,OAAO,CAACiH,MAAM,GAAG,YAAV,EAAwB,IAAxB,CAAP;AACH,aAJK,CAKN;;;AACA,gBAAGc,EAAE,IAAI,CAAT,EAAYA,EAAE,GAAGC,EAAE,GAAG,GAAV,CAAZ,KACK,IAAGA,EAAE,IAAI,CAAT,EAAYA,EAAE,GAAGD,EAAE,GAAG,GAAV,CAPX,CAQN;;AACA/H,YAAAA,OAAO,CAACiH,MAAM,GAAG,WAAV,EAAuBzW,IAAI,CAAC/C,GAAL,CAASsa,EAAT,IAAevX,IAAI,CAACyX,IAA3C,CAAP;AACAjI,YAAAA,OAAO,CAACiH,MAAM,GAAG,WAAV,EAAuBzW,IAAI,CAAC/C,GAAL,CAASua,EAAT,IAAexX,IAAI,CAACyX,IAA3C,CAAP;AACH,WAXD,MAWO;AACHjI,YAAAA,OAAO,CAACiH,MAAM,GAAG,WAAV,EAAuBzW,IAAI,CAAC0X,GAAL,CAAS,EAAT,EAAaH,EAAb,CAAvB,CAAP;AACA/H,YAAAA,OAAO,CAACiH,MAAM,GAAG,WAAV,EAAuBzW,IAAI,CAAC0X,GAAL,CAAS,EAAT,EAAaF,EAAb,CAAvB,CAAP;AACH;AACJ,SApBM,MAoBA,IAAGH,KAAH,EAAU;AACb;AACA;AACAnC,UAAAA,EAAE,CAACT,KAAH,GAAYS,EAAE,CAACT,KAAH,CAAS,CAAT,IAAcS,EAAE,CAACT,KAAH,CAAS,CAAT,CAAf,GAA8B,CAAC,CAAD,EAAI,CAAJ,CAA9B,GAAuC,CAAC,CAAD,EAAI,CAAJ,CAAlD;AACH,SA9BgB,CAgCjB;AACA;;;AACA,YAAGxY,KAAK,CAACC,OAAN,CAAcU,UAAU,CAAC+a,SAAX,CAAqBC,KAAnC,KACChb,UAAU,CAAC+a,SAAX,CAAqBC,KAArB,CAA2Bvb,MAD5B,IAECO,UAAU,CAACsZ,CAAC,CAAC7Q,KAAF,CAAQ,CAAR,CAAD,CAFX,IAGC6Q,CAAC,CAAC7Q,KAAF,CAAQ,CAAR,MAAe,YAHnB,EAIE;AACE,iBAAOzI,UAAU,CAACsZ,CAAC,CAAC7Q,KAAF,CAAQ,CAAR,CAAD,CAAV,CAAuBwS,QAAvB,CAAgCC,WAAhC,CAA4C,kBAA5C,CAAP;AACH,SAxCgB,CA0CjB;AACA;;;AACAte,QAAAA,QAAQ,CAACmI,kBAAT,CAA4B,aAA5B,EAA2C,eAA3C,EAA4D/G,EAA5D,EAAgEgc,UAAhE,EAA4EvG,EAA5E,EAAgFb,OAAhF;AACAhW,QAAAA,QAAQ,CAACmI,kBAAT,CAA4B,QAA5B,EAAsC,eAAtC,EAAuD/G,EAAvD,EAA2Dgc,UAA3D,EAAuEvG,EAAvE,EAA2Eb,OAA3E;AACH,OA9CD,MA8CO;AACH;AACA;AACAA,QAAAA,OAAO,CAACiH,MAAM,GAAG,YAAV,EAAwB,IAAxB,CAAP;AACAjH,QAAAA,OAAO,CAACiH,MAAM,GAAG,QAAV,EAAoB,IAApB,CAAP;AACH;;AACDpd,MAAAA,cAAc,CAACuD,UAAD,EAAa6Z,MAAM,GAAG,cAAtB,CAAd,CAAoDnN,GAApD,CAAwD,IAAxD;AACH,KA1DD,MA0DO,IAAGkN,KAAK,CAACS,KAAN,CAAYzc,eAAZ,CAAH,EAAiC;AACpC,UAAIud,QAAQ,GAAG1e,cAAc,CAACuD,UAAD,EAAawT,EAAb,CAAd,CAA+BtH,GAA/B,EAAf;AACA,UAAIkP,OAAO,GAAG,CAAC3H,EAAE,IAAI,EAAP,EAAWpP,IAAzB,CAFoC,CAIpC;AACA;AACA;;AACA,UAAG,CAAC+W,OAAD,IAAYA,OAAO,KAAK,GAA3B,EAAgCA,OAAO,GAAG,QAAV;AAChCxe,MAAAA,QAAQ,CAACmI,kBAAT,CAA4B,aAA5B,EAA2C,eAA3C,EAA4D/G,EAA5D,EAAgEmd,QAAhE,EAA0EC,OAA1E,EAAmFxI,OAAnF;AACAhW,MAAAA,QAAQ,CAACmI,kBAAT,CAA4B,QAA5B,EAAsC,eAAtC,EAAuD/G,EAAvD,EAA2Dmd,QAA3D,EAAqEC,OAArE,EAA8ExI,OAA9E;AACH,KApJe,CAsJhB;AAEA;AACA;AACA;AACA;;;AACA,QAAIyI,mBAAmB,GAAG7d,YAAY,CAAC6d,mBAAb,CAAiC7H,EAAjC,CAA1B;;AACA,QAAG6H,mBAAH,EAAwB;AACpBtC,MAAAA,QAAQ,GAAGsC,mBAAmB,CAACC,KAA/B;AACAta,MAAAA,CAAC,GAAGqa,mBAAmB,CAACxQ,KAAxB;AACA,UAAI0Q,OAAO,GAAGF,mBAAmB,CAACG,QAAlC;AACA,UAAIC,eAAe,GAAG3H,SAAS,IAAI;AAAC4H,QAAAA,QAAQ,EAAE;AAAX,OAAnC;;AAEA,UAAG1a,CAAC,KAAK,EAAN,IAAYua,OAAO,KAAK,EAA3B,EAA+B;AAC3B;AACA;AACA;AACA,YAAG/d,YAAY,CAACme,QAAb,CAAsBlI,EAAtB,CAAH,EAA8B;AAC1BpD,UAAAA,MAAM,CAACmD,EAAD,CAAN,GAAa,IAAb;AACH,SAFD,MAEO,IAAGhW,YAAY,CAACoe,WAAb,CAAyBnI,EAAzB,CAAH,EAAiC;AACpCpD,UAAAA,MAAM,CAACmD,EAAD,CAAN,GAAa,CAAC/W,cAAc,CAACyB,MAAD,EAAS6a,QAAT,CAAd,CAAiC7M,GAAjC,MAA0C,EAA3C,EAA+ClL,CAA/C,CAAb;AACH,SAFM,MAEA;AACHxE,UAAAA,GAAG,CAACsC,IAAJ,CAAS,gCAAT,EAA2CyQ,IAA3C;AACH;AACJ;;AACD5R,MAAAA,SAAS,CAAC8N,MAAV,CAAiBmE,KAAjB,EAAwB6L,eAAxB,EAlBoB,CAoBpB;;AACA,UAAG,CAAC3C,UAAU,CAACC,QAAD,CAAd,EAA0BD,UAAU,CAACC,QAAD,CAAV,GAAuB,EAAvB;AAC1B,UAAI8C,QAAQ,GAAG/C,UAAU,CAACC,QAAD,CAAV,CAAqB/X,CAArB,CAAf;AACA,UAAG,CAAC6a,QAAJ,EAAcA,QAAQ,GAAG/C,UAAU,CAACC,QAAD,CAAV,CAAqB/X,CAArB,IAA0B,EAArC;AACd6a,MAAAA,QAAQ,CAACN,OAAD,CAAR,GAAoB9H,EAApB;AAEA,aAAOlE,IAAI,CAACiE,EAAD,CAAX;AACH,KA3BD,MA2BO,IAAGoG,KAAK,KAAK,SAAb,EAAwB;AAC3B;AAEA,UAAGG,QAAQ,CAAClC,KAAZ,EAAmBkC,QAAQ,CAAClC,KAAT,CAAeiE,OAAf,GAAnB,KACK;AACDlJ,QAAAA,OAAO,CAACiH,MAAM,GAAG,YAAV,EAAwB,IAAxB,CAAP;AACAE,QAAAA,QAAQ,CAAClC,KAAT,GAAiB,CAAC,CAAD,EAAI,CAAJ,CAAjB;AACH;AAED,UAAGmC,UAAU,CAACpC,SAAd,EAAyBhI,KAAK,CAACC,IAAN,GAAa,IAAb,CAAzB,KACKD,KAAK,CAAC7R,IAAN,GAAa,IAAb;AACR,KAXM,MAWA;AACH,UAAIiC,UAAU,CAACG,IAAX,CAAgB,cAAhB,KAAmCH,UAAU,CAACG,IAAX,CAAgB,MAAhB,CAApC,IACEqT,EAAE,KAAK,UAAP,KACAC,EAAE,KAAK,OAAP,IAAkBA,EAAE,KAAK,QADzB,KAED,EAAEwG,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,QAA/B,CAHJ,EAIE;AACErK,QAAAA,KAAK,CAAC7R,IAAN,GAAa,IAAb;AACH,OAND,MAMO,IAAGiC,UAAU,CAACG,IAAX,CAAgB,MAAhB,CAAH,EAA4B;AAC/ByP,QAAAA,KAAK,CAAC7R,IAAN,GAAa,IAAb;AACH,OAFM,MAEA,IAAG+V,SAAH,EAAcnW,SAAS,CAAC8N,MAAV,CAAiBmE,KAAjB,EAAwBkE,SAAxB,EAAd,KACFlE,KAAK,CAACC,IAAN,GAAa,IAAb;;AAELyJ,MAAAA,CAAC,CAAC5M,GAAF,CAAM+G,EAAN;AACH;AACJ,GA1RwB,CA4RzB;;;AACA,OAAIsF,QAAJ,IAAgBD,UAAhB,EAA4B;AACxB,QAAIiD,QAAQ,GAAGve,YAAY,CAACwe,0BAAb,CAAwChe,EAAxC,EACX4T,QAAQ,CAAC1T,MAAD,EAAS6a,QAAT,CADG,EACiBD,UAAU,CAACC,QAAD,CAD3B,EACuCnJ,KADvC,EAC8CgC,QAD9C,CAAf;AAEA,QAAG,CAACmK,QAAJ,EAAcnM,KAAK,CAAC7R,IAAN,GAAa,IAAb;AACjB,GAjSwB,CAmSzB;;;AACA,MAAIke,WAAW,GAAGjc,UAAU,CAACkc,qBAAX,IAAoC,EAAtD;;AACA,OAAIzE,IAAJ,IAAYP,aAAZ,EAA2B;AACvB,SAAIlW,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGib,WAAW,CAACxc,MAA3B,EAAmCuB,CAAC,EAApC,EAAwC;AACpC,UAAImb,KAAK,GAAGF,WAAW,CAACjb,CAAD,CAAvB;;AACA,UAAGmb,KAAK,CAAC1E,IAAD,CAAR,EAAgB;AACZ;AACA;AACA;AACA;AACA;AACA7H,QAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;;AACA,aAAI,IAAIuM,SAAR,IAAqBD,KAArB,EAA4B;AACxB,cAAG,CAACjF,aAAa,CAACkF,SAAD,CAAjB,EAA8B;AAC1Bpf,YAAAA,IAAI,CAACub,SAAL,CAAeva,EAAf,EAAmBoe,SAAnB,EAA8BC,qBAA9B,GAAsD,IAAtD;AACH;AACJ;AACJ;AACJ;AACJ,GAtTwB,CAwTzB;AACA;AACA;AACA;;;AACA,MAAGC,cAAc,CAACte,EAAD,CAAd,IAAsBuR,IAAI,CAACrM,MAA3B,IAAqCqM,IAAI,CAACtM,KAA7C,EAAoD2M,KAAK,CAAC7R,IAAN,GAAa,IAAb;;AAEpD,MAAG6R,KAAK,CAAC7R,IAAN,IAAc6R,KAAK,CAACC,IAAvB,EAA6B;AACzBD,IAAAA,KAAK,CAACgH,YAAN,GAAqB,IAArB;AACH,GAhUwB,CAkUzB;AACA;;;AAEA,SAAO;AACHhH,IAAAA,KAAK,EAAEA,KADJ;AAEHsH,IAAAA,aAAa,EAAEA,aAFZ;AAGH7G,IAAAA,MAAM,EAAEA,MAHL;AAIHC,IAAAA,MAAM,EAAEA,MAJL;AAKHC,IAAAA,SAAS,EAAEA;AALR,GAAP;AAOH;AAED;;;;;;;AAKA,SAAS+L,cAAT,CAAwBte,EAAxB,EAA4B;AACxB,MAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAApB;AACA,MAAIsc,QAAQ,GAAGvc,UAAU,CAACiD,KAA1B;AACA,MAAIuZ,SAAS,GAAGxc,UAAU,CAACkD,MAA3B,CAHwB,CAKxB;;AACA,MAAGlF,EAAE,CAACE,MAAH,CAAUue,QAAb,EAAuB3f,KAAK,CAAC4f,YAAN,CAAmB1e,EAAnB,EAAuBA,EAAE,CAACE,MAA1B,EAAkC8B,UAAlC;AAEvB,SAAQA,UAAU,CAACiD,KAAX,KAAqBsZ,QAAtB,IAAoCvc,UAAU,CAACkD,MAAX,KAAsBsZ,SAAjE;AACH;AAED;;;;;;;;;;;;;;;;;AAeA,SAAS/Q,MAAT,CAAgBzN,EAAhB,EAAoB2e,WAApB,EAAiCC,YAAjC,EAA+CvN,OAA/C,EAAwD;AACpDrR,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AACAP,EAAAA,OAAO,CAAC6R,iBAAR,CAA0BtR,EAA1B;;AAEA,MAAGA,EAAE,CAACyC,SAAH,IAAgBzC,EAAE,CAACyC,SAAH,CAAaiW,OAAhC,EAAyC;AACrC,WAAO/X,OAAO,CAACiH,OAAR,CAAgB5H,EAAhB,CAAP;AACH;;AAED,MAAG,CAACxB,GAAG,CAAC+B,aAAJ,CAAkBoe,WAAlB,CAAJ,EAAoCA,WAAW,GAAG,EAAd;AACpC,MAAG,CAACngB,GAAG,CAAC+B,aAAJ,CAAkBqe,YAAlB,CAAJ,EAAqCA,YAAY,GAAG,EAAf;AAErC,MAAG5V,MAAM,CAACD,IAAP,CAAY4V,WAAZ,EAAyBld,MAA5B,EAAoCzB,EAAE,CAACwR,OAAH,GAAa,IAAb;AACpC,MAAGxI,MAAM,CAACD,IAAP,CAAY6V,YAAZ,EAA0Bnd,MAA7B,EAAqCzB,EAAE,CAACwR,OAAH,GAAa,IAAb;AAErC,MAAIlE,MAAM,GAAG7N,OAAO,CAACgS,kBAAR,CAA2BzR,EAA3B,EAA+BqR,OAA/B,CAAb;;AAEA,MAAIwN,YAAY,GAAGlN,QAAQ,CAAC3R,EAAD,EAAKxB,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmBgb,WAAnB,CAAL,EAAsCrR,MAAtC,CAA3B;;AACA,MAAIwR,YAAY,GAAGD,YAAY,CAACjN,KAAhC;;AAEA,MAAImN,aAAa,GAAGpG,SAAS,CAAC3Y,EAAD,EAAKxB,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmBib,YAAnB,CAAL,CAA7B;;AACA,MAAII,aAAa,GAAGD,aAAa,CAACnN,KAAlC,CApBoD,CAsBpD;;AACA,MAAGkN,YAAY,CAACjN,IAAb,IAAqBmN,aAAa,CAACnN,IAAtC,EAA4C7R,EAAE,CAAC6C,QAAH,GAAcuG,SAAd;AAC5C,MAAG0V,YAAY,CAAChN,cAAhB,EAAgCrS,OAAO,CAACqS,cAAR,CAAuB9R,EAAvB,EAA2BsN,MAA3B,EAAmCsR,YAAnC,EAxBoB,CA0BpD;;AACA,MAAIxX,GAAG,GAAG,EAAV;;AAEA,MAAG4X,aAAa,CAACpG,YAAjB,EAA+B;AAC3B;AACA;AACAxR,IAAAA,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACkZ,YAArB;AACH,GAJD,MAIO,IAAGkG,YAAY,CAAC/M,UAAhB,EAA4B;AAC/B3K,IAAAA,GAAG,CAACzF,IAAJ,CAASX,OAAO,CAACjB,IAAjB;AACH,GAFM,MAEA;AACHqH,IAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAACiH,gBAAf;AACA8S,IAAAA,2BAA2B,CAAC7Y,EAAD,EAAKgf,aAAL,EAAoBD,aAApB,CAA3B,IAAiEjgB,KAAK,CAACiD,cAAN,CAAqB/B,EAArB,CAAjE;AAEA,QAAG8e,YAAY,CAACla,KAAhB,EAAuBwC,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACwS,YAArB;AACvB,QAAG4M,YAAY,CAAC3M,SAAb,IAA0B6M,aAAa,CAAC7M,SAA3C,EAAsD/K,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0S,WAArB;AACtD,QAAG4M,aAAa,CAAClG,MAAjB,EAAyB1R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACqZ,QAArB;AACzB,QAAGiG,aAAa,CAAChG,WAAjB,EAA8B5R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACkH,YAArB;AAC9B,QAAGoY,aAAa,CAAC/F,OAAjB,EAA0BhH,kBAAkB,CAAC7K,GAAD,EAAM2X,aAAa,CAAC7F,aAApB,CAAlB;AAC1B,QAAG8F,aAAa,CAAC7F,KAAjB,EAAwB/R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0Z,eAArB;AACxB,QAAG4F,aAAa,CAACpZ,OAAjB,EAA0BwB,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC2Z,SAArB;AAC1B,QAAG2F,aAAa,CAAC1F,MAAjB,EAAyBlS,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC6Z,QAArB;AAEzBnS,IAAAA,GAAG,CAACzF,IAAJ,CAASkG,aAAT;AACH;;AAEDT,EAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAAC0I,OAAf,EAAwB1I,KAAK,CAAC2I,MAA9B;AAEA9I,EAAAA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EACIyN,MADJ,EACY,CAACzN,EAAD,EAAK6e,YAAY,CAACxM,MAAlB,EAA0B0M,aAAa,CAAC1M,MAAxC,EAAgDwM,YAAY,CAACvR,MAA7D,CADZ,EAEIG,MAFJ,EAEY,CAACzN,EAAD,EAAK6e,YAAY,CAACvM,MAAlB,EAA0ByM,aAAa,CAACzM,MAAxC,EAAgDuM,YAAY,CAACvR,MAA7D,CAFZ;AAKA,MAAI5F,QAAQ,GAAGlJ,GAAG,CAACmI,WAAJ,CAAgBS,GAAhB,EAAqBpH,EAArB,CAAf;AACA,MAAG,CAAC0H,QAAD,IAAa,CAACA,QAAQ,CAACC,IAA1B,EAAgCD,QAAQ,GAAG/G,OAAO,CAACiH,OAAR,CAAgB5H,EAAhB,CAAX;AAEhC,SAAO0H,QAAQ,CAACC,IAAT,CAAc,YAAW;AAC5B3H,IAAAA,EAAE,CAAC+H,IAAH,CAAQ,eAAR,EAAyB;AACrB9H,MAAAA,IAAI,EAAE4e,YAAY,CAACtM,SADE;AAErBrS,MAAAA,MAAM,EAAE6e,aAAa,CAACxM;AAFD,KAAzB;AAKA,WAAOvS,EAAP;AACH,GAPM,CAAP;AAQH;AAED;;;;;;;AAKA,SAASif,OAAT,CAAiBC,IAAjB,EAAuB;AACnB,SAAO,SAASC,WAAT,CAAqBnf,EAArB,EAAyB;AAC5BA,IAAAA,EAAE,CAACiC,WAAH,CAAe0R,WAAf,GAA6B,IAA7B;AACA,QAAI2H,CAAC,GAAG4D,IAAI,CAACtd,KAAL,CAAW,IAAX,EAAiBqO,SAAjB,CAAR;AACAjQ,IAAAA,EAAE,CAACiC,WAAH,CAAe0R,WAAf,GAA6B,KAA7B;AACA,WAAO2H,CAAP;AACH,GALD;AAMH,C,CAED;AACA;AACA;;;AACA,IAAI8D,uBAAuB,GAAG,CAC1B;AAACC,EAAAA,OAAO,EAAE,eAAV;AAA2B3a,EAAAA,IAAI,EAAE;AAAjC,CAD0B,EAE1B;AAAC2a,EAAAA,OAAO,EAAE;AAAV,CAF0B,EAI1B;AACA;AAACA,EAAAA,OAAO,EAAE,sBAAV;AAAkC3a,EAAAA,IAAI,EAAE;AAAxC,CAL0B,EAM1B;AAAC2a,EAAAA,OAAO,EAAE,mBAAV;AAA+B3a,EAAAA,IAAI,EAAE;AAArC,CAN0B,EAQ1B;AAAC2a,EAAAA,OAAO,EAAE;AAAV,CAR0B,EAS1B;AAACA,EAAAA,OAAO,EAAE;AAAV,CAT0B,EAU1B;AAACA,EAAAA,OAAO,EAAE;AAAV,CAV0B,EAW1B;AAACA,EAAAA,OAAO,EAAE;AAAV,CAX0B,EAY1B;AAACA,EAAAA,OAAO,EAAE;AAAV,CAZ0B,EAa1B;AAACA,EAAAA,OAAO,EAAE;AAAV,CAb0B,EAe1B;AAACA,EAAAA,OAAO,EAAE,iBAAV;AAA6B3a,EAAAA,IAAI,EAAE;AAAnC,CAf0B,EAgB1B;AAAC2a,EAAAA,OAAO,EAAE,uBAAV;AAAmC3a,EAAAA,IAAI,EAAE;AAAzC,CAhB0B,EAiB1B;AAAC2a,EAAAA,OAAO,EAAE,eAAV;AAA2B3a,EAAAA,IAAI,EAAE;AAAjC,CAjB0B,CAA9B,C,CAoBA;AACA;;AACA,IAAI4a,sBAAsB,GAAG,CACzB;AAACD,EAAAA,OAAO,EAAE,kBAAV;AAA8B3a,EAAAA,IAAI,EAAE;AAApC,CADyB,EAEzB;AACA;AAAC2a,EAAAA,OAAO,EAAE,qBAAV;AAAiC3a,EAAAA,IAAI,EAAE;AAAvC,CAHyB,EAIzB;AAAC2a,EAAAA,OAAO,EAAE;AAAV,CAJyB,EAKzB;AAACA,EAAAA,OAAO,EAAE;AAAV,CALyB,EAKS;AAClC;AAACA,EAAAA,OAAO,EAAE;AAAV,CANyB,EAMH;AAEtB;AACA;AACA;AACA;AAEA;AACA;AAACA,EAAAA,OAAO,EAAE;AAAV,CAdyB,EAezB;AACA;AAACA,EAAAA,OAAO,EAAE;AAAV,CAhByB,EAiBzB;AAACA,EAAAA,OAAO,EAAE,kBAAV;AAA8B3a,EAAAA,IAAI,EAAE;AAApC,CAjByB,CAA7B;;AAoBA,SAAS6a,aAAT,CAAuBnb,GAAvB,EAA4Bob,YAA5B,EAA0C;AACtC,OAAI,IAAIxc,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGwc,YAAY,CAAC/d,MAAhC,EAAwCuB,CAAC,EAAzC,EAA6C;AACzC,QAAIyc,IAAI,GAAGD,YAAY,CAACxc,CAAD,CAAvB;AACA,QAAIqZ,KAAK,GAAGjY,GAAG,CAACiY,KAAJ,CAAUoD,IAAI,CAACJ,OAAf,CAAZ;;AACA,QAAGhD,KAAH,EAAU;AACN,aAAO;AAACqD,QAAAA,IAAI,EAAErD,KAAK,CAAC,CAAD,CAAZ;AAAiB3X,QAAAA,IAAI,EAAE+a,IAAI,CAAC/a;AAA5B,OAAP;AACH;AACJ;AACJ,C,CAED;AACA;AACA;;;AACA,SAASib,SAAT,CAAmBC,OAAnB,EAA4BhN,SAA5B,EAAuC;AACnC,MAAIiN,MAAM,GAAGphB,cAAc,CAACmU,SAAD,EAAYgN,OAAZ,CAAd,CAAmC1R,GAAnC,EAAb;AACA,MAAG2R,MAAM,KAAKzW,SAAd,EAAyB,OAAOyW,MAAP;AAEzB,MAAIpV,KAAK,GAAGmV,OAAO,CAAC9W,KAAR,CAAc,GAAd,CAAZ;AACA2B,EAAAA,KAAK,CAACqV,GAAN;;AACA,SAAMrV,KAAK,CAAChJ,MAAN,GAAe,CAArB,EAAwB;AACpBgJ,IAAAA,KAAK,CAACqV,GAAN;AACAD,IAAAA,MAAM,GAAGphB,cAAc,CAACmU,SAAD,EAAYnI,KAAK,CAACqR,IAAN,CAAW,GAAX,IAAkB,aAA9B,CAAd,CAA2D5N,GAA3D,EAAT;AACA,QAAG2R,MAAM,KAAKzW,SAAd,EAAyB,OAAOyW,MAAP;AAC5B;;AAED,SAAOjN,SAAS,CAACmN,UAAjB;AACH;;AAED,SAASC,wBAAT,CAAkCzZ,GAAlC,EAAuCH,QAAvC,EAAiD;AAC7C,OAAI,IAAIpD,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoD,QAAQ,CAAC3E,MAA5B,EAAoCuB,CAAC,EAArC,EAAyC;AACrC,QAAGoD,QAAQ,CAACpD,CAAD,CAAR,CAAYmS,UAAZ,CAAuB5O,GAAvB,KAA+BA,GAAlC,EAAuC,OAAOvD,CAAP;AAC1C;;AACD,SAAO,CAAC,CAAR;AACH;;AAED,SAASid,oBAAT,CAA8B1Z,GAA9B,EAAmCtG,IAAnC,EAAyCgV,MAAzC,EAAiD;AAC7C,OAAI,IAAIjS,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG/C,IAAI,CAACwB,MAAxB,EAAgCuB,CAAC,EAAjC,EAAqC;AACjC,QAAG/C,IAAI,CAAC+C,CAAD,CAAJ,CAAQuD,GAAR,KAAgBA,GAAnB,EAAwB,OAAOvD,CAAP;AAC3B,GAH4C,CAI7C;;;AACA,SAAQ,CAAC/C,IAAI,CAACgV,MAAD,CAAL,IAAiBhV,IAAI,CAACgV,MAAD,CAAJ,CAAa1O,GAA/B,GAAsC,CAAC,CAAvC,GAA2C0O,MAAlD;AACH;;AAED,SAASiL,SAAT,CAAmBC,EAAnB,EAAuBC,EAAvB,EAA2B;AACvB,MAAIC,OAAO,GAAG7hB,GAAG,CAAC+B,aAAJ,CAAkB4f,EAAlB,CAAd;AACA,MAAIG,SAAS,GAAGjf,KAAK,CAACC,OAAN,CAAc6e,EAAd,CAAhB;;AACA,MAAGE,OAAO,IAAIC,SAAd,EAAyB;AACrB,WAAO,CACFD,OAAO,IAAI7hB,GAAG,CAAC+B,aAAJ,CAAkB6f,EAAlB,CAAZ,IACCE,SAAS,IAAIjf,KAAK,CAACC,OAAN,CAAc8e,EAAd,CAFX,KAGFG,IAAI,CAACC,SAAL,CAAeL,EAAf,MAAuBI,IAAI,CAACC,SAAL,CAAeJ,EAAf,CAH5B;AAIH;;AACD,SAAOD,EAAE,KAAKC,EAAd;AACH;;AAED,SAASK,gBAAT,CAA0BxgB,IAA1B,EAAgCC,MAAhC,EAAwCwgB,WAAxC,EAAqDC,aAArD,EAAoE;AAChE,MAAIC,YAAY,GAAGD,aAAa,CAAC9M,OAAjC;AACA,MAAIzP,GAAJ,EAASwb,OAAT,EAAkBiB,MAAlB,EAA0BhB,MAA1B,EAAkCxD,KAAlC,EAAyCyE,SAAzC,EAAoDC,KAApD,EAA2D7N,MAA3D;AACA,MAAI8N,oBAAoB,GAAG,EAA3B;AACA,MAAIC,gBAAgB,GAAG,EAAvB;;AACA,OAAI7c,GAAJ,IAAWwc,YAAX,EAAyB;AACrBvE,IAAAA,KAAK,GAAGkD,aAAa,CAACnb,GAAD,EAAMgb,uBAAN,CAArB;;AACA,QAAG/C,KAAH,EAAU;AACNuD,MAAAA,OAAO,GAAGvD,KAAK,CAAC3X,IAAN,IAAe2X,KAAK,CAACqD,IAAN,GAAa,aAAtC;AACAmB,MAAAA,MAAM,GAAGpiB,cAAc,CAACkiB,aAAD,EAAgBf,OAAhB,CAAd,CAAuC1R,GAAvC,EAAT;AACA2R,MAAAA,MAAM,GAAGgB,MAAM,IAAIlB,SAAS,CAACC,OAAD,EAAU1f,MAAV,CAA5B;;AACA,UAAG2f,MAAM,IAAKA,MAAM,KAAKgB,MAAzB,EAAkC;AAC9BC,QAAAA,SAAS,GAAGF,YAAY,CAACxc,GAAD,CAAxB;AACA,YAAG0c,SAAS,KAAK,IAAjB,EAAuBA,SAAS,GAAG1X,SAAZ;AACvB2X,QAAAA,KAAK,GAAGtiB,cAAc,CAACyB,MAAD,EAASkE,GAAT,CAAtB;AACA8O,QAAAA,MAAM,GAAG6N,KAAK,CAAC7S,GAAN,EAAT;;AACA,YAAGgS,SAAS,CAAChN,MAAD,EAAS4N,SAAT,CAAZ,EAAiC;AAC7B,cAAG5N,MAAM,KAAK9J,SAAX,IAAwBhF,GAAG,CAAC4Q,MAAJ,CAAW5Q,GAAG,CAAC3C,MAAJ,GAAa,CAAxB,MAA+B,WAA1D,EAAuE;AACnEuf,YAAAA,oBAAoB,CAACrf,IAArB,CAA0ByC,GAAG,CAAC4Q,MAAJ,CAAW,CAAX,EAAc5Q,GAAG,CAAC3C,MAAJ,GAAa,EAA3B,CAA1B;AACH;;AACDsf,UAAAA,KAAK,CAACrS,GAAN,CAAU8D,eAAe,CAAC/T,cAAc,CAACkiB,aAAD,EAAgBvc,GAAhB,CAAd,CAAmC8J,GAAnC,EAAD,CAAzB;AACA;AACH;AACJ;AACJ,KAjBD,MAiBO;AACH1P,MAAAA,GAAG,CAACsC,IAAJ,CAAS,4BAA4BsD,GAArC;AACH,KArBoB,CAsBrB;AACA;AACA;;;AACA,WAAOwc,YAAY,CAACxc,GAAD,CAAnB;;AAEA,QAAGA,GAAG,CAAC4Q,MAAJ,CAAW5Q,GAAG,CAAC3C,MAAJ,GAAa,CAAxB,EAA2B,CAA3B,MAAkC,QAArC,EAA+C;AAC3Cwf,MAAAA,gBAAgB,CAAC7c,GAAG,CAAC4Q,MAAJ,CAAW,CAAX,EAAc5Q,GAAG,CAAC3C,MAAJ,GAAa,CAA3B,CAAD,CAAhB,GAAkD,CAAlD;AACH;AACJ,GAnC+D,CAqChE;AACA;AACA;AACA;;;AACA,OAAI,IAAIuB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGge,oBAAoB,CAACvf,MAAxC,EAAgDuB,CAAC,EAAjD,EAAqD;AACjD,QAAIke,MAAM,GAAGF,oBAAoB,CAAChe,CAAD,CAAjC;;AACA,QAAGie,gBAAgB,CAACC,MAAD,CAAnB,EAA6B;AACzB,UAAIC,KAAK,GAAG1iB,cAAc,CAACyB,MAAD,EAASghB,MAAT,CAAd,CAA+BhT,GAA/B,EAAZ;AACA,UAAGiT,KAAH,EAAU,OAAOA,KAAK,CAACvH,SAAb;AACb;AACJ,GA/C+D,CAiDhE;AACA;;;AACA,MAAIwH,cAAc,GAAGT,aAAa,CAACzL,YAAnC;;AACA,OAAI,IAAI3O,GAAR,IAAe6a,cAAf,EAA+B;AAC3B,QAAIC,WAAW,GAAGD,cAAc,CAAC7a,GAAD,CAAhC;AACA,QAAI+a,QAAQ,GAAG,IAAf;AACA,QAAIC,SAAJ;;AACA,SAAInd,GAAJ,IAAWid,WAAX,EAAwB;AACpB;AACA;AACA,UAAG,CAACC,QAAJ,EAAc;AACV,YAAIE,KAAK,GAAGxB,wBAAwB,CAACzZ,GAAD,EAAMma,WAAN,CAApC;;AACA,YAAGc,KAAK,GAAG,CAAX,EAAc;AACV;AACA;AACA,iBAAOJ,cAAc,CAAC7a,GAAD,CAArB;AACA;AACH;;AACD,YAAIkb,SAAS,GAAGf,WAAW,CAACc,KAAD,CAA3B;AACAD,QAAAA,SAAS,GAAGE,SAAS,CAACtM,UAAtB;AAEA,YAAIuM,SAAS,GAAGzB,oBAAoB,CAAC1Z,GAAD,EAAMtG,IAAN,EAAYshB,SAAS,CAAC1U,KAAtB,CAApC;;AACA,YAAG6U,SAAS,GAAG,CAAf,EAAkB;AACd;AACA,iBAAON,cAAc,CAAC7a,GAAD,CAArB;AACA;AACH;;AACD+a,QAAAA,QAAQ,GAAGrhB,IAAI,CAACyhB,SAAD,CAAf;AACH;;AAEDrF,MAAAA,KAAK,GAAGkD,aAAa,CAACnb,GAAD,EAAMkb,sBAAN,CAArB;;AACA,UAAGjD,KAAH,EAAU;AACN,YAAGA,KAAK,CAAC3X,IAAT,EAAe;AACXmc,UAAAA,MAAM,GAAGpiB,cAAc,CAACkiB,aAAD,EAAgBtE,KAAK,CAAC3X,IAAtB,CAAd,CAA0CwJ,GAA1C,EAAT;AACA2R,UAAAA,MAAM,GAAGgB,MAAM,IAAIlB,SAAS,CAACtD,KAAK,CAAC3X,IAAP,EAAaxE,MAAb,CAA5B;AACH,SAHD,MAGO;AACH2gB,UAAAA,MAAM,GAAGU,SAAS,CAACxB,UAAnB,CADG,CAEH;;AACAF,UAAAA,MAAM,GAAGyB,QAAQ,CAACvB,UAAlB;AACA,cAAGF,MAAM,KAAKzW,SAAd,EAAyByW,MAAM,GAAG3f,MAAM,CAAC6f,UAAhB;AAC5B;;AAED,YAAGF,MAAM,IAAIA,MAAM,KAAKgB,MAAxB,EAAgC;AAC5BC,UAAAA,SAAS,GAAGO,WAAW,CAACjd,GAAD,CAAvB;AACA,cAAG0c,SAAS,KAAK,IAAjB,EAAuBA,SAAS,GAAG1X,SAAZ;AACvB2X,UAAAA,KAAK,GAAGtiB,cAAc,CAAC6iB,QAAD,EAAWld,GAAX,CAAtB;AACA8O,UAAAA,MAAM,GAAG6N,KAAK,CAAC7S,GAAN,EAAT;;AACA,cAAGgS,SAAS,CAAChN,MAAD,EAAS4N,SAAT,CAAZ,EAAiC;AAC7BC,YAAAA,KAAK,CAACrS,GAAN,CAAU8D,eAAe,CAAC/T,cAAc,CAAC8iB,SAAD,EAAYnd,GAAZ,CAAd,CAA+B8J,GAA/B,EAAD,CAAzB;AACA;AACH;AACJ;AACJ,OArBD,MAqBO;AACH1P,QAAAA,GAAG,CAACsC,IAAJ,CAAS,4BAA4BsD,GAA5B,GAAkC,gBAAlC,GAAqDmC,GAA9D;AACH;;AACD,aAAO8a,WAAW,CAACjd,GAAD,CAAlB;AACH;AACJ;AACJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAASud,KAAT,CAAe3hB,EAAf,EAAmBC,IAAnB,EAAyBC,MAAzB,EAAiCC,MAAjC,EAAyC;AACrC,MAAIC,MAAJ,EAAYsH,QAAZ;;AAEA,WAAS3G,SAAT,GAAqB;AAAE,WAAOC,OAAO,CAACD,SAAR,CAAkBf,EAAlB,EAAsBI,MAAtB,CAAP;AAAuC;;AAE9DJ,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AACAP,EAAAA,OAAO,CAAC6R,iBAAR,CAA0BtR,EAA1B;AAEA,MAAI0gB,WAAW,GAAG1gB,EAAE,CAAC8C,SAArB;AACA,MAAI6d,aAAa,GAAG3gB,EAAE,CAACiC,WAAvB,CATqC,CAWrC;;AACA,MAAG,CAACzD,GAAG,CAACqC,SAAJ,CAAcb,EAAd,CAAD,IAAsB,CAAC0gB,WAAvB,IAAsC,CAACC,aAA1C,EAAyD;AACrDjZ,IAAAA,QAAQ,GAAG1G,OAAO,CAACsL,OAAR,CAAgBtM,EAAhB,EAAoBC,IAApB,EAA0BC,MAA1B,EAAkCC,MAAlC,CAAX;AACH,GAFD,MAEO;AACH,QAAG3B,GAAG,CAAC+B,aAAJ,CAAkBN,IAAlB,CAAH,EAA4B;AACxB,UAAIO,GAAG,GAAGP,IAAV;AACAA,MAAAA,IAAI,GAAGO,GAAG,CAACP,IAAX;AACAC,MAAAA,MAAM,GAAGM,GAAG,CAACN,MAAb;AACAC,MAAAA,MAAM,GAAGK,GAAG,CAACL,MAAb;AACAC,MAAAA,MAAM,GAAGI,GAAG,CAACJ,MAAb;AACH;;AAED,QAAIwhB,aAAa,GAAG,KAApB,CATG,CAUH;AACA;;AACA,QAAGzhB,MAAH,EAAW;AACP,UAAI0hB,SAAS,GAAGrjB,GAAG,CAACgK,UAAJ,CAAe,EAAf,EAAmBxI,EAAE,CAACkD,QAAtB,CAAhB;AACAlD,MAAAA,EAAE,CAACkD,QAAH,GAAckG,SAAd;AACAnI,MAAAA,cAAc,CAACjB,EAAD,EAAKG,MAAL,CAAd;AACAyhB,MAAAA,aAAa,GAAGE,UAAU,CAACD,SAAD,EAAY7hB,EAAE,CAACkD,QAAf,CAA1B;AACH;;AAEDlD,IAAAA,EAAE,CAACC,IAAH,GAAUA,IAAI,IAAI,EAAlB;AACAR,IAAAA,OAAO,CAACiC,SAAR,CAAkB1B,EAAE,CAACC,IAArB;AACAD,IAAAA,EAAE,CAACE,MAAH,GAAYA,MAAM,IAAI,EAAtB;AACAT,IAAAA,OAAO,CAACqC,WAAR,CAAoB9B,EAAE,CAACE,MAAvB;AAEAugB,IAAAA,gBAAgB,CAACzgB,EAAE,CAACC,IAAJ,EAAUD,EAAE,CAACE,MAAb,EAAqBwgB,WAArB,EAAkCC,aAAlC,CAAhB,CAxBG,CA0BH;AACA;AACA;;AACA7hB,IAAAA,KAAK,CAACiD,cAAN,CAAqB/B,EAArB,EAAyB;AAAC+hB,MAAAA,cAAc,EAAE;AAAjB,KAAzB;AAEA,QAAIC,WAAW,GAAGhiB,EAAE,CAAC8C,SAArB;AACA,QAAImf,aAAa,GAAGjiB,EAAE,CAACiC,WAAvB;AACA,QAAIigB,SAAS,GAAGD,aAAa,CAACE,YAAd,KAA+B/Y,SAA/C;AACA,QAAI2C,UAAU,GAAGkW,aAAa,CAAClW,UAA/B;AAEA,QAAIiT,aAAa,GAAGoD,UAAU,CAACpiB,EAAD,EAAK2gB,aAAL,EAAoBsB,aAApB,EAAmCC,SAAnC,EAA8CnW,UAA9C,CAA9B;AACA,QAAIsW,eAAe,GAAGrD,aAAa,CAACqD,eAApC;AACA,QAAIvD,YAAY,GAAGwD,QAAQ,CAACtiB,EAAD,EAAK0gB,WAAL,EAAkBsB,WAAlB,EAA+BE,SAA/B,EAA0CnW,UAA1C,EAAsDsW,eAAtD,CAA3B,CAtCG,CAwCH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAG/D,cAAc,CAACte,EAAD,CAAjB,EAAuBgf,aAAa,CAACpG,YAAd,GAA6B,IAA7B,CAjDpB,CAmDH;;AACA,QAAGkG,YAAY,CAACjN,IAAb,IAAqBmN,aAAa,CAACnN,IAAtC,EAA4C7R,EAAE,CAAC6C,QAAH,GAAcuG,SAAd,CAA5C,CACA;AADA,SAEKtK,KAAK,CAACyjB,wBAAN,CAA+BviB,EAAE,CAAC6C,QAAlC,EAA4Cmf,WAA5C,EAtDF,CAwDH;AACA;AAEA;;AACA,QAAI5a,GAAG,GAAG,EAAV;;AAEA,QAAGhH,MAAH,EAAW;AACPJ,MAAAA,EAAE,CAACwiB,eAAH,GAAqB,EAArB;AACA1jB,MAAAA,KAAK,CAAC2jB,oBAAN,CAA2BziB,EAA3B;AACAoH,MAAAA,GAAG,CAACzF,IAAJ,CAASZ,SAAT;AACH,KAlEE,CAoEH;AACA;AACA;AACA;;;AACA,QAAGkhB,aAAa,CAAClW,UAAd,IAA4B,CAAC6V,aAA7B,KAA+C9C,YAAY,CAAC4D,IAAb,IAAqB1D,aAAa,CAAC0D,IAAlF,CAAH,EAA4F;AACxF5jB,MAAAA,KAAK,CAACiE,UAAN,CAAiB/C,EAAjB;AACAN,MAAAA,WAAW,CAACoH,yBAAZ,CAAsC9G,EAAtC;AAEAoH,MAAAA,GAAG,CAACzF,IAAJ,CAAS,YAAW;AAChB,eAAO7C,KAAK,CAAC6jB,mBAAN,CAA0B3iB,EAA1B,EAA8B8e,YAA9B,EAA4CE,aAA5C,EAA2D2B,aAA3D,CAAP;AACH,OAFD;AAGH,KAPD,MAOO,IAAG7B,YAAY,CAAC/M,UAAb,IAA2BiN,aAAa,CAACpG,YAAzC,IAAyDgJ,aAA5D,EAA2E;AAC9E5hB,MAAAA,EAAE,CAACiC,WAAH,CAAe2gB,aAAf,GAA+B,IAA/B;AACAxb,MAAAA,GAAG,CAACzF,IAAJ,CAASX,OAAO,CAACjB,IAAjB;AACH,KAHM,MAGA;AACH,WAAI,IAAI8iB,aAAR,IAAyB7D,aAAa,CAAC8D,MAAvC,EAA+C;AAC3C,YAAIrW,OAAO,GAAGuS,aAAa,CAAC8D,MAAd,CAAqBD,aAArB,CAAd;;AACA,YAAGpW,OAAO,CAAChL,MAAX,EAAmB;AACf,cAAIshB,OAAO,GAAGnkB,QAAQ,CAACmI,kBAAT,CAA4B8b,aAA5B,EAA2C,SAA3C,CAAd;;AACA,cAAGE,OAAO,KAAKvkB,GAAG,CAACwkB,IAAnB,EAAyB;AACrB,iBAAI,IAAIhgB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGyJ,OAAO,CAAChL,MAA3B,EAAmCuB,CAAC,EAApC,EAAwC;AACpC+f,cAAAA,OAAO,CAAC/iB,EAAD,EAAKyM,OAAO,CAACzJ,CAAD,CAAZ,CAAP;AACH;AACJ,WAJD,MAIO;AACH,gBAAImE,IAAI,GAAGvI,QAAQ,CAACmI,kBAAT,CAA4B8b,aAA5B,EAA2C,MAA3C,CAAX;;AACA,gBAAG1b,IAAI,KAAK3I,GAAG,CAACwkB,IAAhB,EAAsB;AAClB,oBAAM,IAAI3W,KAAJ,CAAU,6BAA6BwW,aAAvC,CAAN;AACH;;AACD1b,YAAAA,IAAI,CAACnH,EAAD,CAAJ;AACH;AACJ;AACJ;;AAEDoH,MAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAACiH,gBAAf;AACA,UAAG+Y,YAAY,CAACla,KAAhB,EAAuBwC,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACwS,YAArB;AACvB,UAAG4M,YAAY,CAAC3M,SAAb,IAA0B6M,aAAa,CAAC7M,SAA3C,EAAsD/K,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0S,WAArB;AACtD,UAAG4M,aAAa,CAAClG,MAAjB,EAAyB1R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACqZ,QAArB;AACzB,UAAGiG,aAAa,CAAChG,WAAjB,EAA8B5R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAACkH,YAArB;AAC9B,UAAGoY,aAAa,CAAC/F,OAAjB,EAA0BhH,kBAAkB,CAAC7K,GAAD,CAAlB;AAC1B,UAAG4X,aAAa,CAAC7F,KAAjB,EAAwB/R,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC0Z,eAArB;AACxB,UAAG4F,aAAa,CAACpZ,OAAjB,EAA0BwB,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC2Z,SAArB;AAC1B,UAAG2F,aAAa,CAAC1F,MAAjB,EAAyBlS,GAAG,CAACzF,IAAJ,CAASjC,WAAW,CAAC6Z,QAArB;AACzBnS,MAAAA,GAAG,CAACzF,IAAJ,CAASkG,aAAT;AACH;;AAEDT,IAAAA,GAAG,CAACzF,IAAJ,CAAS7C,KAAK,CAAC0I,OAAf,EAAwB1I,KAAK,CAAC2I,MAA9B;AAEAC,IAAAA,QAAQ,GAAGlJ,GAAG,CAACmI,WAAJ,CAAgBS,GAAhB,EAAqBpH,EAArB,CAAX;AACA,QAAG,CAAC0H,QAAD,IAAa,CAACA,QAAQ,CAACC,IAA1B,EAAgCD,QAAQ,GAAG/G,OAAO,CAACiH,OAAR,CAAgB5H,EAAhB,CAAX;AACnC;;AAED,SAAO0H,QAAQ,CAACC,IAAT,CAAc,YAAW;AAC5B3H,IAAAA,EAAE,CAAC+H,IAAH,CAAQ,cAAR,EAAwB;AACpB9H,MAAAA,IAAI,EAAEA,IADc;AAEpBC,MAAAA,MAAM,EAAEA;AAFY,KAAxB;AAKA,WAAOF,EAAP;AACH,GAPM,CAAP;AAQH;;AAED,SAASsiB,QAAT,CAAkBtiB,EAAlB,EAAsB0gB,WAAtB,EAAmCsB,WAAnC,EAAgDE,SAAhD,EAA2DnW,UAA3D,EAAuEsW,eAAvE,EAAwF;AACpF,MAAIY,eAAe,GAAGvC,WAAW,CAACjf,MAAZ,KAAuBugB,WAAW,CAACvgB,MAAzD;;AAEA,MAAG,CAACsK,UAAD,IAAe,CAACkX,eAAnB,EAAoC;AAChC,WAAO;AACHlR,MAAAA,UAAU,EAAE,IADT;AAEHF,MAAAA,IAAI,EAAE;AAFH,KAAP;AAIH;;AAED,MAAID,KAAK,GAAGjS,SAAS,CAACqU,UAAV,EAAZ;AACApC,EAAAA,KAAK,CAACkR,MAAN,GAAe,EAAf;AACAlR,EAAAA,KAAK,CAACsR,QAAN,GAAiB,CAAjB;AACAtR,EAAAA,KAAK,CAACuR,YAAN,GAAqB,CAArB;AAEA,MAAIngB,CAAJ,EAAOC,KAAP;;AAEA,WAASkT,iBAAT,CAA2B1L,KAA3B,EAAkC;AAC9B,QAAIgE,GAAG,GAAG5P,UAAU,CAACsX,iBAAX,CAA6BlT,KAA7B,EAAoCwH,KAApC,CAAV;;AACA,QAAG,CAACxH,KAAK,CAACmgB,OAAN,CAAcC,UAAf,IAA6B5U,GAAG,CAACiU,IAApC,EAA0C;AACtCjU,MAAAA,GAAG,CAACiU,IAAJ,GAAW,KAAX;AACH;;AACD,WAAOjU,GAAP;AACH;;AAED,MAAI6U,QAAQ,GAAG;AACXC,IAAAA,YAAY,EAAEpN,iBADH;AAEXvE,IAAAA,KAAK,EAAEA,KAFI;AAGXsQ,IAAAA,SAAS,EAAEA,SAHA;AAIXnW,IAAAA,UAAU,EAAEA,UAJD;AAKXsW,IAAAA,eAAe,EAAEA,eALN;AAMXriB,IAAAA,EAAE,EAAEA;AANO,GAAf;AASA,MAAIwjB,QAAQ,GAAG,EAAf;;AAEA,OAAIxgB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG0d,WAAW,CAACjf,MAA3B,EAAmCuB,CAAC,EAApC,EAAwC;AACpC,QAAGgf,WAAW,CAAChf,CAAD,CAAd,EAAmB;AACfC,MAAAA,KAAK,GAAG+e,WAAW,CAAChf,CAAD,CAAX,CAAemS,UAAvB;AACA,UAAGrW,KAAK,CAAC2kB,qBAAN,CAA4BxgB,KAA5B,CAAH,EAAuCA,KAAK,GAAG+e,WAAW,CAAChf,CAAD,CAAnB;AACvC,UAAGwgB,QAAQ,CAACvgB,KAAK,CAACsD,GAAP,CAAX,EAAwB;AACxBid,MAAAA,QAAQ,CAACvgB,KAAK,CAACsD,GAAP,CAAR,GAAsB,CAAtB;AAEAmd,MAAAA,YAAY,CAAChD,WAAW,CAAC1d,CAAD,CAAX,CAAemS,UAAhB,EAA4BlS,KAA5B,EAAmC,EAAnC,EAAuCqgB,QAAvC,CAAZ;AACH;AACJ;;AAED,MAAG1R,KAAK,CAACC,IAAN,IAAcD,KAAK,CAAC7R,IAAvB,EAA6B;AACzB6R,IAAAA,KAAK,CAACG,UAAN,GAAmB,IAAnB;AACH;;AAED,MAAGhG,UAAU,IAAI6F,KAAK,CAACsR,QAApB,IAAgCtR,KAAK,CAACuR,YAAzC,EAAuD;AACnDvR,IAAAA,KAAK,CAAC8Q,IAAN,GAAc9Q,KAAK,CAACsR,QAAN,KAAmBtR,KAAK,CAACuR,YAA1B,IAA2CF,eAA3C,GAA6D,KAA7D,GAAqE,MAAlF;AACH;;AAED,SAAOrR,KAAP;AACH;;AAED,SAASwQ,UAAT,CAAoBpiB,EAApB,EAAwB2gB,aAAxB,EAAuCsB,aAAvC,EAAsDC,SAAtD,EAAiEnW,UAAjE,EAA6E;AACzE,MAAI6F,KAAK,GAAGjS,SAAS,CAAC0b,WAAV,EAAZ;AACAzJ,EAAAA,KAAK,CAACkR,MAAN,GAAe,EAAf;AACAlR,EAAAA,KAAK,CAACsH,aAAN,GAAsB,EAAtB;AACAtH,EAAAA,KAAK,CAACsR,QAAN,GAAiB,CAAjB;AACAtR,EAAAA,KAAK,CAACuR,YAAN,GAAqB,CAArB;;AAEA,WAASjH,kBAAT,CAA4BzR,KAA5B,EAAmC;AAC/B,WAAO5L,UAAU,CAACqd,kBAAX,CAA8B+F,aAA9B,EAA6CxX,KAA7C,CAAP;AACH;;AAED,MAAI6Y,QAAQ,GAAG;AACXC,IAAAA,YAAY,EAAErH,kBADH;AAEXtK,IAAAA,KAAK,EAAEA,KAFI;AAGXsQ,IAAAA,SAAS,EAAEA,SAHA;AAIXnW,IAAAA,UAAU,EAAEA,UAJD;AAKX/L,IAAAA,EAAE,EAAEA;AALO,GAAf;AAQA0jB,EAAAA,YAAY,CAAC/C,aAAD,EAAgBsB,aAAhB,EAA+B,EAA/B,EAAmCqB,QAAnC,CAAZ;;AAEA,MAAG1R,KAAK,CAAC7R,IAAN,IAAc6R,KAAK,CAACC,IAAvB,EAA6B;AACzBD,IAAAA,KAAK,CAACgH,YAAN,GAAqB,IAArB;AACH;;AAED,MAAG7M,UAAU,IAAI6F,KAAK,CAACsR,QAApB,IAAgCtR,KAAK,CAACuR,YAAzC,EAAuD;AACnDvR,IAAAA,KAAK,CAAC8Q,IAAN,GAAa9Q,KAAK,CAACsR,QAAN,KAAmBtR,KAAK,CAACuR,YAAzB,GAAwC,KAAxC,GAAgD,MAA7D;AACH;;AAED,SAAOvR,KAAP;AACH;;AAED,SAAS8R,YAAT,CAAsBC,YAAtB,EAAoCC,YAApC,EAAkDC,UAAlD,EAA8DC,IAA9D,EAAoE;AAChE,MAAIhO,SAAJ,EAAe1R,GAAf,EAAoBuK,IAApB;AAEA,MAAI4U,YAAY,GAAGO,IAAI,CAACP,YAAxB;AACA,MAAI3R,KAAK,GAAGkS,IAAI,CAAClS,KAAjB;AACA,MAAIsQ,SAAS,GAAG4B,IAAI,CAAC5B,SAArB;AACA,MAAI6B,OAAO,GAAGD,IAAI,CAACC,OAAnB;AACA,MAAIC,UAAU,GAAGF,IAAI,CAACE,UAAtB;;AAEA,WAASxS,OAAT,GAAmB;AACf,QAAIkM,QAAQ,GAAG5H,SAAS,CAAC4H,QAAzB;;AACA,QAAGqG,OAAO,IAAIrG,QAAQ,CAACzQ,OAAT,CAAiB,WAAjB,MAAkC,CAAC,CAAjD,EAAoD;AAChDzO,MAAAA,GAAG,CAACylB,UAAJ,CAAerS,KAAK,CAACkR,MAAN,CAAaiB,OAAb,CAAf,EAAsCC,UAAtC;AACA;AACH;;AACDrkB,IAAAA,SAAS,CAAC8N,MAAV,CAAiBmE,KAAjB,EAAwBkE,SAAxB;;AAEA,QAAG4H,QAAQ,KAAK,MAAhB,EAAwB;AACpB9L,MAAAA,KAAK,CAACsR,QAAN;AACH,KAVc,CAYf;;;AACA,QAAGY,IAAI,CAAC/X,UAAL,IAAmB+J,SAAS,CAAC4M,IAAhC,EAAsC;AAClC9Q,MAAAA,KAAK,CAACuR,YAAN;AACH,KAfc,CAiBf;;;AACA,QAAG1I,WAAW,CAACnC,IAAZ,CAAiB3J,IAAjB,KAA0B+L,eAAe,CAACpC,IAAhB,CAAqB3J,IAArB,CAA7B,EAAyD;AACrDiD,MAAAA,KAAK,CAACsH,aAAN,CAAoB2K,UAAU,CAAC,CAAD,CAA9B,IAAqC,CAArC;AACH,KApBc,CAsBf;;;AACA,QAAGlJ,YAAY,CAACrC,IAAb,CAAkB3J,IAAlB,CAAH,EAA4B;AACxBlQ,MAAAA,cAAc,CAACmlB,YAAD,EAAe,cAAf,CAAd,CAA6ClV,GAA7C,CAAiD,IAAjD;AACH,KAzBc,CA2Bf;;;AACA,QAAGtK,GAAG,KAAK,cAAX,EAA2B;AACvBwN,MAAAA,KAAK,CAACyQ,eAAN,GAAwB,CAAxB;AACH;AACJ;;AAED,WAAS6B,uBAAT,CAAiCpO,SAAjC,EAA4C;AACxC,WAAOA,SAAS,CAACqO,OAAV,KAAsB,YAAtB,IAAsCrO,SAAS,CAAC+B,OAAvD;AACH;;AAED,OAAIzT,GAAJ,IAAWuf,YAAX,EAAyB;AACrB;AACA,QAAG/R,KAAK,CAACC,IAAN,IAAc,CAACiS,IAAI,CAAC/X,UAAvB,EAAmC;AAEnC,QAAI8J,MAAM,GAAG8N,YAAY,CAACvf,GAAD,CAAzB;AACA,QAAI8O,MAAM,GAAG0Q,YAAY,CAACxf,GAAD,CAAzB;AACA,QAAIqG,KAAK,GAAGoZ,UAAU,CAACnU,MAAX,CAAkBtL,GAAlB,CAAZ;AACAuK,IAAAA,IAAI,GAAGlE,KAAK,CAACqR,IAAN,CAAW,GAAX,CAAP;AAEA,QAAG1X,GAAG,CAAC2R,MAAJ,CAAW,CAAX,MAAkB,GAAlB,IAAyB,OAAOF,MAAP,KAAkB,UAA3C,IAAyDA,MAAM,KAAK3C,MAAvE,EAA+E,SAT1D,CAWrB;AACA;AACA;;AACA,QAAG,CAAC9O,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,OAA5B,KAAwCyf,UAAU,CAAC,CAAD,CAAV,KAAkB,KAA7D,EAAoE;AAChE,UAAIO,QAAQ,GAAGR,YAAY,CAACS,QAA5B;AACA,UAAGD,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,OAApC,IAA+C,CAACA,QAAnD,EAA6D;AAChE,KAjBoB,CAkBrB;AACA;;;AACA,QAAGhgB,GAAG,KAAK,OAAR,IAAmBwf,YAAY,CAAChK,SAAnC,EAA8C;AAC9C,QAAG,CAACxV,GAAG,KAAK,MAAR,IAAkBA,GAAG,KAAK,MAA3B,KAAsCwf,YAAY,CAACvd,IAAb,KAAsB,eAA/D,EAAgF;AAEhFyP,IAAAA,SAAS,GAAGyN,YAAY,CAAC9Y,KAAD,CAAxB,CAvBqB,CAyBrB;;AACA,QAAG,CAACqL,SAAJ,EAAe;AAEf,QAAGA,SAAS,CAACwO,cAAV,IAA4B/D,IAAI,CAACC,SAAL,CAAe3K,MAAf,MAA2B0K,IAAI,CAACC,SAAL,CAAetN,MAAf,CAA1D,EAAkF;AAElF,QAAIiR,OAAO,GAAGrO,SAAS,CAACqO,OAAxB;AACA,QAAInhB,CAAJ;AAEA,QAAIuhB,cAAc,GAAGL,uBAAuB,CAACpO,SAAD,CAA5C;AACA,QAAI0O,QAAQ,GAAGnjB,KAAK,CAACC,OAAN,CAAcuU,MAAd,CAAf;AACA,QAAI4O,QAAQ,GAAGpjB,KAAK,CAACC,OAAN,CAAc4R,MAAd,CAAf,CAnCqB,CAqCrB;AACA;;AACA,QAAGsR,QAAQ,IAAIC,QAAf,EAAyB;AACrB,UAAIC,QAAQ,GAAG,YAAYtgB,GAA3B;AACA,UAAIugB,QAAQ,GAAGhB,YAAY,CAACe,QAAD,CAA3B;AACA,UAAIE,QAAQ,GAAGhB,YAAY,CAACc,QAAD,CAA3B;AACA,UAAGrjB,KAAK,CAACC,OAAN,CAAcqjB,QAAd,KAA2BA,QAAQ,KAAKC,QAA3C,EAAqD;AACxD;;AAED,QAAG1R,MAAM,KAAK9J,SAAd,EAAyB;AACrB,UAAGmb,cAAc,IAAIC,QAArB,EAA+B5S,KAAK,CAACC,IAAN,GAAa,IAAb,CAA/B,KACKL,OAAO;AACf,KAHD,MAGO,IAAGsE,SAAS,CAAC+O,gBAAb,EAA+B;AAClC,UAAIC,gBAAgB,GAAG,EAAvB;AACA,UAAIC,YAAY,GAAG,KAAnB;AACA,UAAG,CAAChB,OAAJ,EAAanS,KAAK,CAACkR,MAAN,CAAa1e,GAAb,IAAoB0gB,gBAApB;AAEb,UAAIE,MAAM,GAAG5f,IAAI,CAAC6f,GAAL,CAASpP,MAAM,CAACpU,MAAhB,EAAwByR,MAAM,CAACzR,MAA/B,CAAb;AACA,UAAI4R,MAAM,GAAGjO,IAAI,CAACkO,GAAL,CAASuC,MAAM,CAACpU,MAAhB,EAAwByR,MAAM,CAACzR,MAA/B,CAAb;;AACA,UAAGujB,MAAM,KAAK3R,MAAd,EAAsB;AAClB,YAAGyC,SAAS,CAAC4H,QAAV,KAAuB,WAA1B,EAAuC;AACnCqH,UAAAA,YAAY,GAAG,IAAf;AACH,SAFD,MAEO;AACHvT,UAAAA,OAAO;AACP;AACH;AACJ;;AAED,WAAIxO,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGgiB,MAAf,EAAuBhiB,CAAC,EAAxB,EAA4B;AACxB0gB,QAAAA,YAAY,CAAC7N,MAAM,CAAC7S,CAAD,CAAP,EAAYkQ,MAAM,CAAClQ,CAAD,CAAlB,EAAuByH,KAAK,CAACiF,MAAN,CAAa1M,CAAb,CAAvB,EACR;AACAxE,QAAAA,GAAG,CAACmF,UAAJ,CAAe;AAACogB,UAAAA,OAAO,EAAE3f,GAAV;AAAe4f,UAAAA,UAAU,EAAEhhB;AAA3B,SAAf,EAA8C8gB,IAA9C,CAFQ,CAAZ;AAGH,OApBiC,CAsBlC;AACA;AACA;;;AACA,UAAGiB,YAAH,EAAiB;AACb,aAAI/hB,CAAC,GAAGgiB,MAAR,EAAgBhiB,CAAC,GAAGqQ,MAApB,EAA4BrQ,CAAC,EAA7B,EAAiC;AAC7B8hB,UAAAA,gBAAgB,CAACnjB,IAAjB,CAAsBqB,CAAtB;AACH;AACJ;AACJ,KA9BM,MA8BA,IAAG,CAACmhB,OAAD,IAAY3lB,GAAG,CAAC+B,aAAJ,CAAkBsV,MAAlB,CAAf,EAA0C;AAC7C6N,MAAAA,YAAY,CAAC7N,MAAD,EAAS3C,MAAT,EAAiBzI,KAAjB,EAAwBqZ,IAAxB,CAAZ;AACH,KAFM,MAEA,IAAGS,cAAH,EAAmB;AACtB,UAAGC,QAAQ,IAAIC,QAAf,EAAyB;AACrB;AACA;AACA,YAAGvC,SAAH,EAAc;AACVtQ,UAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACH,SALoB,CAOrB;;;AACA,YAAGqQ,SAAS,IAAI4B,IAAI,CAACzB,eAArB,EAAsC;AAClC7Q,UAAAA,OAAO;AACV;AACJ,OAXD,MAWO,IAAGgT,QAAQ,KAAKC,QAAhB,EAA0B;AAC7B7S,QAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACH,OAFM,MAEAL,OAAO;AACjB,KAfM,MAeA,IAAGgT,QAAQ,IAAIC,QAAf,EAAyB;AAC5B;AACA;AACA;AACA;AACA,UAAG5O,MAAM,CAACpU,MAAP,KAAkByR,MAAM,CAACzR,MAAzB,IAAmCyjB,MAAM,CAACrP,MAAD,CAAN,KAAmBqP,MAAM,CAAChS,MAAD,CAA/D,EAAyE;AACrE1B,QAAAA,OAAO;AACV;AACJ,KARM,MAQA;AACHA,MAAAA,OAAO;AACV;AACJ;;AAED,OAAIpN,GAAJ,IAAWwf,YAAX,EAAyB;AACrB,QAAG,EAAExf,GAAG,IAAIuf,YAAP,IAAuBvf,GAAG,CAAC2R,MAAJ,CAAW,CAAX,MAAkB,GAAzC,IAAgD,OAAO6N,YAAY,CAACxf,GAAD,CAAnB,KAA6B,UAA/E,CAAH,EAA+F;AAC3F0R,MAAAA,SAAS,GAAGyN,YAAY,CAACM,UAAU,CAACnU,MAAX,CAAkBtL,GAAlB,CAAD,CAAxB;;AAEA,UAAG8f,uBAAuB,CAACpO,SAAD,CAAvB,IAAsCzU,KAAK,CAACC,OAAN,CAAcsiB,YAAY,CAACxf,GAAD,CAA1B,CAAzC,EAA2E;AACvEwN,QAAAA,KAAK,CAACC,IAAN,GAAa,IAAb;AACA;AACH,OAHD,MAGOL,OAAO;AACjB;AACJ;AACJ;AAED;;;;;AAGA,SAASsQ,UAAT,CAAoBD,SAApB,EAA+BsD,SAA/B,EAA0C;AACtC,MAAI/gB,GAAJ;;AAEA,OAAIA,GAAJ,IAAWyd,SAAX,EAAsB;AAClB,QAAGzd,GAAG,CAAC2R,MAAJ,CAAW,CAAX,MAAkB,GAArB,EAA0B;AAC1B,QAAIF,MAAM,GAAGgM,SAAS,CAACzd,GAAD,CAAtB;AACA,QAAI8O,MAAM,GAAGiS,SAAS,CAAC/gB,GAAD,CAAtB;;AACA,QAAGyR,MAAM,KAAK3C,MAAd,EAAsB;AAClB,UAAG1U,GAAG,CAAC+B,aAAJ,CAAkBsV,MAAlB,KAA6BrX,GAAG,CAAC+B,aAAJ,CAAkB2S,MAAlB,CAAhC,EAA2D;AACvD,YAAG4O,UAAU,CAACjM,MAAD,EAAS3C,MAAT,CAAb,EAA+B;AAC3B,iBAAO,IAAP;AACH;AACJ,OAJD,MAIO,IAAG7R,KAAK,CAACC,OAAN,CAAcuU,MAAd,KAAyBxU,KAAK,CAACC,OAAN,CAAc4R,MAAd,CAA5B,EAAmD;AACtD,YAAG2C,MAAM,CAACpU,MAAP,KAAkByR,MAAM,CAACzR,MAA5B,EAAoC;AAChC,iBAAO,IAAP;AACH;;AACD,aAAI,IAAIuB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG6S,MAAM,CAACpU,MAA1B,EAAkCuB,CAAC,EAAnC,EAAuC;AACnC,cAAG6S,MAAM,CAAC7S,CAAD,CAAN,KAAckQ,MAAM,CAAClQ,CAAD,CAAvB,EAA4B;AACxB,gBAAGxE,GAAG,CAAC+B,aAAJ,CAAkBsV,MAAM,CAAC7S,CAAD,CAAxB,KAAgCxE,GAAG,CAAC+B,aAAJ,CAAkB2S,MAAM,CAAClQ,CAAD,CAAxB,CAAnC,EAAiE;AAC7D,kBAAG8e,UAAU,CAACjM,MAAM,CAAC7S,CAAD,CAAP,EAAYkQ,MAAM,CAAClQ,CAAD,CAAlB,CAAb,EAAqC;AACjC,uBAAO,IAAP;AACH;AACJ,aAJD,MAIO;AACH,qBAAO,IAAP;AACH;AACJ;AACJ;AACJ,OAfM,MAeA;AACH,eAAO,IAAP;AACH;AACJ;AACJ;AACJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,SAASoiB,OAAT,CAAiBplB,EAAjB,EAAqBqlB,2BAArB,EAAkDC,aAAlD,EAAiE;AAC7DtlB,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;;AAEA,MAAG,CAACxB,GAAG,CAACqC,SAAJ,CAAcb,EAAd,CAAJ,EAAuB;AACnB,UAAM,IAAIqM,KAAJ,CACF,wCAAwCrM,EAAxC,GAA6C,qCAA7C,GACA,8DADA,GAEA,wCAHE,CAAN;AAKH;;AAED,MAAIulB,KAAK,GAAGvlB,EAAE,CAACwiB,eAAf,CAX6D,CAa7D;AACA;;AACA,MAAG,CAAC+C,KAAK,CAACC,WAAV,EAAuB;AACnBD,IAAAA,KAAK,CAACC,WAAN,GAAoB,EAApB;AACH;;AAEDF,EAAAA,aAAa,GAAGxmB,KAAK,CAAC2mB,uBAAN,CAA8BH,aAA9B,CAAhB;AACA,MAAII,cAAc,GAAGJ,aAAa,CAACvZ,UAAnC;AACA,MAAI4Z,SAAS,GAAGL,aAAa,CAACM,KAA9B,CArB6D,CAuB7D;AACA;AACA;AACA;;AACA,MAAGL,KAAK,CAACM,gBAAN,KAA2Bzc,SAA9B,EAAyC;AACrCmc,IAAAA,KAAK,CAACM,gBAAN,GAAyB,CAAzB;AACH;;AAED,WAASC,iBAAT,CAA2B9iB,CAA3B,EAA8B;AAC1B,QAAG3B,KAAK,CAACC,OAAN,CAAcokB,cAAd,CAAH,EAAkC;AAC9B,UAAG1iB,CAAC,IAAI0iB,cAAc,CAACjkB,MAAvB,EAA+B;AAC3B,eAAOikB,cAAc,CAAC,CAAD,CAArB;AACH,OAFD,MAEO;AACH,eAAOA,cAAc,CAAC1iB,CAAD,CAArB;AACH;AACJ,KAND,MAMO;AACH,aAAO0iB,cAAP;AACH;AACJ;;AAED,WAASK,YAAT,CAAsB/iB,CAAtB,EAAyB;AACrB,QAAG3B,KAAK,CAACC,OAAN,CAAcqkB,SAAd,CAAH,EAA6B;AACzB,UAAG3iB,CAAC,IAAI2iB,SAAS,CAAClkB,MAAlB,EAA0B;AACtB,eAAOkkB,SAAS,CAAC,CAAD,CAAhB;AACH,OAFD,MAEO;AACH,eAAOA,SAAS,CAAC3iB,CAAD,CAAhB;AACH;AACJ,KAND,MAMO;AACH,aAAO2iB,SAAP;AACH;AACJ,GArD4D,CAuD7D;AACA;AACA;AACA;AACA;;;AACA,WAASK,iBAAT,CAA2BC,EAA3B,EAA+BC,CAA/B,EAAkC;AAC9B,QAAIC,GAAG,GAAG,CAAV;AACA,WAAO,YAAW;AACd,UAAGF,EAAE,IAAI,EAAEE,GAAF,KAAUD,CAAnB,EAAsB;AAClB,eAAOD,EAAE,EAAT;AACH;AACJ,KAJD;AAKH;;AAED,SAAO,IAAItlB,OAAJ,CAAY,UAASiH,OAAT,EAAkBhH,MAAlB,EAA0B;AACzC,aAASwlB,qBAAT,GAAiC;AAC7B,UAAGb,KAAK,CAACC,WAAN,CAAkB/jB,MAAlB,KAA6B,CAAhC,EAAmC;AAC/B;AACH;;AAED,aAAM8jB,KAAK,CAACC,WAAN,CAAkB/jB,MAAxB,EAAgC;AAC5B,YAAI4kB,IAAI,GAAGd,KAAK,CAACC,WAAN,CAAkB1F,GAAlB,EAAX;;AACA,YAAGuG,IAAI,CAACC,WAAR,EAAqB;AACjBD,UAAAA,IAAI,CAACC,WAAL;AACH;AACJ;;AAEDtmB,MAAAA,EAAE,CAAC+H,IAAH,CAAQ,6BAAR,EAAuC,EAAvC;AACH;;AAED,aAASwe,WAAT,CAAqBC,SAArB,EAAgC;AAC5B,UAAGA,SAAS,CAAC/kB,MAAV,KAAqB,CAAxB,EAA2B;;AAE3B,WAAI,IAAIuB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGwjB,SAAS,CAAC/kB,MAA7B,EAAqCuB,CAAC,EAAtC,EAA0C;AACtC,YAAIyjB,aAAJ;;AAEA,YAAGD,SAAS,CAACxjB,CAAD,CAAT,CAAaqD,IAAb,KAAsB,QAAzB,EAAmC;AAC/B;AACAogB,UAAAA,aAAa,GAAG3nB,KAAK,CAAC4nB,YAAN,CAAmB1mB,EAAnB,EAAuBwmB,SAAS,CAACxjB,CAAD,CAAT,CAAa2jB,IAApC,CAAhB;AACH,SAHD,MAGO;AACH;AACA;AACAF,UAAAA,aAAa,GAAGD,SAAS,CAACxjB,CAAD,CAAT,CAAa/C,IAA7B;AACH;;AAED,YAAI0lB,SAAS,GAAGI,YAAY,CAAC/iB,CAAD,CAA5B;AACA,YAAI0iB,cAAc,GAAGI,iBAAiB,CAAC9iB,CAAD,CAAtC,CAbsC,CAetC;AACA;;AACA0iB,QAAAA,cAAc,CAAC1Z,QAAf,GAA0B5G,IAAI,CAAC6f,GAAL,CAASS,cAAc,CAAC1Z,QAAxB,EAAkC2Z,SAAS,CAAC3Z,QAA5C,CAA1B;AAEA,YAAI4a,SAAS,GAAG;AACZhB,UAAAA,KAAK,EAAEa,aADK;AAEZE,UAAAA,IAAI,EAAEH,SAAS,CAACxjB,CAAD,CAAT,CAAa2jB,IAFP;AAGZhB,UAAAA,SAAS,EAAEA,SAHC;AAIZD,UAAAA,cAAc,EAAEA;AAJJ,SAAhB;;AAMA,YAAG1iB,CAAC,KAAKwjB,SAAS,CAAC/kB,MAAV,GAAmB,CAA5B,EAA+B;AAC3B;AACA;AACA;AACA;AACA;AACAmlB,UAAAA,SAAS,CAACC,UAAV,GAAuBb,iBAAiB,CAACpe,OAAD,EAAU,CAAV,CAAxC;AACAgf,UAAAA,SAAS,CAACN,WAAV,GAAwB1lB,MAAxB;AACH;;AAED2kB,QAAAA,KAAK,CAACC,WAAN,CAAkB7jB,IAAlB,CAAuBilB,SAAvB;AACH,OAvC2B,CAyC5B;AACA;AACA;AACA;;;AACA,UAAGtB,aAAa,CAACwB,IAAd,KAAuB,WAA1B,EAAuC;AACnCvB,QAAAA,KAAK,CAACwB,YAAN,GAAqB,CAACC,QAAtB;AACH,OA/C2B,CAiD5B;AACA;AACA;AACA;AACA;;;AACA,UAAG,CAACzB,KAAK,CAAC0B,aAAV,EAAyB;AACrBC,QAAAA,kBAAkB;AACrB;AACJ;;AAED,aAASC,iBAAT,GAA6B;AACzBnnB,MAAAA,EAAE,CAAC+H,IAAH,CAAQ,iBAAR,EADyB,CAGzB;;AACAxE,MAAAA,MAAM,CAAC6jB,oBAAP,CAA4B7B,KAAK,CAAC0B,aAAlC;AACA1B,MAAAA,KAAK,CAAC0B,aAAN,GAAsB,IAAtB;AACH;;AAED,aAASL,SAAT,GAAqB;AACjB,UAAGrB,KAAK,CAAC8B,aAAN,IAAuB9B,KAAK,CAAC8B,aAAN,CAAoBR,UAA9C,EAA0D;AACtD;AACA;AACAtB,QAAAA,KAAK,CAAC8B,aAAN,CAAoBR,UAApB;AACH;;AAED,UAAIS,QAAQ,GAAG/B,KAAK,CAAC8B,aAAN,GAAsB9B,KAAK,CAACC,WAAN,CAAkB+B,KAAlB,EAArC;;AAEA,UAAGD,QAAH,EAAa;AACT;AACA;AACA;AACA,YAAIE,UAAU,GAAGF,QAAQ,CAACX,IAAT,GAAgBW,QAAQ,CAACX,IAAT,CAAcc,QAAd,EAAhB,GAA2C,IAA5D;AACAznB,QAAAA,EAAE,CAACiC,WAAH,CAAeolB,aAAf,GAA+BG,UAA/B;AAEAjC,QAAAA,KAAK,CAACwB,YAAN,GAAqBW,IAAI,CAACC,GAAL,EAArB;AACApC,QAAAA,KAAK,CAACqC,WAAN,GAAoBN,QAAQ,CAAC3B,SAAT,CAAmB3Z,QAAvC,CARS,CAUT;AACA;AACA;;AACAlN,QAAAA,KAAK,CAACiN,UAAN,CAAiB/L,EAAjB,EACIsnB,QAAQ,CAAC1B,KAAT,CAAe3lB,IADnB,EAEIqnB,QAAQ,CAAC1B,KAAT,CAAe1lB,MAFnB,EAGIT,OAAO,CAACgS,kBAAR,CAA2BzR,EAA3B,EAA+BsnB,QAAQ,CAAC1B,KAAT,CAAetY,MAA9C,CAHJ,EAIIga,QAAQ,CAAC3B,SAJb,EAKI2B,QAAQ,CAAC5B,cALb,EAME/d,IANF,CAMO,YAAW;AACd,cAAG2f,QAAQ,CAACT,UAAZ,EAAwB;AACpBS,YAAAA,QAAQ,CAACT,UAAT;AACH;AACJ,SAVD;AAYA7mB,QAAAA,EAAE,CAAC+H,IAAH,CAAQ,uBAAR,EAAiC;AAC7B4e,UAAAA,IAAI,EAAEa,UADuB;AAE7B5B,UAAAA,KAAK,EAAE0B,QAAQ,CAAC1B,KAFa;AAG7BiC,UAAAA,SAAS,EAAE;AACPjC,YAAAA,KAAK,EAAE0B,QAAQ,CAAC3B,SADT;AAEP5Z,YAAAA,UAAU,EAAEub,QAAQ,CAAC5B;AAFd;AAHkB,SAAjC;AAQH,OAjCD,MAiCO;AACH;AACAyB,QAAAA,iBAAiB;AACpB;AACJ;;AAED,aAASD,kBAAT,GAA8B;AAC1BlnB,MAAAA,EAAE,CAAC+H,IAAH,CAAQ,kBAAR,EAD0B,CAG1B;AACA;;AACAwd,MAAAA,KAAK,CAACwB,YAAN,GAAqB,CAACC,QAAtB;AACAzB,MAAAA,KAAK,CAACqC,WAAN,GAAoB,CAApB;AACArC,MAAAA,KAAK,CAACuC,mBAAN,GAA4B,CAA5B;AACAvC,MAAAA,KAAK,CAAC8B,aAAN,GAAsB,IAAtB;;AAEA,UAAIU,OAAO,GAAG,SAAVA,OAAU,GAAW;AACrB;AACA;AACAxC,QAAAA,KAAK,CAAC0B,aAAN,GAAsB1jB,MAAM,CAACykB,qBAAP,CAA6BD,OAA7B,CAAtB,CAHqB,CAKrB;;AACA,YAAGL,IAAI,CAACC,GAAL,KAAapC,KAAK,CAACwB,YAAnB,GAAkCxB,KAAK,CAACqC,WAA3C,EAAwD;AACpDhB,UAAAA,SAAS;AACZ;AACJ,OATD;;AAWAmB,MAAAA,OAAO;AACV,KAzJwC,CA2JzC;AACA;;;AACA,QAAIE,aAAa,GAAG,CAApB;;AACA,aAASC,mBAAT,CAA6BtC,KAA7B,EAAoC;AAChC,UAAGvkB,KAAK,CAACC,OAAN,CAAcokB,cAAd,CAAH,EAAkC;AAC9B,YAAGuC,aAAa,IAAIvC,cAAc,CAACjkB,MAAnC,EAA2C;AACvCmkB,UAAAA,KAAK,CAACF,cAAN,GAAuBA,cAAc,CAACuC,aAAD,CAArC;AACH,SAFD,MAEO;AACHrC,UAAAA,KAAK,CAACF,cAAN,GAAuBA,cAAc,CAAC,CAAD,CAArC;AACH;AACJ,OAND,MAMO;AACHE,QAAAA,KAAK,CAACF,cAAN,GAAuBA,cAAvB;AACH;;AACDuC,MAAAA,aAAa;AACb,aAAOrC,KAAP;AACH,KA1KwC,CA4KzC;;;AACA,QAAI5iB,CAAJ,EAAO4iB,KAAP;AACA,QAAIY,SAAS,GAAG,EAAhB;AACA,QAAI2B,SAAS,GAAG9C,2BAA2B,KAAKjc,SAAhC,IAA6Cic,2BAA2B,KAAK,IAA7F;AACA,QAAI+C,YAAY,GAAG/mB,KAAK,CAACC,OAAN,CAAc+jB,2BAAd,CAAnB;AACA,QAAIgD,aAAa,GAAG,CAACF,SAAD,IAAc,CAACC,YAAf,IAA+B5pB,GAAG,CAAC+B,aAAJ,CAAkB8kB,2BAAlB,CAAnD;;AAEA,QAAGgD,aAAH,EAAkB;AACd;AACA7B,MAAAA,SAAS,CAAC7kB,IAAV,CAAe;AACX0E,QAAAA,IAAI,EAAE,QADK;AAEXpG,QAAAA,IAAI,EAAEioB,mBAAmB,CAAC1pB,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmB0hB,2BAAnB,CAAD;AAFd,OAAf;AAIH,KAND,MAMO,IAAG8C,SAAS,IAAI,CAAC,QAAD,EAAW,QAAX,EAAqBlb,OAArB,CAA6B,OAAOoY,2BAApC,MAAqE,CAAC,CAAtF,EAAyF;AAC5F;AACA;AACA,WAAIriB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGuiB,KAAK,CAAC+C,OAAN,CAAc7mB,MAA7B,EAAqCuB,CAAC,EAAtC,EAA0C;AACtC4iB,QAAAA,KAAK,GAAGL,KAAK,CAAC+C,OAAN,CAActlB,CAAd,CAAR;AAEA,YAAG,CAAC4iB,KAAJ,EAAW;;AAEX,YAAGuC,SAAS,IAAIjD,MAAM,CAACU,KAAK,CAACzH,KAAP,CAAN,KAAwB+G,MAAM,CAACG,2BAAD,CAA9C,EAA6E;AACzEmB,UAAAA,SAAS,CAAC7kB,IAAV,CAAe;AACX0E,YAAAA,IAAI,EAAE,QADK;AAEXsgB,YAAAA,IAAI,EAAEzB,MAAM,CAACU,KAAK,CAACe,IAAP,CAFD;AAGX1mB,YAAAA,IAAI,EAAEioB,mBAAmB,CAAC;AAACvB,cAAAA,IAAI,EAAEf,KAAK,CAACe;AAAb,aAAD;AAHd,WAAf;AAKH;AACJ;AACJ,KAhBM,MAgBA,IAAGyB,YAAH,EAAiB;AACpB,WAAIplB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGqiB,2BAA2B,CAAC5jB,MAA3C,EAAmDuB,CAAC,EAApD,EAAwD;AACpD,YAAIulB,WAAW,GAAGlD,2BAA2B,CAACriB,CAAD,CAA7C;;AACA,YAAG,CAAC,QAAD,EAAW,QAAX,EAAqBiK,OAArB,CAA6B,OAAOsb,WAApC,MAAqD,CAAC,CAAzD,EAA4D;AACxDA,UAAAA,WAAW,GAAGrD,MAAM,CAACqD,WAAD,CAApB,CADwD,CAExD;;AACA/B,UAAAA,SAAS,CAAC7kB,IAAV,CAAe;AACX0E,YAAAA,IAAI,EAAE,QADK;AAEXsgB,YAAAA,IAAI,EAAE4B,WAFK;AAGXtoB,YAAAA,IAAI,EAAEioB,mBAAmB,CAAC;AAACvB,cAAAA,IAAI,EAAE4B;AAAP,aAAD;AAHd,WAAf;AAKH,SARD,MAQO,IAAG/pB,GAAG,CAAC+B,aAAJ,CAAkBgoB,WAAlB,CAAH,EAAmC;AACtC/B,UAAAA,SAAS,CAAC7kB,IAAV,CAAe;AACX0E,YAAAA,IAAI,EAAE,QADK;AAEXpG,YAAAA,IAAI,EAAEioB,mBAAmB,CAAC1pB,GAAG,CAACmF,UAAJ,CAAe,EAAf,EAAmB4kB,WAAnB,CAAD;AAFd,WAAf;AAIH;AACJ;AACJ,KA3NwC,CA6NzC;;;AACA,SAAIvlB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGwjB,SAAS,CAAC/kB,MAAzB,EAAiCuB,CAAC,EAAlC,EAAsC;AAClC4iB,MAAAA,KAAK,GAAGY,SAAS,CAACxjB,CAAD,CAAjB;;AACA,UAAG4iB,KAAK,CAACvf,IAAN,KAAe,QAAf,IAA2B,CAACkf,KAAK,CAACiD,UAAN,CAAiB5C,KAAK,CAAC3lB,IAAN,CAAW0mB,IAA5B,CAA/B,EAAkE;AAC9DnoB,QAAAA,GAAG,CAACsC,IAAJ,CAAS,wCAAwC8kB,KAAK,CAAC3lB,IAAN,CAAW0mB,IAAnD,GAA0D,GAAnE;AACA/lB,QAAAA,MAAM;AACN;AACH;AACJ,KArOwC,CAuOzC;AACA;;;AACA,QAAG,CAAC,MAAD,EAAS,WAAT,EAAsBqM,OAAtB,CAA8BqY,aAAa,CAACwB,IAA5C,MAAsD,CAAC,CAA1D,EAA6D;AACzDV,MAAAA,qBAAqB;AACxB;;AAED,QAAGd,aAAa,CAACmD,SAAd,KAA4B,SAA/B,EAA0C;AACtCjC,MAAAA,SAAS,CAAC1I,OAAV;AACH;;AAED,QAAI4K,YAAY,GAAG1oB,EAAE,CAACiC,WAAH,CAAeolB,aAAlC;;AACA,QAAGqB,YAAY,IAAIpD,aAAa,CAACqD,WAAjC,EAA8C;AAC1C,UAAIC,GAAG,GAAG,CAAC,CAAX;;AACA,WAAI5lB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGwjB,SAAS,CAAC/kB,MAAzB,EAAiCuB,CAAC,EAAlC,EAAsC;AAClC4iB,QAAAA,KAAK,GAAGY,SAAS,CAACxjB,CAAD,CAAjB;;AACA,YAAG4iB,KAAK,CAACvf,IAAN,KAAe,QAAf,IAA2Buf,KAAK,CAACe,IAAN,KAAe+B,YAA7C,EAA2D;AACvDE,UAAAA,GAAG,GAAG5lB,CAAN;AACA;AACH;AACJ;;AAED,UAAG4lB,GAAG,GAAG,CAAN,IAAWA,GAAG,GAAGpC,SAAS,CAAC/kB,MAAV,GAAmB,CAAvC,EAA0C;AACtC,YAAIonB,iBAAiB,GAAG,EAAxB;;AACA,aAAI7lB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGwjB,SAAS,CAAC/kB,MAAzB,EAAiCuB,CAAC,EAAlC,EAAsC;AAClC4iB,UAAAA,KAAK,GAAGY,SAAS,CAACxjB,CAAD,CAAjB;;AACA,cAAGwjB,SAAS,CAACxjB,CAAD,CAAT,CAAaqD,IAAb,KAAsB,QAAtB,IAAkCrD,CAAC,GAAG4lB,GAAzC,EAA8C;AAC1CC,YAAAA,iBAAiB,CAAClnB,IAAlB,CAAuBikB,KAAvB;AACH;AACJ;;AACDY,QAAAA,SAAS,GAAGqC,iBAAZ;AACH;AACJ;;AAED,QAAGrC,SAAS,CAAC/kB,MAAV,GAAmB,CAAtB,EAAyB;AACrB8kB,MAAAA,WAAW,CAACC,SAAD,CAAX;AACH,KAFD,MAEO;AACH;AACA;AACAxmB,MAAAA,EAAE,CAAC+H,IAAH,CAAQ,iBAAR;AACAH,MAAAA,OAAO;AACV;AACJ,GAhRM,CAAP;AAiRH;AAED;;;;;;;;;;;;;;;;;;;;;AAmBA,SAAS7G,SAAT,CAAmBf,EAAnB,EAAuBwmB,SAAvB,EAAkC/Z,OAAlC,EAA2C;AACvCzM,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;;AAEA,MAAGwmB,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKpd,SAAvC,EAAkD;AAC9C,WAAOzI,OAAO,CAACiH,OAAR,EAAP;AACH;;AAED,MAAG,CAACpJ,GAAG,CAACqC,SAAJ,CAAcb,EAAd,CAAJ,EAAuB;AACnB,UAAM,IAAIqM,KAAJ,CACF,wCAAwCrM,EAAxC,GAA6C,qCAA7C,GACA,+DADA,GAEA,wCAHE,CAAN;AAKH;;AAED,MAAIgD,CAAJ,EAAO4iB,KAAP,EAAc3X,CAAd,EAAiB2a,GAAjB;AACA,MAAIN,OAAO,GAAGtoB,EAAE,CAACwiB,eAAH,CAAmB8F,OAAjC;AACA,MAAIE,UAAU,GAAGxoB,EAAE,CAACwiB,eAAH,CAAmBgG,UAApC;;AAGA,MAAG,CAACnnB,KAAK,CAACC,OAAN,CAAcklB,SAAd,CAAJ,EAA8B;AAC1B,UAAM,IAAIna,KAAJ,CAAU,uEAAuEma,SAAjF,CAAN;AACH,GAtBsC,CAwBvC;AACA;AACA;AACA;AACA;;;AACA,MAAIsC,QAAQ,GAAGR,OAAO,CAAC7mB,MAAR,GAAiB+kB,SAAS,CAAC/kB,MAAV,GAAmB,CAAnD;AAEA,MAAIsnB,UAAU,GAAG,EAAjB;AACA,MAAIC,eAAe,GAAG,EAAtB;;AACA,OAAIhmB,CAAC,GAAGwjB,SAAS,CAAC/kB,MAAV,GAAmB,CAA3B,EAA8BuB,CAAC,IAAI,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;AACvC,QAAG,CAACxE,GAAG,CAAC+B,aAAJ,CAAkBimB,SAAS,CAACxjB,CAAD,CAA3B,CAAJ,EAAqC,SADE,CAGvC;AACA;;AACA,QAAIimB,UAAU,GAAGzC,SAAS,CAACxjB,CAAD,CAAT,CAAa2jB,IAA9B;AACA,QAAIA,IAAI,GAAG,CAAC6B,UAAU,CAACS,UAAD,CAAV,IAA0BD,eAAe,CAACC,UAAD,CAAzC,IAAyD,EAA1D,EAA8DtC,IAAzE;AACA,QAAIuC,OAAO,GAAG1C,SAAS,CAACxjB,CAAD,CAAT,CAAa2jB,IAA3B;AACA,QAAIwC,gBAAgB,GAAGX,UAAU,CAAC7B,IAAD,CAAV,IAAoBqC,eAAe,CAACrC,IAAD,CAA1D;;AAEA,QAAGA,IAAI,IAAIuC,OAAR,IAAmB,OAAOA,OAAP,KAAmB,QAAtC,IAAkDC,gBAAlD,IAAsEtpB,uBAAuB,GAAGC,4BAAnG,EAAiI;AAC7HD,MAAAA,uBAAuB;AAEvBrB,MAAAA,GAAG,CAACsC,IAAJ,CAAS,mCAAmC,CAAC0nB,UAAU,CAAC7B,IAAD,CAAV,IAAoBqC,eAAe,CAACrC,IAAD,CAApC,EAA4CA,IAA/E,GACL,8DADK,GAELA,IAFK,GAEE,0DAFF,GAGL,iEAHK,GAIL,aAJJ;;AAMA,UAAG9mB,uBAAuB,KAAKC,4BAA/B,EAA6D;AACzDtB,QAAAA,GAAG,CAACsC,IAAJ,CAAS,sEACL,kEADK,GAEL,2BAFJ;AAGH;AACJ;;AAEDkoB,IAAAA,eAAe,CAACC,UAAD,CAAf,GAA8B;AAACtC,MAAAA,IAAI,EAAEsC;AAAP,KAA9B;AAEAF,IAAAA,UAAU,CAACpnB,IAAX,CAAgB;AACZikB,MAAAA,KAAK,EAAE9mB,KAAK,CAACsqB,mBAAN,CAA0B5C,SAAS,CAACxjB,CAAD,CAAnC,CADK;AAEZ6J,MAAAA,KAAK,EAAGJ,OAAO,IAAIA,OAAO,CAACzJ,CAAD,CAAP,KAAeoG,SAA1B,IAAuCqD,OAAO,CAACzJ,CAAD,CAAP,KAAe,IAAvD,GAA+DyJ,OAAO,CAACzJ,CAAD,CAAtE,GAA4E8lB,QAAQ,GAAG9lB;AAFlF,KAAhB;AAIH,GAjEsC,CAmEvC;;;AACA+lB,EAAAA,UAAU,CAACnY,IAAX,CAAgB,UAASK,CAAT,EAAYC,CAAZ,EAAe;AAC3B,QAAGD,CAAC,CAACpE,KAAF,GAAUqE,CAAC,CAACrE,KAAf,EAAsB,OAAO,CAAC,CAAR;AACtB,QAAGoE,CAAC,CAACpE,KAAF,GAAUqE,CAAC,CAACrE,KAAf,EAAsB,OAAO,CAAP;AACtB,WAAO,CAAP;AACH,GAJD;AAMA,MAAIwc,GAAG,GAAG,EAAV;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,UAAU,GAAGjB,OAAO,CAAC7mB,MAAzB;;AAEA,OAAIuB,CAAC,GAAG+lB,UAAU,CAACtnB,MAAX,GAAoB,CAA5B,EAA+BuB,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AACxC4iB,IAAAA,KAAK,GAAGmD,UAAU,CAAC/lB,CAAD,CAAV,CAAc4iB,KAAtB;;AAEA,QAAG,OAAOA,KAAK,CAACe,IAAb,KAAsB,QAAzB,EAAmC;AAC/BnoB,MAAAA,GAAG,CAACsC,IAAJ,CAAS,8EACL,4BADJ;AAEH;;AAED,QAAG,CAAC8kB,KAAK,CAACe,IAAV,EAAgB;AACZ;AACA;AACA,aAAM6B,UAAU,CAAE5C,KAAK,CAACe,IAAN,GAAa,WAAW3mB,EAAE,CAACwiB,eAAH,CAAmBgH,QAAnB,EAA1B,CAAhB;AAA0E;AAA1E;AACH;;AAED,QAAGhB,UAAU,CAAC5C,KAAK,CAACe,IAAP,CAAb,EAA2B;AACvB;AACA,WAAI1Y,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGqa,OAAO,CAAC7mB,MAAvB,EAA+BwM,CAAC,EAAhC,EAAoC;AAChC,YAAG,CAACqa,OAAO,CAACra,CAAD,CAAP,IAAc,EAAf,EAAmB0Y,IAAnB,KAA4Bf,KAAK,CAACe,IAArC,EAA2C;AAC9C;;AACD0C,MAAAA,GAAG,CAAC1nB,IAAJ,CAAS;AAAC0E,QAAAA,IAAI,EAAE,SAAP;AAAkBwG,QAAAA,KAAK,EAAEoB,CAAzB;AAA4BV,QAAAA,KAAK,EAAEqY;AAAnC,OAAT;AACA0D,MAAAA,MAAM,CAACG,OAAP,CAAe;AAACpjB,QAAAA,IAAI,EAAE,SAAP;AAAkBwG,QAAAA,KAAK,EAAEoB,CAAzB;AAA4BV,QAAAA,KAAK,EAAE+a,OAAO,CAACra,CAAD;AAA1C,OAAf;AACH,KAPD,MAOO;AACH;AACA2a,MAAAA,GAAG,GAAGxjB,IAAI,CAACkO,GAAL,CAAS,CAAT,EAAYlO,IAAI,CAAC6f,GAAL,CAAS8D,UAAU,CAAC/lB,CAAD,CAAV,CAAc6J,KAAvB,EAA8B0c,UAA9B,CAAZ,CAAN;AAEAF,MAAAA,GAAG,CAAC1nB,IAAJ,CAAS;AAAC0E,QAAAA,IAAI,EAAE,QAAP;AAAiBwG,QAAAA,KAAK,EAAE+b,GAAxB;AAA6Brb,QAAAA,KAAK,EAAEqY;AAApC,OAAT;AACA0D,MAAAA,MAAM,CAACG,OAAP,CAAe;AAACpjB,QAAAA,IAAI,EAAE,QAAP;AAAiBwG,QAAAA,KAAK,EAAE+b;AAAxB,OAAf;AACAW,MAAAA,UAAU;AACb;AACJ;;AAED,MAAIpZ,QAAQ,GAAGrR,KAAK,CAAC4qB,YAArB;AACA,MAAIrZ,QAAQ,GAAGvR,KAAK,CAAC4qB,YAArB;AACA,MAAI5Z,QAAQ,GAAG,CAAC9P,EAAD,EAAKspB,MAAL,CAAf;AACA,MAAIhZ,QAAQ,GAAG,CAACtQ,EAAD,EAAKqpB,GAAL,CAAf;AAEA,MAAG1qB,KAAH,EAAUA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcmQ,QAAd,EAAwBL,QAAxB,EAAkCO,QAAlC,EAA4CC,QAA5C;AAEV,SAAOxR,KAAK,CAAC4qB,YAAN,CAAmB1pB,EAAnB,EAAuBqpB,GAAvB,CAAP;AACH;AAED;;;;;;;;;;;AASA,SAASM,YAAT,CAAsB3pB,EAAtB,EAA0BwmB,SAA1B,EAAqC;AACjCxmB,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;;AAEA,MAAG,CAACxB,GAAG,CAACqC,SAAJ,CAAcb,EAAd,CAAJ,EAAuB;AACnB,UAAM,IAAIqM,KAAJ,CAAU,wCAAwCrM,EAAlD,CAAN;AACH;;AAED,MAAIgD,CAAJ,EAAO4lB,GAAP;AACA,MAAIN,OAAO,GAAGtoB,EAAE,CAACwiB,eAAH,CAAmB8F,OAAjC;AACA,MAAIe,GAAG,GAAG,EAAV;AACA,MAAIC,MAAM,GAAG,EAAb;;AAEA,MAAG,CAAC9C,SAAJ,EAAe;AACXA,IAAAA,SAAS,GAAG,EAAZ;;AACA,SAAIxjB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGslB,OAAO,CAAC7mB,MAAvB,EAA+BuB,CAAC,EAAhC,EAAoC;AAChCwjB,MAAAA,SAAS,CAAC7kB,IAAV,CAAeqB,CAAf;AACH;AACJ;;AAEDwjB,EAAAA,SAAS,GAAGA,SAAS,CAAC1M,KAAV,EAAZ;AACA0M,EAAAA,SAAS,CAAC5V,IAAV;;AAEA,OAAI5N,CAAC,GAAGwjB,SAAS,CAAC/kB,MAAV,GAAmB,CAA3B,EAA8BuB,CAAC,IAAI,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;AACvC4lB,IAAAA,GAAG,GAAGpC,SAAS,CAACxjB,CAAD,CAAf;AACAqmB,IAAAA,GAAG,CAAC1nB,IAAJ,CAAS;AAAC0E,MAAAA,IAAI,EAAE,QAAP;AAAiBwG,MAAAA,KAAK,EAAE+b;AAAxB,KAAT;AACAU,IAAAA,MAAM,CAACG,OAAP,CAAe;AAACpjB,MAAAA,IAAI,EAAE,QAAP;AAAiBwG,MAAAA,KAAK,EAAE+b,GAAxB;AAA6Brb,MAAAA,KAAK,EAAE+a,OAAO,CAACM,GAAD;AAA3C,KAAf;AACH;;AAED,MAAIzY,QAAQ,GAAGrR,KAAK,CAAC4qB,YAArB;AACA,MAAIrZ,QAAQ,GAAGvR,KAAK,CAAC4qB,YAArB;AACA,MAAI5Z,QAAQ,GAAG,CAAC9P,EAAD,EAAKspB,MAAL,CAAf;AACA,MAAIhZ,QAAQ,GAAG,CAACtQ,EAAD,EAAKqpB,GAAL,CAAf;AAEA,MAAG1qB,KAAH,EAAUA,KAAK,CAACoR,GAAN,CAAU/P,EAAV,EAAcmQ,QAAd,EAAwBL,QAAxB,EAAkCO,QAAlC,EAA4CC,QAA5C;AAEV,SAAOxR,KAAK,CAAC4qB,YAAN,CAAmB1pB,EAAnB,EAAuBqpB,GAAvB,CAAP;AACH;AAED;;;;;;;;AAMA,SAAS9c,KAAT,CAAevM,EAAf,EAAmB;AACfA,EAAAA,EAAE,GAAGxB,GAAG,CAAC6B,WAAJ,CAAgBL,EAAhB,CAAL;AAEA,MAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAH,IAAkB,EAAnC;AACA,MAAImE,QAAQ,GAAGpG,EAAE,CAAC8C,SAAH,IAAgB,EAA/B,CAJe,CAMf;;AACAhE,EAAAA,KAAK,CAAC6G,SAAN,CAAgB,EAAhB,EAAoB,EAApB,EAAwBS,QAAxB,EAAkCpE,UAAlC,EAPe,CASf;;AACAlD,EAAAA,KAAK,CAACyN,KAAN,CAAYvM,EAAZ,EAVe,CAYf;;AACAtB,EAAAA,MAAM,CAAC6N,KAAP,CAAavM,EAAb,EAbe,CAef;;AACA,MAAGgC,UAAU,CAAC4nB,UAAd,EAA0B5nB,UAAU,CAAC4nB,UAAX,CAAsBxS,MAAtB,GAhBX,CAkBf;;AACA,SAAOpX,EAAE,CAACkD,QAAV;AAEA,SAAOlD,EAAP;AACH,C,CAED;AACA;AACA;;;AACA,SAASwC,iBAAT,CAA2BxC,EAA3B,EAA+B;AAC3B,MAAI6pB,GAAG,GAAGzrB,EAAE,CAAC8C,MAAH,CAAUlB,EAAV,CAAV;AACA,MAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAApB,CAF2B,CAI3B;;AACAD,EAAAA,UAAU,CAAC4nB,UAAX,GAAwBC,GAAG,CAAC1lB,SAAJ,CAAc,iBAAd,EAAiClE,IAAjC,CAAsC,CAAC,CAAD,CAAtC,CAAxB;;AACA+B,EAAAA,UAAU,CAAC4nB,UAAX,CAAsBplB,KAAtB,GAA8BmG,MAA9B,CAAqC,KAArC,EAA4C,cAA5C,EACKxJ,OADL,CACa,gBADb,EAC+B,IAD/B,EAEKA,OAFL,CAEa,QAFb,EAEuB,IAFvB,EAN2B,CAU3B;;;AACAa,EAAAA,UAAU,CAAC8nB,SAAX,GAAuB9nB,UAAU,CAAC4nB,UAAX,CAAsBzlB,SAAtB,CAAgC,gBAAhC,EAAkDlE,IAAlD,CAAuD,CAAC,CAAD,CAAvD,CAAvB;;AACA+B,EAAAA,UAAU,CAAC8nB,SAAX,CAAqBtlB,KAArB,GAA6BC,MAA7B,CAAoC,KAApC,EACKtD,OADL,CACa,eADb,EAC8B,IAD9B,EAEKyD,KAFL,CAEW,UAFX,EAEuB,UAFvB,EAZ2B,CAgB3B;AACA;AACA;AACA;AACA;AACA;;;AACA5C,EAAAA,UAAU,CAACkC,YAAX,GAA0BlC,UAAU,CAAC8nB,SAAX,CAAqB3lB,SAArB,CAA+B,eAA/B,EACrBlE,IADqB,CAChB,CAAC,EAAD,CADgB,CAA1B;;AAGA+B,EAAAA,UAAU,CAACkC,YAAX,CAAwBM,KAAxB,GAAgCC,MAAhC,CAAuC,KAAvC,EACKtD,OADL,CACa,cADb,EAC6B,IAD7B;;AAGAa,EAAAA,UAAU,CAAC8nB,SAAX,CAAqB3lB,SAArB,CAA+B,WAA/B,EAA4CiT,MAA5C;;AACApV,EAAAA,UAAU,CAAC8nB,SAAX,CAAqB5oB,MAArB,CAA4B,oBAA5B,EAAkDkW,MAAlD;;AAEApV,EAAAA,UAAU,CAACmG,MAAX,GAAoBnG,UAAU,CAAC8nB,SAAX,CAAqBnf,MAArB,CAA4B,KAA5B,EAAmC,cAAnC,EACfxJ,OADe,CACP,UADO,EACK,IADL,CAApB;AAGAa,EAAAA,UAAU,CAAC+nB,SAAX,GAAuB/nB,UAAU,CAAC8nB,SAAX,CAAqBrlB,MAArB,CAA4B,KAA5B,EAClBtD,OADkB,CACV,UADU,EACE,IADF,CAAvB;AAGAa,EAAAA,UAAU,CAAC8D,WAAX,GAAyB9D,UAAU,CAAC8nB,SAAX,CAAqBrlB,MAArB,CAA4B,KAA5B,CAAzB;AAEAzC,EAAAA,UAAU,CAACgoB,WAAX,GAAyBhoB,UAAU,CAAC8nB,SAAX,CAAqBrlB,MAArB,CAA4B,KAA5B,EACpBtD,OADoB,CACZ,UADY,EACA,IADA,CAAzB;;AAGA,MAAG,CAACa,UAAU,CAACioB,IAAf,EAAqB;AACjB,QAAIC,SAAS,GAAG,EAAhB;AACA9rB,IAAAA,EAAE,CAAC+F,SAAH,CAAa,MAAb,EAAqBgmB,IAArB,CAA0B,YAAW;AACjC,UAAG,KAAK9P,EAAR,EAAY6P,SAAS,CAAC,KAAK7P,EAAL,CAAQvR,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAD,CAAT,GAAmC,CAAnC;AACf,KAFD;AAGA9G,IAAAA,UAAU,CAACioB,IAAX,GAAkBzrB,GAAG,CAAC4rB,OAAJ,CAAYF,SAAZ,CAAlB;AACH;;AAEDloB,EAAAA,UAAU,CAAC8nB,SAAX,CAAqB3lB,SAArB,CAA+B,WAA/B,EACKO,IADL,CACUtF,eAAe,CAACirB,QAD1B;;AAGAroB,EAAAA,UAAU,CAACsoB,KAAX,GAAmBtoB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,MAAzB,EACdC,IADc,CACT,IADS,EACH,UAAU1C,UAAU,CAACioB,IADlB,CAAnB;AAGAjoB,EAAAA,UAAU,CAACuoB,MAAX,GAAoBvoB,UAAU,CAACsoB,KAAX,CAAiB7lB,MAAjB,CAAwB,GAAxB,EACftD,OADe,CACP,OADO,EACE,IADF,CAApB;AAGAa,EAAAA,UAAU,CAACwoB,QAAX,GAAsBxoB,UAAU,CAAC+nB,SAAX,CAAqBtlB,MAArB,CAA4B,MAA5B,EACjBC,IADiB,CACZ,IADY,EACN,aAAa1C,UAAU,CAACioB,IADlB,CAAtB;AAGAjoB,EAAAA,UAAU,CAACyoB,SAAX,GAAuBzoB,UAAU,CAACwoB,QAAX,CAAoB/lB,MAApB,CAA2B,GAA3B,EAClBtD,OADkB,CACV,OADU,EACD,IADC,CAAvB;AAGAa,EAAAA,UAAU,CAAC0oB,QAAX,GAAsB1oB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EACjBtD,OADiB,CACT,SADS,EACE,IADF,CAAtB;AAGAa,EAAAA,UAAU,CAAC2oB,SAAX,GAAuB3oB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAClBtD,OADkB,CACV,WADU,EACG,IADH,CAAvB,CApE2B,CAuE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIypB,UAAU,GAAG5oB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EACZtD,OADY,CACJ,aADI,EACW,IADX,CAAjB;;AAEAa,EAAAA,UAAU,CAAC6oB,gBAAX,GAA8BD,UAAU,CAACnmB,MAAX,CAAkB,GAAlB,EACzBtD,OADyB,CACjB,YADiB,EACH,IADG,CAA9B;AAEAa,EAAAA,UAAU,CAAC8oB,gBAAX,GAA8BF,UAAU,CAACnmB,MAAX,CAAkB,GAAlB,EACzBtD,OADyB,CACjB,YADiB,EACH,IADG,CAA9B,CAnF2B,CAsF3B;;AACAa,EAAAA,UAAU,CAAC+oB,eAAX,GAA6B/oB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,gBAAtC,EAAwD,IAAxD,CAA7B,CAvF2B,CAyF3B;;AACAa,EAAAA,UAAU,CAACgpB,WAAX,GAAyBhpB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,YAAtC,EAAoD,IAApD,CAAzB,CA1F2B,CA4F3B;;AACAa,EAAAA,UAAU,CAACipB,aAAX,GAA2BjpB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,cAAtC,EAAsD,IAAtD,CAA3B,CA7F2B,CA+F3B;;AACAa,EAAAA,UAAU,CAACkpB,SAAX,GAAuBlpB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,UAAtC,EAAkD,IAAlD,CAAvB,CAhG2B,CAkG3B;;AACAa,EAAAA,UAAU,CAACmpB,gBAAX,GAA8BnpB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,iBAAtC,EAAyD,IAAzD,CAA9B,CAnG2B,CAqG3B;;AACAa,EAAAA,UAAU,CAACmV,SAAX,GAAuBnV,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,UAAtC,EAAkD,IAAlD,CAAvB,CAtG2B,CAwG3B;;AACAa,EAAAA,UAAU,CAACopB,aAAX,GAA2BppB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,cAAtC,EAAsD,IAAtD,CAA3B,CAzG2B,CA2G3B;;AACAa,EAAAA,UAAU,CAACqpB,cAAX,GAA4BrpB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,eAAtC,EAAuD,IAAvD,CAA5B,CA5G2B,CA8G3B;;AACAa,EAAAA,UAAU,CAACspB,eAAX,GAA6BtpB,UAAU,CAAC+nB,SAAX,CAAqBtlB,MAArB,CAA4B,GAA5B,EAAiCtD,OAAjC,CAAyC,gBAAzC,EAA2D,IAA3D,CAA7B,CA/G2B,CAiH3B;;AACAa,EAAAA,UAAU,CAACupB,SAAX,GAAuBvpB,UAAU,CAACmG,MAAX,CAAkB1D,MAAlB,CAAyB,GAAzB,EAA8BtD,OAA9B,CAAsC,UAAtC,EAAkD,IAAlD,CAAvB,CAlH2B,CAoH3B;AACA;AACA;AACA;;AACA,MAAIqqB,UAAU,GAAGxpB,UAAU,CAAC+nB,SAAX,CAAqBtlB,MAArB,CAA4B,GAA5B,EACZtD,OADY,CACJ,aADI,EACW,IADX,CAAjB;;AAEAa,EAAAA,UAAU,CAACypB,gBAAX,GAA8BD,UAAU,CAAC/mB,MAAX,CAAkB,GAAlB,EACzBtD,OADyB,CACjB,YADiB,EACH,IADG,CAA9B;AAEAa,EAAAA,UAAU,CAAC0pB,gBAAX,GAA8BF,UAAU,CAAC/mB,MAAX,CAAkB,GAAlB,EACzBtD,OADyB,CACjB,YADiB,EACH,IADG,CAA9B;AAGAa,EAAAA,UAAU,CAAC2pB,UAAX,GAAwB3pB,UAAU,CAAC+nB,SAAX,CAAqBtlB,MAArB,CAA4B,GAA5B,EAAiCtD,OAAjC,CAAyC,WAAzC,EAAsD,IAAtD,CAAxB;AACAa,EAAAA,UAAU,CAAC4pB,UAAX,GAAwB5pB,UAAU,CAAC+nB,SAAX,CAAqBtlB,MAArB,CAA4B,GAA5B,EAAiCtD,OAAjC,CAAyC,WAAzC,EAAsD,IAAtD,CAAxB;AACAa,EAAAA,UAAU,CAAC6pB,UAAX,GAAwB7pB,UAAU,CAAC+nB,SAAX,CAAqBtlB,MAArB,CAA4B,GAA5B,EAAiCtD,OAAjC,CAAyC,WAAzC,EAAsD,IAAtD,CAAxB;AACAa,EAAAA,UAAU,CAAC8pB,WAAX,GAAyB9pB,UAAU,CAACgoB,WAAX,CAAuBvlB,MAAvB,CAA8B,GAA9B,EAAmCtD,OAAnC,CAA2C,YAA3C,EAAyD,IAAzD,CAAzB,CAlI2B,CAoI3B;;AACAa,EAAAA,UAAU,CAAC8D,WAAX,CACK3E,OADL,CACa,mBADb,EACkC,IADlC,EAEKyD,KAFL,CAEW,UAFX,EAEuB,UAFvB,EAGKA,KAHL,CAGW,KAHX,EAGkB,KAHlB,EAIKA,KAJL,CAIW,OAJX,EAIoB,KAJpB;;AAMA5E,EAAAA,EAAE,CAAC+H,IAAH,CAAQ,kBAAR;AACH;;AAED/G,OAAO,CAACokB,OAAR,GAAkBA,OAAlB;AACApkB,OAAO,CAACD,SAAR,GAAoBA,SAApB;AACAC,OAAO,CAAC2oB,YAAR,GAAuBA,YAAvB;AAEA3oB,OAAO,CAACkP,SAAR,GAAoBA,SAApB;AACAlP,OAAO,CAACoP,YAAR,GAAuBA,YAAvB;AACApP,OAAO,CAACgO,YAAR,GAAuBA,YAAvB;AACAhO,OAAO,CAACyP,UAAR,GAAqBA,UAArB;AACAzP,OAAO,CAACgP,aAAR,GAAwBA,aAAxB;AAEAhP,OAAO,CAACsL,OAAR,GAAkBA,OAAlB;AACAtL,OAAO,CAACjB,IAAR,GAAeA,IAAf;AACAiB,OAAO,CAACuL,KAAR,GAAgBA,KAAhB;AAEAvL,OAAO,CAAC2gB,KAAR,GAAgBA,KAAhB;AACA3gB,OAAO,CAACoL,MAAR,GAAiBA,MAAjB;AACApL,OAAO,CAACyX,QAAR,GAAmBA,QAAnB;AACAzX,OAAO,CAACmQ,OAAR,GAAkBA,OAAlB;AAEAnQ,OAAO,CAACgH,aAAR,GAAwBA,aAAxB;AAEAhH,OAAO,CAACyM,MAAR,GAAiBA,MAAjB;AAEAzM,OAAO,CAAC+qB,YAAR,GAAuB9M,OAAO,CAACxG,QAAD,CAA9B;AACAzX,OAAO,CAACgrB,WAAR,GAAsB/M,OAAO,CAAC9N,OAAD,CAA7B;AACAnQ,OAAO,CAACirB,UAAR,GAAqBhN,OAAO,CAACxR,MAAD,CAA5B;AAEAzM,OAAO,CAAC0S,mBAAR,GAA8BA,mBAA9B","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar Polar = require('../plots/polar/legacy');\n\nvar Axes = require('../plots/cartesian/axes');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar svgTextUtils = require('../lib/svg_text_utils');\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction plot(gd, data, layout, config) {\n    var frames;\n\n    gd = Lib.getGraphDiv(gd);\n\n    // Events.init is idempotent and bails early if gd has already been init'd\n    Events.init(gd);\n\n    if(Lib.isPlainObject(data)) {\n        var obj = data;\n        data = obj.data;\n        layout = obj.layout;\n        config = obj.config;\n        frames = obj.frames;\n    }\n\n    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n    if(okToPlot === false) return Promise.reject();\n\n    // if there's no data or layout, and this isn't yet a plotly plot\n    // container, log a warning to help plotly.js users debug\n    if(!data && !layout && !Lib.isPlotDiv(gd)) {\n        Lib.warn('Calling Plotly.plot as if redrawing ' +\n            'but this container doesn\\'t yet have a plot.', gd);\n    }\n\n    function addFrames() {\n        if(frames) {\n            return exports.addFrames(gd, frames);\n        }\n    }\n\n    // transfer configuration options to gd until we move over to\n    // a more OO like model\n    setPlotContext(gd, config);\n\n    if(!layout) layout = {};\n\n    // hook class for plots main container (in case of plotly.js\n    // this won't be #embedded-graph or .js-tab-contents)\n    d3.select(gd).classed('js-plotly-plot', true);\n\n    // off-screen getBoundingClientRect testing space,\n    // in #js-plotly-tester (and stored as Drawing.tester)\n    // so we can share cached text across tabs\n    Drawing.makeTester();\n\n    // collect promises for any async actions during plotting\n    // any part of the plotting code can push to gd._promises, then\n    // before we move to the next step, we check that they're all\n    // complete, and empty out the promise list again.\n    if(!Array.isArray(gd._promises)) gd._promises = [];\n\n    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));\n\n    // if there is already data on the graph, append the new data\n    // if you only want to redraw, pass a non-array for data\n    if(Array.isArray(data)) {\n        helpers.cleanData(data);\n\n        if(graphWasEmpty) gd.data = data;\n        else gd.data.push.apply(gd.data, data);\n\n        // for routines outside graph_obj that want a clean tab\n        // (rather than appending to an existing one) gd.empty\n        // is used to determine whether to make a new tab\n        gd.empty = false;\n    }\n\n    if(!gd.layout || graphWasEmpty) {\n        gd.layout = helpers.cleanLayout(layout);\n    }\n\n    Plots.supplyDefaults(gd);\n\n    var fullLayout = gd._fullLayout;\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // Legacy polar plots\n    if(!fullLayout._has('polar') && data && data[0] && data[0].r) {\n        Lib.log('Legacy polar charts are deprecated!');\n        return plotLegacyPolar(gd, data, layout);\n    }\n\n    // so we don't try to re-call Plotly.plot from inside\n    // legend and colorbar, if margins changed\n    fullLayout._replotting = true;\n\n    // make or remake the framework if we need to\n    if(graphWasEmpty) makePlotFramework(gd);\n\n    // polar need a different framework\n    if(gd.framework !== makePlotFramework) {\n        gd.framework = makePlotFramework;\n        makePlotFramework(gd);\n    }\n\n    // clear gradient defs on each .plot call, because we know we'll loop through all traces\n    Drawing.initGradients(gd);\n\n    // save initial show spikes once per graph\n    if(graphWasEmpty) Axes.saveShowSpikeInitial(gd);\n\n    // prepare the data and find the autorange\n\n    // generate calcdata, if we need to\n    // to force redoing calcdata, just delete it before calling Plotly.plot\n    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n    if(recalc) Plots.doCalcdata(gd);\n\n    // in case it has changed, attach fullData traces to calcdata\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        gd.calcdata[i][0].trace = gd._fullData[i];\n    }\n\n    // make the figure responsive\n    if(gd._context.responsive) {\n        if(!gd._responsiveChartHandler) {\n            // Keep a reference to the resize handler to purge it down the road\n            gd._responsiveChartHandler = function() { if(!Lib.isHidden(gd)) Plots.resize(gd); };\n\n            // Listen to window resize\n            window.addEventListener('resize', gd._responsiveChartHandler);\n        }\n    } else {\n        Lib.clearResponsive(gd);\n    }\n\n    /*\n     * start async-friendly code - now we're actually drawing things\n     */\n\n    var oldMargins = Lib.extendFlat({}, fullLayout._size);\n\n    // draw framework first so that margin-pushing\n    // components can position themselves correctly\n    var drawFrameworkCalls = 0;\n    function drawFramework() {\n        var basePlotModules = fullLayout._basePlotModules;\n\n        for(var i = 0; i < basePlotModules.length; i++) {\n            if(basePlotModules[i].drawFramework) {\n                basePlotModules[i].drawFramework(gd);\n            }\n        }\n\n        if(!fullLayout._glcanvas && fullLayout._has('gl')) {\n            fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n                key: 'contextLayer',\n                context: true,\n                pick: false\n            }, {\n                key: 'focusLayer',\n                context: false,\n                pick: false\n            }, {\n                key: 'pickLayer',\n                context: false,\n                pick: true\n            }], function(d) { return d.key; });\n\n            fullLayout._glcanvas.enter().append('canvas')\n                .attr('class', function(d) {\n                    return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n                })\n                .style({\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    overflow: 'visible',\n                    'pointer-events': 'none'\n                });\n        }\n\n        if(fullLayout._glcanvas) {\n            fullLayout._glcanvas\n                .attr('width', fullLayout.width)\n                .attr('height', fullLayout.height);\n\n            var regl = fullLayout._glcanvas.data()[0].regl;\n            if(regl) {\n                // Unfortunately, this can happen when relayouting to large\n                // width/height on some browsers.\n                if(Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth ||\n                    Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight\n                 ) {\n                    var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n                    if(drawFrameworkCalls) {\n                        Lib.error(msg);\n                    } else {\n                        Lib.log(msg + ' Clearing graph and plotting again.');\n                        Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n                        Plots.supplyDefaults(gd);\n                        fullLayout = gd._fullLayout;\n                        Plots.doCalcdata(gd);\n                        drawFrameworkCalls++;\n                        return drawFramework();\n                    }\n                }\n            }\n        }\n\n        if(fullLayout.modebar.orientation === 'h') {\n            fullLayout._modebardiv\n              .style('height', null)\n              .style('width', '100%');\n        } else {\n            fullLayout._modebardiv\n              .style('width', null)\n              .style('height', fullLayout.height + 'px');\n        }\n\n        return Plots.previousPromises(gd);\n    }\n\n    // draw anything that can affect margins.\n    function marginPushers() {\n        // First reset the list of things that are allowed to change the margins\n        // So any deleted traces or components will be wiped out of the\n        // automargin calculation.\n        // This means *every* margin pusher must be listed here, even if it\n        // doesn't actually try to push the margins until later.\n        Plots.clearAutoMarginIds(gd);\n\n        subroutines.drawMarginPushers(gd);\n        Axes.allowAutoMargin(gd);\n\n        // TODO can this be moved elsewhere?\n        if(fullLayout._has('pie')) {\n            var fullData = gd._fullData;\n            for(var i = 0; i < fullData.length; i++) {\n                var trace = fullData[i];\n                if(trace.type === 'pie' && trace.automargin) {\n                    Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n                }\n            }\n        }\n\n        Plots.doAutoMargin(gd);\n        return Plots.previousPromises(gd);\n    }\n\n    // in case the margins changed, draw margin pushers again\n    function marginPushersAgain() {\n        if(!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n\n        return Lib.syncOrAsync([\n            marginPushers,\n            subroutines.layoutStyles\n        ], gd);\n    }\n\n    function positionAndAutorange() {\n        if(!recalc) {\n            doAutoRangeAndConstraints();\n            return;\n        }\n\n        // TODO: autosize extra for text markers and images\n        // see https://github.com/plotly/plotly.js/issues/1111\n        return Lib.syncOrAsync([\n            Registry.getComponentMethod('shapes', 'calcAutorange'),\n            Registry.getComponentMethod('annotations', 'calcAutorange'),\n            doAutoRangeAndConstraints\n        ], gd);\n    }\n\n    function doAutoRangeAndConstraints() {\n        if(gd._transitioning) return;\n\n        subroutines.doAutoRangeAndConstraints(gd);\n\n        // store initial ranges *after* enforcing constraints, otherwise\n        // we will never look like we're at the initial ranges\n        if(graphWasEmpty) Axes.saveRangeInitial(gd);\n\n        // this one is different from shapes/annotations calcAutorange\n        // the others incorporate those components into ax._extremes,\n        // this one actually sets the ranges in rangesliders.\n        Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n    }\n\n    // draw ticks, titles, and calculate axis scaling (._b, ._m)\n    function drawAxes() {\n        return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n    }\n\n    var seq = [\n        Plots.previousPromises,\n        addFrames,\n        drawFramework,\n        marginPushers,\n        marginPushersAgain\n    ];\n\n    if(hasCartesian) seq.push(positionAndAutorange);\n\n    seq.push(subroutines.layoutStyles);\n    if(hasCartesian) seq.push(drawAxes);\n\n    seq.push(\n        subroutines.drawData,\n        subroutines.finalDraw,\n        initInteractions,\n        Plots.addLinks,\n        Plots.rehover,\n        Plots.redrag,\n        // TODO: doAutoMargin is only needed here for axis automargin, which\n        // happens outside of marginPushers where all the other automargins are\n        // calculated. Would be much better to separate margin calculations from\n        // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n        Plots.doAutoMargin,\n        Plots.previousPromises\n    );\n\n    // even if everything we did was synchronous, return a promise\n    // so that the caller doesn't care which route we took\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        emitAfterPlot(gd);\n        return gd;\n    });\n}\n\nfunction emitAfterPlot(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(fullLayout._redrawFromAutoMarginCount) {\n        fullLayout._redrawFromAutoMarginCount--;\n    } else {\n        gd.emit('plotly_afterplot');\n    }\n}\n\nfunction setPlotConfig(obj) {\n    return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n    try {\n        gd._fullLayout._paper.style('background', bgColor);\n    } catch(e) {\n        Lib.error(e);\n    }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n    var blend = Color.combine(bgColor, 'white');\n    setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n    if(!gd._context) {\n        gd._context = Lib.extendDeep({}, dfltConfig);\n\n        // stash <base> href, used to make robust clipPath URLs\n        var base = d3.select('base');\n        gd._context._baseUrl = base.size() && base.attr('href') ?\n            window.location.href.split('#')[0] :\n            '';\n    }\n\n    var context = gd._context;\n\n    var i, keys, key;\n\n    if(config) {\n        keys = Object.keys(config);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            if(key === 'editable' || key === 'edits') continue;\n            if(key in context) {\n                if(key === 'setBackground' && config[key] === 'opaque') {\n                    context[key] = opaqueSetBackground;\n                } else {\n                    context[key] = config[key];\n                }\n            }\n        }\n\n        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n            context.plotGlPixelRatio = context.plot3dPixelRatio;\n        }\n\n        // now deal with editable and edits - first editable overrides\n        // everything, then edits refines\n        var editable = config.editable;\n        if(editable !== undefined) {\n            // we're not going to *use* context.editable, we're only going to\n            // use context.edits... but keep it for the record\n            context.editable = editable;\n\n            keys = Object.keys(context.edits);\n            for(i = 0; i < keys.length; i++) {\n                context.edits[keys[i]] = editable;\n            }\n        }\n        if(config.edits) {\n            keys = Object.keys(config.edits);\n            for(i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if(key in context.edits) {\n                    context.edits[key] = config.edits[key];\n                }\n            }\n        }\n\n        // not part of the user-facing config options\n        context._exportedPlot = config._exportedPlot;\n    }\n\n    // staticPlot forces a bunch of others:\n    if(context.staticPlot) {\n        context.editable = false;\n        context.edits = {};\n        context.autosizable = false;\n        context.scrollZoom = false;\n        context.doubleClick = false;\n        context.showTips = false;\n        context.showLink = false;\n        context.displayModeBar = false;\n    }\n\n    // make sure hover-only devices have mode bar visible\n    if(context.displayModeBar === 'hover' && !hasHover) {\n        context.displayModeBar = true;\n    }\n\n    // default and fallback for setBackground\n    if(context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n        context.setBackground = setBackground;\n    }\n\n    // Check if gd has a specified widht/height to begin with\n    context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n    context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\n\n    // fill context._scrollZoom helper to help manage scrollZoom flaglist\n    var szIn = context.scrollZoom;\n    var szOut = context._scrollZoom = {};\n    if(szIn === true) {\n        szOut.cartesian = 1;\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n    } else if(typeof szIn === 'string') {\n        var parts = szIn.split('+');\n        for(i = 0; i < parts.length; i++) {\n            szOut[parts[i]] = 1;\n        }\n    } else if(szIn !== false) {\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n    }\n}\n\nfunction plotLegacyPolar(gd, data, layout) {\n    // build or reuse the container skeleton\n    var plotContainer = d3.select(gd).selectAll('.plot-container')\n        .data([0]);\n    plotContainer.enter()\n        .insert('div', ':first-child')\n        .classed('plot-container plotly', true);\n    var paperDiv = plotContainer.selectAll('.svg-container')\n        .data([0]);\n    paperDiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // empty it everytime for now\n    paperDiv.html('');\n\n    // fulfill gd requirements\n    if(data) gd.data = data;\n    if(layout) gd.layout = layout;\n    Polar.manager.fillLayout(gd);\n\n    // resize canvas\n    paperDiv.style({\n        width: gd._fullLayout.width + 'px',\n        height: gd._fullLayout.height + 'px'\n    });\n\n    // instantiate framework\n    gd.framework = Polar.manager.framework(gd);\n\n    // plot\n    gd.framework({data: gd.data, layout: gd.layout}, paperDiv.node());\n\n    // set undo point\n    gd.framework.setUndoPoint();\n\n    // get the resulting svg for extending it\n    var polarPlotSVG = gd.framework.svg();\n\n    // editable title\n    var opacity = 1;\n    var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n    if(txt === '' || !txt) opacity = 0;\n\n    var titleLayout = function() {\n        this.call(svgTextUtils.convertToTspans, gd);\n        // TODO: html/mathjax\n        // TODO: center title\n    };\n\n    var title = polarPlotSVG.select('.title-group text')\n        .call(titleLayout);\n\n    if(gd._context.edits.titleText) {\n        var placeholderText = Lib._(gd, 'Click to enter Plot title');\n        if(!txt || txt === placeholderText) {\n            opacity = 0.2;\n            // placeholder is not going through convertToTspans\n            // so needs explicit data-unformatted\n            title.attr({'data-unformatted': placeholderText})\n                .text(placeholderText)\n                .style({opacity: opacity})\n                .on('mouseover.opacity', function() {\n                    d3.select(this).transition().duration(100)\n                        .style('opacity', 1);\n                })\n                .on('mouseout.opacity', function() {\n                    d3.select(this).transition().duration(1000)\n                        .style('opacity', 0);\n                });\n        }\n\n        var setContenteditable = function() {\n            this.call(svgTextUtils.makeEditable, {gd: gd})\n                .on('edit', function(text) {\n                    gd.framework({layout: {title: {text: text}}});\n                    this.text(text)\n                        .call(titleLayout);\n                    this.call(setContenteditable);\n                })\n                .on('cancel', function() {\n                    var txt = this.attr('data-unformatted');\n                    this.text(txt).call(titleLayout);\n                });\n        };\n        title.call(setContenteditable);\n    }\n\n    gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n    Plots.addLinks(gd);\n\n    return Promise.resolve();\n}\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nfunction redraw(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    helpers.cleanData(gd.data);\n    helpers.cleanLayout(gd.layout);\n\n    gd.calcdata = undefined;\n    return exports.plot(gd).then(function() {\n        gd.emit('plotly_redraw');\n        return gd;\n    });\n}\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nfunction newPlot(gd, data, layout, config) {\n    gd = Lib.getGraphDiv(gd);\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n\n    Plots.purge(gd);\n    return exports.plot(gd, data, layout, config);\n}\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n    var parentLength = maxIndex + 1;\n    var positiveIndices = [];\n    var i;\n    var index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n        if(index < 0) {\n            positiveIndices.push(parentLength + index);\n        } else {\n            positiveIndices.push(index);\n        }\n    }\n    return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n    var i,\n        index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n\n        // validate that indices are indeed integers\n        if(index !== parseInt(index, 10)) {\n            throw new Error('all values in ' + arrayName + ' must be integers');\n        }\n\n        // check that all indices are in bounds for given gd.data array length\n        if(index >= gd.data.length || index < -gd.data.length) {\n            throw new Error(arrayName + ' must be valid indices for gd.data.');\n        }\n\n        // check that indices aren't repeated\n        if(indices.indexOf(index, i + 1) > -1 ||\n                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||\n                index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n            throw new Error('each index in ' + arrayName + ' must be unique.');\n        }\n    }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // validate currentIndices array\n    if(typeof currentIndices === 'undefined') {\n        throw new Error('currentIndices is a required argument.');\n    } else if(!Array.isArray(currentIndices)) {\n        currentIndices = [currentIndices];\n    }\n    assertIndexArray(gd, currentIndices, 'currentIndices');\n\n    // validate newIndices array if it exists\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined') {\n        assertIndexArray(gd, newIndices, 'newIndices');\n    }\n\n    // check currentIndices and newIndices are the same length if newIdices exists\n    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n        throw new Error('current and new indices must be of equal length.');\n    }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n    var i, value;\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // make sure traces exists\n    if(typeof traces === 'undefined') {\n        throw new Error('traces must be defined.');\n    }\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure each value in traces is an object\n    for(i = 0; i < traces.length; i++) {\n        value = traces[i];\n        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {\n            throw new Error('all values in traces array must be non-array objects');\n        }\n    }\n\n    // make sure we have an index for each trace\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n        throw new Error(\n            'if indices is specified, traces.length must equal indices.length'\n        );\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array');\n    }\n    if(!Lib.isPlainObject(update)) {\n        throw new Error('update must be a key:value object');\n    }\n\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers');\n    }\n\n    assertIndexArray(gd, indices, 'indices');\n\n    for(var key in update) {\n        /*\n         * Verify that the attribute to be updated contains as many trace updates\n         * as indices. Failure must result in throw and no-op\n         */\n        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {\n            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n        }\n\n        /*\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n         */\n        if(maxPointsIsObject &&\n            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||\n            maxPoints[key].length !== update[key].length)) {\n            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +\n                            'corrispondence with the keys and number of traces in the update object');\n        }\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n    var updateProps = [];\n    var trace, target, prop, insert, maxp;\n\n    // allow scalar index to represent a single trace position\n    if(!Array.isArray(indices)) indices = [indices];\n\n    // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // loop through all update keys and traces and harvest validated data.\n    for(var key in update) {\n        for(var j = 0; j < indices.length; j++) {\n            /*\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\n             * instance that references the key and value for this particular trace.\n             */\n            trace = gd.data[indices[j]];\n            prop = nestedProperty(trace, key);\n\n            /*\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n             * Target must exist as an Array to allow the extend operation to be performed.\n             */\n            target = prop.get();\n            insert = update[key][j];\n\n            if(!Lib.isArrayOrTypedArray(insert)) {\n                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n            }\n            if(!Lib.isArrayOrTypedArray(target)) {\n                throw new Error('cannot extend missing or non-array attribute: ' + key);\n            }\n            if(target.constructor !== insert.constructor) {\n                throw new Error('cannot extend array with an array of a different type: ' + key);\n            }\n\n            /*\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\n             * Use the scalar maxPoints for all key and trace combinations.\n             */\n            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n            // could have chosen null here, -1 just tells us to not take a window\n            if(!isNumeric(maxp)) maxp = -1;\n\n            /*\n             * Wrap the nestedProperty in an object containing required data\n             * for lengthening and windowing this particular trace - key combination.\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n             */\n            updateProps.push({\n                prop: prop,\n                target: target,\n                insert: insert,\n                maxp: Math.floor(maxp)\n            });\n        }\n    }\n\n    // all target and insertion data now validated\n    return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n    assertExtendTracesArgs(gd, update, indices, maxPoints);\n\n    var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n    var undoUpdate = {};\n    var undoPoints = {};\n\n    for(var i = 0; i < updateProps.length; i++) {\n        var prop = updateProps[i].prop;\n        var maxp = updateProps[i].maxp;\n\n        // return new array and remainder\n        var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n        prop.set(out[0]);\n\n        // build the inverse update object for the undo operation\n        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n        undoUpdate[prop.astr].push(out[1]);\n\n         // build the matching maxPoints undo object containing original trace lengths\n        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n        undoPoints[prop.astr].push(updateProps[i].target.length);\n    }\n\n    return {update: undoUpdate, maxPoints: undoPoints};\n}\n\nfunction concatTypedArray(arr0, arr1) {\n    var arr2 = new arr0.constructor(arr0.length + arr1.length);\n    arr2.set(arr0);\n    arr2.set(arr1, arr0.length);\n    return arr2;\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nfunction extendTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp < 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(target, insert);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target);\n                    remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n                    var targetBegin = target.length - numberOfItemsFromTarget;\n\n                    newArray.set(target.subarray(targetBegin));\n                    newArray.set(insert, numberOfItemsFromTarget);\n                    remainder.set(target.subarray(0, targetBegin));\n                }\n            }\n        } else {\n            newArray = target.concat(insert);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(0, newArray.length - maxp) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n\n    return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp <= 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(insert, target);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n                    remainder.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target, numberOfItemsFromInsert);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n\n                    newArray.set(insert);\n                    newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n                    remainder.set(target.subarray(numberOfItemsFromTarget));\n                }\n            }\n        } else {\n            newArray = insert.concat(target);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(maxp, newArray.length) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n\n    return promise;\n}\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nfunction addTraces(gd, traces, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var currentIndices = [];\n    var undoFunc = exports.deleteTraces;\n    var redoFunc = addTraces;\n    var undoArgs = [gd, currentIndices];\n    var redoArgs = [gd, traces];  // no newIndices here\n    var i;\n    var promise;\n\n    // all validation is done elsewhere to remove clutter here\n    checkAddTracesArgs(gd, traces, newIndices);\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure traces do not repeat existing ones\n    traces = traces.map(function(trace) {\n        return Lib.extendFlat({}, trace);\n    });\n\n    helpers.cleanData(traces);\n\n    // add the traces to gd.data (no redrawing yet!)\n    for(i = 0; i < traces.length; i++) {\n        gd.data.push(traces[i]);\n    }\n\n    // to continue, we need to call moveTraces which requires currentIndices\n    for(i = 0; i < traces.length; i++) {\n        currentIndices.push(-traces.length + i);\n    }\n\n    // if the user didn't define newIndices, they just want the traces appended\n    // i.e., we can simply redraw and be done\n    if(typeof newIndices === 'undefined') {\n        promise = exports.redraw(gd);\n        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n        return promise;\n    }\n\n    // make sure indices is property defined\n    if(!Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n\n    try {\n        // this is redundant, but necessary to not catch later possible errors!\n        checkMoveTracesArgs(gd, currentIndices, newIndices);\n    } catch(error) {\n        // something went wrong, reset gd to be safe and rethrow error\n        gd.data.splice(gd.data.length - traces.length, traces.length);\n        throw error;\n    }\n\n    // if we're here, the user has defined specific places to place the new traces\n    // this requires some extra work that moveTraces will do\n    Queue.startSequence(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    promise = exports.moveTraces(gd, currentIndices, newIndices);\n    Queue.stopSequence(gd);\n    return promise;\n}\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nfunction deleteTraces(gd, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var traces = [];\n    var undoFunc = exports.addTraces;\n    var redoFunc = deleteTraces;\n    var undoArgs = [gd, traces, indices];\n    var redoArgs = [gd, indices];\n    var i;\n    var deletedTrace;\n\n    // make sure indices are defined\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers.');\n    } else if(!Array.isArray(indices)) {\n        indices = [indices];\n    }\n    assertIndexArray(gd, indices, 'indices');\n\n    // convert negative indices to positive indices\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // we want descending here so that splicing later doesn't affect indexing\n    indices.sort(Lib.sorterDes);\n    for(i = 0; i < indices.length; i += 1) {\n        deletedTrace = gd.data.splice(indices[i], 1)[0];\n        traces.push(deletedTrace);\n    }\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n}\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nfunction moveTraces(gd, currentIndices, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var newData = [];\n    var movingTraceMap = [];\n    var undoFunc = moveTraces;\n    var redoFunc = moveTraces;\n    var undoArgs = [gd, newIndices, currentIndices];\n    var redoArgs = [gd, currentIndices, newIndices];\n    var i;\n\n    // to reduce complexity here, check args elsewhere\n    // this throws errors where appropriate\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n    // make sure currentIndices is an array\n    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n    // if undefined, define newIndices to point to the end of gd.data array\n    if(typeof newIndices === 'undefined') {\n        newIndices = [];\n        for(i = 0; i < currentIndices.length; i++) {\n            newIndices.push(-currentIndices.length + i);\n        }\n    }\n\n    // make sure newIndices is an array if it's user-defined\n    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n    // convert negative indices to positive indices (they're the same length)\n    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n    newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n    // at this point, we've coerced the index arrays into predictable forms\n\n    // get the traces that aren't being moved around\n    for(i = 0; i < gd.data.length; i++) {\n        // if index isn't in currentIndices, include it in ignored!\n        if(currentIndices.indexOf(i) === -1) {\n            newData.push(gd.data[i]);\n        }\n    }\n\n    // get a mapping of indices to moving traces\n    for(i = 0; i < currentIndices.length; i++) {\n        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});\n    }\n\n    // reorder this mapping by newIndex, ascending\n    movingTraceMap.sort(function(a, b) {\n        return a.newIndex - b.newIndex;\n    });\n\n    // now, add the moving traces back in, in order!\n    for(i = 0; i < movingTraceMap.length; i += 1) {\n        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n    }\n\n    gd.data = newData;\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n}\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nfunction restyle(gd, astr, val, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var aobj = {};\n    if(typeof astr === 'string') aobj[astr] = val;\n    else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = Lib.extendFlat({}, astr);\n        if(_traces === undefined) _traces = val;\n    } else {\n        Lib.warn('Restyle fail.', astr, val, _traces);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var specs = _restyle(gd, aobj, traces);\n    var flags = specs.flags;\n\n    // clear calcdata and/or axis types if required so they get regenerated\n    if(flags.calc) gd.calcdata = undefined;\n    if(flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(flags.fullReplot) {\n        seq.push(exports.plot);\n    } else {\n        seq.push(Plots.previousPromises);\n\n        // maybe only call Plots.supplyDataDefaults in the splom case,\n        // to skip over long and slow axes defaults\n        Plots.supplyDefaults(gd);\n\n        if(flags.markerSize) {\n            Plots.doCalcdata(gd);\n            addAxRangeSequence(seq);\n\n            // TODO\n            // if all axes have autorange:false, then\n            // proceed to subroutines.doTraceStyle(),\n            // otherwise we must go through addAxRangeSequence,\n            // which in general must redraws 'all' axes\n        }\n\n        if(flags.style) seq.push(subroutines.doTraceStyle);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n\n    Queue.add(gd,\n        restyle, [gd, specs.undoit, specs.traces],\n        restyle, [gd, specs.redoit, specs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        gd.emit('plotly_restyle', specs.eventData);\n        return gd;\n    });\n}\n\n// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val) {\n    if(val === undefined) return null;\n    return val;\n}\n\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\nfunction makeNP(preGUI, guiEditFlag) {\n    if(!guiEditFlag) return nestedProperty;\n\n    return function(container, attr, prefix) {\n        var np = nestedProperty(container, attr);\n        var npSet = np.set;\n        np.set = function(val) {\n            var fullAttr = (prefix || '') + attr;\n            storeCurrent(fullAttr, np.get(), val, preGUI);\n            npSet(val);\n        };\n        return np;\n    };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n    if(Array.isArray(val) || Array.isArray(newVal)) {\n        var arrayVal = Array.isArray(val) ? val : [];\n        var arrayNew = Array.isArray(newVal) ? newVal : [];\n        var maxLen = Math.max(arrayVal.length, arrayNew.length);\n        for(var i = 0; i < maxLen; i++) {\n            storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n        }\n    } else if(Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n        var objVal = Lib.isPlainObject(val) ? val : {};\n        var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n        var objBoth = Lib.extendFlat({}, objVal, objNew);\n        for(var key in objBoth) {\n            storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n        }\n    } else if(preGUI[attr] === undefined) {\n        preGUI[attr] = undefinedToNull(val);\n    }\n}\n\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n    for(var attr in edits) {\n        var np = nestedProperty(container, attr);\n        storeCurrent(attr, np.get(), edits[attr], preGUI);\n    }\n}\n\nfunction _restyle(gd, aobj, traces) {\n    var fullLayout = gd._fullLayout;\n    var fullData = gd._fullData;\n    var data = gd.data;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var i;\n\n    cleanDeprecatedAttributeKeys(aobj);\n\n    // initialize flags\n    var flags = editTypes.traceFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n    var axlist;\n\n    // make a new empty vals array for undoit\n    function a0() { return traces.map(function() { return undefined; }); }\n\n    // for autoranging multiple axes\n    function addToAxlist(axid) {\n        var axName = Axes.id2name(axid);\n        if(axlist.indexOf(axName) === -1) axlist.push(axName);\n    }\n\n    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }\n\n    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }\n\n    function getFullTrace(traceIndex) {\n        // usually fullData maps 1:1 onto data, but with groupby transforms\n        // the fullData index can be greater. Take the *first* matching trace.\n        for(var j = traceIndex; j < fullData.length; j++) {\n            if(fullData[j]._input === data[traceIndex]) return fullData[j];\n        }\n        // should never get here - and if we *do* it should cause an error\n        // later on undefined fullTrace is passed to nestedProperty.\n    }\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // val=null will delete the attribute\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val, i) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val, i); });\n            return;\n        }\n        // quit if explicitly setting this elsewhere\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var extraparam;\n        if(attr.substr(0, 6) === 'LAYOUT') {\n            extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n        } else {\n            var tracei = traces[i];\n            var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n            extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n        }\n\n        if(!(attr in undoit)) {\n            undoit[attr] = a0();\n        }\n        if(undoit[attr][i] === undefined) {\n            undoit[attr][i] = undefinedToNull(extraparam.get());\n        }\n        if(val !== undefined) {\n            extraparam.set(val);\n        }\n    }\n\n    function allBins(binAttr) {\n        return function(j) {\n            return fullData[j][binAttr];\n        };\n    }\n\n    function arrayBins(binAttr) {\n        return function(vij, j) {\n            return vij === false ? fullData[traces[j]][binAttr] : null;\n        };\n    }\n\n    // now make the changes to gd.data (and occasionally gd.layout)\n    // and figure out what kind of graphics update we need to do\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n        }\n\n        var vi = aobj[ai];\n        var cont;\n        var contFull;\n        var param;\n        var oldVal;\n        var newVal;\n        var valObject;\n\n        // Backward compatibility shim for turning histogram autobin on,\n        // or freezing previous autobinned values.\n        // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n        // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n        if(ai === 'autobinx' || ai === 'autobiny') {\n            ai = ai.charAt(ai.length - 1) + 'bins';\n            if(Array.isArray(vi)) vi = vi.map(arrayBins(ai));\n            else if(vi === false) vi = traces.map(allBins(ai));\n            else vi = null;\n        }\n\n        redoit[ai] = vi;\n\n        if(ai.substr(0, 6) === 'LAYOUT') {\n            param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n            undoit[ai] = [undefinedToNull(param.get())];\n            // since we're allowing val to be an array, allow it here too,\n            // even though that's meaningless\n            param.set(Array.isArray(vi) ? vi[0] : vi);\n            // ironically, the layout attrs in restyle only require replot,\n            // not relayout\n            flags.calc = true;\n            continue;\n        }\n\n        // set attribute in gd.data\n        undoit[ai] = a0();\n        for(i = 0; i < traces.length; i++) {\n            cont = data[traces[i]];\n            contFull = getFullTrace(traces[i]);\n            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n            param = makeNP(preGUI, guiEditFlag)(cont, ai);\n            oldVal = param.get();\n            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n\n            if(newVal === undefined) continue;\n\n            var finalPart = param.parts[param.parts.length - 1];\n            var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n            var prefixDot = prefix ? prefix + '.' : '';\n            var innerContFull = prefix ?\n                nestedProperty(contFull, prefix).get() : contFull;\n\n            valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n            if(valObject && valObject.impliedEdits && newVal !== null) {\n                for(var impliedKey in valObject.impliedEdits) {\n                    doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n                }\n            } else if((finalPart === 'thicknessmode' || finalPart === 'lenmode') &&\n                    oldVal !== newVal &&\n                    (newVal === 'fraction' || newVal === 'pixels') &&\n                    innerContFull\n            ) {\n                // changing colorbar size modes,\n                // make the resulting size not change\n                // note that colorbar fractional sizing is based on the\n                // original plot size, before anything (like a colorbar)\n                // increases the margins\n\n                var gs = fullLayout._size;\n                var orient = innerContFull.orient;\n                var topOrBottom = (orient === 'top') || (orient === 'bottom');\n                if(finalPart === 'thicknessmode') {\n                    var thicknorm = topOrBottom ? gs.h : gs.w;\n                    doextra(prefixDot + 'thickness', innerContFull.thickness *\n                        (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n                } else {\n                    var lennorm = topOrBottom ? gs.w : gs.h;\n                    doextra(prefixDot + 'len', innerContFull.len *\n                        (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n                }\n            } else if(ai === 'type' && (\n                (newVal === 'pie') !== (oldVal === 'pie') ||\n                (newVal === 'funnelarea') !== (oldVal === 'funnelarea')\n            )) {\n                var labelsTo = 'x';\n                var valuesTo = 'y';\n                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n                    labelsTo = 'y';\n                    valuesTo = 'x';\n                }\n                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n                if(oldVal === 'pie' || oldVal === 'funnelarea') {\n                    nestedProperty(cont, 'marker.color')\n                        .set(nestedProperty(cont, 'marker.colors').get());\n\n                    // super kludgy - but if all pies are gone we won't remove them otherwise\n                    fullLayout._pielayer.selectAll('g.trace').remove();\n                } else if(Registry.traceIs(cont, 'cartesian')) {\n                    nestedProperty(cont, 'marker.colors')\n                        .set(nestedProperty(cont, 'marker.color').get());\n                }\n            }\n\n            undoit[ai][i] = undefinedToNull(oldVal);\n            // set the new value - if val is an array, it's one el per trace\n            // first check for attributes that get more complex alterations\n            var swapAttrs = [\n                'swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'\n            ];\n            if(swapAttrs.indexOf(ai) !== -1) {\n                // setting an orientation: make sure it's changing\n                // before we swap everything else\n                if(ai === 'orientation') {\n                    param.set(newVal);\n                    // obnoxious that we need this level of coupling... but in order to\n                    // properly handle setting orientation to `null` we need to mimic\n                    // the logic inside Bars.supplyDefaults for default orientation\n                    var defaultOrientation = (cont.x && !cont.y) ? 'h' : 'v';\n                    if((param.get() || defaultOrientation) === contFull.orientation) {\n                        continue;\n                    }\n                } else if(ai === 'orientationaxes') {\n                    // orientationaxes has no value,\n                    // it flips everything and the axes\n\n                    cont.orientation =\n                        {v: 'h', h: 'v'}[contFull.orientation];\n                }\n                helpers.swapXYData(cont);\n                flags.calc = flags.clearAxisTypes = true;\n            } else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n                // TODO: use manageArrays.applyContainerArrayChanges here too\n                helpers.manageArrayContainers(param, newVal, undoit);\n                flags.calc = true;\n            } else {\n                if(valObject) {\n                    // must redo calcdata when restyling array values of arrayOk attributes\n                    // ... but no need to this for regl-based traces\n                    if(valObject.arrayOk &&\n                        !Registry.traceIs(contFull, 'regl') &&\n                        (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))\n                    ) {\n                        flags.calc = true;\n                    } else editTypes.update(flags, valObject);\n                } else {\n                    /*\n                     * if we couldn't find valObject,  assume a full recalc.\n                     * This can happen if you're changing type and making\n                     * some other edits too, so the modules we're\n                     * looking at don't have these attributes in them.\n                     */\n                    flags.calc = true;\n                }\n\n                // all the other ones, just modify that one attribute\n                param.set(newVal);\n            }\n        }\n\n        // swap the data attributes of the relevant x and y axes?\n        if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n            Axes.swap(gd, traces);\n        }\n\n        // swap hovermode if set to \"compare x/y data\"\n        if(ai === 'orientationaxes') {\n            var hovermode = nestedProperty(gd.layout, 'hovermode');\n            if(hovermode.get() === 'x') {\n                hovermode.set('y');\n            } else if(hovermode.get() === 'y') {\n                hovermode.set('x');\n            }\n        }\n\n        // Major enough changes deserve autoscale and\n        // non-reversed axes so people don't get confused\n        //\n        // Note: autobin (or its new analog bin clearing) is not included here\n        // since we're not pushing bins back to gd.data, so if we have bin\n        // info it was explicitly provided by the user.\n        if(['orientation', 'type'].indexOf(ai) !== -1) {\n            axlist = [];\n            for(i = 0; i < traces.length; i++) {\n                var trace = data[traces[i]];\n\n                if(Registry.traceIs(trace, 'cartesian')) {\n                    addToAxlist(trace.xaxis || 'x');\n                    addToAxlist(trace.yaxis || 'y');\n                }\n            }\n\n            doextra(axlist.map(autorangeAttr), true, 0);\n            doextra(axlist.map(rangeAttr), [0, 1], 0);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    return {\n        flags: flags,\n        undoit: undoit,\n        redoit: redoit,\n        traces: traces,\n        eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n    };\n}\n\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\nfunction cleanDeprecatedAttributeKeys(aobj) {\n    var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n    var colorbarRegex = /colorbar\\.title$/;\n    var keys = Object.keys(aobj);\n    var i, key, value;\n\n    for(i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = aobj[key];\n\n        if((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) &&\n          (typeof value === 'string' || typeof value === 'number')) {\n            replace(key, key.replace('title', 'title.text'));\n        } else if(key.indexOf('titlefont') > -1) {\n            replace(key, key.replace('titlefont', 'title.font'));\n        } else if(key.indexOf('titleposition') > -1) {\n            replace(key, key.replace('titleposition', 'title.position'));\n        } else if(key.indexOf('titleside') > -1) {\n            replace(key, key.replace('titleside', 'title.side'));\n        } else if(key.indexOf('titleoffset') > -1) {\n            replace(key, key.replace('titleoffset', 'title.offset'));\n        }\n    }\n\n    function replace(oldAttrStr, newAttrStr) {\n        aobj[newAttrStr] = aobj[oldAttrStr];\n        delete aobj[oldAttrStr];\n    }\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nfunction relayout(gd, astr, val) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = Lib.extendFlat({}, astr);\n    } else {\n        Lib.warn('Relayout fail.', astr, val);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var specs = _relayout(gd, aobj);\n    var flags = specs.flags;\n\n    // clear calcdata if required\n    if(flags.calc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n\n    // even if we don't have anything left in aobj,\n    // something may have happened within relayout that we\n    // need to wait for\n    var seq = [Plots.previousPromises];\n\n    if(flags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    } else if(Object.keys(aobj).length) {\n        axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n\n        if(flags.legend) seq.push(subroutines.doLegend);\n        if(flags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n        if(flags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(flags.modebar) seq.push(subroutines.doModeBar);\n        if(flags.camera) seq.push(subroutines.doCamera);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n\n    Queue.add(gd,\n        relayout, [gd, specs.undoit],\n        relayout, [gd, specs.redoit]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_relayout', specs.eventData);\n        return gd;\n    });\n}\n\n// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n    var fullLayout = gd._fullLayout;\n\n    if(!flags.axrange) return false;\n\n    for(var k in flags) {\n        if(k !== 'axrange' && flags[k]) return false;\n    }\n\n    for(var axId in specs.rangesAltered) {\n        var axName = Axes.id2name(axId);\n        var axIn = gd.layout[axName];\n        var axOut = fullLayout[axName];\n        axOut.autorange = axIn.autorange;\n        axOut.range = axIn.range.slice();\n        axOut.cleanRange();\n\n        if(axOut._matchGroup) {\n            for(var axId2 in axOut._matchGroup) {\n                if(axId2 !== axId) {\n                    var ax2 = fullLayout[Axes.id2name(axId2)];\n                    ax2.autorange = axOut.autorange;\n                    ax2.range = axOut.range.slice();\n                    ax2._input.range = axOut.range.slice();\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n    // N.B. leave as sequence of subroutines (for now) instead of\n    // subroutine of its own so that finalDraw always gets\n    // executed after drawData\n    var drawAxes = rangesAltered ?\n        function(gd) {\n            var axIds = [];\n            var skipTitle = true;\n\n            for(var id in rangesAltered) {\n                var ax = Axes.getFromId(gd, id);\n                axIds.push(id);\n\n                if(ax._matchGroup) {\n                    for(var id2 in ax._matchGroup) {\n                        if(!rangesAltered[id2]) {\n                            axIds.push(id2);\n                        }\n                    }\n                }\n\n                if(ax.automargin) skipTitle = false;\n            }\n\n            return Axes.draw(gd, axIds, {skipTitle: skipTitle});\n        } :\n        function(gd) {\n            return Axes.draw(gd, 'redraw');\n        };\n\n    seq.push(\n        clearSelect,\n        subroutines.doAutoRangeAndConstraints,\n        drawAxes,\n        subroutines.drawData,\n        subroutines.finalDraw\n    );\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n    var layout = gd.layout;\n    var fullLayout = gd._fullLayout;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var keys = Object.keys(aobj);\n    var axes = Axes.list(gd);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var arrayEdits = {};\n\n    var arrayStr, i, j;\n\n    cleanDeprecatedAttributeKeys(aobj);\n    keys = Object.keys(aobj);\n\n    // look for 'allaxes', split out into all axes\n    // in case of 3D the axis are nested within a scene which is held in _id\n    for(i = 0; i < keys.length; i++) {\n        if(keys[i].indexOf('allaxes') === 0) {\n            for(j = 0; j < axes.length; j++) {\n                var scene = axes[j]._id.substr(1);\n                var axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '';\n                var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n\n                if(!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n            }\n\n            delete aobj[keys[i]];\n        }\n    }\n\n    // initialize flags\n    var flags = editTypes.layoutFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val); });\n            return;\n        }\n\n        // if we have another value for this attribute (explicitly or\n        // via a parent) do not override with this auto-generated extra\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var p = layoutNP(layout, attr);\n        if(!(attr in undoit)) {\n            undoit[attr] = undefinedToNull(p.get());\n        }\n        if(val !== undefined) p.set(val);\n    }\n\n    // for constraint enforcement: keep track of all axes (as {id: name})\n    // we're editing the (auto)range of, so we can tell the others constrained\n    // to scale with them that it's OK for them to shrink\n    var rangesAltered = {};\n    var axId;\n\n    function recordAlteredAxis(pleafPlus) {\n        var axId = Axes.name2id(pleafPlus.split('.')[0]);\n        rangesAltered[axId] = 1;\n        return axId;\n    }\n\n    // alter gd.layout\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n        }\n\n        var p = layoutNP(layout, ai);\n        var vi = aobj[ai];\n        var plen = p.parts.length;\n        // p.parts may end with an index integer if the property is an array\n        var pend = plen - 1;\n        while(pend > 0 && typeof p.parts[pend] !== 'string') pend--;\n        // last property in chain (leaf node)\n        var pleaf = p.parts[pend];\n        // leaf plus immediate parent\n        var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\n        // trunk nodes (everything except the leaf)\n        var ptrunk = p.parts.slice(0, pend).join('.');\n        var parentIn = nestedProperty(gd.layout, ptrunk).get();\n        var parentFull = nestedProperty(fullLayout, ptrunk).get();\n        var vOld = p.get();\n\n        if(vi === undefined) continue;\n\n        redoit[ai] = vi;\n\n        // axis reverse is special - it is its own inverse\n        // op and has no flag.\n        undoit[ai] = (pleaf === 'reverse') ? vi : undefinedToNull(vOld);\n\n        var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n        if(valObject && valObject.impliedEdits && vi !== null) {\n            for(var impliedKey in valObject.impliedEdits) {\n                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n            }\n        }\n\n        // Setting width or height to null must reset the graph's width / height\n        // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        //\n        // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // can't use impliedEdits for this because behavior depends on vi\n        if(['width', 'height'].indexOf(ai) !== -1) {\n            if(vi) {\n                doextra('autosize', null);\n                // currently we don't support autosize one dim only - so\n                // explicitly set the other one. Note that doextra will\n                // ignore this if the same relayout call also provides oppositeAttr\n                var oppositeAttr = ai === 'height' ? 'width' : 'height';\n                doextra(oppositeAttr, fullLayout[oppositeAttr]);\n            } else {\n                fullLayout[ai] = gd._initialAutoSize[ai];\n            }\n        } else if(ai === 'autosize') {\n            // depends on vi here too, so again can't use impliedEdits\n            doextra('width', vi ? null : fullLayout.width);\n            doextra('height', vi ? null : fullLayout.height);\n        } else if(pleafPlus.match(AX_RANGE_RE)) {\n            // check autorange vs range\n\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        } else if(pleafPlus.match(AX_AUTORANGE_RE)) {\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n            var axFull = nestedProperty(fullLayout, ptrunk).get();\n            if(axFull._inputDomain) {\n                // if we're autoranging and this axis has a constrained domain,\n                // reset it so we don't get locked into a shrunken size\n                axFull._input.domain = axFull._inputDomain.slice();\n            }\n        } else if(pleafPlus.match(AX_DOMAIN_RE)) {\n            nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n        }\n\n        // toggling axis type between log and linear: we need to convert\n        // positions for components that are still using linearized values,\n        // not data values like newer components.\n        // previously we did this for log <-> not-log, but now only do it\n        // for log <-> linear\n        if(pleaf === 'type') {\n            var ax = parentIn;\n            var toLog = parentFull.type === 'linear' && vi === 'log';\n            var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n            if(toLog || fromLog) {\n                if(!ax || !ax.range) {\n                    // 2D never gets here, but 3D does\n                    // I don't think this is needed, but left here in case there\n                    // are edge cases I'm not thinking of.\n                    doextra(ptrunk + '.autorange', true);\n                } else if(!parentFull.autorange) {\n                    // toggling log without autorange: need to also recalculate ranges\n                    // because log axes use linearized values for range endpoints\n                    var r0 = ax.range[0];\n                    var r1 = ax.range[1];\n                    if(toLog) {\n                        // if both limits are negative, autorange\n                        if(r0 <= 0 && r1 <= 0) {\n                            doextra(ptrunk + '.autorange', true);\n                        }\n                        // if one is negative, set it 6 orders below the other.\n                        if(r0 <= 0) r0 = r1 / 1e6;\n                        else if(r1 <= 0) r1 = r0 / 1e6;\n                        // now set the range values as appropriate\n                        doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n                        doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n                    } else {\n                        doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n                        doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n                    }\n                } else if(toLog) {\n                    // just make sure the range is positive and in the right\n                    // order, it'll get recalculated later\n                    ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];\n                }\n\n                // clear polar view initial stash for radial range so that\n                // value get recomputed in correct units\n                if(Array.isArray(fullLayout._subplots.polar) &&\n                    fullLayout._subplots.polar.length &&\n                    fullLayout[p.parts[0]] &&\n                    p.parts[1] === 'radialaxis'\n                ) {\n                    delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n                }\n\n                // Annotations and images also need to convert to/from linearized coords\n                // Shapes do not need this :)\n                Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n                Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n            } else {\n                // any other type changes: the range from the previous type\n                // will not make sense, so autorange it.\n                doextra(ptrunk + '.autorange', true);\n                doextra(ptrunk + '.range', null);\n            }\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        } else if(pleaf.match(AX_NAME_PATTERN)) {\n            var fullProp = nestedProperty(fullLayout, ai).get();\n            var newType = (vi || {}).type;\n\n            // This can potentially cause strange behavior if the autotype is not\n            // numeric (linear, because we don't auto-log) but the previous type\n            // was log. That's a very strange edge case though\n            if(!newType || newType === '-') newType = 'linear';\n            Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n            Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n        }\n\n        // alter gd.layout\n\n        // collect array component edits for execution all together\n        // so we can ensure consistent behavior adding/removing items\n        // and order-independence for add/remove/edit all together in\n        // one relayout call\n        var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n        if(containerArrayMatch) {\n            arrayStr = containerArrayMatch.array;\n            i = containerArrayMatch.index;\n            var propStr = containerArrayMatch.property;\n            var updateValObject = valObject || {editType: 'calc'};\n\n            if(i !== '' && propStr === '') {\n                // special handling of undoit if we're adding or removing an element\n                // ie 'annotations[2]' which can be {...} (add) or null,\n                // does not work when replacing the entire array\n                if(manageArrays.isAddVal(vi)) {\n                    undoit[ai] = null;\n                } else if(manageArrays.isRemoveVal(vi)) {\n                    undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n                } else {\n                    Lib.warn('unrecognized full object value', aobj);\n                }\n            }\n            editTypes.update(flags, updateValObject);\n\n            // prepare the edits object we'll send to applyContainerArrayChanges\n            if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n            var objEdits = arrayEdits[arrayStr][i];\n            if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n            objEdits[propStr] = vi;\n\n            delete aobj[ai];\n        } else if(pleaf === 'reverse') {\n            // handle axis reversal explicitly, as there's no 'reverse' attribute\n\n            if(parentIn.range) parentIn.range.reverse();\n            else {\n                doextra(ptrunk + '.autorange', true);\n                parentIn.range = [1, 0];\n            }\n\n            if(parentFull.autorange) flags.calc = true;\n            else flags.plot = true;\n        } else {\n            if((fullLayout._has('scatter-like') && fullLayout._has('regl')) &&\n                (ai === 'dragmode' &&\n                (vi === 'lasso' || vi === 'select') &&\n                !(vOld === 'lasso' || vOld === 'select'))\n            ) {\n                flags.plot = true;\n            } else if(fullLayout._has('gl2d')) {\n                flags.plot = true;\n            } else if(valObject) editTypes.update(flags, valObject);\n            else flags.calc = true;\n\n            p.set(vi);\n        }\n    }\n\n    // now we've collected component edits - execute them all together\n    for(arrayStr in arrayEdits) {\n        var finished = manageArrays.applyContainerArrayChanges(gd,\n            layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n        if(!finished) flags.plot = true;\n    }\n\n    // figure out if we need to recalculate axis constraints\n    var constraints = fullLayout._axisConstraintGroups || [];\n    for(axId in rangesAltered) {\n        for(i = 0; i < constraints.length; i++) {\n            var group = constraints[i];\n            if(group[axId]) {\n                // Always recalc if we're changing constrained ranges.\n                // Otherwise it's possible to violate the constraints by\n                // specifying arbitrary ranges for all axes in the group.\n                // this way some ranges may expand beyond what's specified,\n                // as they do at first draw, to satisfy the constraints.\n                flags.calc = true;\n                for(var groupAxId in group) {\n                    if(!rangesAltered[groupAxId]) {\n                        Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the autosize changed or height or width was explicitly specified,\n    // this triggers a redraw\n    // TODO: do we really need special aobj.height/width handling here?\n    // couldn't editType do this?\n    if(updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    // now all attribute mods are done, as are\n    // redo and undo so we can save them\n\n    return {\n        flags: flags,\n        rangesAltered: rangesAltered,\n        undoit: undoit,\n        redoit: redoit,\n        eventData: eventData\n    };\n}\n\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\nfunction updateAutosize(gd) {\n    var fullLayout = gd._fullLayout;\n    var oldWidth = fullLayout.width;\n    var oldHeight = fullLayout.height;\n\n    // calculate autosizing\n    if(gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n\n    return (fullLayout.width !== oldWidth) || (fullLayout.height !== oldHeight);\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n\n    if(Object.keys(traceUpdate).length) gd.changed = true;\n    if(Object.keys(layoutUpdate).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n    var restyleFlags = restyleSpecs.flags;\n\n    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n    var relayoutFlags = relayoutSpecs.flags;\n\n    // clear calcdata and/or axis types if required\n    if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n    if(restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(relayoutFlags.layoutReplot) {\n        // N.B. works fine when both\n        // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n        seq.push(subroutines.layoutReplot);\n    } else if(restyleFlags.fullReplot) {\n        seq.push(exports.plot);\n    } else {\n        seq.push(Plots.previousPromises);\n        axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n\n        if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n        if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n        if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n        if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n        if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n        if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n\n    Queue.add(gd,\n        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],\n        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_update', {\n            data: restyleSpecs.eventData,\n            layout: relayoutSpecs.eventData\n        });\n\n        return gd;\n    });\n}\n\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\nfunction guiEdit(func) {\n    return function wrappedEdit(gd) {\n        gd._fullLayout._guiEditing = true;\n        var p = func.apply(null, arguments);\n        gd._fullLayout._guiEditing = false;\n        return p;\n    };\n}\n\n// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns = [\n    {pattern: /^hiddenlabels/, attr: 'legend.uirevision'},\n    {pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/},\n\n    // showspikes and modes include those nested inside scenes\n    {pattern: /axis\\d*\\.showspikes$/, attr: 'modebar.uirevision'},\n    {pattern: /(hover|drag)mode$/, attr: 'modebar.uirevision'},\n\n    {pattern: /^(scene\\d*)\\.camera/},\n    {pattern: /^(geo\\d*)\\.(projection|center)/},\n    {pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/},\n    {pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/},\n    {pattern: /^(polar\\d*\\.angularaxis)\\.rotation/},\n    {pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/},\n\n    {pattern: /^legend\\.(x|y)$/, attr: 'editrevision'},\n    {pattern: /^(shapes|annotations)/, attr: 'editrevision'},\n    {pattern: /^title\\.text$/, attr: 'editrevision'}\n];\n\n// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns = [\n    {pattern: /^selectedpoints$/, attr: 'selectionrevision'},\n    // \"visible\" includes trace.transforms[i].styles[j].value.visible\n    {pattern: /(^|value\\.)visible$/, attr: 'legend.uirevision'},\n    {pattern: /^dimensions\\[\\d+\\]\\.constraintrange/},\n    {pattern: /^node\\.(x|y|groups)/}, // for Sankey nodes\n    {pattern: /^level$/}, // for Sunburst & Treemap traces\n\n    // below this you must be in editable: true mode\n    // TODO: I still put name and title with `trace.uirevision`\n    // reasonable or should these be `editrevision`?\n    // Also applies to axis titles up in the layout section\n\n    // \"name\" also includes transform.styles\n    {pattern: /(^|value\\.)name$/},\n    // including nested colorbar attributes (ie marker.colorbar)\n    {pattern: /colorbar\\.title\\.text$/},\n    {pattern: /colorbar\\.(x|y)$/, attr: 'editrevision'}\n];\n\nfunction findUIPattern(key, patternSpecs) {\n    for(var i = 0; i < patternSpecs.length; i++) {\n        var spec = patternSpecs[i];\n        var match = key.match(spec.pattern);\n        if(match) {\n            return {head: match[1], attr: spec.attr};\n        }\n    }\n}\n\n// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr, container) {\n    var newRev = nestedProperty(container, revAttr).get();\n    if(newRev !== undefined) return newRev;\n\n    var parts = revAttr.split('.');\n    parts.pop();\n    while(parts.length > 1) {\n        parts.pop();\n        newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n        if(newRev !== undefined) return newRev;\n    }\n\n    return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n    for(var i = 0; i < fullData.length; i++) {\n        if(fullData[i]._fullInput.uid === uid) return i;\n    }\n    return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n    for(var i = 0; i < data.length; i++) {\n        if(data[i].uid === uid) return i;\n    }\n    // fall back on trace order, but only if user didn't provide a uid for that trace\n    return (!data[tracei] || data[tracei].uid) ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n    var v1IsObj = Lib.isPlainObject(v1);\n    var v1IsArray = Array.isArray(v1);\n    if(v1IsObj || v1IsArray) {\n        return (\n            (v1IsObj && Lib.isPlainObject(v2)) ||\n            (v1IsArray && Array.isArray(v2))\n        ) && JSON.stringify(v1) === JSON.stringify(v2);\n    }\n    return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n    var layoutPreGUI = oldFullLayout._preGUI;\n    var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n    var bothInheritAutorange = [];\n    var newRangeAccepted = {};\n    for(key in layoutPreGUI) {\n        match = findUIPattern(key, layoutUIControlPatterns);\n        if(match) {\n            revAttr = match.attr || (match.head + '.uirevision');\n            oldRev = nestedProperty(oldFullLayout, revAttr).get();\n            newRev = oldRev && getNewRev(revAttr, layout);\n            if(newRev && (newRev === oldRev)) {\n                preGUIVal = layoutPreGUI[key];\n                if(preGUIVal === null) preGUIVal = undefined;\n                newNP = nestedProperty(layout, key);\n                newVal = newNP.get();\n                if(valsMatch(newVal, preGUIVal)) {\n                    if(newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n                        bothInheritAutorange.push(key.substr(0, key.length - 10));\n                    }\n                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n                    continue;\n                }\n            }\n        } else {\n            Lib.warn('unrecognized GUI edit: ' + key);\n        }\n        // if we got this far, the new value was accepted as the new starting\n        // point (either because it changed or revision changed)\n        // so remove it from _preGUI for next time.\n        delete layoutPreGUI[key];\n\n        if(key.substr(key.length - 8, 6) === 'range[') {\n            newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n        }\n    }\n\n    // Special logic for `autorange`, since it interacts with `range`:\n    // If the new figure's matching `range` was kept, and `autorange`\n    // wasn't supplied explicitly in either the original or the new figure,\n    // we shouldn't alter that - but we may just have done that, so fix it.\n    for(var i = 0; i < bothInheritAutorange.length; i++) {\n        var axAttr = bothInheritAutorange[i];\n        if(newRangeAccepted[axAttr]) {\n            var newAx = nestedProperty(layout, axAttr).get();\n            if(newAx) delete newAx.autorange;\n        }\n    }\n\n    // Now traces - try to match them up by uid (in case we added/deleted in\n    // the middle), then fall back on index.\n    var allTracePreGUI = oldFullLayout._tracePreGUI;\n    for(var uid in allTracePreGUI) {\n        var tracePreGUI = allTracePreGUI[uid];\n        var newTrace = null;\n        var fullInput;\n        for(key in tracePreGUI) {\n            // wait until we know we have preGUI values to look for traces\n            // but if we don't find both, stop looking at this uid\n            if(!newTrace) {\n                var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n                if(fulli < 0) {\n                    // Somehow we didn't even have this trace in oldFullData...\n                    // I guess this could happen with `deleteTraces` or something\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                var fullTrace = oldFullData[fulli];\n                fullInput = fullTrace._fullInput;\n\n                var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n                if(newTracei < 0) {\n                    // No match in new data\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                newTrace = data[newTracei];\n            }\n\n            match = findUIPattern(key, traceUIControlPatterns);\n            if(match) {\n                if(match.attr) {\n                    oldRev = nestedProperty(oldFullLayout, match.attr).get();\n                    newRev = oldRev && getNewRev(match.attr, layout);\n                } else {\n                    oldRev = fullInput.uirevision;\n                    // inheritance for trace.uirevision is simple, just layout.uirevision\n                    newRev = newTrace.uirevision;\n                    if(newRev === undefined) newRev = layout.uirevision;\n                }\n\n                if(newRev && newRev === oldRev) {\n                    preGUIVal = tracePreGUI[key];\n                    if(preGUIVal === null) preGUIVal = undefined;\n                    newNP = nestedProperty(newTrace, key);\n                    newVal = newNP.get();\n                    if(valsMatch(newVal, preGUIVal)) {\n                        newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n                        continue;\n                    }\n                }\n            } else {\n                Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n            }\n            delete tracePreGUI[key];\n        }\n    }\n}\n\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction react(gd, data, layout, config) {\n    var frames, plotDone;\n\n    function addFrames() { return exports.addFrames(gd, frames); }\n\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var oldFullData = gd._fullData;\n    var oldFullLayout = gd._fullLayout;\n\n    // you can use this as the initial draw as well as to update\n    if(!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n        plotDone = exports.newPlot(gd, data, layout, config);\n    } else {\n        if(Lib.isPlainObject(data)) {\n            var obj = data;\n            data = obj.data;\n            layout = obj.layout;\n            config = obj.config;\n            frames = obj.frames;\n        }\n\n        var configChanged = false;\n        // assume that if there's a config at all, we're reacting to it too,\n        // and completely replace the previous config\n        if(config) {\n            var oldConfig = Lib.extendDeep({}, gd._context);\n            gd._context = undefined;\n            setPlotContext(gd, config);\n            configChanged = diffConfig(oldConfig, gd._context);\n        }\n\n        gd.data = data || [];\n        helpers.cleanData(gd.data);\n        gd.layout = layout || {};\n        helpers.cleanLayout(gd.layout);\n\n        applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\n\n        // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n        // which supplyDefaults usually does at the end, but we may need to NOT do\n        // if the diff (which we haven't determined yet) says we'll recalc\n        Plots.supplyDefaults(gd, {skipUpdateCalc: true});\n\n        var newFullData = gd._fullData;\n        var newFullLayout = gd._fullLayout;\n        var immutable = newFullLayout.datarevision === undefined;\n        var transition = newFullLayout.transition;\n\n        var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n        var newDataRevision = relayoutFlags.newDataRevision;\n        var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\n\n        // TODO: how to translate this part of relayout to Plotly.react?\n        // // Setting width or height to null must reset the graph's width / height\n        // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        // //\n        // // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n        //     fullLayout[ai] = gd._initialAutoSize[ai];\n        // }\n\n        if(updateAutosize(gd)) relayoutFlags.layoutReplot = true;\n\n        // clear calcdata if required\n        if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n        // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n        else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n\n        // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n        // must be handled by the user when using Plotly.react.\n\n        // fill in redraw sequence\n        var seq = [];\n\n        if(frames) {\n            gd._transitionData = {};\n            Plots.createTransitionData(gd);\n            seq.push(addFrames);\n        }\n\n        // Transition pathway,\n        // only used when 'transition' is set by user and\n        // when at least one animatable attribute has changed,\n        // N.B. config changed aren't animatable\n        if(newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n            Plots.doCalcdata(gd);\n            subroutines.doAutoRangeAndConstraints(gd);\n\n            seq.push(function() {\n                return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n            });\n        } else if(restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n            gd._fullLayout._skipDefaults = true;\n            seq.push(exports.plot);\n        } else {\n            for(var componentType in relayoutFlags.arrays) {\n                var indices = relayoutFlags.arrays[componentType];\n                if(indices.length) {\n                    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n                    if(drawOne !== Lib.noop) {\n                        for(var i = 0; i < indices.length; i++) {\n                            drawOne(gd, indices[i]);\n                        }\n                    } else {\n                        var draw = Registry.getComponentMethod(componentType, 'draw');\n                        if(draw === Lib.noop) {\n                            throw new Error('cannot draw components: ' + componentType);\n                        }\n                        draw(gd);\n                    }\n                }\n            }\n\n            seq.push(Plots.previousPromises);\n            if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n            if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n            if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n            if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n            if(relayoutFlags.axrange) addAxRangeSequence(seq);\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n            if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n            if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n            seq.push(emitAfterPlot);\n        }\n\n        seq.push(Plots.rehover, Plots.redrag);\n\n        plotDone = Lib.syncOrAsync(seq, gd);\n        if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n    }\n\n    return plotDone.then(function() {\n        gd.emit('plotly_react', {\n            data: data,\n            layout: layout\n        });\n\n        return gd;\n    });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n    var sameTraceLength = oldFullData.length === newFullData.length;\n\n    if(!transition && !sameTraceLength) {\n        return {\n            fullReplot: true,\n            calc: true\n        };\n    }\n\n    var flags = editTypes.traceFlags();\n    flags.arrays = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    var i, trace;\n\n    function getTraceValObject(parts) {\n        var out = PlotSchema.getTraceValObject(trace, parts);\n        if(!trace._module.animatable && out.anim) {\n            out.anim = false;\n        }\n        return out;\n    }\n\n    var diffOpts = {\n        getValObject: getTraceValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        newDataRevision: newDataRevision,\n        gd: gd\n    };\n\n    var seenUIDs = {};\n\n    for(i = 0; i < oldFullData.length; i++) {\n        if(newFullData[i]) {\n            trace = newFullData[i]._fullInput;\n            if(Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n            if(seenUIDs[trace.uid]) continue;\n            seenUIDs[trace.uid] = 1;\n\n            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = (flags.nChanges === flags.nChangesAnim) && sameTraceLength ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n    var flags = editTypes.layoutFlags();\n    flags.arrays = {};\n    flags.rangesAltered = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    function getLayoutValObject(parts) {\n        return PlotSchema.getLayoutValObject(newFullLayout, parts);\n    }\n\n    var diffOpts = {\n        getValObject: getLayoutValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        gd: gd\n    };\n\n    getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n    var valObject, key, astr;\n\n    var getValObject = opts.getValObject;\n    var flags = opts.flags;\n    var immutable = opts.immutable;\n    var inArray = opts.inArray;\n    var arrayIndex = opts.arrayIndex;\n\n    function changed() {\n        var editType = valObject.editType;\n        if(inArray && editType.indexOf('arraydraw') !== -1) {\n            Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n            return;\n        }\n        editTypes.update(flags, valObject);\n\n        if(editType !== 'none') {\n            flags.nChanges++;\n        }\n\n        // track animatable changes\n        if(opts.transition && valObject.anim) {\n            flags.nChangesAnim++;\n        }\n\n        // track cartesian axes with altered ranges\n        if(AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n            flags.rangesAltered[outerparts[0]] = 1;\n        }\n\n        // clear _inputDomain on cartesian axes with altered domains\n        if(AX_DOMAIN_RE.test(astr)) {\n            nestedProperty(newContainer, '_inputDomain').set(null);\n        }\n\n        // track datarevision changes\n        if(key === 'datarevision') {\n            flags.newDataRevision = 1;\n        }\n    }\n\n    function valObjectCanBeDataArray(valObject) {\n        return valObject.valType === 'data_array' || valObject.arrayOk;\n    }\n\n    for(key in oldContainer) {\n        // short-circuit based on previous calls or previous keys that already maximized the pathway\n        if(flags.calc && !opts.transition) return;\n\n        var oldVal = oldContainer[key];\n        var newVal = newContainer[key];\n        var parts = outerparts.concat(key);\n        astr = parts.join('.');\n\n        if(key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\n\n        // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n        // and unlike other auto values they don't make it back into the input,\n        // so newContainer won't have them.\n        if((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n            var tickMode = newContainer.tickmode;\n            if(tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n        }\n        // FIXME: Similarly for axis ranges for 3D\n        // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n        if(key === 'range' && newContainer.autorange) continue;\n        if((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n\n        valObject = getValObject(parts);\n\n        // in case type changed, we may not even *have* a valObject.\n        if(!valObject) continue;\n\n        if(valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n\n        var valType = valObject.valType;\n        var i;\n\n        var canBeDataArray = valObjectCanBeDataArray(valObject);\n        var wasArray = Array.isArray(oldVal);\n        var nowArray = Array.isArray(newVal);\n\n        // hack for traces that modify the data in supplyDefaults, like\n        // converting 1D to 2D arrays, which will always create new objects\n        if(wasArray && nowArray) {\n            var inputKey = '_input_' + key;\n            var oldValIn = oldContainer[inputKey];\n            var newValIn = newContainer[inputKey];\n            if(Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n        }\n\n        if(newVal === undefined) {\n            if(canBeDataArray && wasArray) flags.calc = true;\n            else changed();\n        } else if(valObject._isLinkedToArray) {\n            var arrayEditIndices = [];\n            var extraIndices = false;\n            if(!inArray) flags.arrays[key] = arrayEditIndices;\n\n            var minLen = Math.min(oldVal.length, newVal.length);\n            var maxLen = Math.max(oldVal.length, newVal.length);\n            if(minLen !== maxLen) {\n                if(valObject.editType === 'arraydraw') {\n                    extraIndices = true;\n                } else {\n                    changed();\n                    continue;\n                }\n            }\n\n            for(i = 0; i < minLen; i++) {\n                getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\n                    // add array indices, but not if we're already in an array\n                    Lib.extendFlat({inArray: key, arrayIndex: i}, opts));\n            }\n\n            // put this at the end so that we know our collected array indices are sorted\n            // but the check for length changes happens up front so we can short-circuit\n            // diffing if appropriate\n            if(extraIndices) {\n                for(i = minLen; i < maxLen; i++) {\n                    arrayEditIndices.push(i);\n                }\n            }\n        } else if(!valType && Lib.isPlainObject(oldVal)) {\n            getDiffFlags(oldVal, newVal, parts, opts);\n        } else if(canBeDataArray) {\n            if(wasArray && nowArray) {\n                // don't try to diff two data arrays. If immutable we know the data changed,\n                // if not, assume it didn't and let `layout.datarevision` tell us if it did\n                if(immutable) {\n                    flags.calc = true;\n                }\n\n                // look for animatable attributes when the data changed\n                if(immutable || opts.newDataRevision) {\n                    changed();\n                }\n            } else if(wasArray !== nowArray) {\n                flags.calc = true;\n            } else changed();\n        } else if(wasArray && nowArray) {\n            // info array, colorscale, 'any' - these are short, just stringify.\n            // I don't *think* that covers up any real differences post-validation, does it?\n            // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n            // all elements.\n            if(oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n                changed();\n            }\n        } else {\n            changed();\n        }\n    }\n\n    for(key in newContainer) {\n        if(!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n            valObject = getValObject(outerparts.concat(key));\n\n            if(valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n                flags.calc = true;\n                return;\n            } else changed();\n        }\n    }\n}\n\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\nfunction diffConfig(oldConfig, newConfig) {\n    var key;\n\n    for(key in oldConfig) {\n        if(key.charAt(0) === '_') continue;\n        var oldVal = oldConfig[key];\n        var newVal = newConfig[key];\n        if(oldVal !== newVal) {\n            if(Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n                if(diffConfig(oldVal, newVal)) {\n                    return true;\n                }\n            } else if(Array.isArray(oldVal) && Array.isArray(newVal)) {\n                if(oldVal.length !== newVal.length) {\n                    return true;\n                }\n                for(var i = 0; i < oldVal.length; i++) {\n                    if(oldVal[i] !== newVal[i]) {\n                        if(Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n                            if(diffConfig(oldVal[i], newVal[i])) {\n                                return true;\n                            }\n                        } else {\n                            return true;\n                        }\n                    }\n                }\n            } else {\n                return true;\n            }\n        }\n    }\n}\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before animating it. For more details, see ' +\n            'https://plot.ly/javascript/animations/'\n        );\n    }\n\n    var trans = gd._transitionData;\n\n    // This is the queue of frames that will be animated as soon as possible. They\n    // are popped immediately upon the *start* of a transition:\n    if(!trans._frameQueue) {\n        trans._frameQueue = [];\n    }\n\n    animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n    var transitionOpts = animationOpts.transition;\n    var frameOpts = animationOpts.frame;\n\n    // Since frames are popped immediately, an empty queue only means all frames have\n    // *started* to transition, not that the animation is complete. To solve that,\n    // track a separate counter that increments at the same time as frames are added\n    // to the queue, but decrements only when the transition is complete.\n    if(trans._frameWaitingCnt === undefined) {\n        trans._frameWaitingCnt = 0;\n    }\n\n    function getTransitionOpts(i) {\n        if(Array.isArray(transitionOpts)) {\n            if(i >= transitionOpts.length) {\n                return transitionOpts[0];\n            } else {\n                return transitionOpts[i];\n            }\n        } else {\n            return transitionOpts;\n        }\n    }\n\n    function getFrameOpts(i) {\n        if(Array.isArray(frameOpts)) {\n            if(i >= frameOpts.length) {\n                return frameOpts[0];\n            } else {\n                return frameOpts[i];\n            }\n        } else {\n            return frameOpts;\n        }\n    }\n\n    // Execute a callback after the wrapper function has been called n times.\n    // This is used to defer the resolution until a transition has resovled *and*\n    // the frame has completed. If it's not done this way, then we get a race\n    // condition in which the animation might resolve before a transition is complete\n    // or vice versa.\n    function callbackOnNthTime(cb, n) {\n        var cnt = 0;\n        return function() {\n            if(cb && ++cnt === n) {\n                return cb();\n            }\n        };\n    }\n\n    return new Promise(function(resolve, reject) {\n        function discardExistingFrames() {\n            if(trans._frameQueue.length === 0) {\n                return;\n            }\n\n            while(trans._frameQueue.length) {\n                var next = trans._frameQueue.pop();\n                if(next.onInterrupt) {\n                    next.onInterrupt();\n                }\n            }\n\n            gd.emit('plotly_animationinterrupted', []);\n        }\n\n        function queueFrames(frameList) {\n            if(frameList.length === 0) return;\n\n            for(var i = 0; i < frameList.length; i++) {\n                var computedFrame;\n\n                if(frameList[i].type === 'byname') {\n                    // If it's a named frame, compute it:\n                    computedFrame = Plots.computeFrame(gd, frameList[i].name);\n                } else {\n                    // Otherwise we must have been given a simple object, so treat\n                    // the input itself as the computed frame.\n                    computedFrame = frameList[i].data;\n                }\n\n                var frameOpts = getFrameOpts(i);\n                var transitionOpts = getTransitionOpts(i);\n\n                // It doesn't make much sense for the transition duration to be greater than\n                // the frame duration, so limit it:\n                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n\n                var nextFrame = {\n                    frame: computedFrame,\n                    name: frameList[i].name,\n                    frameOpts: frameOpts,\n                    transitionOpts: transitionOpts,\n                };\n                if(i === frameList.length - 1) {\n                    // The last frame in this .animate call stores the promise resolve\n                    // and reject callbacks. This is how we ensure that the animation\n                    // loop (which may exist as a result of a *different* .animate call)\n                    // still resolves or rejecdts this .animate call's promise. once it's\n                    // complete.\n                    nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n                    nextFrame.onInterrupt = reject;\n                }\n\n                trans._frameQueue.push(nextFrame);\n            }\n\n            // Set it as never having transitioned to a frame. This will cause the animation\n            // loop to immediately transition to the next frame (which, for immediate mode,\n            // is the first frame in the list since all others would have been discarded\n            // below)\n            if(animationOpts.mode === 'immediate') {\n                trans._lastFrameAt = -Infinity;\n            }\n\n            // Only it's not already running, start a RAF loop. This could be avoided in the\n            // case that there's only one frame, but it significantly complicated the logic\n            // and only sped things up by about 5% or so for a lorenz attractor simulation.\n            // It would be a fine thing to implement, but the benefit of that optimization\n            // doesn't seem worth the extra complexity.\n            if(!trans._animationRaf) {\n                beginAnimationLoop();\n            }\n        }\n\n        function stopAnimationLoop() {\n            gd.emit('plotly_animated');\n\n            // Be sure to unset also since it's how we know whether a loop is already running:\n            window.cancelAnimationFrame(trans._animationRaf);\n            trans._animationRaf = null;\n        }\n\n        function nextFrame() {\n            if(trans._currentFrame && trans._currentFrame.onComplete) {\n                // Execute the callback and unset it to ensure it doesn't\n                // accidentally get called twice\n                trans._currentFrame.onComplete();\n            }\n\n            var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n            if(newFrame) {\n                // Since it's sometimes necessary to do deep digging into frame data,\n                // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n                // so check when casting the name, just to be absolutely certain:\n                var stringName = newFrame.name ? newFrame.name.toString() : null;\n                gd._fullLayout._currentFrame = stringName;\n\n                trans._lastFrameAt = Date.now();\n                trans._timeToNext = newFrame.frameOpts.duration;\n\n                // This is simply called and it's left to .transition to decide how to manage\n                // interrupting current transitions. That means we don't need to worry about\n                // how it resolves or what happens after this:\n                Plots.transition(gd,\n                    newFrame.frame.data,\n                    newFrame.frame.layout,\n                    helpers.coerceTraceIndices(gd, newFrame.frame.traces),\n                    newFrame.frameOpts,\n                    newFrame.transitionOpts\n                ).then(function() {\n                    if(newFrame.onComplete) {\n                        newFrame.onComplete();\n                    }\n                });\n\n                gd.emit('plotly_animatingframe', {\n                    name: stringName,\n                    frame: newFrame.frame,\n                    animation: {\n                        frame: newFrame.frameOpts,\n                        transition: newFrame.transitionOpts,\n                    }\n                });\n            } else {\n                // If there are no more frames, then stop the RAF loop:\n                stopAnimationLoop();\n            }\n        }\n\n        function beginAnimationLoop() {\n            gd.emit('plotly_animating');\n\n            // If no timer is running, then set last frame = long ago so that the next\n            // frame is immediately transitioned:\n            trans._lastFrameAt = -Infinity;\n            trans._timeToNext = 0;\n            trans._runningTransitions = 0;\n            trans._currentFrame = null;\n\n            var doFrame = function() {\n                // This *must* be requested before nextFrame since nextFrame may decide\n                // to cancel it if there's nothing more to animated:\n                trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n                // Check if we're ready for a new frame:\n                if(Date.now() - trans._lastFrameAt > trans._timeToNext) {\n                    nextFrame();\n                }\n            };\n\n            doFrame();\n        }\n\n        // This is an animate-local counter that helps match up option input list\n        // items with the particular frame.\n        var configCounter = 0;\n        function setTransitionConfig(frame) {\n            if(Array.isArray(transitionOpts)) {\n                if(configCounter >= transitionOpts.length) {\n                    frame.transitionOpts = transitionOpts[configCounter];\n                } else {\n                    frame.transitionOpts = transitionOpts[0];\n                }\n            } else {\n                frame.transitionOpts = transitionOpts;\n            }\n            configCounter++;\n            return frame;\n        }\n\n        // Disambiguate what's sort of frames have been received\n        var i, frame;\n        var frameList = [];\n        var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n        var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n        var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n        if(isSingleFrame) {\n            // In this case, a simple object has been passed to animate.\n            frameList.push({\n                type: 'object',\n                data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n            });\n        } else if(allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n            // In this case, null or undefined has been passed so that we want to\n            // animate *all* currently defined frames\n            for(i = 0; i < trans._frames.length; i++) {\n                frame = trans._frames[i];\n\n                if(!frame) continue;\n\n                if(allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n                    frameList.push({\n                        type: 'byname',\n                        name: String(frame.name),\n                        data: setTransitionConfig({name: frame.name})\n                    });\n                }\n            }\n        } else if(isFrameArray) {\n            for(i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n                var frameOrName = frameOrGroupNameOrFrameList[i];\n                if(['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n                    frameOrName = String(frameOrName);\n                    // In this case, there's an array and this frame is a string name:\n                    frameList.push({\n                        type: 'byname',\n                        name: frameOrName,\n                        data: setTransitionConfig({name: frameOrName})\n                    });\n                } else if(Lib.isPlainObject(frameOrName)) {\n                    frameList.push({\n                        type: 'object',\n                        data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n                    });\n                }\n            }\n        }\n\n        // Verify that all of these frames actually exist; return and reject if not:\n        for(i = 0; i < frameList.length; i++) {\n            frame = frameList[i];\n            if(frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n                Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n                reject();\n                return;\n            }\n        }\n\n        // If the mode is either next or immediate, then all currently queued frames must\n        // be dumped and the corresponding .animate promises rejected.\n        if(['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n            discardExistingFrames();\n        }\n\n        if(animationOpts.direction === 'reverse') {\n            frameList.reverse();\n        }\n\n        var currentFrame = gd._fullLayout._currentFrame;\n        if(currentFrame && animationOpts.fromcurrent) {\n            var idx = -1;\n            for(i = 0; i < frameList.length; i++) {\n                frame = frameList[i];\n                if(frame.type === 'byname' && frame.name === currentFrame) {\n                    idx = i;\n                    break;\n                }\n            }\n\n            if(idx > 0 && idx < frameList.length - 1) {\n                var filteredFrameList = [];\n                for(i = 0; i < frameList.length; i++) {\n                    frame = frameList[i];\n                    if(frameList[i].type !== 'byname' || i > idx) {\n                        filteredFrameList.push(frame);\n                    }\n                }\n                frameList = filteredFrameList;\n            }\n        }\n\n        if(frameList.length > 0) {\n            queueFrames(frameList);\n        } else {\n            // This is the case where there were simply no frames. It's a little strange\n            // since there's not much to do:\n            gd.emit('plotly_animated');\n            resolve();\n        }\n    });\n}\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nfunction addFrames(gd, frameList, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(frameList === null || frameList === undefined) {\n        return Promise.resolve();\n    }\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before adding frames. For more details, see ' +\n            'https://plot.ly/javascript/animations/'\n        );\n    }\n\n    var i, frame, j, idx;\n    var _frames = gd._transitionData._frames;\n    var _frameHash = gd._transitionData._frameHash;\n\n\n    if(!Array.isArray(frameList)) {\n        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n    }\n\n    // Create a sorted list of insertions since we run into lots of problems if these\n    // aren't in ascending order of index:\n    //\n    // Strictly for sorting. Make sure this is guaranteed to never collide with any\n    // already-exisisting indices:\n    var bigIndex = _frames.length + frameList.length * 2;\n\n    var insertions = [];\n    var _frameHashLocal = {};\n    for(i = frameList.length - 1; i >= 0; i--) {\n        if(!Lib.isPlainObject(frameList[i])) continue;\n\n        // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n        // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n        var lookupName = frameList[i].name;\n        var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n        var newName = frameList[i].name;\n        var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n        if(name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n            numericNameWarningCount++;\n\n            Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name +\n                '\" with a frame whose name of type \"number\" also equates to \"' +\n                name + '\". This is valid but may potentially lead to unexpected ' +\n                'behavior since all plotly.js frame names are stored internally ' +\n                'as strings.');\n\n            if(numericNameWarningCount === numericNameWarningCountLimit) {\n                Lib.warn('addFrames: This API call has yielded too many of these warnings. ' +\n                    'For the rest of this call, further warnings about numeric frame ' +\n                    'names will be suppressed.');\n            }\n        }\n\n        _frameHashLocal[lookupName] = {name: lookupName};\n\n        insertions.push({\n            frame: Plots.supplyFrameDefaults(frameList[i]),\n            index: (indices && indices[i] !== undefined && indices[i] !== null) ? indices[i] : bigIndex + i\n        });\n    }\n\n    // Sort this, taking note that undefined insertions end up at the end:\n    insertions.sort(function(a, b) {\n        if(a.index > b.index) return -1;\n        if(a.index < b.index) return 1;\n        return 0;\n    });\n\n    var ops = [];\n    var revops = [];\n    var frameCount = _frames.length;\n\n    for(i = insertions.length - 1; i >= 0; i--) {\n        frame = insertions[i].frame;\n\n        if(typeof frame.name === 'number') {\n            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +\n                'implicitly cast to strings');\n        }\n\n        if(!frame.name) {\n            // Repeatedly assign a default name, incrementing the counter each time until\n            // we get a name that's not in the hashed lookup table:\n            while(_frameHash[(frame.name = 'frame ' + gd._transitionData._counter++)]);\n        }\n\n        if(_frameHash[frame.name]) {\n            // If frame is present, overwrite its definition:\n            for(j = 0; j < _frames.length; j++) {\n                if((_frames[j] || {}).name === frame.name) break;\n            }\n            ops.push({type: 'replace', index: j, value: frame});\n            revops.unshift({type: 'replace', index: j, value: _frames[j]});\n        } else {\n            // Otherwise insert it at the end of the list:\n            idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n\n            ops.push({type: 'insert', index: idx, value: frame});\n            revops.unshift({type: 'delete', index: idx});\n            frameCount++;\n        }\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nfunction deleteFrames(gd, frameList) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    var i, idx;\n    var _frames = gd._transitionData._frames;\n    var ops = [];\n    var revops = [];\n\n    if(!frameList) {\n        frameList = [];\n        for(i = 0; i < _frames.length; i++) {\n            frameList.push(i);\n        }\n    }\n\n    frameList = frameList.slice();\n    frameList.sort();\n\n    for(i = frameList.length - 1; i >= 0; i--) {\n        idx = frameList[i];\n        ops.push({type: 'delete', index: idx});\n        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nfunction purge(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    var fullLayout = gd._fullLayout || {};\n    var fullData = gd._fullData || [];\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, fullData, fullLayout);\n\n    // purge properties\n    Plots.purge(gd);\n\n    // purge event emitter methods\n    Events.purge(gd);\n\n    // remove plot container\n    if(fullLayout._container) fullLayout._container.remove();\n\n    // in contrast to Plotly.Plots.purge which does NOT clear _context!\n    delete gd._context;\n\n    return gd;\n}\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n    var gd3 = d3.select(gd);\n    var fullLayout = gd._fullLayout;\n\n    // Plot container\n    fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n    fullLayout._container.enter().insert('div', ':first-child')\n        .classed('plot-container', true)\n        .classed('plotly', true);\n\n    // Make the svg container\n    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n    fullLayout._paperdiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // Make the graph containers\n    // start fresh each time we get here, so we know the order comes out\n    // right, rather than enter/exit which can muck up the order\n    // TODO: sort out all the ordering so we don't have to\n    // explicitly delete anything\n    // FIXME: parcoords reuses this object, not the best pattern\n    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')\n        .data([{}]);\n\n    fullLayout._glcontainer.enter().append('div')\n        .classed('gl-container', true);\n\n    fullLayout._paperdiv.selectAll('.main-svg').remove();\n    fullLayout._paperdiv.select('.modebar-container').remove();\n\n    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')\n        .classed('main-svg', true);\n\n    fullLayout._toppaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n\n    fullLayout._hoverpaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    if(!fullLayout._uid) {\n        var otherUids = {};\n        d3.selectAll('defs').each(function() {\n            if(this.id) otherUids[this.id.split('-')[1]] = 1;\n        });\n        fullLayout._uid = Lib.randstr(otherUids);\n    }\n\n    fullLayout._paperdiv.selectAll('.main-svg')\n        .attr(xmlnsNamespaces.svgAttrs);\n\n    fullLayout._defs = fullLayout._paper.append('defs')\n        .attr('id', 'defs-' + fullLayout._uid);\n\n    fullLayout._clips = fullLayout._defs.append('g')\n        .classed('clips', true);\n\n    fullLayout._topdefs = fullLayout._toppaper.append('defs')\n        .attr('id', 'topdefs-' + fullLayout._uid);\n\n    fullLayout._topclips = fullLayout._topdefs.append('g')\n        .classed('clips', true);\n\n    fullLayout._bgLayer = fullLayout._paper.append('g')\n        .classed('bglayer', true);\n\n    fullLayout._draggers = fullLayout._paper.append('g')\n        .classed('draglayer', true);\n\n    // lower shape/image layer - note that this is behind\n    // all subplots data/grids but above the backgrounds\n    // except inset subplots, whose backgrounds are drawn\n    // inside their own group so that they appear above\n    // the data for the main subplot\n    // lower shapes and images which are fully referenced to\n    // a subplot still get drawn within the subplot's group\n    // so they will work correctly on insets\n    var layerBelow = fullLayout._paper.append('g')\n        .classed('layer-below', true);\n    fullLayout._imageLowerLayer = layerBelow.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeLowerLayer = layerBelow.append('g')\n        .classed('shapelayer', true);\n\n    // single cartesian layer for the whole plot\n    fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n    // single polar layer for the whole plot\n    fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\n\n    // single ternary layer for the whole plot\n    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n    // single geo layer for the whole plot\n    fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n    // single funnelarea layer for the whole plot\n    fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true);\n\n    // single pie layer for the whole plot\n    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n    // single treemap layer for the whole plot\n    fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true);\n\n    // single sunburst layer for the whole plot\n    fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true);\n\n    // single indicator layer for the whole plot\n    fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true);\n\n    // fill in image server scrape-svg\n    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n    // lastly upper shapes, info (legend, annotations) and hover layers go on top\n    // these are in a different svg element normally, but get collapsed into a single\n    // svg when exporting (after inserting 3D)\n    // upper shapes/images are only those drawn above the whole plot, including subplots\n    var layerAbove = fullLayout._toppaper.append('g')\n        .classed('layer-above', true);\n    fullLayout._imageUpperLayer = layerAbove.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeUpperLayer = layerAbove.append('g')\n        .classed('shapelayer', true);\n\n    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n    fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n    fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true);\n\n    // Make the modebar container\n    fullLayout._modebardiv\n        .classed('modebar-container', true)\n        .style('position', 'absolute')\n        .style('top', '0px')\n        .style('right', '0px');\n\n    gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\n\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\n\nexports.newPlot = newPlot;\nexports.plot = plot;\nexports.purge = purge;\n\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\n\nexports.setPlotConfig = setPlotConfig;\n\nexports.update = update;\n\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\n\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;\n"]},"metadata":{},"sourceType":"script"}