{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar SHOWISOLATETIP = true;\n\nmodule.exports = function handleClick(g, gd, numClicks) {\n  var fullLayout = gd._fullLayout;\n  if (gd._dragged || gd._editing) return;\n  var itemClick = fullLayout.legend.itemclick;\n  var itemDoubleClick = fullLayout.legend.itemdoubleclick;\n\n  if (numClicks === 1 && itemClick === 'toggle' && itemDoubleClick === 'toggleothers' && SHOWISOLATETIP && gd.data && gd._context.showTips) {\n    Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n    SHOWISOLATETIP = false;\n  } else {\n    SHOWISOLATETIP = false;\n  }\n\n  var mode;\n  if (numClicks === 1) mode = itemClick;else if (numClicks === 2) mode = itemDoubleClick;\n  if (!mode) return;\n  var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];\n  var legendItem = g.data()[0][0];\n  var fullData = gd._fullData;\n  var fullTrace = legendItem.trace;\n  var legendgroup = fullTrace.legendgroup;\n  var i, j, kcont, key, keys, val;\n  var attrUpdate = {};\n  var attrIndices = [];\n  var carrs = [];\n  var carrIdx = [];\n\n  function insertUpdate(traceIndex, key, value) {\n    var attrIndex = attrIndices.indexOf(traceIndex);\n    var valueArray = attrUpdate[key];\n\n    if (!valueArray) {\n      valueArray = attrUpdate[key] = [];\n    }\n\n    if (attrIndices.indexOf(traceIndex) === -1) {\n      attrIndices.push(traceIndex);\n      attrIndex = attrIndices.length - 1;\n    }\n\n    valueArray[attrIndex] = value;\n    return attrIndex;\n  }\n\n  function setVisibility(fullTrace, visibility) {\n    var fullInput = fullTrace._fullInput;\n\n    if (Registry.hasTransform(fullInput, 'groupby')) {\n      var kcont = carrs[fullInput.index];\n\n      if (!kcont) {\n        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n        var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n        kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n        carrs[fullInput.index] = kcont;\n      }\n\n      var curState = kcont.get(fullTrace._group); // If not specified, assume visible. This happens if there are other style\n      // properties set for a group but not the visibility. There are many similar\n      // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n      // answer is: because it breaks other things like groupby trace names in\n      // subtle ways.)\n\n      if (curState === undefined) {\n        curState = true;\n      }\n\n      if (curState !== false) {\n        // true -> legendonly. All others toggle to true:\n        kcont.set(fullTrace._group, visibility);\n      }\n\n      carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n    } else {\n      // false -> false (not possible since will not be visible in legend)\n      // true -> legendonly\n      // legendonly -> true\n      var nextVisibility = fullInput.visible === false ? false : visibility;\n      insertUpdate(fullInput.index, 'visible', nextVisibility);\n    }\n  }\n\n  if (Registry.traceIs(fullTrace, 'pie-like')) {\n    var thisLabel = legendItem.label;\n    var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n\n    if (mode === 'toggle') {\n      if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);else hiddenSlices.splice(thisLabelIndex, 1);\n    } else if (mode === 'toggleothers') {\n      hiddenSlices = [];\n      gd.calcdata[0].forEach(function (d) {\n        if (thisLabel !== d.label) {\n          hiddenSlices.push(d.label);\n        }\n      });\n\n      if (gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n        hiddenSlices = [];\n      }\n    }\n\n    Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n  } else {\n    var hasLegendgroup = legendgroup && legendgroup.length;\n    var traceIndicesInGroup = [];\n    var tracei;\n\n    if (hasLegendgroup) {\n      for (i = 0; i < fullData.length; i++) {\n        tracei = fullData[i];\n        if (!tracei.visible) continue;\n\n        if (tracei.legendgroup === legendgroup) {\n          traceIndicesInGroup.push(i);\n        }\n      }\n    }\n\n    if (mode === 'toggle') {\n      var nextVisibility;\n\n      switch (fullTrace.visible) {\n        case true:\n          nextVisibility = 'legendonly';\n          break;\n\n        case false:\n          nextVisibility = false;\n          break;\n\n        case 'legendonly':\n          nextVisibility = true;\n          break;\n      }\n\n      if (hasLegendgroup) {\n        for (i = 0; i < fullData.length; i++) {\n          if (fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n            setVisibility(fullData[i], nextVisibility);\n          }\n        }\n      } else {\n        setVisibility(fullTrace, nextVisibility);\n      }\n    } else if (mode === 'toggleothers') {\n      // Compute the clicked index. expandedIndex does what we want for expanded traces\n      // but also culls hidden traces. That means we have some work to do.\n      var isClicked, isInGroup, otherState;\n      var isIsolated = true;\n\n      for (i = 0; i < fullData.length; i++) {\n        isClicked = fullData[i] === fullTrace;\n        if (isClicked) continue;\n        isInGroup = hasLegendgroup && fullData[i].legendgroup === legendgroup;\n\n        if (!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          isIsolated = false;\n          break;\n        }\n      }\n\n      for (i = 0; i < fullData.length; i++) {\n        // False is sticky; we don't change it.\n        if (fullData[i].visible === false) continue;\n\n        if (Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          continue;\n        }\n\n        switch (fullTrace.visible) {\n          case 'legendonly':\n            setVisibility(fullData[i], true);\n            break;\n\n          case true:\n            otherState = isIsolated ? true : 'legendonly';\n            isClicked = fullData[i] === fullTrace;\n            isInGroup = isClicked || hasLegendgroup && fullData[i].legendgroup === legendgroup;\n            setVisibility(fullData[i], isInGroup ? true : otherState);\n            break;\n        }\n      }\n    }\n\n    for (i = 0; i < carrs.length; i++) {\n      kcont = carrs[i];\n      if (!kcont) continue;\n      var update = kcont.constructUpdate();\n      var updateKeys = Object.keys(update);\n\n      for (j = 0; j < updateKeys.length; j++) {\n        key = updateKeys[j];\n        val = attrUpdate[key] = attrUpdate[key] || [];\n        val[carrIdx[i]] = update[key];\n      }\n    } // The length of the value arrays should be equal and any unspecified\n    // values should be explicitly undefined for them to get properly culled\n    // as updates and not accidentally reset to the default value. This fills\n    // out sparse arrays with the required number of undefined values:\n\n\n    keys = Object.keys(attrUpdate);\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n\n      for (j = 0; j < attrIndices.length; j++) {\n        // Use hasOwnPropety to protect against falsey values:\n        if (!attrUpdate[key].hasOwnProperty(j)) {\n          attrUpdate[key][j] = undefined;\n        }\n      }\n    }\n\n    Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}