{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar polygon = require('../../lib/polygon');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\n\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\n\nvar style = require('./style').style;\n\nfunction plot(gd, geo, calcData) {\n  for (var i = 0; i < calcData.length; i++) {\n    calcGeoJSON(calcData[i], geo.topojson);\n  }\n\n  var choroplethLayer = geo.layers.backplot.select('.choroplethlayer');\n  Lib.makeTraceGroups(choroplethLayer, calcData, 'trace choropleth').each(function (calcTrace) {\n    var sel = d3.select(this);\n    var paths = sel.selectAll('path.choroplethlocation').data(Lib.identity);\n    paths.enter().append('path').classed('choroplethlocation', true);\n    paths.exit().remove(); // call style here within topojson request callback\n\n    style(gd, calcTrace);\n  });\n}\n\nfunction calcGeoJSON(calcTrace, topojson) {\n  var trace = calcTrace[0].trace;\n  var len = calcTrace.length;\n  var features = getTopojsonFeatures(trace, topojson);\n\n  for (var i = 0; i < len; i++) {\n    var calcPt = calcTrace[i];\n    var feature = locationToFeature(trace.locationmode, calcPt.loc, features);\n\n    if (!feature) {\n      calcPt.geojson = null;\n      continue;\n    }\n\n    calcPt.geojson = feature;\n    calcPt.ct = feature.properties.ct;\n    calcPt._polygons = feature2polygons(feature);\n  }\n}\n\nfunction feature2polygons(feature) {\n  var geometry = feature.geometry;\n  var coords = geometry.coordinates;\n  var loc = feature.id;\n  var polygons = [];\n  var appendPolygon, j, k, m;\n\n  function doesCrossAntiMerdian(pts) {\n    for (var l = 0; l < pts.length - 1; l++) {\n      if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n    }\n\n    return null;\n  }\n\n  if (loc === 'RUS' || loc === 'FJI') {\n    // Russia and Fiji have landmasses that cross the antimeridian,\n    // we need to add +360 to their longitude coordinates, so that\n    // polygon 'contains' doesn't get confused when crossing the antimeridian.\n    //\n    // Note that other countries have polygons on either side of the antimeridian\n    // (e.g. some Aleutian island for the USA), but those don't confuse\n    // the 'contains' method; these are skipped here.\n    appendPolygon = function (_pts) {\n      var pts;\n\n      if (doesCrossAntiMerdian(_pts) === null) {\n        pts = _pts;\n      } else {\n        pts = new Array(_pts.length);\n\n        for (m = 0; m < _pts.length; m++) {\n          // do nut mutate calcdata[i][j].geojson !!\n          pts[m] = [_pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0], _pts[m][1]];\n        }\n      }\n\n      polygons.push(polygon.tester(pts));\n    };\n  } else if (loc === 'ATA') {\n    // Antarctica has a landmass that wraps around every longitudes which\n    // confuses the 'contains' methods.\n    appendPolygon = function (pts) {\n      var crossAntiMeridianIndex = doesCrossAntiMerdian(pts); // polygon that do not cross anti-meridian need no special handling\n\n      if (crossAntiMeridianIndex === null) {\n        return polygons.push(polygon.tester(pts));\n      } // stitch polygon by adding pt over South Pole,\n      // so that it covers the projected region covers all latitudes\n      //\n      // Note that the algorithm below only works for polygons that\n      // start and end on longitude -180 (like the ones built by\n      // https://github.com/etpinard/sane-topojson).\n\n\n      var stitch = new Array(pts.length + 1);\n      var si = 0;\n\n      for (m = 0; m < pts.length; m++) {\n        if (m > crossAntiMeridianIndex) {\n          stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n        } else if (m === crossAntiMeridianIndex) {\n          stitch[si++] = pts[m];\n          stitch[si++] = [pts[m][0], -90];\n        } else {\n          stitch[si++] = pts[m];\n        }\n      } // polygon.tester by default appends pt[0] to the points list,\n      // we must remove it here, to avoid a jump in longitude from 180 to -180,\n      // that would confuse the 'contains' method\n\n\n      var tester = polygon.tester(stitch);\n      tester.pts.pop();\n      polygons.push(tester);\n    };\n  } else {\n    // otherwise using same array ref is fine\n    appendPolygon = function (pts) {\n      polygons.push(polygon.tester(pts));\n    };\n  }\n\n  switch (geometry.type) {\n    case 'MultiPolygon':\n      for (j = 0; j < coords.length; j++) {\n        for (k = 0; k < coords[j].length; k++) {\n          appendPolygon(coords[j][k]);\n        }\n      }\n\n      break;\n\n    case 'Polygon':\n      for (j = 0; j < coords.length; j++) {\n        appendPolygon(coords[j]);\n      }\n\n      break;\n  }\n\n  return polygons;\n}\n\nmodule.exports = {\n  plot: plot,\n  feature2polygons: feature2polygons\n};","map":null,"metadata":{},"sourceType":"script"}