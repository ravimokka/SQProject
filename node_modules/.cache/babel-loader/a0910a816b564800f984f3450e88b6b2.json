{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar dragElement = require('../dragelement');\n\nvar Lib = require('../../lib');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar setCursor = require('../../lib/setcursor');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar Titles = require('../titles');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar flipScale = require('../colorscale/helpers').flipScale;\n\nvar handleAxisDefaults = require('../../plots/cartesian/axis_defaults');\n\nvar handleAxisPositionDefaults = require('../../plots/cartesian/position_defaults');\n\nvar axisLayoutAttrs = require('../../plots/cartesian/layout_attributes');\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nvar cn = require('./constants').cn;\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  var colorBars = fullLayout._infolayer.selectAll('g.' + cn.colorbar).data(makeColorBarData(gd), function (opts) {\n    return opts._id;\n  });\n\n  colorBars.enter().append('g').attr('class', function (opts) {\n    return opts._id;\n  }).classed(cn.colorbar, true);\n  colorBars.each(function (opts) {\n    var g = d3.select(this);\n    Lib.ensureSingle(g, 'rect', cn.cbbg);\n    Lib.ensureSingle(g, 'g', cn.cbfills);\n    Lib.ensureSingle(g, 'g', cn.cblines);\n    Lib.ensureSingle(g, 'g', cn.cbaxis, function (s) {\n      s.classed(cn.crisp, true);\n    });\n    Lib.ensureSingle(g, 'g', cn.cbtitleunshift, function (s) {\n      s.append('g').classed(cn.cbtitle, true);\n    });\n    Lib.ensureSingle(g, 'rect', cn.cboutline);\n    var done = drawColorBar(g, opts, gd);\n    if (done && done.then) (gd._promises || []).push(done);\n\n    if (gd._context.edits.colorbarPosition) {\n      makeEditable(g, opts, gd);\n    }\n  });\n  colorBars.exit().each(function (opts) {\n    Plots.autoMargin(gd, opts._id);\n  }).remove();\n  colorBars.order();\n}\n\nfunction makeColorBarData(gd) {\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var out = []; // single out item\n\n  var opts; // colorbar attr parent container\n\n  var cont; // trace attr container\n\n  var trace; // colorbar options\n\n  var cbOpt;\n\n  function initOpts(opts) {\n    return extendFlat(opts, {\n      // fillcolor can be a d3 scale, domain is z values, range is colors\n      // or leave it out for no fill,\n      // or set to a string constant for single-color fill\n      _fillcolor: null,\n      // line.color has the same options as fillcolor\n      _line: {\n        color: null,\n        width: null,\n        dash: null\n      },\n      // levels of lines to draw.\n      // note that this DOES NOT determine the extent of the bar\n      // that's given by the domain of fillcolor\n      // (or line.color if no fillcolor domain)\n      _levels: {\n        start: null,\n        end: null,\n        size: null\n      },\n      // separate fill levels (for example, heatmap coloring of a\n      // contour map) if this is omitted, fillcolors will be\n      // evaluated halfway between levels\n      _filllevels: null,\n      // for continuous colorscales: fill with a gradient instead of explicit levels\n      // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]\n      _fillgradient: null,\n      // when using a gradient, we need the data range specified separately\n      _zrange: null\n    });\n  }\n\n  function calcOpts() {\n    if (typeof cbOpt.calc === 'function') {\n      cbOpt.calc(gd, trace, opts);\n    } else {\n      opts._fillgradient = cont.reversescale ? flipScale(cont.colorscale) : cont.colorscale;\n      opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];\n    }\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    trace = cd[0].trace;\n    var moduleOpts = trace._module.colorbar;\n\n    if (trace.visible === true && moduleOpts) {\n      var allowsMultiplotCbs = Array.isArray(moduleOpts);\n      var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];\n\n      for (var j = 0; j < cbOpts.length; j++) {\n        cbOpt = cbOpts[j];\n        var contName = cbOpt.container;\n        cont = contName ? trace[contName] : trace;\n\n        if (cont && cont.showscale) {\n          opts = initOpts(cont.colorbar);\n          opts._id = 'cb' + trace.uid + (allowsMultiplotCbs && contName ? '-' + contName : '');\n          opts._traceIndex = trace.index;\n          opts._propPrefix = (contName ? contName + '.' : '') + 'colorbar.';\n          opts._meta = trace._meta;\n          calcOpts();\n          out.push(opts);\n        }\n      }\n    }\n  }\n\n  for (var k in fullLayout._colorAxes) {\n    cont = fullLayout[k];\n\n    if (cont.showscale) {\n      var colorAxOpts = fullLayout._colorAxes[k];\n      opts = initOpts(cont.colorbar);\n      opts._id = 'cb' + k;\n      opts._propPrefix = k + '.colorbar.';\n      opts._meta = fullLayout._meta;\n      cbOpt = {\n        min: 'cmin',\n        max: 'cmax'\n      };\n\n      if (colorAxOpts[0] !== 'heatmap') {\n        trace = colorAxOpts[1];\n        cbOpt.calc = trace._module.colorbar.calc;\n      }\n\n      calcOpts();\n      out.push(opts);\n    }\n  }\n\n  return out;\n}\n\nfunction drawColorBar(g, opts, gd) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var fillColor = opts._fillcolor;\n  var line = opts._line;\n  var title = opts.title;\n  var titleSide = title.side;\n  var zrange = opts._zrange || d3.extent((typeof fillColor === 'function' ? fillColor : line.color).domain());\n  var lineColormap = typeof line.color === 'function' ? line.color : function () {\n    return line.color;\n  };\n  var fillColormap = typeof fillColor === 'function' ? fillColor : function () {\n    return fillColor;\n  };\n  var levelsIn = opts._levels;\n  var levelsOut = calcLevels(gd, opts, zrange);\n  var fillLevels = levelsOut.fill;\n  var lineLevels = levelsOut.line; // we calculate pixel sizes based on the specified graph size,\n  // not the actual (in case something pushed the margins around)\n  // which is a little odd but avoids an odd iterative effect\n  // when the colorbar itself is pushing the margins.\n  // but then the fractional size is calculated based on the\n  // actual graph size, so that the axes will size correctly.\n\n  var thickPx = Math.round(opts.thickness * (opts.thicknessmode === 'fraction' ? gs.w : 1));\n  var thickFrac = thickPx / gs.w;\n  var lenPx = Math.round(opts.len * (opts.lenmode === 'fraction' ? gs.h : 1));\n  var lenFrac = lenPx / gs.h;\n  var xpadFrac = opts.xpad / gs.w;\n  var yExtraPx = (opts.borderwidth + opts.outlinewidth) / 2;\n  var ypadFrac = opts.ypad / gs.h; // x positioning: do it initially just for left anchor,\n  // then fix at the end (since we don't know the width yet)\n\n  var xLeft = Math.round(opts.x * gs.w + opts.xpad); // for dragging... this is getting a little muddled...\n\n  var xLeftFrac = opts.x - thickFrac * ({\n    middle: 0.5,\n    right: 1\n  }[opts.xanchor] || 0); // y positioning we can do correctly from the start\n\n  var yBottomFrac = opts.y + lenFrac * (({\n    top: -0.5,\n    bottom: 0.5\n  }[opts.yanchor] || 0) - 0.5);\n  var yBottomPx = Math.round(gs.h * (1 - yBottomFrac));\n  var yTopPx = yBottomPx - lenPx; // stash a few things for makeEditable\n\n  opts._lenFrac = lenFrac;\n  opts._thickFrac = thickFrac;\n  opts._xLeftFrac = xLeftFrac;\n  opts._yBottomFrac = yBottomFrac; // stash mocked axis for contour label formatting\n\n  var ax = opts._axis = mockColorBarAxis(gd, opts, zrange); // position can't go in through supplyDefaults\n  // because that restricts it to [0,1]\n\n  ax.position = opts.x + xpadFrac + thickFrac;\n\n  if (['top', 'bottom'].indexOf(titleSide) !== -1) {\n    ax.title.side = titleSide;\n    ax.titlex = opts.x + xpadFrac;\n    ax.titley = yBottomFrac + (title.side === 'top' ? lenFrac - ypadFrac : ypadFrac);\n  }\n\n  if (line.color && opts.tickmode === 'auto') {\n    ax.tickmode = 'linear';\n    ax.tick0 = levelsIn.start;\n    var dtick = levelsIn.size; // expand if too many contours, so we don't get too many ticks\n\n    var autoNtick = Lib.constrain((yBottomPx - yTopPx) / 50, 4, 15) + 1;\n    var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);\n\n    if (dtFactor > 1) {\n      var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));\n      dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]); // if the contours are at round multiples, reset tick0\n      // so they're still at round multiples. Otherwise,\n      // keep the first label on the first contour level\n\n      if ((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {\n        ax.tick0 = 0;\n      }\n    }\n\n    ax.dtick = dtick;\n  } // set domain after init, because we may want to\n  // allow it outside [0,1]\n\n\n  ax.domain = [yBottomFrac + ypadFrac, yBottomFrac + lenFrac - ypadFrac];\n  ax.setScale();\n  g.attr('transform', 'translate(' + Math.round(gs.l) + ',' + Math.round(gs.t) + ')');\n  var titleCont = g.select('.' + cn.cbtitleunshift).attr('transform', 'translate(-' + Math.round(gs.l) + ',-' + Math.round(gs.t) + ')');\n  var axLayer = g.select('.' + cn.cbaxis);\n  var titleEl;\n  var titleHeight = 0;\n\n  function drawTitle(titleClass, titleOpts) {\n    var dfltTitleOpts = {\n      propContainer: ax,\n      propName: opts._propPrefix + 'title',\n      traceIndex: opts._traceIndex,\n      _meta: opts._meta,\n      placeholder: fullLayout._dfltTitle.colorbar,\n      containerGroup: g.select('.' + cn.cbtitle)\n    }; // this class-to-rotate thing with convertToTspans is\n    // getting hackier and hackier... delete groups with the\n    // wrong class (in case earlier the colorbar was drawn on\n    // a different side, I think?)\n\n    var otherClass = titleClass.charAt(0) === 'h' ? titleClass.substr(1) : 'h' + titleClass;\n    g.selectAll('.' + otherClass + ',.' + otherClass + '-math-group').remove();\n    Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));\n  }\n\n  function drawDummyTitle() {\n    if (['top', 'bottom'].indexOf(titleSide) !== -1) {\n      // draw the title so we know how much room it needs\n      // when we squish the axis. This one only applies to\n      // top or bottom titles, not right side.\n      var x = gs.l + (opts.x + xpadFrac) * gs.w;\n      var fontSize = ax.title.font.size;\n      var y;\n\n      if (titleSide === 'top') {\n        y = (1 - (yBottomFrac + lenFrac - ypadFrac)) * gs.h + gs.t + 3 + fontSize * 0.75;\n      } else {\n        y = (1 - (yBottomFrac + ypadFrac)) * gs.h + gs.t - 3 - fontSize * 0.25;\n      }\n\n      drawTitle(ax._id + 'title', {\n        attributes: {\n          x: x,\n          y: y,\n          'text-anchor': 'start'\n        }\n      });\n    }\n  }\n\n  function drawCbTitle() {\n    if (['top', 'bottom'].indexOf(titleSide) === -1) {\n      var fontSize = ax.title.font.size;\n      var y = ax._offset + ax._length / 2;\n      var x = gs.l + (ax.position || 0) * gs.w + (ax.side === 'right' ? 10 + fontSize * (ax.showticklabels ? 1 : 0.5) : -10 - fontSize * (ax.showticklabels ? 0.5 : 0)); // the 'h' + is a hack to get around the fact that\n      // convertToTspans rotates any 'y...' class by 90 degrees.\n      // TODO: find a better way to control this.\n\n      drawTitle('h' + ax._id + 'title', {\n        avoid: {\n          selection: d3.select(gd).selectAll('g.' + ax._id + 'tick'),\n          side: titleSide,\n          offsetLeft: gs.l,\n          offsetTop: 0,\n          maxShift: fullLayout.width\n        },\n        attributes: {\n          x: x,\n          y: y,\n          'text-anchor': 'middle'\n        },\n        transform: {\n          rotate: '-90',\n          offset: 0\n        }\n      });\n    }\n  }\n\n  function drawAxis() {\n    if (['top', 'bottom'].indexOf(titleSide) !== -1) {\n      // squish the axis top to make room for the title\n      var titleGroup = g.select('.' + cn.cbtitle);\n      var titleText = titleGroup.select('text');\n      var titleTrans = [-opts.outlinewidth / 2, opts.outlinewidth / 2];\n      var mathJaxNode = titleGroup.select('.h' + ax._id + 'title-math-group').node();\n      var lineSize = 15.6;\n\n      if (titleText.node()) {\n        lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;\n      }\n\n      if (mathJaxNode) {\n        titleHeight = Drawing.bBox(mathJaxNode).height;\n\n        if (titleHeight > lineSize) {\n          // not entirely sure how mathjax is doing\n          // vertical alignment, but this seems to work.\n          titleTrans[1] -= (titleHeight - lineSize) / 2;\n        }\n      } else if (titleText.node() && !titleText.classed(cn.jsPlaceholder)) {\n        titleHeight = Drawing.bBox(titleText.node()).height;\n      }\n\n      if (titleHeight) {\n        // buffer btwn colorbar and title\n        // TODO: configurable\n        titleHeight += 5;\n\n        if (titleSide === 'top') {\n          ax.domain[1] -= titleHeight / gs.h;\n          titleTrans[1] *= -1;\n        } else {\n          ax.domain[0] += titleHeight / gs.h;\n          var nlines = svgTextUtils.lineCount(titleText);\n          titleTrans[1] += (1 - nlines) * lineSize;\n        }\n\n        titleGroup.attr('transform', 'translate(' + titleTrans + ')');\n        ax.setScale();\n      }\n    }\n\n    g.selectAll('.' + cn.cbfills + ',.' + cn.cblines).attr('transform', 'translate(0,' + Math.round(gs.h * (1 - ax.domain[1])) + ')');\n    axLayer.attr('transform', 'translate(0,' + Math.round(-gs.t) + ')');\n    var fills = g.select('.' + cn.cbfills).selectAll('rect.' + cn.cbfill).data(fillLevels);\n    fills.enter().append('rect').classed(cn.cbfill, true).style('stroke', 'none');\n    fills.exit().remove();\n    var zBounds = zrange.map(ax.c2p).map(Math.round).sort(function (a, b) {\n      return a - b;\n    });\n    fills.each(function (d, i) {\n      var z = [i === 0 ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2, i === fillLevels.length - 1 ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2].map(ax.c2p).map(Math.round); // offset the side adjoining the next rectangle so they\n      // overlap, to prevent antialiasing gaps\n\n      z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]); // Colorbar cannot currently support opacities so we\n      // use an opaque fill even when alpha channels present\n\n      var fillEl = d3.select(this).attr({\n        x: xLeft,\n        width: Math.max(thickPx, 2),\n        y: d3.min(z),\n        height: Math.max(d3.max(z) - d3.min(z), 2)\n      });\n\n      if (opts._fillgradient) {\n        Drawing.gradient(fillEl, gd, opts._id, 'vertical', opts._fillgradient, 'fill');\n      } else {\n        // tinycolor can't handle exponents and\n        // at this scale, removing it makes no difference.\n        var colorString = fillColormap(d).replace('e-', '');\n        fillEl.attr('fill', tinycolor(colorString).toHexString());\n      }\n    });\n    var lines = g.select('.' + cn.cblines).selectAll('path.' + cn.cbline).data(line.color && line.width ? lineLevels : []);\n    lines.enter().append('path').classed(cn.cbline, true);\n    lines.exit().remove();\n    lines.each(function (d) {\n      d3.select(this).attr('d', 'M' + xLeft + ',' + (Math.round(ax.c2p(d)) + line.width / 2 % 1) + 'h' + thickPx).call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);\n    }); // force full redraw of labels and ticks\n\n    axLayer.selectAll('g.' + ax._id + 'tick,path').remove();\n    var shift = xLeft + thickPx + (opts.outlinewidth || 0) / 2 - (opts.ticks === 'outside' ? 1 : 0);\n    var vals = Axes.calcTicks(ax);\n    var transFn = Axes.makeTransFn(ax);\n    var tickSign = Axes.getTickSigns(ax)[2];\n    Axes.drawTicks(gd, ax, {\n      vals: ax.ticks === 'inside' ? Axes.clipEnds(ax, vals) : vals,\n      layer: axLayer,\n      path: Axes.makeTickPath(ax, shift, tickSign),\n      transFn: transFn\n    });\n    return Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: axLayer,\n      transFn: transFn,\n      labelFns: Axes.makeLabelFns(ax, shift)\n    });\n  } // wait for the axis & title to finish rendering before\n  // continuing positioning\n  // TODO: why are we redrawing multiple times now with this?\n  // I guess autoMargin doesn't like being post-promise?\n\n\n  function positionCB() {\n    var innerWidth = thickPx + opts.outlinewidth / 2 + Drawing.bBox(axLayer.node()).width;\n    titleEl = titleCont.select('text');\n\n    if (titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {\n      var mathJaxNode = titleCont.select('.h' + ax._id + 'title-math-group').node();\n      var titleWidth;\n\n      if (mathJaxNode && ['top', 'bottom'].indexOf(titleSide) !== -1) {\n        titleWidth = Drawing.bBox(mathJaxNode).width;\n      } else {\n        // note: the formula below works for all title sides,\n        // (except for top/bottom mathjax, above)\n        // but the weird gs.l is because the titleunshift\n        // transform gets removed by Drawing.bBox\n        titleWidth = Drawing.bBox(titleCont.node()).right - xLeft - gs.l;\n      }\n\n      innerWidth = Math.max(innerWidth, titleWidth);\n    }\n\n    var outerwidth = 2 * opts.xpad + innerWidth + opts.borderwidth + opts.outlinewidth / 2;\n    var outerheight = yBottomPx - yTopPx;\n    g.select('.' + cn.cbbg).attr({\n      x: xLeft - opts.xpad - (opts.borderwidth + opts.outlinewidth) / 2,\n      y: yTopPx - yExtraPx,\n      width: Math.max(outerwidth, 2),\n      height: Math.max(outerheight + 2 * yExtraPx, 2)\n    }).call(Color.fill, opts.bgcolor).call(Color.stroke, opts.bordercolor).style('stroke-width', opts.borderwidth);\n    g.selectAll('.' + cn.cboutline).attr({\n      x: xLeft,\n      y: yTopPx + opts.ypad + (titleSide === 'top' ? titleHeight : 0),\n      width: Math.max(thickPx, 2),\n      height: Math.max(outerheight - 2 * opts.ypad - titleHeight, 2)\n    }).call(Color.stroke, opts.outlinecolor).style({\n      fill: 'none',\n      'stroke-width': opts.outlinewidth\n    }); // fix positioning for xanchor!='left'\n\n    var xoffset = ({\n      center: 0.5,\n      right: 1\n    }[opts.xanchor] || 0) * outerwidth;\n    g.attr('transform', 'translate(' + (gs.l - xoffset) + ',' + gs.t + ')'); // auto margin adjustment\n\n    var marginOpts = {};\n    var tFrac = FROM_TL[opts.yanchor];\n    var bFrac = FROM_BR[opts.yanchor];\n\n    if (opts.lenmode === 'pixels') {\n      marginOpts.y = opts.y;\n      marginOpts.t = outerheight * tFrac;\n      marginOpts.b = outerheight * bFrac;\n    } else {\n      marginOpts.t = marginOpts.b = 0;\n      marginOpts.yt = opts.y + opts.len * tFrac;\n      marginOpts.yb = opts.y - opts.len * bFrac;\n    }\n\n    var lFrac = FROM_TL[opts.xanchor];\n    var rFrac = FROM_BR[opts.xanchor];\n\n    if (opts.thicknessmode === 'pixels') {\n      marginOpts.x = opts.x;\n      marginOpts.l = outerwidth * lFrac;\n      marginOpts.r = outerwidth * rFrac;\n    } else {\n      var extraThickness = outerwidth - thickPx;\n      marginOpts.l = extraThickness * lFrac;\n      marginOpts.r = extraThickness * rFrac;\n      marginOpts.xl = opts.x - opts.thickness * lFrac;\n      marginOpts.xr = opts.x + opts.thickness * rFrac;\n    }\n\n    Plots.autoMargin(gd, opts._id, marginOpts);\n  }\n\n  return Lib.syncOrAsync([Plots.previousPromises, drawDummyTitle, drawAxis, drawCbTitle, Plots.previousPromises, positionCB], gd);\n}\n\nfunction makeEditable(g, opts, gd) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var t0, xf, yf;\n  dragElement.init({\n    element: g.node(),\n    gd: gd,\n    prepFn: function () {\n      t0 = g.attr('transform');\n      setCursor(g);\n    },\n    moveFn: function (dx, dy) {\n      g.attr('transform', t0 + ' ' + 'translate(' + dx + ',' + dy + ')');\n      xf = dragElement.align(opts._xLeftFrac + dx / gs.w, opts._thickFrac, 0, 1, opts.xanchor);\n      yf = dragElement.align(opts._yBottomFrac - dy / gs.h, opts._lenFrac, 0, 1, opts.yanchor);\n      var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);\n      setCursor(g, csr);\n    },\n    doneFn: function () {\n      setCursor(g);\n\n      if (xf !== undefined && yf !== undefined) {\n        var update = {};\n        update[opts._propPrefix + 'x'] = xf;\n        update[opts._propPrefix + 'y'] = yf;\n\n        if (opts._traceIndex !== undefined) {\n          Registry.call('_guiRestyle', gd, update, opts._traceIndex);\n        } else {\n          Registry.call('_guiRelayout', gd, update);\n        }\n      }\n    }\n  });\n}\n\nfunction calcLevels(gd, opts, zrange) {\n  var levelsIn = opts._levels;\n  var lineLevels = [];\n  var fillLevels = [];\n  var l;\n  var i;\n  var l0 = levelsIn.end + levelsIn.size / 100;\n  var ls = levelsIn.size;\n  var zr0 = 1.001 * zrange[0] - 0.001 * zrange[1];\n  var zr1 = 1.001 * zrange[1] - 0.001 * zrange[0];\n\n  for (i = 0; i < 1e5; i++) {\n    l = levelsIn.start + i * ls;\n    if (ls > 0 ? l >= l0 : l <= l0) break;\n    if (l > zr0 && l < zr1) lineLevels.push(l);\n  }\n\n  if (opts._fillgradient) {\n    fillLevels = [0];\n  } else if (typeof opts._fillcolor === 'function') {\n    var fillLevelsIn = opts._filllevels;\n\n    if (fillLevelsIn) {\n      l0 = fillLevelsIn.end + fillLevelsIn.size / 100;\n      ls = fillLevelsIn.size;\n\n      for (i = 0; i < 1e5; i++) {\n        l = fillLevelsIn.start + i * ls;\n        if (ls > 0 ? l >= l0 : l <= l0) break;\n        if (l > zrange[0] && l < zrange[1]) fillLevels.push(l);\n      }\n    } else {\n      fillLevels = lineLevels.map(function (v) {\n        return v - levelsIn.size / 2;\n      });\n      fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);\n    }\n  } else if (opts._fillcolor && typeof opts._fillcolor === 'string') {\n    // doesn't matter what this value is, with a single value\n    // we'll make a single fill rect covering the whole bar\n    fillLevels = [0];\n  }\n\n  if (levelsIn.size < 0) {\n    lineLevels.reverse();\n    fillLevels.reverse();\n  }\n\n  return {\n    line: lineLevels,\n    fill: fillLevels\n  };\n}\n\nfunction mockColorBarAxis(gd, opts, zrange) {\n  var fullLayout = gd._fullLayout;\n  var cbAxisIn = {\n    type: 'linear',\n    range: zrange,\n    tickmode: opts.tickmode,\n    nticks: opts.nticks,\n    tick0: opts.tick0,\n    dtick: opts.dtick,\n    tickvals: opts.tickvals,\n    ticktext: opts.ticktext,\n    ticks: opts.ticks,\n    ticklen: opts.ticklen,\n    tickwidth: opts.tickwidth,\n    tickcolor: opts.tickcolor,\n    showticklabels: opts.showticklabels,\n    tickfont: opts.tickfont,\n    tickangle: opts.tickangle,\n    tickformat: opts.tickformat,\n    exponentformat: opts.exponentformat,\n    separatethousands: opts.separatethousands,\n    showexponent: opts.showexponent,\n    showtickprefix: opts.showtickprefix,\n    tickprefix: opts.tickprefix,\n    showticksuffix: opts.showticksuffix,\n    ticksuffix: opts.ticksuffix,\n    title: opts.title,\n    showline: true,\n    anchor: 'free',\n    side: 'right',\n    position: 1\n  };\n  var cbAxisOut = {\n    type: 'linear',\n    _id: 'y' + opts._id\n  };\n  var axisOptions = {\n    letter: 'y',\n    font: fullLayout.font,\n    noHover: true,\n    noTickson: true,\n    calendar: fullLayout.calendar // not really necessary (yet?)\n\n  };\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);\n  }\n\n  handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);\n  handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);\n  return cbAxisOut;\n}\n\nmodule.exports = {\n  draw: draw\n};","map":null,"metadata":{},"sourceType":"script"}