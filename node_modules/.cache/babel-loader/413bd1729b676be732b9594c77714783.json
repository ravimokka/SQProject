{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as _ from 'lodash';\nvar QUICK_TYPE = [{\n  type: 'pie',\n  series: {\n    gemo: 'interval',\n    adjust: 'stack'\n  },\n  coord: {\n    type: 'theta'\n  }\n}, {\n  type: 'sector',\n  series: {\n    gemo: 'interval'\n  },\n  coord: {\n    type: 'polar'\n  }\n}, {\n  type: 'line',\n  series: {\n    gemo: 'line'\n  }\n}, {\n  type: 'smoothLine',\n  series: {\n    gemo: 'line',\n    shape: 'smooth'\n  }\n}, {\n  type: 'dashLine',\n  series: {\n    gemo: 'line',\n    shape: 'dash'\n  }\n}, {\n  type: 'stackLine',\n  series: {\n    gemo: 'line',\n    adjust: 'stack'\n  }\n}, {\n  type: 'area',\n  series: {\n    gemo: 'area'\n  }\n}, {\n  type: 'stackArea',\n  series: {\n    gemo: 'area',\n    adjust: 'stack'\n  }\n}, {\n  type: 'smoothArea',\n  series: {\n    gemo: 'area',\n    shape: 'smooth'\n  }\n}, {\n  type: 'interval',\n  series: {\n    gemo: 'interval'\n  }\n}, {\n  type: 'stackInterval',\n  series: {\n    gemo: 'interval',\n    adjust: 'stack'\n  }\n}, {\n  type: 'dodgeInterval',\n  series: {\n    gemo: 'interval',\n    shape: 'interval',\n    adjust: 'dodge'\n  }\n}, {\n  type: 'bar',\n  series: {\n    gemo: 'interval'\n  }\n}, {\n  type: 'stackBar',\n  series: {\n    gemo: 'interval',\n    shape: 'interval',\n    adjust: 'stack'\n  }\n}, {\n  type: 'dodgeBar',\n  series: {\n    gemo: 'interval',\n    shape: 'interval',\n    adjust: 'dodge'\n  }\n}, {\n  type: 'point',\n  series: {\n    gemo: 'point',\n    shape: 'hollowCircle'\n  }\n}, {\n  type: 'funnel',\n  series: {\n    gemo: 'interval',\n    adjust: 'symmetric',\n    shape: 'funnel'\n  }\n}, {\n  type: 'pyramid',\n  series: {\n    gemo: 'interval',\n    adjust: 'symmetric',\n    shape: 'pyramid'\n  }\n}, {\n  type: 'schema',\n  series: {\n    gemo: 'schema',\n    shape: 'box'\n  }\n}, {\n  type: 'box',\n  series: {\n    gemo: 'schema',\n    shape: 'box'\n  }\n}, {\n  type: 'candle',\n  series: {\n    gemo: 'schema',\n    shape: 'candle'\n  }\n}, {\n  type: 'polygon',\n  series: {\n    gemo: 'polygon'\n  }\n}, {\n  type: 'contour',\n  series: {\n    gemo: 'contour'\n  }\n}, {\n  type: 'heatmap',\n  series: {\n    gemo: 'heatmap'\n  }\n}, {\n  type: 'edge',\n  series: {\n    gemo: 'edge'\n  }\n}, {\n  type: 'sankey',\n  series: {\n    gemo: 'edge',\n    shape: 'sankey'\n  }\n}, {\n  type: 'errorBar',\n  series: {\n    gemo: 'schema',\n    shape: 'errorbar'\n  }\n}, {\n  type: 'jitterPoint',\n  series: {\n    gemo: 'point',\n    adjust: 'jitter'\n  }\n}, {\n  type: 'path',\n  series: {\n    gemo: 'path'\n  }\n}, {\n  type: 'venn',\n  series: {\n    gemo: 'venn'\n  }\n}];\nexport var process = function (series, coord) {\n  var quickType = {};\n\n  for (var _i = 0, QUICK_TYPE_1 = QUICK_TYPE; _i < QUICK_TYPE_1.length; _i++) {\n    var item = QUICK_TYPE_1[_i];\n    quickType[item.type] = item;\n  }\n\n  for (var i = 0; i < series.length; i++) {\n    var currType = quickType[series[i].quickType];\n\n    if (currType) {\n      series[i] = __assign({}, currType.series, series[i]);\n\n      if (coord && coord.type && _.get(currType, 'coord.type') && _.get(currType, 'coord.type') !== coord.type) {\n        throw new Error('quickType and coord had conflicted.');\n      }\n    }\n  }\n\n  return series;\n};","map":{"version":3,"sources":["../../src/components/setQuickType.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as _ from 'lodash';\nvar QUICK_TYPE = [\n    {\n        type: 'pie',\n        series: {\n            gemo: 'interval',\n            adjust: 'stack'\n        },\n        coord: {\n            type: 'theta'\n        }\n    },\n    {\n        type: 'sector',\n        series: {\n            gemo: 'interval'\n        },\n        coord: {\n            type: 'polar'\n        }\n    },\n    {\n        type: 'line',\n        series: {\n            gemo: 'line'\n        }\n    },\n    {\n        type: 'smoothLine',\n        series: {\n            gemo: 'line',\n            shape: 'smooth'\n        }\n    },\n    {\n        type: 'dashLine',\n        series: {\n            gemo: 'line',\n            shape: 'dash'\n        }\n    },\n    {\n        type: 'stackLine',\n        series: {\n            gemo: 'line',\n            adjust: 'stack'\n        }\n    },\n    {\n        type: 'area',\n        series: {\n            gemo: 'area'\n        }\n    },\n    {\n        type: 'stackArea',\n        series: {\n            gemo: 'area',\n            adjust: 'stack'\n        }\n    },\n    {\n        type: 'smoothArea',\n        series: {\n            gemo: 'area',\n            shape: 'smooth'\n        }\n    },\n    {\n        type: 'interval',\n        series: {\n            gemo: 'interval'\n        }\n    },\n    {\n        type: 'stackInterval',\n        series: {\n            gemo: 'interval',\n            adjust: 'stack'\n        }\n    },\n    {\n        type: 'dodgeInterval',\n        series: {\n            gemo: 'interval',\n            shape: 'interval',\n            adjust: 'dodge'\n        }\n    },\n    {\n        type: 'bar',\n        series: {\n            gemo: 'interval'\n        }\n    },\n    {\n        type: 'stackBar',\n        series: {\n            gemo: 'interval',\n            shape: 'interval',\n            adjust: 'stack'\n        }\n    },\n    {\n        type: 'dodgeBar',\n        series: {\n            gemo: 'interval',\n            shape: 'interval',\n            adjust: 'dodge'\n        }\n    },\n    {\n        type: 'point',\n        series: {\n            gemo: 'point',\n            shape: 'hollowCircle'\n        }\n    },\n    {\n        type: 'funnel',\n        series: {\n            gemo: 'interval',\n            adjust: 'symmetric',\n            shape: 'funnel'\n        }\n    },\n    {\n        type: 'pyramid',\n        series: {\n            gemo: 'interval',\n            adjust: 'symmetric',\n            shape: 'pyramid'\n        }\n    },\n    {\n        type: 'schema',\n        series: {\n            gemo: 'schema',\n            shape: 'box'\n        }\n    },\n    {\n        type: 'box',\n        series: {\n            gemo: 'schema',\n            shape: 'box'\n        }\n    },\n    {\n        type: 'candle',\n        series: {\n            gemo: 'schema',\n            shape: 'candle'\n        }\n    },\n    {\n        type: 'polygon',\n        series: {\n            gemo: 'polygon'\n        }\n    },\n    {\n        type: 'contour',\n        series: {\n            gemo: 'contour'\n        }\n    },\n    {\n        type: 'heatmap',\n        series: {\n            gemo: 'heatmap'\n        }\n    },\n    {\n        type: 'edge',\n        series: {\n            gemo: 'edge'\n        }\n    },\n    {\n        type: 'sankey',\n        series: {\n            gemo: 'edge',\n            shape: 'sankey'\n        }\n    },\n    {\n        type: 'errorBar',\n        series: {\n            gemo: 'schema',\n            shape: 'errorbar'\n        }\n    },\n    {\n        type: 'jitterPoint',\n        series: {\n            gemo: 'point',\n            adjust: 'jitter'\n        }\n    },\n    {\n        type: 'path',\n        series: {\n            gemo: 'path'\n        }\n    },\n    {\n        type: 'venn',\n        series: {\n            gemo: 'venn'\n        }\n    },\n];\nexport var process = function (series, coord) {\n    var quickType = {};\n    for (var _i = 0, QUICK_TYPE_1 = QUICK_TYPE; _i < QUICK_TYPE_1.length; _i++) {\n        var item = QUICK_TYPE_1[_i];\n        quickType[item.type] = item;\n    }\n    for (var i = 0; i < series.length; i++) {\n        var currType = quickType[series[i].quickType];\n        if (currType) {\n            series[i] = __assign({}, currType.series, series[i]);\n            if (coord && coord.type && _.get(currType, 'coord.type') &&\n                _.get(currType, 'coord.type') !== coord.type) {\n                throw new Error('quickType and coord had conflicted.');\n            }\n        }\n    }\n    return series;\n};\n//# sourceMappingURL=setQuickType.js.map"]},"metadata":{},"sourceType":"module"}