{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar dragElement = require('../dragelement');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers'); // Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne\n};\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout; // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n\n  fullLayout._shapeUpperLayer.selectAll('path').remove();\n\n  fullLayout._shapeLowerLayer.selectAll('path').remove();\n\n  for (var k in fullLayout._plots) {\n    var shapelayer = fullLayout._plots[k].shapelayer;\n    if (shapelayer) shapelayer.selectAll('path').remove();\n  }\n\n  for (var i = 0; i < fullLayout.shapes.length; i++) {\n    if (fullLayout.shapes[i].visible) {\n      drawOne(gd, i);\n    }\n  } // may need to resurrect this if we put text (LaTeX) in shapes\n  // return Plots.previousPromises(gd);\n\n}\n\nfunction drawOne(gd, index) {\n  // remove the existing shape if there is one.\n  // because indices can change, we need to look in all shape layers\n  gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index=\"' + index + '\"]').remove();\n\n  var options = gd._fullLayout.shapes[index] || {}; // this shape is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n\n  if (!options._input || options.visible === false) return;\n\n  if (options.layer !== 'below') {\n    drawShape(gd._fullLayout._shapeUpperLayer);\n  } else if (options.xref === 'paper' || options.yref === 'paper') {\n    drawShape(gd._fullLayout._shapeLowerLayer);\n  } else {\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n\n    if (plotinfo) {\n      var mainPlot = plotinfo.mainplotinfo || plotinfo;\n      drawShape(mainPlot.shapelayer);\n    } else {\n      // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n      // This can happen if you reference the shape to an x / y axis combination\n      // that doesn't have any data on it (and layer is below)\n      drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n  }\n\n  function drawShape(shapeLayer) {\n    var attrs = {\n      'data-index': index,\n      'fill-rule': 'evenodd',\n      d: getPathString(gd, options)\n    };\n    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n    var path = shapeLayer.append('path').attr(attrs).style('opacity', options.opacity).call(Color.stroke, lineColor).call(Color.fill, options.fillcolor).call(Drawing.dashLine, options.line.dash, options.line.width);\n    setClipPath(path, gd, options);\n    if (gd._context.edits.shapePosition) setupDragElement(gd, path, options, index, shapeLayer);\n  }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n  // note that for layer=\"below\" the clipAxes can be different from the\n  // subplot we're drawing this in. This could cause problems if the shape\n  // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n  var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '');\n  Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer) {\n  var MINWIDTH = 10;\n  var MINHEIGHT = 10;\n  var xPixelSized = shapeOptions.xsizemode === 'pixel';\n  var yPixelSized = shapeOptions.ysizemode === 'pixel';\n  var isLine = shapeOptions.type === 'line';\n  var isPath = shapeOptions.type === 'path';\n  var editHelpers = arrayEditor(gd.layout, 'shapes', shapeOptions);\n  var modifyItem = editHelpers.modifyItem;\n  var x0, y0, x1, y1, xAnchor, yAnchor;\n  var n0, s0, w0, e0, optN, optS, optW, optE;\n  var pathIn; // setup conversion functions\n\n  var xa = Axes.getFromId(gd, shapeOptions.xref);\n  var ya = Axes.getFromId(gd, shapeOptions.yref);\n  var x2p = helpers.getDataToPixel(gd, xa);\n  var y2p = helpers.getDataToPixel(gd, ya, true);\n  var p2x = helpers.getPixelToData(gd, xa);\n  var p2y = helpers.getPixelToData(gd, ya, true);\n  var sensoryElement = obtainSensoryElement();\n  var dragOptions = {\n    element: sensoryElement.node(),\n    gd: gd,\n    prepFn: startDrag,\n    doneFn: endDrag,\n    clickFn: abortDrag\n  };\n  var dragMode;\n  dragElement.init(dragOptions);\n  sensoryElement.node().onmousemove = updateDragMode;\n\n  function obtainSensoryElement() {\n    return isLine ? createLineDragHandles() : shapePath;\n  }\n\n  function createLineDragHandles() {\n    var minSensoryWidth = 10;\n    var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth); // Helper shapes group\n    // Note that by setting the `data-index` attr, it is ensured that\n    // the helper group is purged in this modules `draw` function\n\n    var g = shapeLayer.append('g').attr('data-index', index); // Helper path for moving\n\n    g.append('path').attr('d', shapePath.attr('d')).style({\n      'cursor': 'move',\n      'stroke-width': sensoryWidth,\n      'stroke-opacity': '0' // ensure not visible\n\n    }); // Helper circles for resizing\n\n    var circleStyle = {\n      'fill-opacity': '0' // ensure not visible\n\n    };\n    var circleRadius = sensoryWidth / 2 > minSensoryWidth ? sensoryWidth / 2 : minSensoryWidth;\n    g.append('circle').attr({\n      'data-line-point': 'start-point',\n      'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n      'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n      'r': circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    g.append('circle').attr({\n      'data-line-point': 'end-point',\n      'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n      'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n      'r': circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    return g;\n  }\n\n  function updateDragMode(evt) {\n    if (isLine) {\n      if (evt.target.tagName === 'path') {\n        dragMode = 'move';\n      } else {\n        dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ? 'resize-over-start-point' : 'resize-over-end-point';\n      }\n    } else {\n      // element might not be on screen at time of setup,\n      // so obtain bounding box here\n      var dragBBox = dragOptions.element.getBoundingClientRect(); // choose 'move' or 'resize'\n      // based on initial position of cursor within the drag element\n\n      var w = dragBBox.right - dragBBox.left;\n      var h = dragBBox.bottom - dragBBox.top;\n      var x = evt.clientX - dragBBox.left;\n      var y = evt.clientY - dragBBox.top;\n      var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : 'move';\n      setCursor(shapePath, cursor); // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n\n      dragMode = cursor.split('-')[0];\n    }\n  }\n\n  function startDrag(evt) {\n    // setup update strings and initial values\n    if (xPixelSized) {\n      xAnchor = x2p(shapeOptions.xanchor);\n    }\n\n    if (yPixelSized) {\n      yAnchor = y2p(shapeOptions.yanchor);\n    }\n\n    if (shapeOptions.type === 'path') {\n      pathIn = shapeOptions.path;\n    } else {\n      x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n      y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n      x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n      y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n    }\n\n    if (x0 < x1) {\n      w0 = x0;\n      optW = 'x0';\n      e0 = x1;\n      optE = 'x1';\n    } else {\n      w0 = x1;\n      optW = 'x1';\n      e0 = x0;\n      optE = 'x0';\n    } // For fixed size shapes take opposing direction of y-axis into account.\n    // Hint: For data sized shapes this is done by the y2p function.\n\n\n    if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {\n      n0 = y0;\n      optN = 'y0';\n      s0 = y1;\n      optS = 'y1';\n    } else {\n      n0 = y1;\n      optN = 'y1';\n      s0 = y0;\n      optS = 'y0';\n    } // setup dragMode and the corresponding handler\n\n\n    updateDragMode(evt);\n    renderVisualCues(shapeLayer, shapeOptions);\n    deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n    dragOptions.moveFn = dragMode === 'move' ? moveShape : resizeShape;\n  }\n\n  function endDrag() {\n    setCursor(shapePath);\n    removeVisualCues(shapeLayer); // Don't rely on clipPath being activated during re-layout\n\n    setClipPath(shapePath, gd, shapeOptions);\n    Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n  }\n\n  function abortDrag() {\n    removeVisualCues(shapeLayer);\n  }\n\n  function moveShape(dx, dy) {\n    if (shapeOptions.type === 'path') {\n      var noOp = function (coord) {\n        return coord;\n      };\n\n      var moveX = noOp;\n      var moveY = noOp;\n\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else {\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n        modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n      }\n\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n        modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n      }\n    }\n\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n  }\n\n  function resizeShape(dx, dy) {\n    if (isPath) {\n      // TODO: implement path resize, don't forget to update dragMode code\n      var noOp = function (coord) {\n        return coord;\n      };\n\n      var moveX = noOp;\n      var moveY = noOp;\n\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else if (isLine) {\n      if (dragMode === 'resize-over-start-point') {\n        var newX0 = x0 + dx;\n        var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n        modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n        modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n      } else if (dragMode === 'resize-over-end-point') {\n        var newX1 = x1 + dx;\n        var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n        modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n        modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n      }\n    } else {\n      var newN = ~dragMode.indexOf('n') ? n0 + dy : n0;\n      var newS = ~dragMode.indexOf('s') ? s0 + dy : s0;\n      var newW = ~dragMode.indexOf('w') ? w0 + dx : w0;\n      var newE = ~dragMode.indexOf('e') ? e0 + dx : e0; // Do things in opposing direction for y-axis.\n      // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n\n      if (~dragMode.indexOf('n') && yPixelSized) newN = n0 - dy;\n      if (~dragMode.indexOf('s') && yPixelSized) newS = s0 - dy; // Update shape eventually. Again, be aware of the\n      // opposing direction of the y-axis of fixed size shapes.\n\n      if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {\n        modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n        modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n      }\n\n      if (newE - newW > MINWIDTH) {\n        modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n        modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n      }\n    }\n\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n  }\n\n  function renderVisualCues(shapeLayer, shapeOptions) {\n    if (xPixelSized || yPixelSized) {\n      renderAnchor();\n    }\n\n    function renderAnchor() {\n      var isNotPath = shapeOptions.type !== 'path'; // d3 join with dummy data to satisfy d3 data-binding\n\n      var visualCues = shapeLayer.selectAll('.visual-cue').data([0]); // Enter\n\n      var strokeWidth = 1;\n      visualCues.enter().append('path').attr({\n        'fill': '#fff',\n        'fill-rule': 'evenodd',\n        'stroke': '#000',\n        'stroke-width': strokeWidth\n      }).classed('visual-cue', true); // Update\n\n      var posX = x2p(xPixelSized ? shapeOptions.xanchor : Lib.midRange(isNotPath ? [shapeOptions.x0, shapeOptions.x1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsX)));\n      var posY = y2p(yPixelSized ? shapeOptions.yanchor : Lib.midRange(isNotPath ? [shapeOptions.y0, shapeOptions.y1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsY)));\n      posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n      posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n      if (xPixelSized && yPixelSized) {\n        var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n        visualCues.attr('d', crossPath);\n      } else if (xPixelSized) {\n        var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) + 'v18 h2 v-18 Z';\n        visualCues.attr('d', vBarPath);\n      } else {\n        var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h18 v2 h-18 Z';\n        visualCues.attr('d', hBarPath);\n      }\n    }\n  }\n\n  function removeVisualCues(shapeLayer) {\n    shapeLayer.selectAll('.visual-cue').remove();\n  }\n\n  function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n    var xref = shapeOptions.xref;\n    var yref = shapeOptions.yref;\n    var xa = Axes.getFromId(gd, xref);\n    var ya = Axes.getFromId(gd, yref);\n    var clipAxes = '';\n    if (xref !== 'paper' && !xa.autorange) clipAxes += xref;\n    if (yref !== 'paper' && !ya.autorange) clipAxes += yref;\n    Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n  }\n}\n\nfunction getPathString(gd, options) {\n  var type = options.type;\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  var gs = gd._fullLayout._size;\n  var x2r, x2p, y2r, y2p;\n  var x0, x1, y0, y1;\n\n  if (xa) {\n    x2r = helpers.shapePositionToRange(xa);\n\n    x2p = function (v) {\n      return xa._offset + xa.r2p(x2r(v, true));\n    };\n  } else {\n    x2p = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  if (ya) {\n    y2r = helpers.shapePositionToRange(ya);\n\n    y2p = function (v) {\n      return ya._offset + ya.r2p(y2r(v, true));\n    };\n  } else {\n    y2p = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  }\n\n  if (type === 'path') {\n    if (xa && xa.type === 'date') x2p = helpers.decodeDate(x2p);\n    if (ya && ya.type === 'date') y2p = helpers.decodeDate(y2p);\n    return convertPath(options, x2p, y2p);\n  }\n\n  if (options.xsizemode === 'pixel') {\n    var xAnchorPos = x2p(options.xanchor);\n    x0 = xAnchorPos + options.x0;\n    x1 = xAnchorPos + options.x1;\n  } else {\n    x0 = x2p(options.x0);\n    x1 = x2p(options.x1);\n  }\n\n  if (options.ysizemode === 'pixel') {\n    var yAnchorPos = y2p(options.yanchor);\n    y0 = yAnchorPos - options.y0;\n    y1 = yAnchorPos - options.y1;\n  } else {\n    y0 = y2p(options.y0);\n    y1 = y2p(options.y1);\n  }\n\n  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z'; // circle\n\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var rx = Math.abs(cx - x0);\n  var ry = Math.abs(cy - y0);\n  var rArc = 'A' + rx + ',' + ry;\n  var rightPt = cx + rx + ',' + cy;\n  var topPt = cx + ',' + (cy - ry);\n  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';\n}\n\nfunction convertPath(options, x2p, y2p) {\n  var pathIn = options.path;\n  var xSizemode = options.xsizemode;\n  var ySizemode = options.ysizemode;\n  var xAnchor = options.xanchor;\n  var yAnchor = options.yanchor;\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (xParams[paramNumber]) {\n        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);\n      } else if (yParams[paramNumber]) {\n        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);\n      }\n\n      paramNumber++;\n      if (paramNumber > nParams) param = 'X';\n      return param;\n    });\n\n    if (paramNumber > nParams) {\n      paramString = paramString.replace(/[\\s,]*X.*/, '');\n      Lib.log('Ignoring extra params in segment ' + segment);\n    }\n\n    return segmentType + paramString;\n  });\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (paramNumber >= nParams) return param;\n      if (xParams[paramNumber]) param = moveX(param);else if (yParams[paramNumber]) param = moveY(param);\n      paramNumber++;\n      return param;\n    });\n    return segmentType + paramString;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}