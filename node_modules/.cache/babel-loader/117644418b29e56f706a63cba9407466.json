{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\n\nvar binFunctions = require('./bin_functions');\n\nvar normFunctions = require('./norm_functions');\n\nvar doAvg = require('./average');\n\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nfunction calc(gd, trace) {\n  var pos = [];\n  var size = [];\n  var pa = Axes.getFromId(gd, trace.orientation === 'h' ? trace.yaxis : trace.xaxis);\n  var mainData = trace.orientation === 'h' ? 'y' : 'x';\n  var counterData = {\n    x: 'y',\n    y: 'x'\n  }[mainData];\n  var calendar = trace[mainData + 'calendar'];\n  var cumulativeSpec = trace.cumulative;\n  var i;\n  var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n  var binSpec = binsAndPos[0];\n  var pos0 = binsAndPos[1];\n  var nonuniformBins = typeof binSpec.size === 'string';\n  var binEdges = [];\n  var bins = nonuniformBins ? binEdges : binSpec; // make the empty bin array\n\n  var inc = [];\n  var counts = [];\n  var inputPoints = [];\n  var total = 0;\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densityNorm = norm.indexOf('density') !== -1;\n  var i2, binEnd, n;\n\n  if (cumulativeSpec.enabled && densityNorm) {\n    // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n    // which in the end means it's the same as without \"density\"\n    norm = norm.replace(/ ?density$/, '');\n    densityNorm = false;\n  }\n\n  var extremeFunc = func === 'max' || func === 'min';\n  var sizeInit = extremeFunc ? null : 0;\n  var binFunc = binFunctions.count;\n  var normFunc = normFunctions[norm];\n  var isAvg = false;\n\n  var pr2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n\n  var rawCounterData;\n\n  if (Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n    rawCounterData = trace[counterData];\n    isAvg = func === 'avg';\n    binFunc = binFunctions[func];\n  } // create the bins (and any extra arrays needed)\n  // assume more than 1e6 bins is an error, so we don't crash the browser\n\n\n  i = pr2c(binSpec.start); // decrease end a little in case of rounding errors\n\n  binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n  while (i < binEnd && pos.length < 1e6) {\n    i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n    pos.push((i + i2) / 2);\n    size.push(sizeInit);\n    inputPoints.push([]); // nonuniform bins (like months) we need to search,\n    // rather than straight calculate the bin we're in\n\n    binEdges.push(i); // nonuniform bins also need nonuniform normalization factors\n\n    if (densityNorm) inc.push(1 / (i2 - i));\n    if (isAvg) counts.push(0); // break to avoid infinite loops\n\n    if (i2 <= i) break;\n    i = i2;\n  }\n\n  binEdges.push(i); // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n\n  if (!nonuniformBins && pa.type === 'date') {\n    bins = {\n      start: pr2c(bins.start),\n      end: pr2c(bins.end),\n      size: bins.size\n    };\n  } // bin the data\n  // and make histogram-specific pt-number-to-cd-index map object\n\n\n  var nMax = size.length;\n  var uniqueValsPerBin = true;\n  var leftGap = Infinity;\n  var rightGap = Infinity;\n  var ptNumber2cdIndex = {};\n\n  for (i = 0; i < pos0.length; i++) {\n    var posi = pos0[i];\n    n = Lib.findBin(posi, bins);\n\n    if (n >= 0 && n < nMax) {\n      total += binFunc(n, i, size, rawCounterData, counts);\n\n      if (uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n        uniqueValsPerBin = false;\n      }\n\n      inputPoints[n].push(i);\n      ptNumber2cdIndex[i] = n;\n      leftGap = Math.min(leftGap, posi - binEdges[n]);\n      rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n    }\n  }\n\n  var roundFn;\n\n  if (!uniqueValsPerBin) {\n    roundFn = getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar);\n  } // average and/or normalize the data, if needed\n\n\n  if (isAvg) total = doAvg(size, counts);\n  if (normFunc) normFunc(size, total, inc); // after all normalization etc, now we can accumulate if desired\n\n  if (cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n  var seriesLen = Math.min(pos.length, size.length);\n  var cd = [];\n  var firstNonzero = 0;\n  var lastNonzero = seriesLen - 1; // look for empty bins at the ends to remove, so autoscale omits them\n\n  for (i = 0; i < seriesLen; i++) {\n    if (size[i]) {\n      firstNonzero = i;\n      break;\n    }\n  }\n\n  for (i = seriesLen - 1; i >= firstNonzero; i--) {\n    if (size[i]) {\n      lastNonzero = i;\n      break;\n    }\n  } // create the \"calculated data\" to plot\n\n\n  for (i = firstNonzero; i <= lastNonzero; i++) {\n    if (isNumeric(pos[i]) && isNumeric(size[i])) {\n      var cdi = {\n        p: pos[i],\n        s: size[i],\n        b: 0\n      }; // setup hover and event data fields,\n      // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n      // for cumulative distributions\n\n      if (!cumulativeSpec.enabled) {\n        cdi.pts = inputPoints[i];\n\n        if (uniqueValsPerBin) {\n          cdi.ph0 = cdi.ph1 = inputPoints[i].length ? pos0[inputPoints[i][0]] : pos[i];\n        } else {\n          cdi.ph0 = roundFn(binEdges[i]);\n          cdi.ph1 = roundFn(binEdges[i + 1], true);\n        }\n      }\n\n      cd.push(cdi);\n    }\n  }\n\n  if (cd.length === 1) {\n    // when we collapse to a single bin, calcdata no longer describes bin size\n    // so we need to explicitly specify it\n    cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n  }\n\n  arraysToCalcdata(cd, trace);\n\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n  }\n\n  return cd;\n}\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\n\n\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n  var binAttr = mainData + 'bins';\n  var fullLayout = gd._fullLayout;\n  var groupName = trace['_' + mainData + 'bingroup'];\n  var binOpts = fullLayout._histogramBinOpts[groupName];\n  var isOverlay = fullLayout.barmode === 'overlay';\n  var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n  var r2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n\n  var c2r = function (v) {\n    return pa.c2r(v, 0, calendar);\n  };\n\n  var cleanBound = pa.type === 'date' ? function (v) {\n    return v || v === 0 ? Lib.cleanDate(v, null, calendar) : null;\n  } : function (v) {\n    return isNumeric(v) ? Number(v) : null;\n  };\n\n  function setBound(attr, bins, newBins) {\n    if (bins[attr + 'Found']) {\n      bins[attr] = cleanBound(bins[attr]);\n      if (bins[attr] === null) bins[attr] = newBins[attr];\n    } else {\n      autoVals[attr] = bins[attr] = newBins[attr];\n      Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n    }\n  } // all but the first trace in this group has already been marked finished\n  // clear this flag, so next time we run calc we will run autobin again\n\n\n  if (trace['_' + mainData + 'autoBinFinished']) {\n    delete trace['_' + mainData + 'autoBinFinished'];\n  } else {\n    traces = binOpts.traces;\n    var allPos = []; // Note: we're including `legendonly` traces here for autobin purposes,\n    // so that showing & hiding from the legend won't affect bins.\n    // But this complicates things a bit since those traces don't `calc`,\n    // hence `isFirstVisible`.\n\n    var isFirstVisible = true;\n    var has2dMap = false;\n    var hasHist2dContour = false;\n\n    for (i = 0; i < traces.length; i++) {\n      tracei = traces[i];\n\n      if (tracei.visible) {\n        var mainDatai = binOpts.dirs[i];\n        pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n        allPos = Lib.concat(allPos, pos0);\n        delete tracei['_' + mainData + 'autoBinFinished'];\n\n        if (trace.visible === true) {\n          if (isFirstVisible) {\n            isFirstVisible = false;\n          } else {\n            delete tracei._autoBin;\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n          }\n\n          if (Registry.traceIs(tracei, '2dMap')) {\n            has2dMap = true;\n          }\n\n          if (tracei.type === 'histogram2dcontour') {\n            hasHist2dContour = true;\n          }\n        }\n      }\n    }\n\n    calendar = traces[0][mainData + 'calendar'];\n    var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n    var autoBin = traces[0]._autoBin = {};\n    autoVals = autoBin[binOpts.dirs[0]] = {};\n\n    if (hasHist2dContour) {\n      // the \"true\" 2nd argument reverses the tick direction (which we can't\n      // just do with a minus sign because of month bins)\n      if (!binOpts.size) {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      }\n\n      if (binOpts.end === undefined) {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    } // Edge case: single-valued histogram overlaying others\n    // Use them all together to calculate the bin size for the single-valued one\n\n\n    if (isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 && pa.type !== 'category' && pa.type !== 'multicategory') {\n      // Several single-valued histograms! Stop infinite recursion,\n      // just return an extra flag that tells handleSingleValueOverlays\n      // to sort out this trace too\n      if (_overlayEdgeCase) return [newBinSpec, pos0, true];\n      newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n    } // adjust for CDF edge cases\n\n\n    cumulativeSpec = tracei.cumulative || {};\n\n    if (cumulativeSpec.enabled && cumulativeSpec.currentbin !== 'include') {\n      if (cumulativeSpec.direction === 'decreasing') {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      } else {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    }\n\n    binOpts.size = newBinSpec.size;\n\n    if (!binOpts.sizeFound) {\n      autoVals.size = newBinSpec.size;\n      Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n    }\n\n    setBound('start', binOpts, newBinSpec);\n    setBound('end', binOpts, newBinSpec);\n  }\n\n  pos0 = trace['_' + mainData + 'pos0'];\n  delete trace['_' + mainData + 'pos0']; // Each trace can specify its own start/end, or if omitted\n  // we ensure they're beyond the bounds of this trace's data,\n  // and we need to make sure start is aligned with the main start\n\n  var traceInputBins = trace._input[binAttr] || {};\n  var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n  var mainStart = binOpts.start;\n  var startIn = pa.r2l(traceInputBins.start);\n  var hasStart = startIn !== undefined;\n\n  if ((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n    // We have an explicit start to reconcile across traces\n    // if this trace has an explicit start, shift it down to a bin edge\n    // if another trace had an explicit start, shift it down to a\n    // bin edge past our data\n    var traceStart = hasStart ? startIn : Lib.aggNums(Math.min, null, pos0);\n    var dummyAx = {\n      type: pa.type === 'category' || pa.type === 'multicategory' ? 'linear' : pa.type,\n      r2l: pa.r2l,\n      dtick: binOpts.size,\n      tick0: mainStart,\n      calendar: calendar,\n      range: [traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)].map(pa.l2r)\n    };\n    var newStart = Axes.tickFirst(dummyAx);\n\n    if (newStart > pa.r2l(traceStart)) {\n      newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n    }\n\n    traceBinOptsCalc.start = pa.l2r(newStart);\n    if (!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n  }\n\n  var mainEnd = binOpts.end;\n  var endIn = pa.r2l(traceInputBins.end);\n  var hasEnd = endIn !== undefined;\n\n  if ((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n    // Reconciling an explicit end is easier, as it doesn't need to\n    // match bin edges\n    var traceEnd = hasEnd ? endIn : Lib.aggNums(Math.max, null, pos0);\n    traceBinOptsCalc.end = pa.l2r(traceEnd);\n    if (!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n  } // Backward compatibility for one-time autobinning.\n  // autobin: true is handled in cleanData, but autobin: false\n  // needs to be here where we have determined the values.\n\n\n  var autoBinAttr = 'autobin' + mainData;\n\n  if (trace._input[autoBinAttr] === false) {\n    trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n    delete trace._input[autoBinAttr];\n    delete trace[autoBinAttr];\n  }\n\n  return [traceBinOptsCalc, pos0];\n}\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\n\n\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n  var fullLayout = gd._fullLayout;\n  var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n  var pastThisTrace = false;\n  var minSize = Infinity;\n  var singleValuedTraces = [trace];\n  var i, tracei, binOpts; // first collect all the:\n  // - min bin size from all multi-valued traces\n  // - single-valued traces\n\n  for (i = 0; i < overlaidTraceGroup.length; i++) {\n    tracei = overlaidTraceGroup[i];\n\n    if (tracei === trace) {\n      pastThisTrace = true;\n    } else if (!pastThisTrace) {\n      // This trace has already had its autobins calculated, so either:\n      // - it is part of a bingroup\n      // - it is NOT a single-valued trace\n      binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n      minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n    } else {\n      var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n      var binSpeci = resulti[0];\n      var isSingleValued = resulti[2]; // so we can use this result when we get to tracei in the normal\n      // course of events, mark it as done and put _pos0 back\n\n      tracei['_' + mainData + 'autoBinFinished'] = 1;\n      tracei['_' + mainData + 'pos0'] = resulti[1];\n\n      if (isSingleValued) {\n        singleValuedTraces.push(tracei);\n      } else {\n        minSize = Math.min(minSize, binSpeci.size);\n      }\n    }\n  } // find the real data values for each single-valued trace\n  // hunt through pos0 for the first valid value\n\n\n  var dataVals = new Array(singleValuedTraces.length);\n\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n\n    for (var j = 0; j < pos0.length; j++) {\n      if (pos0[j] !== undefined) {\n        dataVals[i] = pos0[j];\n        break;\n      }\n    }\n  } // are ALL traces are single-valued? use the min difference between\n  // all of their values (which defaults to 1 if there's still only one)\n\n\n  if (!isFinite(minSize)) {\n    minSize = Lib.distinctVals(dataVals).minDiff;\n  } // now apply the min size we found to all single-valued traces\n\n\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    tracei = singleValuedTraces[i];\n    var calendar = tracei[mainData + 'calendar'];\n    var newBins = {\n      start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n      end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n      size: minSize\n    };\n    tracei._input[binAttr] = tracei[binAttr] = newBins;\n    binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n    if (binOpts) Lib.extendFlat(binOpts, newBins);\n  }\n\n  return trace[binAttr];\n}\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\n\n\nfunction getConnectedHistograms(gd, trace) {\n  var xid = trace.xaxis;\n  var yid = trace.yaxis;\n  var orientation = trace.orientation;\n  var out = [];\n  var fullData = gd._fullData;\n\n  for (var i = 0; i < fullData.length; i++) {\n    var tracei = fullData[i];\n\n    if (tracei.type === 'histogram' && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {\n      out.push(tracei);\n    }\n  }\n\n  return out;\n}\n\nfunction cdf(size, direction, currentBin) {\n  var i, vi, prevSum;\n\n  function firstHalfPoint(i) {\n    prevSum = size[i];\n    size[i] /= 2;\n  }\n\n  function nextHalfPoint(i) {\n    vi = size[i];\n    size[i] = prevSum + vi / 2;\n    prevSum += vi;\n  }\n\n  if (currentBin === 'half') {\n    if (direction === 'increasing') {\n      firstHalfPoint(0);\n\n      for (i = 1; i < size.length; i++) {\n        nextHalfPoint(i);\n      }\n    } else {\n      firstHalfPoint(size.length - 1);\n\n      for (i = size.length - 2; i >= 0; i--) {\n        nextHalfPoint(i);\n      }\n    }\n  } else if (direction === 'increasing') {\n    for (i = 1; i < size.length; i++) {\n      size[i] += size[i - 1];\n    } // 'exclude' is identical to 'include' just shifted one bin over\n\n\n    if (currentBin === 'exclude') {\n      size.unshift(0);\n      size.pop();\n    }\n  } else {\n    for (i = size.length - 2; i >= 0; i--) {\n      size[i] += size[i + 1];\n    }\n\n    if (currentBin === 'exclude') {\n      size.push(0);\n      size.shift();\n    }\n  }\n}\n\nmodule.exports = {\n  calc: calc,\n  calcAllAutoBins: calcAllAutoBins\n};","map":null,"metadata":{},"sourceType":"script"}