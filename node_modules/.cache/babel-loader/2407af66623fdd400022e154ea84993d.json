{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\n\nvar Registry = require('../../registry');\n\nmodule.exports = {\n  getAutoRange: getAutoRange,\n  makePadFn: makePadFn,\n  doAutoRange: doAutoRange,\n  findExtremes: findExtremes,\n  concatExtremes: concatExtremes\n};\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\n\nfunction getAutoRange(gd, ax) {\n  var i, j;\n  var newRange = [];\n  var getPad = makePadFn(ax);\n  var extremes = concatExtremes(gd, ax);\n  var minArray = extremes.min;\n  var maxArray = extremes.max;\n\n  if (minArray.length === 0 || maxArray.length === 0) {\n    return Lib.simpleMap(ax.range, ax.r2l);\n  }\n\n  var minmin = minArray[0].val;\n  var maxmax = maxArray[0].val;\n\n  for (i = 1; i < minArray.length; i++) {\n    if (minmin !== maxmax) break;\n    minmin = Math.min(minmin, minArray[i].val);\n  }\n\n  for (i = 1; i < maxArray.length; i++) {\n    if (minmin !== maxmax) break;\n    maxmax = Math.max(maxmax, maxArray[i].val);\n  }\n\n  var axReverse = false;\n\n  if (ax.range) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    axReverse = rng[1] < rng[0];\n  } // one-time setting to easily reverse the axis\n  // when plotting from code\n\n\n  if (ax.autorange === 'reversed') {\n    axReverse = true;\n    ax.autorange = true;\n  }\n\n  var rangeMode = ax.rangemode;\n  var toZero = rangeMode === 'tozero';\n  var nonNegative = rangeMode === 'nonnegative';\n  var axLen = ax._length; // don't allow padding to reduce the data to < 10% of the length\n\n  var minSpan = axLen / 10;\n  var mbest = 0;\n  var minpt, maxpt, minbest, maxbest, dp, dv;\n\n  for (i = 0; i < minArray.length; i++) {\n    minpt = minArray[i];\n\n    for (j = 0; j < maxArray.length; j++) {\n      maxpt = maxArray[j];\n      dv = maxpt.val - minpt.val;\n\n      if (dv > 0) {\n        dp = axLen - getPad(minpt) - getPad(maxpt);\n\n        if (dp > minSpan) {\n          if (dv / dp > mbest) {\n            minbest = minpt;\n            maxbest = maxpt;\n            mbest = dv / dp;\n          }\n        } else if (dv / axLen > mbest) {\n          // in case of padding longer than the axis\n          // at least include the unpadded data values.\n          minbest = {\n            val: minpt.val,\n            pad: 0\n          };\n          maxbest = {\n            val: maxpt.val,\n            pad: 0\n          };\n          mbest = dv / axLen;\n        }\n      }\n    }\n  }\n\n  function getMaxPad(prev, pt) {\n    return Math.max(prev, getPad(pt));\n  }\n\n  if (minmin === maxmax) {\n    var lower = minmin - 1;\n    var upper = minmin + 1;\n\n    if (toZero) {\n      if (minmin === 0) {\n        // The only value we have on this axis is 0, and we want to\n        // autorange so zero is one end.\n        // In principle this could be [0, 1] or [-1, 0] but usually\n        // 'tozero' pins 0 to the low end, so follow that.\n        newRange = [0, 1];\n      } else {\n        var maxPad = (minmin > 0 ? maxArray : minArray).reduce(getMaxPad, 0); // we're pushing a single value away from the edge due to its\n        // padding, with the other end clamped at zero\n        // 0.5 means don't push it farther than the center.\n\n        var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n        newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n      }\n    } else if (nonNegative) {\n      newRange = [Math.max(0, lower), Math.max(1, upper)];\n    } else {\n      newRange = [lower, upper];\n    }\n  } else {\n    if (toZero) {\n      if (minbest.val >= 0) {\n        minbest = {\n          val: 0,\n          pad: 0\n        };\n      }\n\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 0,\n          pad: 0\n        };\n      }\n    } else if (nonNegative) {\n      if (minbest.val - mbest * getPad(minbest) < 0) {\n        minbest = {\n          val: 0,\n          pad: 0\n        };\n      }\n\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 1,\n          pad: 0\n        };\n      }\n    } // in case it changed again...\n\n\n    mbest = (maxbest.val - minbest.val) / (axLen - getPad(minbest) - getPad(maxbest));\n    newRange = [minbest.val - mbest * getPad(minbest), maxbest.val + mbest * getPad(maxbest)];\n  } // maintain reversal\n\n\n  if (axReverse) newRange.reverse();\n  return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\n\n\nfunction makePadFn(ax) {\n  // 5% padding for points that specify extrapad: true\n  var extrappad = ax._length / 20; // domain-constrained axes: base extrappad on the unconstrained\n  // domain so it's consistent as the domain changes\n\n  if (ax.constrain === 'domain' && ax._inputDomain) {\n    extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);\n  }\n\n  return function getPad(pt) {\n    return pt.pad + (pt.extrapad ? extrappad : 0);\n  };\n}\n\nfunction concatExtremes(gd, ax) {\n  var axId = ax._id;\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n  var minArray = [];\n  var maxArray = [];\n  var i, j, d;\n\n  function _concat(cont, indices) {\n    for (i = 0; i < indices.length; i++) {\n      var item = cont[indices[i]];\n      var extremes = (item._extremes || {})[axId];\n\n      if (item.visible === true && extremes) {\n        for (j = 0; j < extremes.min.length; j++) {\n          d = extremes.min[j];\n          collapseMinArray(minArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n\n        for (j = 0; j < extremes.max.length; j++) {\n          d = extremes.max[j];\n          collapseMaxArray(maxArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n      }\n    }\n  }\n\n  _concat(fullData, ax._traceIndices);\n\n  _concat(fullLayout.annotations || [], ax._annIndices || []);\n\n  _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n\n  return {\n    min: minArray,\n    max: maxArray\n  };\n}\n\nfunction doAutoRange(gd, ax) {\n  ax.setScale();\n\n  if (ax.autorange) {\n    ax.range = getAutoRange(gd, ax);\n    ax._r = ax.range.slice();\n    ax._rl = Lib.simpleMap(ax._r, ax.r2l); // doAutoRange will get called on fullLayout,\n    // but we want to report its results back to layout\n\n    var axIn = ax._input; // before we edit _input, store preGUI values\n\n    var edits = {};\n    edits[ax._attr + '.range'] = ax.range;\n    edits[ax._attr + '.autorange'] = ax.autorange;\n    Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n    axIn.range = ax.range.slice();\n    axIn.autorange = ax.autorange;\n  }\n\n  var anchorAx = ax._anchorAxis;\n\n  if (anchorAx && anchorAx.rangeslider) {\n    var axeRangeOpts = anchorAx.rangeslider[ax._name];\n\n    if (axeRangeOpts) {\n      if (axeRangeOpts.rangemode === 'auto') {\n        axeRangeOpts.range = getAutoRange(gd, ax);\n      }\n    }\n\n    anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n  }\n}\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)\n *          is linearized (for log scale axes)\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\n\n\nfunction findExtremes(ax, data, opts) {\n  if (!opts) opts = {};\n  if (!ax._m) ax.setScale();\n  var minArray = [];\n  var maxArray = [];\n  var len = data.length;\n  var extrapad = opts.padded || false;\n  var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n  var isLog = ax.type === 'log';\n  var hasArrayOption = false;\n  var vpadLinearized = opts.vpadLinearized || false;\n  var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n\n  function makePadAccessor(item) {\n    if (Array.isArray(item)) {\n      hasArrayOption = true;\n      return function (i) {\n        return Math.max(Number(item[i] || 0), 0);\n      };\n    } else {\n      var v = Math.max(Number(item || 0), 0);\n      return function () {\n        return v;\n      };\n    }\n  }\n\n  var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n  var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n  var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n  var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n\n  if (!hasArrayOption) {\n    // with no arrays other than `data` we don't need to consider\n    // every point, only the extreme data points\n    vmin = Infinity;\n    vmax = -Infinity;\n\n    if (isLog) {\n      for (i = 0; i < len; i++) {\n        v = data[i]; // data is not linearized yet so we still have to filter out negative logs\n\n        if (v < vmin && v > 0) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        v = data[i];\n        if (v < vmin && v > -FP_SAFE) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    }\n\n    data = [vmin, vmax];\n    len = 2;\n  }\n\n  var collapseOpts = {\n    tozero: tozero,\n    extrapad: extrapad\n  };\n\n  function addItem(i) {\n    di = data[i];\n    if (!isNumeric(di)) return;\n    ppadiplus = ppadplus(i);\n    ppadiminus = ppadminus(i);\n\n    if (vpadLinearized) {\n      dmin = ax.c2l(di) - vpadminus(i);\n      dmax = ax.c2l(di) + vpadplus(i);\n    } else {\n      vmin = di - vpadminus(i);\n      vmax = di + vpadplus(i); // special case for log axes: if vpad makes this object span\n      // more than an order of mag, clip it to one order. This is so\n      // we don't have non-positive errors or absurdly large lower\n      // range due to rounding errors\n\n      if (isLog && vmin < vmax / 10) vmin = vmax / 10;\n      dmin = ax.c2l(vmin);\n      dmax = ax.c2l(vmax);\n    }\n\n    if (tozero) {\n      dmin = Math.min(0, dmin);\n      dmax = Math.max(0, dmax);\n    }\n\n    if (goodNumber(dmin)) {\n      collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n    }\n\n    if (goodNumber(dmax)) {\n      collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n    }\n  } // For efficiency covering monotonic or near-monotonic data,\n  // check a few points at both ends first and then sweep\n  // through the middle\n\n\n  var iMax = Math.min(6, len);\n\n  for (i = 0; i < iMax; i++) {\n    addItem(i);\n  }\n\n  for (i = len - 1; i >= iMax; i--) {\n    addItem(i);\n  }\n\n  return {\n    min: minArray,\n    max: maxArray,\n    opts: opts\n  };\n}\n\nfunction collapseMinArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\n\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\n\n\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n  var tozero = opts.tozero;\n  var extrapad = opts.extrapad;\n  var includeThis = true;\n\n  for (var j = 0; j < array.length && includeThis; j++) {\n    var v = array[j];\n\n    if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n      includeThis = false;\n      break;\n    } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n      array.splice(j, 1);\n      j--;\n    }\n  }\n\n  if (includeThis) {\n    var clipAtZero = tozero && newVal === 0;\n    array.push({\n      val: newVal,\n      pad: clipAtZero ? 0 : newPad,\n      extrapad: clipAtZero ? false : extrapad\n    });\n  }\n} // In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\n\n\nfunction goodNumber(v) {\n  return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\n\nfunction lessOrEqual(v0, v1) {\n  return v0 <= v1;\n}\n\nfunction greaterOrEqual(v0, v1) {\n  return v0 >= v1;\n}","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/plots/cartesian/autorange.js"],"names":["isNumeric","require","Lib","FP_SAFE","Registry","module","exports","getAutoRange","makePadFn","doAutoRange","findExtremes","concatExtremes","gd","ax","i","j","newRange","getPad","extremes","minArray","min","maxArray","max","length","simpleMap","range","r2l","minmin","val","maxmax","Math","axReverse","rng","autorange","rangeMode","rangemode","toZero","nonNegative","axLen","_length","minSpan","mbest","minpt","maxpt","minbest","maxbest","dp","dv","pad","getMaxPad","prev","pt","lower","upper","maxPad","reduce","rangeEnd","reverse","l2r","Number","extrappad","constrain","_inputDomain","domain","extrapad","axId","_id","fullData","_fullData","fullLayout","_fullLayout","d","_concat","cont","indices","item","_extremes","visible","collapseMinArray","collapseMaxArray","_traceIndices","annotations","_annIndices","shapes","_shapeIndices","setScale","_r","slice","_rl","axIn","_input","edits","_attr","call","layout","_preGUI","anchorAx","_anchorAxis","rangeslider","axeRangeOpts","_name","extendFlat","data","opts","_m","len","padded","tozero","type","isLog","hasArrayOption","vpadLinearized","v","di","dmin","dmax","ppadiplus","ppadiminus","vmin","vmax","makePadAccessor","Array","isArray","ppadplus","ppadminus","ppad","vpadplus","vpad","vpadminus","Infinity","collapseOpts","addItem","c2l","goodNumber","iMax","array","newVal","newPad","collapseArray","lessOrEqual","greaterOrEqual","atLeastAsExtreme","includeThis","splice","clipAtZero","push","abs","v0","v1"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\nvar Registry = require('../../registry');\n\nmodule.exports = {\n    getAutoRange: getAutoRange,\n    makePadFn: makePadFn,\n    doAutoRange: doAutoRange,\n    findExtremes: findExtremes,\n    concatExtremes: concatExtremes\n};\n\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\nfunction getAutoRange(gd, ax) {\n    var i, j;\n    var newRange = [];\n\n    var getPad = makePadFn(ax);\n    var extremes = concatExtremes(gd, ax);\n    var minArray = extremes.min;\n    var maxArray = extremes.max;\n\n    if(minArray.length === 0 || maxArray.length === 0) {\n        return Lib.simpleMap(ax.range, ax.r2l);\n    }\n\n    var minmin = minArray[0].val;\n    var maxmax = maxArray[0].val;\n\n    for(i = 1; i < minArray.length; i++) {\n        if(minmin !== maxmax) break;\n        minmin = Math.min(minmin, minArray[i].val);\n    }\n    for(i = 1; i < maxArray.length; i++) {\n        if(minmin !== maxmax) break;\n        maxmax = Math.max(maxmax, maxArray[i].val);\n    }\n\n    var axReverse = false;\n\n    if(ax.range) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        axReverse = rng[1] < rng[0];\n    }\n    // one-time setting to easily reverse the axis\n    // when plotting from code\n    if(ax.autorange === 'reversed') {\n        axReverse = true;\n        ax.autorange = true;\n    }\n\n    var rangeMode = ax.rangemode;\n    var toZero = rangeMode === 'tozero';\n    var nonNegative = rangeMode === 'nonnegative';\n    var axLen = ax._length;\n    // don't allow padding to reduce the data to < 10% of the length\n    var minSpan = axLen / 10;\n\n    var mbest = 0;\n    var minpt, maxpt, minbest, maxbest, dp, dv;\n\n    for(i = 0; i < minArray.length; i++) {\n        minpt = minArray[i];\n        for(j = 0; j < maxArray.length; j++) {\n            maxpt = maxArray[j];\n            dv = maxpt.val - minpt.val;\n            if(dv > 0) {\n                dp = axLen - getPad(minpt) - getPad(maxpt);\n                if(dp > minSpan) {\n                    if(dv / dp > mbest) {\n                        minbest = minpt;\n                        maxbest = maxpt;\n                        mbest = dv / dp;\n                    }\n                } else if(dv / axLen > mbest) {\n                    // in case of padding longer than the axis\n                    // at least include the unpadded data values.\n                    minbest = {val: minpt.val, pad: 0};\n                    maxbest = {val: maxpt.val, pad: 0};\n                    mbest = dv / axLen;\n                }\n            }\n        }\n    }\n\n    function getMaxPad(prev, pt) {\n        return Math.max(prev, getPad(pt));\n    }\n\n    if(minmin === maxmax) {\n        var lower = minmin - 1;\n        var upper = minmin + 1;\n        if(toZero) {\n            if(minmin === 0) {\n                // The only value we have on this axis is 0, and we want to\n                // autorange so zero is one end.\n                // In principle this could be [0, 1] or [-1, 0] but usually\n                // 'tozero' pins 0 to the low end, so follow that.\n                newRange = [0, 1];\n            } else {\n                var maxPad = (minmin > 0 ? maxArray : minArray).reduce(getMaxPad, 0);\n                // we're pushing a single value away from the edge due to its\n                // padding, with the other end clamped at zero\n                // 0.5 means don't push it farther than the center.\n                var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n                newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n            }\n        } else if(nonNegative) {\n            newRange = [Math.max(0, lower), Math.max(1, upper)];\n        } else {\n            newRange = [lower, upper];\n        }\n    } else {\n        if(toZero) {\n            if(minbest.val >= 0) {\n                minbest = {val: 0, pad: 0};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 0, pad: 0};\n            }\n        } else if(nonNegative) {\n            if(minbest.val - mbest * getPad(minbest) < 0) {\n                minbest = {val: 0, pad: 0};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 1, pad: 0};\n            }\n        }\n\n        // in case it changed again...\n        mbest = (maxbest.val - minbest.val) /\n            (axLen - getPad(minbest) - getPad(maxbest));\n\n        newRange = [\n            minbest.val - mbest * getPad(minbest),\n            maxbest.val + mbest * getPad(maxbest)\n        ];\n    }\n\n    // maintain reversal\n    if(axReverse) newRange.reverse();\n\n    return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\nfunction makePadFn(ax) {\n    // 5% padding for points that specify extrapad: true\n    var extrappad = ax._length / 20;\n\n    // domain-constrained axes: base extrappad on the unconstrained\n    // domain so it's consistent as the domain changes\n    if((ax.constrain === 'domain') && ax._inputDomain) {\n        extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) /\n            (ax.domain[1] - ax.domain[0]);\n    }\n\n    return function getPad(pt) { return pt.pad + (pt.extrapad ? extrappad : 0); };\n}\n\nfunction concatExtremes(gd, ax) {\n    var axId = ax._id;\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var minArray = [];\n    var maxArray = [];\n    var i, j, d;\n\n    function _concat(cont, indices) {\n        for(i = 0; i < indices.length; i++) {\n            var item = cont[indices[i]];\n            var extremes = (item._extremes || {})[axId];\n            if(item.visible === true && extremes) {\n                for(j = 0; j < extremes.min.length; j++) {\n                    d = extremes.min[j];\n                    collapseMinArray(minArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n                for(j = 0; j < extremes.max.length; j++) {\n                    d = extremes.max[j];\n                    collapseMaxArray(maxArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n            }\n        }\n    }\n\n    _concat(fullData, ax._traceIndices);\n    _concat(fullLayout.annotations || [], ax._annIndices || []);\n    _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n\n    return {min: minArray, max: maxArray};\n}\n\nfunction doAutoRange(gd, ax) {\n    ax.setScale();\n\n    if(ax.autorange) {\n        ax.range = getAutoRange(gd, ax);\n\n        ax._r = ax.range.slice();\n        ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n        // doAutoRange will get called on fullLayout,\n        // but we want to report its results back to layout\n\n        var axIn = ax._input;\n\n        // before we edit _input, store preGUI values\n        var edits = {};\n        edits[ax._attr + '.range'] = ax.range;\n        edits[ax._attr + '.autorange'] = ax.autorange;\n        Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n\n        axIn.range = ax.range.slice();\n        axIn.autorange = ax.autorange;\n    }\n\n    var anchorAx = ax._anchorAxis;\n\n    if(anchorAx && anchorAx.rangeslider) {\n        var axeRangeOpts = anchorAx.rangeslider[ax._name];\n        if(axeRangeOpts) {\n            if(axeRangeOpts.rangemode === 'auto') {\n                axeRangeOpts.range = getAutoRange(gd, ax);\n            }\n        }\n        anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n    }\n}\n\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)\n *          is linearized (for log scale axes)\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\nfunction findExtremes(ax, data, opts) {\n    if(!opts) opts = {};\n    if(!ax._m) ax.setScale();\n\n    var minArray = [];\n    var maxArray = [];\n\n    var len = data.length;\n    var extrapad = opts.padded || false;\n    var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n    var isLog = ax.type === 'log';\n    var hasArrayOption = false;\n    var vpadLinearized = opts.vpadLinearized || false;\n    var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n\n    function makePadAccessor(item) {\n        if(Array.isArray(item)) {\n            hasArrayOption = true;\n            return function(i) { return Math.max(Number(item[i]||0), 0); };\n        } else {\n            var v = Math.max(Number(item||0), 0);\n            return function() { return v; };\n        }\n    }\n\n    var ppadplus = makePadAccessor((ax._m > 0 ?\n        opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n    var ppadminus = makePadAccessor((ax._m > 0 ?\n        opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n    var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n    var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n\n    if(!hasArrayOption) {\n        // with no arrays other than `data` we don't need to consider\n        // every point, only the extreme data points\n        vmin = Infinity;\n        vmax = -Infinity;\n\n        if(isLog) {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                // data is not linearized yet so we still have to filter out negative logs\n                if(v < vmin && v > 0) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        } else {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                if(v < vmin && v > -FP_SAFE) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        }\n\n        data = [vmin, vmax];\n        len = 2;\n    }\n\n    var collapseOpts = {tozero: tozero, extrapad: extrapad};\n\n    function addItem(i) {\n        di = data[i];\n        if(!isNumeric(di)) return;\n        ppadiplus = ppadplus(i);\n        ppadiminus = ppadminus(i);\n\n        if(vpadLinearized) {\n            dmin = ax.c2l(di) - vpadminus(i);\n            dmax = ax.c2l(di) + vpadplus(i);\n        } else {\n            vmin = di - vpadminus(i);\n            vmax = di + vpadplus(i);\n            // special case for log axes: if vpad makes this object span\n            // more than an order of mag, clip it to one order. This is so\n            // we don't have non-positive errors or absurdly large lower\n            // range due to rounding errors\n            if(isLog && vmin < vmax / 10) vmin = vmax / 10;\n\n            dmin = ax.c2l(vmin);\n            dmax = ax.c2l(vmax);\n        }\n\n        if(tozero) {\n            dmin = Math.min(0, dmin);\n            dmax = Math.max(0, dmax);\n        }\n        if(goodNumber(dmin)) {\n            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n        }\n        if(goodNumber(dmax)) {\n            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n        }\n    }\n\n    // For efficiency covering monotonic or near-monotonic data,\n    // check a few points at both ends first and then sweep\n    // through the middle\n    var iMax = Math.min(6, len);\n    for(i = 0; i < iMax; i++) addItem(i);\n    for(i = len - 1; i >= iMax; i--) addItem(i);\n\n    return {\n        min: minArray,\n        max: maxArray,\n        opts: opts\n    };\n}\n\nfunction collapseMinArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\n\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n    var tozero = opts.tozero;\n    var extrapad = opts.extrapad;\n    var includeThis = true;\n\n    for(var j = 0; j < array.length && includeThis; j++) {\n        var v = array[j];\n        if(atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n            includeThis = false;\n            break;\n        } else if(atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n            array.splice(j, 1);\n            j--;\n        }\n    }\n    if(includeThis) {\n        var clipAtZero = (tozero && newVal === 0);\n        array.push({\n            val: newVal,\n            pad: clipAtZero ? 0 : newPad,\n            extrapad: clipAtZero ? false : extrapad\n        });\n    }\n}\n\n// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v) {\n    return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\n\nfunction lessOrEqual(v0, v1) { return v0 <= v1; }\nfunction greaterOrEqual(v0, v1) { return v0 >= v1; }\n"]},"metadata":{},"sourceType":"script"}