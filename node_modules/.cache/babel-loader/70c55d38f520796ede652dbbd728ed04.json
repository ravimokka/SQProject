{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar supportsPassive = require('has-passive-events');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Fx = require('../../components/fx');\n\nvar Axes = require('./axes');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar dragElement = require('../../components/dragelement');\n\nvar FROM_TL = require('../../constants/alignment').FROM_TL;\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar Plots = require('../plots');\n\nvar getFromId = require('./axis_ids').getFromId;\n\nvar prepSelect = require('./select').prepSelect;\n\nvar clearSelect = require('./select').clearSelect;\n\nvar selectOnClick = require('./select').selectOnClick;\n\nvar scaleZoom = require('./scale_zoom');\n\nvar constants = require('./constants');\n\nvar MINDRAG = constants.MINDRAG;\nvar MINZOOM = constants.MINZOOM; // flag for showing \"doubleclick to zoom out\" only at the beginning\n\nvar SHOWZOOMOUTTIP = true; // dragBox: create an element to drag one or more axis ends\n// inputs:\n//      plotinfo - which subplot are we making dragboxes on?\n//      x,y,w,h - left, top, width, height of the box\n//      ns - how does this drag the vertical axis?\n//          'n' - top only\n//          's' - bottom only\n//          'ns' - top and bottom together, difference unchanged\n//      ew - same for horizontal axis\n\nfunction makeDragBox(gd, plotinfo, x, y, w, h, ns, ew) {\n  // mouseDown stores ms of first mousedown event in the last\n  // `gd._context.doubleClickDelay` ms on the drag bars\n  // numClicks stores how many mousedowns have been seen\n  // within `gd._context.doubleClickDelay` so we can check for click or doubleclick events\n  // dragged stores whether a drag has occurred, so we don't have to\n  // redraw unnecessarily, ie if no move bigger than MINDRAG or MINZOOM px\n  var zoomlayer = gd._fullLayout._zoomlayer;\n  var isMainDrag = ns + ew === 'nsew';\n  var singleEnd = (ns + ew).length === 1; // main subplot x and y (i.e. found in plotinfo - the main ones)\n\n  var xa0, ya0; // {ax._id: ax} hash objects\n\n  var xaHash, yaHash; // xaHash/yaHash values (arrays)\n\n  var xaxes, yaxes; // main axis offsets\n\n  var xs, ys; // main axis lengths\n\n  var pw, ph; // contains keys 'xaHash', 'yaHash', 'xaxes', and 'yaxes'\n  // which are the x/y {ax._id: ax} hash objects and their values\n  // for linked axis relative to this subplot\n\n  var links; // similar to `links` but for matching axes\n\n  var matches; // set to ew/ns val when active, set to '' when inactive\n\n  var xActive, yActive; // are all axes in this subplot are fixed?\n\n  var allFixedRanges; // do we need to edit x/y ranges?\n\n  var editX, editY; // graph-wide optimization flags\n\n  var hasScatterGl, hasSplom, hasSVG; // collected changes to be made to the plot by relayout at the end\n\n  var updates;\n\n  function recomputeAxisLists() {\n    xa0 = plotinfo.xaxis;\n    ya0 = plotinfo.yaxis;\n    pw = xa0._length;\n    ph = ya0._length;\n    xs = xa0._offset;\n    ys = ya0._offset;\n    xaHash = {};\n    xaHash[xa0._id] = xa0;\n    yaHash = {};\n    yaHash[ya0._id] = ya0; // if we're dragging two axes at once, also drag overlays\n\n    if (ns && ew) {\n      var overlays = plotinfo.overlays;\n\n      for (var i = 0; i < overlays.length; i++) {\n        var xa = overlays[i].xaxis;\n        xaHash[xa._id] = xa;\n        var ya = overlays[i].yaxis;\n        yaHash[ya._id] = ya;\n      }\n    }\n\n    xaxes = hashValues(xaHash);\n    yaxes = hashValues(yaHash);\n    xActive = isDirectionActive(xaxes, ew);\n    yActive = isDirectionActive(yaxes, ns);\n    allFixedRanges = !yActive && !xActive;\n    links = calcLinks(gd, gd._fullLayout._axisConstraintGroups, xaHash, yaHash);\n    matches = calcLinks(gd, gd._fullLayout._axisMatchGroups, xaHash, yaHash);\n    editX = ew || links.isSubplotConstrained || matches.isSubplotConstrained;\n    editY = ns || links.isSubplotConstrained || matches.isSubplotConstrained;\n    var fullLayout = gd._fullLayout;\n    hasScatterGl = fullLayout._has('scattergl');\n    hasSplom = fullLayout._has('splom');\n    hasSVG = fullLayout._has('svg');\n  }\n\n  recomputeAxisLists();\n  var cursor = getDragCursor(yActive + xActive, gd._fullLayout.dragmode, isMainDrag);\n  var dragger = makeRectDragger(plotinfo, ns + ew + 'drag', cursor, x, y, w, h); // still need to make the element if the axes are disabled\n  // but nuke its events (except for maindrag which needs them for hover)\n  // and stop there\n\n  if (allFixedRanges && !isMainDrag) {\n    dragger.onmousedown = null;\n    dragger.style.pointerEvents = 'none';\n    return dragger;\n  }\n\n  var dragOptions = {\n    element: dragger,\n    gd: gd,\n    plotinfo: plotinfo\n  };\n\n  dragOptions.prepFn = function (e, startX, startY) {\n    var dragModePrev = dragOptions.dragmode;\n    var dragModeNow = gd._fullLayout.dragmode;\n\n    if (dragModeNow !== dragModePrev) {\n      dragOptions.dragmode = dragModeNow;\n    }\n\n    recomputeAxisLists();\n\n    if (!allFixedRanges) {\n      if (isMainDrag) {\n        // main dragger handles all drag modes, and changes\n        // to pan (or to zoom if it already is pan) on shift\n        if (e.shiftKey) {\n          if (dragModeNow === 'pan') dragModeNow = 'zoom';else if (!isSelectOrLasso(dragModeNow)) dragModeNow = 'pan';\n        } else if (e.ctrlKey) {\n          dragModeNow = 'pan';\n        }\n      } else {\n        // all other draggers just pan\n        dragModeNow = 'pan';\n      }\n    }\n\n    if (dragModeNow === 'lasso') dragOptions.minDrag = 1;else dragOptions.minDrag = undefined;\n\n    if (isSelectOrLasso(dragModeNow)) {\n      dragOptions.xaxes = xaxes;\n      dragOptions.yaxes = yaxes; // this attaches moveFn, clickFn, doneFn on dragOptions\n\n      prepSelect(e, startX, startY, dragOptions, dragModeNow);\n    } else {\n      dragOptions.clickFn = clickFn;\n\n      if (isSelectOrLasso(dragModePrev)) {\n        // TODO Fix potential bug\n        // Note: clearing / resetting selection state only happens, when user\n        // triggers at least one interaction in pan/zoom mode. Otherwise, the\n        // select/lasso outlines are deleted (in plots.js.cleanPlot) but the selection\n        // cache isn't cleared. So when the user switches back to select/lasso and\n        // 'adds to a selection' with Shift, the \"old\", seemingly removed outlines\n        // are redrawn again because the selection cache still holds their coordinates.\n        // However, this isn't easily solved, since plots.js would need\n        // to have a reference to the dragOptions object (which holds the\n        // selection cache).\n        clearAndResetSelect();\n      }\n\n      if (!allFixedRanges) {\n        if (dragModeNow === 'zoom') {\n          dragOptions.moveFn = zoomMove;\n          dragOptions.doneFn = zoomDone; // zoomMove takes care of the threshold, but we need to\n          // minimize this so that constrained zoom boxes will flip\n          // orientation at the right place\n\n          dragOptions.minDrag = 1;\n          zoomPrep(e, startX, startY);\n        } else if (dragModeNow === 'pan') {\n          dragOptions.moveFn = plotDrag;\n          dragOptions.doneFn = dragTail;\n        }\n      }\n    }\n\n    gd._fullLayout._redrag = function () {\n      var dragDataNow = gd._dragdata;\n\n      if (dragDataNow && dragDataNow.element === dragger) {\n        var dragModeNow = gd._fullLayout.dragmode;\n\n        if (!isSelectOrLasso(dragModeNow)) {\n          recomputeAxisLists();\n          updateSubplots([0, 0, pw, ph]);\n          dragOptions.moveFn(dragDataNow.dx, dragDataNow.dy);\n        } // TODO should we try to \"re-select\" under select/lasso modes?\n        // probably best to wait for https://github.com/plotly/plotly.js/issues/1851\n\n      }\n    };\n  };\n\n  function clearAndResetSelect() {\n    // clear selection polygon cache (if any)\n    dragOptions.plotinfo.selection = false; // clear selection outlines\n\n    clearSelect(gd);\n  }\n\n  function clickFn(numClicks, evt) {\n    var clickmode = gd._fullLayout.clickmode;\n    removeZoombox(gd);\n    if (numClicks === 2 && !singleEnd) doubleClick();\n\n    if (isMainDrag) {\n      if (clickmode.indexOf('select') > -1) {\n        selectOnClick(evt, gd, xaxes, yaxes, plotinfo.id, dragOptions);\n      }\n\n      if (clickmode.indexOf('event') > -1) {\n        Fx.click(gd, evt, plotinfo.id);\n      }\n    } else if (numClicks === 1 && singleEnd) {\n      var ax = ns ? ya0 : xa0;\n      var end = ns === 's' || ew === 'w' ? 0 : 1;\n      var attrStr = ax._name + '.range[' + end + ']';\n      var initialText = getEndText(ax, end);\n      var hAlign = 'left';\n      var vAlign = 'middle';\n      if (ax.fixedrange) return;\n\n      if (ns) {\n        vAlign = ns === 'n' ? 'top' : 'bottom';\n        if (ax.side === 'right') hAlign = 'right';\n      } else if (ew === 'e') hAlign = 'right';\n\n      if (gd._context.showAxisRangeEntryBoxes) {\n        d3.select(dragger).call(svgTextUtils.makeEditable, {\n          gd: gd,\n          immediate: true,\n          background: gd._fullLayout.paper_bgcolor,\n          text: String(initialText),\n          fill: ax.tickfont ? ax.tickfont.color : '#444',\n          horizontalAlign: hAlign,\n          verticalAlign: vAlign\n        }).on('edit', function (text) {\n          var v = ax.d2r(text);\n\n          if (v !== undefined) {\n            Registry.call('_guiRelayout', gd, attrStr, v);\n          }\n        });\n      }\n    }\n  }\n\n  dragElement.init(dragOptions); // x/y px position at start of drag\n\n  var x0, y0; // bbox object of the zoombox\n\n  var box; // luminance of bg behind zoombox\n\n  var lum; // zoombox path outline\n\n  var path0; // is zoombox dimmed (during drag)\n\n  var dimmed; // 'x'-only, 'y' or 'xy' zooming\n\n  var zoomMode; // zoombox d3 selection\n\n  var zb; // zoombox corner d3 selection\n\n  var corners; // zoom takes over minDrag, so it also has to take over gd._dragged\n\n  var zoomDragged;\n\n  function zoomPrep(e, startX, startY) {\n    var dragBBox = dragger.getBoundingClientRect();\n    x0 = startX - dragBBox.left;\n    y0 = startY - dragBBox.top;\n    box = {\n      l: x0,\n      r: x0,\n      w: 0,\n      t: y0,\n      b: y0,\n      h: 0\n    };\n    lum = gd._hmpixcount ? gd._hmlumcount / gd._hmpixcount : tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();\n    path0 = 'M0,0H' + pw + 'V' + ph + 'H0V0';\n    dimmed = false;\n    zoomMode = 'xy';\n    zoomDragged = false;\n    zb = makeZoombox(zoomlayer, lum, xs, ys, path0);\n    corners = makeCorners(zoomlayer, xs, ys);\n  }\n\n  function zoomMove(dx0, dy0) {\n    if (gd._transitioningWithDuration) {\n      return false;\n    }\n\n    var x1 = Math.max(0, Math.min(pw, dx0 + x0));\n    var y1 = Math.max(0, Math.min(ph, dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n    box.l = Math.min(x0, x1);\n    box.r = Math.max(x0, x1);\n    box.t = Math.min(y0, y1);\n    box.b = Math.max(y0, y1);\n\n    function noZoom() {\n      zoomMode = '';\n      box.r = box.l;\n      box.t = box.b;\n      corners.attr('d', 'M0,0Z');\n    }\n\n    if (links.isSubplotConstrained) {\n      if (dx > MINZOOM || dy > MINZOOM) {\n        zoomMode = 'xy';\n\n        if (dx / pw > dy / ph) {\n          dy = dx * ph / pw;\n          if (y0 > y1) box.t = y0 - dy;else box.b = y0 + dy;\n        } else {\n          dx = dy * pw / ph;\n          if (x0 > x1) box.l = x0 - dx;else box.r = x0 + dx;\n        }\n\n        corners.attr('d', xyCorners(box));\n      } else {\n        noZoom();\n      }\n    } else if (matches.isSubplotConstrained) {\n      if (dx > MINZOOM || dy > MINZOOM) {\n        zoomMode = 'xy';\n        var r0 = Math.min(box.l / pw, (ph - box.b) / ph);\n        var r1 = Math.max(box.r / pw, (ph - box.t) / ph);\n        box.l = r0 * pw;\n        box.r = r1 * pw;\n        box.b = (1 - r0) * ph;\n        box.t = (1 - r1) * ph;\n        corners.attr('d', xyCorners(box));\n      } else {\n        noZoom();\n      }\n    } else if (!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {\n      // look for small drags in one direction or the other,\n      // and only drag the other axis\n      if (dx < MINDRAG || !xActive) {\n        noZoom();\n      } else {\n        box.t = 0;\n        box.b = ph;\n        zoomMode = 'x';\n        corners.attr('d', xCorners(box, y0));\n      }\n    } else if (!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {\n      box.l = 0;\n      box.r = pw;\n      zoomMode = 'y';\n      corners.attr('d', yCorners(box, x0));\n    } else {\n      zoomMode = 'xy';\n      corners.attr('d', xyCorners(box));\n    }\n\n    box.w = box.r - box.l;\n    box.h = box.b - box.t;\n    if (zoomMode) zoomDragged = true;\n    gd._dragged = zoomDragged;\n    updateZoombox(zb, corners, box, path0, dimmed, lum);\n    computeZoomUpdates();\n    gd.emit('plotly_relayouting', updates);\n    dimmed = true;\n  }\n\n  function computeZoomUpdates() {\n    updates = {}; // TODO: edit linked axes in zoomAxRanges and in dragTail\n\n    if (zoomMode === 'xy' || zoomMode === 'x') {\n      zoomAxRanges(xaxes, box.l / pw, box.r / pw, updates, links.xaxes);\n      updateMatchedAxRange('x', updates);\n    }\n\n    if (zoomMode === 'xy' || zoomMode === 'y') {\n      zoomAxRanges(yaxes, (ph - box.b) / ph, (ph - box.t) / ph, updates, links.yaxes);\n      updateMatchedAxRange('y', updates);\n    }\n  }\n\n  function zoomDone() {\n    computeZoomUpdates();\n    removeZoombox(gd);\n    dragTail();\n    showDoubleClickNotifier(gd);\n  } // scroll zoom, on all draggers except corners\n\n\n  var scrollViewBox = [0, 0, pw, ph]; // wait a little after scrolling before redrawing\n\n  var redrawTimer = null;\n  var REDRAWDELAY = constants.REDRAWDELAY;\n  var mainplot = plotinfo.mainplot ? gd._fullLayout._plots[plotinfo.mainplot] : plotinfo;\n\n  function zoomWheel(e) {\n    // deactivate mousewheel scrolling on embedded graphs\n    // devs can override this with layout._enablescrollzoom,\n    // but _ ensures this setting won't leave their page\n    if (!gd._context._scrollZoom.cartesian && !gd._fullLayout._enablescrollzoom) {\n      return;\n    }\n\n    clearAndResetSelect(); // If a transition is in progress, then disable any behavior:\n\n    if (gd._transitioningWithDuration) {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n\n    recomputeAxisLists();\n    clearTimeout(redrawTimer);\n    var wheelDelta = -e.deltaY;\n    if (!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;\n\n    if (!isFinite(wheelDelta)) {\n      Lib.log('Did not find wheel motion attributes: ', e);\n      return;\n    }\n\n    var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 200);\n    var gbb = mainplot.draglayer.select('.nsewdrag').node().getBoundingClientRect();\n    var xfrac = (e.clientX - gbb.left) / gbb.width;\n    var yfrac = (gbb.bottom - e.clientY) / gbb.height;\n    var i;\n\n    function zoomWheelOneAxis(ax, centerFraction, zoom) {\n      if (ax.fixedrange) return;\n      var axRange = Lib.simpleMap(ax.range, ax.r2l);\n      var v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;\n\n      function doZoom(v) {\n        return ax.l2r(v0 + (v - v0) * zoom);\n      }\n\n      ax.range = axRange.map(doZoom);\n    }\n\n    if (editX) {\n      // if we're only zooming this axis because of constraints,\n      // zoom it about the center\n      if (!ew) xfrac = 0.5;\n\n      for (i = 0; i < xaxes.length; i++) {\n        zoomWheelOneAxis(xaxes[i], xfrac, zoom);\n      }\n\n      updateMatchedAxRange('x');\n      scrollViewBox[2] *= zoom;\n      scrollViewBox[0] += scrollViewBox[2] * xfrac * (1 / zoom - 1);\n    }\n\n    if (editY) {\n      if (!ns) yfrac = 0.5;\n\n      for (i = 0; i < yaxes.length; i++) {\n        zoomWheelOneAxis(yaxes[i], yfrac, zoom);\n      }\n\n      updateMatchedAxRange('y');\n      scrollViewBox[3] *= zoom;\n      scrollViewBox[1] += scrollViewBox[3] * (1 - yfrac) * (1 / zoom - 1);\n    } // viewbox redraw at first\n\n\n    updateSubplots(scrollViewBox);\n    ticksAndAnnotations();\n    gd.emit('plotly_relayouting', updates); // then replot after a delay to make sure\n    // no more scrolling is coming\n\n    redrawTimer = setTimeout(function () {\n      scrollViewBox = [0, 0, pw, ph];\n      dragTail();\n    }, REDRAWDELAY);\n    e.preventDefault();\n    return;\n  } // everything but the corners gets wheel zoom\n\n\n  if (ns.length * ew.length !== 1) {\n    attachWheelEventHandler(dragger, zoomWheel);\n  } // plotDrag: move the plot in response to a drag\n\n\n  function plotDrag(dx, dy) {\n    // If a transition is in progress, then disable any behavior:\n    if (gd._transitioningWithDuration) {\n      return;\n    } // prevent axis drawing from monkeying with margins until we're done\n\n\n    gd._fullLayout._replotting = true;\n\n    if (xActive === 'ew' || yActive === 'ns') {\n      if (xActive) {\n        dragAxList(xaxes, dx);\n        updateMatchedAxRange('x');\n      }\n\n      if (yActive) {\n        dragAxList(yaxes, dy);\n        updateMatchedAxRange('y');\n      }\n\n      updateSubplots([xActive ? -dx : 0, yActive ? -dy : 0, pw, ph]);\n      ticksAndAnnotations();\n      gd.emit('plotly_relayouting', updates);\n      return;\n    } // dz: set a new value for one end (0 or 1) of an axis array axArray,\n    // and return a pixel shift for that end for the viewbox\n    // based on pixel drag distance d\n    // TODO: this makes (generally non-fatal) errors when you get\n    // near floating point limits\n\n\n    function dz(axArray, end, d) {\n      var otherEnd = 1 - end;\n      var movedAx;\n      var newLinearizedEnd;\n\n      for (var i = 0; i < axArray.length; i++) {\n        var axi = axArray[i];\n        if (axi.fixedrange) continue;\n        movedAx = axi;\n        newLinearizedEnd = axi._rl[otherEnd] + (axi._rl[end] - axi._rl[otherEnd]) / dZoom(d / axi._length);\n        var newEnd = axi.l2r(newLinearizedEnd); // if l2r comes back false or undefined, it means we've dragged off\n        // the end of valid ranges - so stop.\n\n        if (newEnd !== false && newEnd !== undefined) axi.range[end] = newEnd;\n      }\n\n      return movedAx._length * (movedAx._rl[end] - newLinearizedEnd) / (movedAx._rl[end] - movedAx._rl[otherEnd]);\n    }\n\n    if (links.isSubplotConstrained && xActive && yActive) {\n      // dragging a corner of a constrained subplot:\n      // respect the fixed corner, but harmonize dx and dy\n      var dxySign = xActive === 'w' === (yActive === 'n') ? 1 : -1;\n      var dxyFraction = (dx / pw + dxySign * dy / ph) / 2;\n      dx = dxyFraction * pw;\n      dy = dxySign * dxyFraction * ph;\n    }\n\n    if (xActive === 'w') dx = dz(xaxes, 0, dx);else if (xActive === 'e') dx = dz(xaxes, 1, -dx);else if (!xActive) dx = 0;\n    if (yActive === 'n') dy = dz(yaxes, 1, dy);else if (yActive === 's') dy = dz(yaxes, 0, -dy);else if (!yActive) dy = 0;\n    var xStart = xActive === 'w' ? dx : 0;\n    var yStart = yActive === 'n' ? dy : 0;\n\n    if (links.isSubplotConstrained) {\n      var i;\n\n      if (!xActive && yActive.length === 1) {\n        // dragging one end of the y axis of a constrained subplot\n        // scale the other axis the same about its middle\n        for (i = 0; i < xaxes.length; i++) {\n          xaxes[i].range = xaxes[i]._r.slice();\n          scaleZoom(xaxes[i], 1 - dy / ph);\n        }\n\n        dx = dy * pw / ph;\n        xStart = dx / 2;\n      }\n\n      if (!yActive && xActive.length === 1) {\n        for (i = 0; i < yaxes.length; i++) {\n          yaxes[i].range = yaxes[i]._r.slice();\n          scaleZoom(yaxes[i], 1 - dx / pw);\n        }\n\n        dy = dx * ph / pw;\n        yStart = dy / 2;\n      }\n    }\n\n    updateMatchedAxRange('x');\n    updateMatchedAxRange('y');\n    updateSubplots([xStart, yStart, pw - dx, ph - dy]);\n    ticksAndAnnotations();\n    gd.emit('plotly_relayouting', updates);\n  }\n\n  function updateMatchedAxRange(axLetter, out) {\n    var matchedAxes = matches.isSubplotConstrained ? {\n      x: yaxes,\n      y: xaxes\n    }[axLetter] : matches[axLetter + 'axes'];\n    var constrainedAxes = matches.isSubplotConstrained ? {\n      x: xaxes,\n      y: yaxes\n    }[axLetter] : [];\n\n    for (var i = 0; i < matchedAxes.length; i++) {\n      var ax = matchedAxes[i];\n      var axId = ax._id;\n      var axId2 = matches.xLinks[axId] || matches.yLinks[axId];\n      var ax2 = constrainedAxes[0] || xaHash[axId2] || yaHash[axId2];\n\n      if (ax2) {\n        if (out) {\n          // zoombox case - don't mutate 'range', just add keys in 'updates'\n          out[ax._name + '.range[0]'] = out[ax2._name + '.range[0]'];\n          out[ax._name + '.range[1]'] = out[ax2._name + '.range[1]'];\n        } else {\n          ax.range = ax2.range.slice();\n        }\n      }\n    }\n  } // Draw ticks and annotations (and other components) when ranges change.\n  // Also records the ranges that have changed for use by update at the end.\n\n\n  function ticksAndAnnotations() {\n    var activeAxIds = [];\n    var i;\n\n    function pushActiveAxIds(axList) {\n      for (i = 0; i < axList.length; i++) {\n        if (!axList[i].fixedrange) activeAxIds.push(axList[i]._id);\n      }\n    }\n\n    if (editX) {\n      pushActiveAxIds(xaxes);\n      pushActiveAxIds(links.xaxes);\n      pushActiveAxIds(matches.xaxes);\n    }\n\n    if (editY) {\n      pushActiveAxIds(yaxes);\n      pushActiveAxIds(links.yaxes);\n      pushActiveAxIds(matches.yaxes);\n    }\n\n    updates = {};\n\n    for (i = 0; i < activeAxIds.length; i++) {\n      var axId = activeAxIds[i];\n      var ax = getFromId(gd, axId);\n      Axes.drawOne(gd, ax, {\n        skipTitle: true\n      });\n      updates[ax._name + '.range[0]'] = ax.range[0];\n      updates[ax._name + '.range[1]'] = ax.range[1];\n    }\n\n    Axes.redrawComponents(gd, activeAxIds);\n  }\n\n  function doubleClick() {\n    if (gd._transitioningWithDuration) return;\n    var doubleClickConfig = gd._context.doubleClick;\n    var axList = [];\n    if (xActive) axList = axList.concat(xaxes);\n    if (yActive) axList = axList.concat(yaxes);\n    if (matches.xaxes) axList = axList.concat(matches.xaxes);\n    if (matches.yaxes) axList = axList.concat(matches.yaxes);\n    var attrs = {};\n    var ax, i, rangeInitial; // For reset+autosize mode:\n    // If *any* of the main axes is not at its initial range\n    // (or autoranged, if we have no initial range, to match the logic in\n    // doubleClickConfig === 'reset' below), we reset.\n    // If they are *all* at their initial ranges, then we autosize.\n\n    if (doubleClickConfig === 'reset+autosize') {\n      doubleClickConfig = 'autosize';\n\n      for (i = 0; i < axList.length; i++) {\n        ax = axList[i];\n\n        if (ax._rangeInitial && (ax.range[0] !== ax._rangeInitial[0] || ax.range[1] !== ax._rangeInitial[1]) || !ax._rangeInitial && !ax.autorange) {\n          doubleClickConfig = 'reset';\n          break;\n        }\n      }\n    }\n\n    if (doubleClickConfig === 'autosize') {\n      // don't set the linked axes here, so relayout marks them as shrinkable\n      // and we autosize just to the requested axis/axes\n      for (i = 0; i < axList.length; i++) {\n        ax = axList[i];\n        if (!ax.fixedrange) attrs[ax._name + '.autorange'] = true;\n      }\n    } else if (doubleClickConfig === 'reset') {\n      // when we're resetting, reset all linked axes too, so we get back\n      // to the fully-auto-with-constraints situation\n      if (xActive || links.isSubplotConstrained) axList = axList.concat(links.xaxes);\n      if (yActive && !links.isSubplotConstrained) axList = axList.concat(links.yaxes);\n\n      if (links.isSubplotConstrained) {\n        if (!xActive) axList = axList.concat(xaxes);else if (!yActive) axList = axList.concat(yaxes);\n      }\n\n      for (i = 0; i < axList.length; i++) {\n        ax = axList[i];\n\n        if (!ax.fixedrange) {\n          if (!ax._rangeInitial) {\n            attrs[ax._name + '.autorange'] = true;\n          } else {\n            rangeInitial = ax._rangeInitial;\n            attrs[ax._name + '.range[0]'] = rangeInitial[0];\n            attrs[ax._name + '.range[1]'] = rangeInitial[1];\n          }\n        }\n      }\n    }\n\n    gd.emit('plotly_doubleclick', null);\n    Registry.call('_guiRelayout', gd, attrs);\n  } // dragTail - finish a drag event with a redraw\n\n\n  function dragTail() {\n    // put the subplot viewboxes back to default (Because we're going to)\n    // be repositioning the data in the relayout. But DON'T call\n    // ticksAndAnnotations again - it's unnecessary and would overwrite `updates`\n    updateSubplots([0, 0, pw, ph]); // since we may have been redrawing some things during the drag, we may have\n    // accumulated MathJax promises - wait for them before we relayout.\n\n    Lib.syncOrAsync([Plots.previousPromises, function () {\n      gd._fullLayout._replotting = false;\n      Registry.call('_guiRelayout', gd, updates);\n    }], gd);\n  } // updateSubplots - find all plot viewboxes that should be\n  // affected by this drag, and update them. look for all plots\n  // sharing an affected axis (including the one being dragged),\n  // includes also scattergl and splom logic.\n\n\n  function updateSubplots(viewBox) {\n    var fullLayout = gd._fullLayout;\n    var plotinfos = fullLayout._plots;\n    var subplots = fullLayout._subplots.cartesian;\n    var i, sp, xa, ya;\n\n    if (hasSplom) {\n      Registry.subplotsRegistry.splom.drag(gd);\n    }\n\n    if (hasScatterGl) {\n      for (i = 0; i < subplots.length; i++) {\n        sp = plotinfos[subplots[i]];\n        xa = sp.xaxis;\n        ya = sp.yaxis;\n\n        if (sp._scene) {\n          var xrng = Lib.simpleMap(xa.range, xa.r2l);\n          var yrng = Lib.simpleMap(ya.range, ya.r2l);\n\n          sp._scene.update({\n            range: [xrng[0], yrng[0], xrng[1], yrng[1]]\n          });\n        }\n      }\n    }\n\n    if (hasSplom || hasScatterGl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n\n    if (hasSVG) {\n      var xScaleFactor = viewBox[2] / xa0._length;\n      var yScaleFactor = viewBox[3] / ya0._length;\n\n      for (i = 0; i < subplots.length; i++) {\n        sp = plotinfos[subplots[i]];\n        xa = sp.xaxis;\n        ya = sp.yaxis;\n        var editX2 = editX && !xa.fixedrange && xaHash[xa._id];\n        var editY2 = editY && !ya.fixedrange && yaHash[ya._id];\n        var xScaleFactor2, yScaleFactor2;\n        var clipDx, clipDy;\n\n        if (editX2) {\n          xScaleFactor2 = xScaleFactor;\n          clipDx = ew ? viewBox[0] : getShift(xa, xScaleFactor2);\n        } else if (matches.xaHash[xa._id]) {\n          xScaleFactor2 = xScaleFactor;\n          clipDx = viewBox[0] * xa._length / xa0._length;\n        } else if (matches.yaHash[xa._id]) {\n          xScaleFactor2 = yScaleFactor;\n          clipDx = yActive === 'ns' ? -viewBox[1] * xa._length / ya0._length : getShift(xa, xScaleFactor2, {\n            n: 'top',\n            s: 'bottom'\n          }[yActive]);\n        } else {\n          xScaleFactor2 = getLinkedScaleFactor(xa, xScaleFactor, yScaleFactor);\n          clipDx = scaleAndGetShift(xa, xScaleFactor2);\n        }\n\n        if (editY2) {\n          yScaleFactor2 = yScaleFactor;\n          clipDy = ns ? viewBox[1] : getShift(ya, yScaleFactor2);\n        } else if (matches.yaHash[ya._id]) {\n          yScaleFactor2 = yScaleFactor;\n          clipDy = viewBox[1] * ya._length / ya0._length;\n        } else if (matches.xaHash[ya._id]) {\n          yScaleFactor2 = xScaleFactor;\n          clipDy = xActive === 'ew' ? -viewBox[0] * ya._length / xa0._length : getShift(ya, yScaleFactor2, {\n            e: 'right',\n            w: 'left'\n          }[xActive]);\n        } else {\n          yScaleFactor2 = getLinkedScaleFactor(ya, xScaleFactor, yScaleFactor);\n          clipDy = scaleAndGetShift(ya, yScaleFactor2);\n        } // don't scale at all if neither axis is scalable here\n\n\n        if (!xScaleFactor2 && !yScaleFactor2) {\n          continue;\n        } // but if only one is, reset the other axis scaling\n\n\n        if (!xScaleFactor2) xScaleFactor2 = 1;\n        if (!yScaleFactor2) yScaleFactor2 = 1;\n        var plotDx = xa._offset - clipDx / xScaleFactor2;\n        var plotDy = ya._offset - clipDy / yScaleFactor2; // TODO could be more efficient here:\n        // setTranslate and setScale do a lot of extra work\n        // when working independently, should perhaps combine\n        // them into a single routine.\n\n        sp.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, xScaleFactor2, yScaleFactor2);\n        sp.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, 1 / xScaleFactor2, 1 / yScaleFactor2); // apply an inverse scale to individual points to counteract\n        // the scale of the trace group.\n        // apply only when scale changes, as adjusting the scale of\n        // all the points can be expansive.\n\n        if (xScaleFactor2 !== sp.xScaleFactor || yScaleFactor2 !== sp.yScaleFactor) {\n          Drawing.setPointGroupScale(sp.zoomScalePts, xScaleFactor2, yScaleFactor2);\n          Drawing.setTextPointsScale(sp.zoomScaleTxt, xScaleFactor2, yScaleFactor2);\n        }\n\n        Drawing.hideOutsideRangePoints(sp.clipOnAxisFalseTraces, sp); // update x/y scaleFactor stash\n\n        sp.xScaleFactor = xScaleFactor2;\n        sp.yScaleFactor = yScaleFactor2;\n      }\n    }\n  } // Find the appropriate scaling for this axis, if it's linked to the\n  // dragged axes by constraints. 0 is special, it means this axis shouldn't\n  // ever be scaled (will be converted to 1 if the other axis is scaled)\n\n\n  function getLinkedScaleFactor(ax, xScaleFactor, yScaleFactor) {\n    if (ax.fixedrange) return 0;\n\n    if (editX && links.xaHash[ax._id]) {\n      return xScaleFactor;\n    }\n\n    if (editY && (links.isSubplotConstrained ? links.xaHash : links.yaHash)[ax._id]) {\n      return yScaleFactor;\n    }\n\n    return 0;\n  }\n\n  function scaleAndGetShift(ax, scaleFactor) {\n    if (scaleFactor) {\n      ax.range = ax._r.slice();\n      scaleZoom(ax, scaleFactor);\n      return getShift(ax, scaleFactor);\n    }\n\n    return 0;\n  }\n\n  function getShift(ax, scaleFactor, from) {\n    return ax._length * (1 - scaleFactor) * FROM_TL[from || ax.constraintoward || 'middle'];\n  }\n\n  return dragger;\n}\n\nfunction makeDragger(plotinfo, nodeName, dragClass, cursor) {\n  var dragger3 = Lib.ensureSingle(plotinfo.draglayer, nodeName, dragClass, function (s) {\n    s.classed('drag', true).style({\n      fill: 'transparent',\n      'stroke-width': 0\n    }).attr('data-subplot', plotinfo.id);\n  });\n  dragger3.call(setCursor, cursor);\n  return dragger3.node();\n}\n\nfunction makeRectDragger(plotinfo, dragClass, cursor, x, y, w, h) {\n  var dragger = makeDragger(plotinfo, 'rect', dragClass, cursor);\n  d3.select(dragger).call(Drawing.setRect, x, y, w, h);\n  return dragger;\n}\n\nfunction isDirectionActive(axList, activeVal) {\n  for (var i = 0; i < axList.length; i++) {\n    if (!axList[i].fixedrange) return activeVal;\n  }\n\n  return '';\n}\n\nfunction getEndText(ax, end) {\n  var initialVal = ax.range[end];\n  var diff = Math.abs(initialVal - ax.range[1 - end]);\n  var dig; // TODO: this should basically be ax.r2d but we're doing extra\n  // rounding here... can we clean up at all?\n\n  if (ax.type === 'date') {\n    return initialVal;\n  } else if (ax.type === 'log') {\n    dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;\n    return d3.format('.' + dig + 'g')(Math.pow(10, initialVal));\n  } else {\n    // linear numeric (or category... but just show numbers here)\n    dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) - Math.floor(Math.log(diff) / Math.LN10) + 4;\n    return d3.format('.' + String(dig) + 'g')(initialVal);\n  }\n}\n\nfunction zoomAxRanges(axList, r0Fraction, r1Fraction, updates, linkedAxes) {\n  for (var i = 0; i < axList.length; i++) {\n    var axi = axList[i];\n    if (axi.fixedrange) continue;\n    var axRangeLinear0 = axi._rl[0];\n    var axRangeLinearSpan = axi._rl[1] - axRangeLinear0;\n    updates[axi._name + '.range[0]'] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r0Fraction);\n    updates[axi._name + '.range[1]'] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r1Fraction);\n  } // zoom linked axes about their centers\n\n\n  if (linkedAxes && linkedAxes.length) {\n    var linkedR0Fraction = (r0Fraction + (1 - r1Fraction)) / 2;\n    zoomAxRanges(linkedAxes, linkedR0Fraction, 1 - linkedR0Fraction, updates, []);\n  }\n}\n\nfunction dragAxList(axList, pix) {\n  for (var i = 0; i < axList.length; i++) {\n    var axi = axList[i];\n\n    if (!axi.fixedrange) {\n      axi.range = [axi.l2r(axi._rl[0] - pix / axi._m), axi.l2r(axi._rl[1] - pix / axi._m)];\n    }\n  }\n} // common transform for dragging one end of an axis\n// d>0 is compressing scale (cursor is over the plot,\n//  the axis end should move with the cursor)\n// d<0 is expanding (cursor is off the plot, axis end moves\n//  nonlinearly so you can expand far)\n\n\nfunction dZoom(d) {\n  return 1 - (d >= 0 ? Math.min(d, 0.9) : 1 / (1 / Math.max(d, -0.3) + 3.222));\n}\n\nfunction getDragCursor(nsew, dragmode, isMainDrag) {\n  if (!nsew) return 'pointer';\n\n  if (nsew === 'nsew') {\n    // in this case here, clear cursor and\n    // use the cursor style set on <g .draglayer>\n    if (isMainDrag) return '';\n    if (dragmode === 'pan') return 'move';\n    return 'crosshair';\n  }\n\n  return nsew.toLowerCase() + '-resize';\n}\n\nfunction makeZoombox(zoomlayer, lum, xs, ys, path0) {\n  return zoomlayer.append('path').attr('class', 'zoombox').style({\n    'fill': lum > 0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',\n    'stroke-width': 0\n  }).attr('transform', 'translate(' + xs + ', ' + ys + ')').attr('d', path0 + 'Z');\n}\n\nfunction makeCorners(zoomlayer, xs, ys) {\n  return zoomlayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1,\n    opacity: 0\n  }).attr('transform', 'translate(' + xs + ', ' + ys + ')').attr('d', 'M0,0Z');\n}\n\nfunction updateZoombox(zb, corners, box, path0, dimmed, lum) {\n  zb.attr('d', path0 + 'M' + box.l + ',' + box.t + 'v' + box.h + 'h' + box.w + 'v-' + box.h + 'h-' + box.w + 'Z');\n  transitionZoombox(zb, corners, dimmed, lum);\n}\n\nfunction transitionZoombox(zb, corners, dimmed, lum) {\n  if (!dimmed) {\n    zb.transition().style('fill', lum > 0.2 ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.3)').duration(200);\n    corners.transition().style('opacity', 1).duration(200);\n  }\n}\n\nfunction removeZoombox(gd) {\n  d3.select(gd).selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners').remove();\n}\n\nfunction showDoubleClickNotifier(gd) {\n  if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {\n    Lib.notifier(Lib._(gd, 'Double-click to zoom back out'), 'long');\n    SHOWZOOMOUTTIP = false;\n  }\n}\n\nfunction isSelectOrLasso(dragmode) {\n  return dragmode === 'lasso' || dragmode === 'select';\n}\n\nfunction xCorners(box, y0) {\n  return 'M' + (box.l - 0.5) + ',' + (y0 - MINZOOM - 0.5) + 'h-3v' + (2 * MINZOOM + 1) + 'h3ZM' + (box.r + 0.5) + ',' + (y0 - MINZOOM - 0.5) + 'h3v' + (2 * MINZOOM + 1) + 'h-3Z';\n}\n\nfunction yCorners(box, x0) {\n  return 'M' + (x0 - MINZOOM - 0.5) + ',' + (box.t - 0.5) + 'v-3h' + (2 * MINZOOM + 1) + 'v3ZM' + (x0 - MINZOOM - 0.5) + ',' + (box.b + 0.5) + 'v3h' + (2 * MINZOOM + 1) + 'v-3Z';\n}\n\nfunction xyCorners(box) {\n  var clen = Math.floor(Math.min(box.b - box.t, box.r - box.l, MINZOOM) / 2);\n  return 'M' + (box.l - 3.5) + ',' + (box.t - 0.5 + clen) + 'h3v' + -clen + 'h' + clen + 'v-3h-' + (clen + 3) + 'ZM' + (box.r + 3.5) + ',' + (box.t - 0.5 + clen) + 'h-3v' + -clen + 'h' + -clen + 'v-3h' + (clen + 3) + 'ZM' + (box.r + 3.5) + ',' + (box.b + 0.5 - clen) + 'h-3v' + clen + 'h' + -clen + 'v3h' + (clen + 3) + 'ZM' + (box.l - 3.5) + ',' + (box.b + 0.5 - clen) + 'h3v' + clen + 'h' + clen + 'v3h-' + (clen + 3) + 'Z';\n}\n\nfunction calcLinks(gd, groups, xaHash, yaHash) {\n  var isSubplotConstrained = false;\n  var xLinks = {};\n  var yLinks = {};\n  var xID, yID, xLinkID, yLinkID;\n\n  for (var i = 0; i < groups.length; i++) {\n    var group = groups[i]; // check if any of the x axes we're dragging is in this constraint group\n\n    for (xID in xaHash) {\n      if (group[xID]) {\n        // put the rest of these axes into xLinks, if we're not already\n        // dragging them, so we know to scale these axes automatically too\n        // to match the changes in the dragged x axes\n        for (xLinkID in group) {\n          if (!(xLinkID.charAt(0) === 'x' ? xaHash : yaHash)[xLinkID]) {\n            xLinks[xLinkID] = xID;\n          }\n        } // check if the x and y axes of THIS drag are linked\n\n\n        for (yID in yaHash) {\n          if (group[yID]) isSubplotConstrained = true;\n        }\n      }\n    } // now check if any of the y axes we're dragging is in this constraint group\n    // only look for outside links, as we've already checked for links within the dragger\n\n\n    for (yID in yaHash) {\n      if (group[yID]) {\n        for (yLinkID in group) {\n          if (!(yLinkID.charAt(0) === 'x' ? xaHash : yaHash)[yLinkID]) {\n            yLinks[yLinkID] = yID;\n          }\n        }\n      }\n    }\n  }\n\n  if (isSubplotConstrained) {\n    // merge xLinks and yLinks if the subplot is constrained,\n    // since we'll always apply both anyway and the two will contain\n    // duplicates\n    Lib.extendFlat(xLinks, yLinks);\n    yLinks = {};\n  }\n\n  var xaHashLinked = {};\n  var xaxesLinked = [];\n\n  for (xLinkID in xLinks) {\n    var xa = getFromId(gd, xLinkID);\n    xaxesLinked.push(xa);\n    xaHashLinked[xa._id] = xa;\n  }\n\n  var yaHashLinked = {};\n  var yaxesLinked = [];\n\n  for (yLinkID in yLinks) {\n    var ya = getFromId(gd, yLinkID);\n    yaxesLinked.push(ya);\n    yaHashLinked[ya._id] = ya;\n  }\n\n  return {\n    xaHash: xaHashLinked,\n    yaHash: yaHashLinked,\n    xaxes: xaxesLinked,\n    yaxes: yaxesLinked,\n    xLinks: xLinks,\n    yLinks: yLinks,\n    isSubplotConstrained: isSubplotConstrained\n  };\n} // still seems to be some confusion about onwheel vs onmousewheel...\n\n\nfunction attachWheelEventHandler(element, handler) {\n  if (!supportsPassive) {\n    if (element.onwheel !== undefined) element.onwheel = handler;else if (element.onmousewheel !== undefined) element.onmousewheel = handler;\n  } else {\n    var wheelEventName = element.onwheel !== undefined ? 'wheel' : 'mousewheel';\n\n    if (element._onwheel) {\n      element.removeEventListener(wheelEventName, element._onwheel);\n    }\n\n    element._onwheel = handler;\n    element.addEventListener(wheelEventName, handler, {\n      passive: false\n    });\n  }\n}\n\nfunction hashValues(hash) {\n  var out = [];\n\n  for (var k in hash) out.push(hash[k]);\n\n  return out;\n}\n\nmodule.exports = {\n  makeDragBox: makeDragBox,\n  makeDragger: makeDragger,\n  makeRectDragger: makeRectDragger,\n  makeZoombox: makeZoombox,\n  makeCorners: makeCorners,\n  updateZoombox: updateZoombox,\n  xyCorners: xyCorners,\n  transitionZoombox: transitionZoombox,\n  removeZoombox: removeZoombox,\n  showDoubleClickNotifier: showDoubleClickNotifier,\n  attachWheelEventHandler: attachWheelEventHandler\n};","map":null,"metadata":{},"sourceType":"script"}