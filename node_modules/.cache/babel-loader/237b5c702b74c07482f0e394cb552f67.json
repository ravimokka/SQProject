{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar dot = require('./matrix').dot;\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nvar polygon = module.exports = {};\n/**\n * Turn an array of [x, y] pairs into a polygon object\n * that can test if points are inside it\n *\n * @param ptsIn Array of [x, y] pairs\n *\n * @returns polygon Object {xmin, xmax, ymin, ymax, pts, contains}\n *      (x|y)(min|max) are the bounding rect of the polygon\n *      pts is the original array, with the first pair repeated at the end\n *      contains is a function: (pt, omitFirstEdge)\n *          pt is the [x, y] pair to test\n *          omitFirstEdge truthy means points exactly on the first edge don't\n *              count. This is for use adding one polygon to another so we\n *              don't double-count the edge where they meet.\n *          returns boolean: is pt inside the polygon (including on its edges)\n */\n\npolygon.tester = function tester(ptsIn) {\n  var pts = ptsIn.slice();\n  var xmin = pts[0][0];\n  var xmax = xmin;\n  var ymin = pts[0][1];\n  var ymax = ymin;\n  var i;\n  pts.push(pts[0]);\n\n  for (i = 1; i < pts.length; i++) {\n    xmin = Math.min(xmin, pts[i][0]);\n    xmax = Math.max(xmax, pts[i][0]);\n    ymin = Math.min(ymin, pts[i][1]);\n    ymax = Math.max(ymax, pts[i][1]);\n  } // do we have a rectangle? Handle this here, so we can use the same\n  // tester for the rectangular case without sacrificing speed\n\n\n  var isRect = false;\n  var rectFirstEdgeTest;\n\n  if (pts.length === 5) {\n    if (pts[0][0] === pts[1][0]) {\n      // vert, horz, vert, horz\n      if (pts[2][0] === pts[3][0] && pts[0][1] === pts[3][1] && pts[1][1] === pts[2][1]) {\n        isRect = true;\n\n        rectFirstEdgeTest = function (pt) {\n          return pt[0] === pts[0][0];\n        };\n      }\n    } else if (pts[0][1] === pts[1][1]) {\n      // horz, vert, horz, vert\n      if (pts[2][1] === pts[3][1] && pts[0][0] === pts[3][0] && pts[1][0] === pts[2][0]) {\n        isRect = true;\n\n        rectFirstEdgeTest = function (pt) {\n          return pt[1] === pts[0][1];\n        };\n      }\n    }\n  }\n\n  function rectContains(pt, omitFirstEdge) {\n    var x = pt[0];\n    var y = pt[1];\n\n    if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {\n      // pt is outside the bounding box of polygon\n      return false;\n    }\n\n    if (omitFirstEdge && rectFirstEdgeTest(pt)) return false;\n    return true;\n  }\n\n  function contains(pt, omitFirstEdge) {\n    var x = pt[0];\n    var y = pt[1];\n\n    if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {\n      // pt is outside the bounding box of polygon\n      return false;\n    }\n\n    var imax = pts.length;\n    var x1 = pts[0][0];\n    var y1 = pts[0][1];\n    var crossings = 0;\n    var i;\n    var x0;\n    var y0;\n    var xmini;\n    var ycross;\n\n    for (i = 1; i < imax; i++) {\n      // find all crossings of a vertical line upward from pt with\n      // polygon segments\n      // crossings exactly at xmax don't count, unless the point is\n      // exactly on the segment, then it counts as inside.\n      x0 = x1;\n      y0 = y1;\n      x1 = pts[i][0];\n      y1 = pts[i][1];\n      xmini = Math.min(x0, x1);\n\n      if (x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {\n        // outside the bounding box of this segment, it's only a crossing\n        // if it's below the box.\n        continue;\n      } else if (y < Math.min(y0, y1)) {\n        // don't count the left-most point of the segment as a crossing\n        // because we don't want to double-count adjacent crossings\n        // UNLESS the polygon turns past vertical at exactly this x\n        // Note that this is repeated below, but we can't factor it out\n        // because\n        if (x !== xmini) crossings++;\n      } else {\n        // inside the bounding box, check the actual line intercept\n        // vertical segment - we know already that the point is exactly\n        // on the segment, so mark the crossing as exactly at the point.\n        if (x1 === x0) ycross = y; // any other angle\n        else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0); // exactly on the edge: counts as inside the polygon, unless it's the\n        // first edge and we're omitting it.\n\n        if (y === ycross) {\n          if (i === 1 && omitFirstEdge) return false;\n          return true;\n        }\n\n        if (y <= ycross && x !== xmini) crossings++;\n      }\n    } // if we've gotten this far, odd crossings means inside, even is outside\n\n\n    return crossings % 2 === 1;\n  } // detect if poly is degenerate\n\n\n  var degenerate = true;\n  var lastPt = pts[0];\n\n  for (i = 1; i < pts.length; i++) {\n    if (lastPt[0] !== pts[i][0] || lastPt[1] !== pts[i][1]) {\n      degenerate = false;\n      break;\n    }\n  }\n\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: pts,\n    contains: isRect ? rectContains : contains,\n    isRect: isRect,\n    degenerate: degenerate\n  };\n};\n/**\n * Test if a segment of a points array is bent or straight\n *\n * @param pts Array of [x, y] pairs\n * @param start the index of the proposed start of the straight section\n * @param end the index of the proposed end point\n * @param tolerance the max distance off the line connecting start and end\n *      before the line counts as bent\n * @returns boolean: true means this segment is bent, false means straight\n */\n\n\npolygon.isSegmentBent = function isSegmentBent(pts, start, end, tolerance) {\n  var startPt = pts[start];\n  var segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]];\n  var segmentSquared = dot(segment, segment);\n  var segmentLen = Math.sqrt(segmentSquared);\n  var unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen];\n  var i;\n  var part;\n  var partParallel;\n\n  for (i = start + 1; i < end; i++) {\n    part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];\n    partParallel = dot(part, segment);\n    if (partParallel < 0 || partParallel > segmentSquared || Math.abs(dot(part, unitPerp)) > tolerance) return true;\n  }\n\n  return false;\n};\n/**\n * Make a filtering polygon, to minimize the number of segments\n *\n * @param pts Array of [x, y] pairs (must start with at least 1 pair)\n * @param tolerance the maximum deviation from straight allowed for\n *      removing points to simplify the polygon\n *\n * @returns Object {addPt, raw, filtered}\n *      addPt is a function(pt: [x, y] pair) to add a raw point and\n *          continue filtering\n *      raw is all the input points\n *      filtered is the resulting filtered Array of [x, y] pairs\n */\n\n\npolygon.filter = function filter(pts, tolerance) {\n  var ptsFiltered = [pts[0]];\n  var doneRawIndex = 0;\n  var doneFilteredIndex = 0;\n\n  function addPt(pt) {\n    pts.push(pt);\n    var prevFilterLen = ptsFiltered.length;\n    var iLast = doneRawIndex;\n    ptsFiltered.splice(doneFilteredIndex + 1);\n\n    for (var i = iLast + 1; i < pts.length; i++) {\n      if (i === pts.length - 1 || polygon.isSegmentBent(pts, iLast, i + 1, tolerance)) {\n        ptsFiltered.push(pts[i]);\n\n        if (ptsFiltered.length < prevFilterLen - 2) {\n          doneRawIndex = i;\n          doneFilteredIndex = ptsFiltered.length - 1;\n        }\n\n        iLast = i;\n      }\n    }\n  }\n\n  if (pts.length > 1) {\n    var lastPt = pts.pop();\n    addPt(lastPt);\n  }\n\n  return {\n    addPt: addPt,\n    raw: pts,\n    filtered: ptsFiltered\n  };\n};","map":null,"metadata":{},"sourceType":"script"}