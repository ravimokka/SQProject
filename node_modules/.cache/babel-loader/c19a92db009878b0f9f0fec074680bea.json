{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isArray = Array.isArray; // IE9 fallbacks\n\nvar ab = typeof ArrayBuffer === 'undefined' || !ArrayBuffer.isView ? {\n  isView: function () {\n    return false;\n  }\n} : ArrayBuffer;\nvar dv = typeof DataView === 'undefined' ? function () {} : DataView;\n\nfunction isTypedArray(a) {\n  return ab.isView(a) && !(a instanceof dv);\n}\n\nexports.isTypedArray = isTypedArray;\n\nfunction isArrayOrTypedArray(a) {\n  return isArray(a) || isTypedArray(a);\n}\n\nexports.isArrayOrTypedArray = isArrayOrTypedArray;\n/*\n * Test whether an input object is 1D.\n *\n * Assumes we already know the object is an array.\n *\n * Looks only at the first element, if the dimensionality is\n * not consistent we won't figure that out here.\n */\n\nfunction isArray1D(a) {\n  return !isArrayOrTypedArray(a[0]);\n}\n\nexports.isArray1D = isArray1D;\n/*\n * Ensures an array has the right amount of storage space. If it doesn't\n * exist, it creates an array. If it does exist, it returns it if too\n * short or truncates it in-place.\n *\n * The goal is to just reuse memory to avoid a bit of excessive garbage\n * collection.\n */\n\nexports.ensureArray = function (out, n) {\n  // TODO: typed array support here? This is only used in\n  // traces/carpet/compute_control_points\n  if (!isArray(out)) out = []; // If too long, truncate. (If too short, it will grow\n  // automatically so we don't care about that case)\n\n  out.length = n;\n  return out;\n};\n/*\n * TypedArray-compatible concatenation of n arrays\n * if all arrays are the same type it will preserve that type,\n * otherwise it falls back on Array.\n * Also tries to avoid copying, in case one array has zero length\n * But never mutates an existing array\n */\n\n\nexports.concat = function () {\n  var args = [];\n  var allArray = true;\n  var totalLen = 0;\n\n  var _constructor, arg0, i, argi, posi, leni, out, j;\n\n  for (i = 0; i < arguments.length; i++) {\n    argi = arguments[i];\n    leni = argi.length;\n\n    if (leni) {\n      if (arg0) args.push(argi);else {\n        arg0 = argi;\n        posi = leni;\n      }\n\n      if (isArray(argi)) {\n        _constructor = false;\n      } else {\n        allArray = false;\n\n        if (!totalLen) {\n          _constructor = argi.constructor;\n        } else if (_constructor !== argi.constructor) {\n          // TODO: in principle we could upgrade here,\n          // ie keep typed array but convert all to Float64Array?\n          _constructor = false;\n        }\n      }\n\n      totalLen += leni;\n    }\n  }\n\n  if (!totalLen) return [];\n  if (!args.length) return arg0;\n  if (allArray) return arg0.concat.apply(arg0, args);\n\n  if (_constructor) {\n    // matching typed arrays\n    out = new _constructor(totalLen);\n    out.set(arg0);\n\n    for (i = 0; i < args.length; i++) {\n      argi = args[i];\n      out.set(argi, posi);\n      posi += argi.length;\n    }\n\n    return out;\n  } // mismatched types or Array + typed\n\n\n  out = new Array(totalLen);\n\n  for (j = 0; j < arg0.length; j++) out[j] = arg0[j];\n\n  for (i = 0; i < args.length; i++) {\n    argi = args[i];\n\n    for (j = 0; j < argi.length; j++) out[posi + j] = argi[j];\n\n    posi += j;\n  }\n\n  return out;\n};\n\nexports.maxRowLength = function (z) {\n  return _rowLength(z, Math.max, 0);\n};\n\nexports.minRowLength = function (z) {\n  return _rowLength(z, Math.min, Infinity);\n};\n\nfunction _rowLength(z, fn, len0) {\n  if (isArrayOrTypedArray(z)) {\n    if (isArrayOrTypedArray(z[0])) {\n      var len = len0;\n\n      for (var i = 0; i < z.length; i++) {\n        len = fn(len, z[i].length);\n      }\n\n      return len;\n    } else {\n      return z.length;\n    }\n  }\n\n  return 0;\n}","map":null,"metadata":{},"sourceType":"script"}