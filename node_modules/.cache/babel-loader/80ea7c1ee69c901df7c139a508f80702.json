{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar binFunctions = require('../histogram/bin_functions');\n\nvar normFunctions = require('../histogram/norm_functions');\n\nvar doAvg = require('../histogram/average');\n\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\n\nvar calcAllAutoBins = require('../histogram/calc').calcAllAutoBins;\n\nmodule.exports = function calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var xcalendar = trace.xcalendar;\n  var ycalendar = trace.ycalendar;\n\n  var xr2c = function (v) {\n    return xa.r2c(v, 0, xcalendar);\n  };\n\n  var yr2c = function (v) {\n    return ya.r2c(v, 0, ycalendar);\n  };\n\n  var xc2r = function (v) {\n    return xa.c2r(v, 0, xcalendar);\n  };\n\n  var yc2r = function (v) {\n    return ya.c2r(v, 0, ycalendar);\n  };\n\n  var i, j, n, m; // calculate the bins\n\n  var xBinsAndPos = calcAllAutoBins(gd, trace, xa, 'x');\n  var xBinSpec = xBinsAndPos[0];\n  var xPos0 = xBinsAndPos[1];\n  var yBinsAndPos = calcAllAutoBins(gd, trace, ya, 'y');\n  var yBinSpec = yBinsAndPos[0];\n  var yPos0 = yBinsAndPos[1];\n  var serieslen = trace._length;\n  if (xPos0.length > serieslen) xPos0.splice(serieslen, xPos0.length - serieslen);\n  if (yPos0.length > serieslen) yPos0.splice(serieslen, yPos0.length - serieslen); // make the empty bin array & scale the map\n\n  var z = [];\n  var onecol = [];\n  var zerocol = [];\n  var nonuniformBinsX = typeof xBinSpec.size === 'string';\n  var nonuniformBinsY = typeof yBinSpec.size === 'string';\n  var xEdges = [];\n  var yEdges = [];\n  var xbins = nonuniformBinsX ? xEdges : xBinSpec;\n  var ybins = nonuniformBinsY ? yEdges : yBinSpec;\n  var total = 0;\n  var counts = [];\n  var inputPoints = [];\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densitynorm = norm.indexOf('density') !== -1;\n  var extremefunc = func === 'max' || func === 'min';\n  var sizeinit = extremefunc ? null : 0;\n  var binfunc = binFunctions.count;\n  var normfunc = normFunctions[norm];\n  var doavg = false;\n  var xinc = [];\n  var yinc = []; // set a binning function other than count?\n  // for binning functions: check first for 'z',\n  // then 'mc' in case we had a colored scatter plot\n  // and want to transfer these colors to the 2D histo\n  // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n\n  var rawCounterData = 'z' in trace ? trace.z : 'marker' in trace && Array.isArray(trace.marker.color) ? trace.marker.color : '';\n\n  if (rawCounterData && func !== 'count') {\n    doavg = func === 'avg';\n    binfunc = binFunctions[func];\n  } // decrease end a little in case of rounding errors\n\n\n  var xBinSize = xBinSpec.size;\n  var xBinStart = xr2c(xBinSpec.start);\n  var xBinEnd = xr2c(xBinSpec.end) + (xBinStart - Axes.tickIncrement(xBinStart, xBinSize, false, xcalendar)) / 1e6;\n\n  for (i = xBinStart; i < xBinEnd; i = Axes.tickIncrement(i, xBinSize, false, xcalendar)) {\n    onecol.push(sizeinit);\n    xEdges.push(i);\n    if (doavg) zerocol.push(0);\n  }\n\n  xEdges.push(i);\n  var nx = onecol.length;\n  var dx = (i - xBinStart) / nx;\n  var x0 = xc2r(xBinStart + dx / 2);\n  var yBinSize = yBinSpec.size;\n  var yBinStart = yr2c(yBinSpec.start);\n  var yBinEnd = yr2c(yBinSpec.end) + (yBinStart - Axes.tickIncrement(yBinStart, yBinSize, false, ycalendar)) / 1e6;\n\n  for (i = yBinStart; i < yBinEnd; i = Axes.tickIncrement(i, yBinSize, false, ycalendar)) {\n    z.push(onecol.slice());\n    yEdges.push(i);\n    var ipCol = new Array(nx);\n\n    for (j = 0; j < nx; j++) ipCol[j] = [];\n\n    inputPoints.push(ipCol);\n    if (doavg) counts.push(zerocol.slice());\n  }\n\n  yEdges.push(i);\n  var ny = z.length;\n  var dy = (i - yBinStart) / ny;\n  var y0 = yc2r(yBinStart + dy / 2);\n\n  if (densitynorm) {\n    xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n    yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n  } // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n\n\n  if (!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n  if (!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins); // put data into bins\n\n  var uniqueValsPerX = true;\n  var uniqueValsPerY = true;\n  var xVals = new Array(nx);\n  var yVals = new Array(ny);\n  var xGapLow = Infinity;\n  var xGapHigh = Infinity;\n  var yGapLow = Infinity;\n  var yGapHigh = Infinity;\n\n  for (i = 0; i < serieslen; i++) {\n    var xi = xPos0[i];\n    var yi = yPos0[i];\n    n = Lib.findBin(xi, xbins);\n    m = Lib.findBin(yi, ybins);\n\n    if (n >= 0 && n < nx && m >= 0 && m < ny) {\n      total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n      inputPoints[m][n].push(i);\n\n      if (uniqueValsPerX) {\n        if (xVals[n] === undefined) xVals[n] = xi;else if (xVals[n] !== xi) uniqueValsPerX = false;\n      }\n\n      if (uniqueValsPerY) {\n        if (yVals[m] === undefined) yVals[m] = yi;else if (yVals[m] !== yi) uniqueValsPerY = false;\n      }\n\n      xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n      xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n      yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n      yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n    }\n  } // normalize, if needed\n\n\n  if (doavg) {\n    for (m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);\n  }\n\n  if (normfunc) {\n    for (m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);\n  }\n\n  return {\n    x: xPos0,\n    xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n    x0: x0,\n    dx: dx,\n    y: yPos0,\n    yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n    y0: y0,\n    dy: dy,\n    z: z,\n    pts: inputPoints\n  };\n};\n\nfunction makeIncrements(len, bins, dv, nonuniform) {\n  var out = new Array(len);\n  var i;\n\n  if (nonuniform) {\n    for (i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);\n  } else {\n    var inc = 1 / dv;\n\n    for (i = 0; i < len; i++) out[i] = inc;\n  }\n\n  return out;\n}\n\nfunction binsToCalc(r2c, bins) {\n  return {\n    start: r2c(bins.start),\n    end: r2c(bins.end),\n    size: bins.size\n  };\n}\n\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n  var i;\n  var len = edges.length - 1;\n  var out = new Array(len);\n  var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n\n  for (i = 0; i < len; i++) {\n    var v = (uniqueVals || [])[i];\n    out[i] = v === undefined ? [roundFn(edges[i]), roundFn(edges[i + 1], true)] : [v, v];\n  }\n\n  return out;\n}","map":null,"metadata":{},"sourceType":"script"}