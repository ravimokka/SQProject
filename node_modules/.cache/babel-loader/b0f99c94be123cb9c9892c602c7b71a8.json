{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isPlainObject = require('../lib/is_plain_object');\n\nvar noop = require('../lib/noop');\n\nvar Loggers = require('../lib/loggers');\n\nvar sorterAsc = require('../lib/search').sorterAsc;\n\nvar Registry = require('../registry');\n\nexports.containerArrayMatch = require('./container_array_match');\n\nvar isAddVal = exports.isAddVal = function isAddVal(val) {\n  return val === 'add' || isPlainObject(val);\n};\n\nvar isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {\n  return val === null || val === 'remove';\n};\n/*\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\n * handles them all with a consistent interface.\n *\n * Here are the supported actions -> relayout calls -> edits we get here\n * (as prepared in _relayout):\n *\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\n *               -> {'annotations[2]': null} -> {2: {'': null}}\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\n *                        -> {'annotations': null} -> {'': {'': null}}\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\n *\n * You can combine many edits to different objects. Objects are added and edited\n * in ascending order, then removed in descending order.\n * For example, starting with [a, b, c], if you want to:\n * - replace b with d:\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\n * - add a new item d between a and b, and edit b:\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\n * - delete b and edit c:\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\n *\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\n *\n * @param {HTMLDivElement} gd\n *  the DOM element of the graph container div\n * @param {Lib.nestedProperty} componentType: the array we are editing\n * @param {Object} edits\n *  the changes to make; keys are indices to edit, values are themselves objects:\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\n *  in special values of the empty attr)\n * @param {Object} flags\n *  the flags for which actions we're going to perform to display these (and\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\n *  individual items\n * @param {function} _nestedProperty\n *  a (possibly modified for gui edits) nestedProperty constructor\n *  The modified version takes a 3rd argument, for a prefix to the attribute\n *  string necessary for storing GUI edits\n *\n * @returns {bool} `true` if it managed to complete drawing of the changes\n *  `false` would mean the parent should replot.\n */\n\n\nexports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {\n  var componentType = np.astr;\n  var supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults');\n  var draw = Registry.getComponentMethod(componentType, 'draw');\n  var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n  var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n\n  if (edits['']) {\n    if (Object.keys(edits).length > 1) {\n      Loggers.warn('Full array edits are incompatible with other edits', componentType);\n    }\n\n    var fullVal = edits[''][''];\n    if (isRemoveVal(fullVal)) np.set(null);else if (Array.isArray(fullVal)) np.set(fullVal);else {\n      Loggers.warn('Unrecognized full array edit value', componentType, fullVal);\n      return true;\n    }\n    if (replotLater) return false;\n    supplyComponentDefaults(layout, fullLayout);\n    draw(gd);\n    return true;\n  }\n\n  var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);\n  var componentArrayIn = np.get();\n  var componentArray = componentArrayIn || []; // componentArrayFull is used just to keep splices in line between\n  // full and input arrays, so private keys can be copied over after\n  // redoing supplyDefaults\n  // TODO: this assumes componentArray is in gd.layout - which will not be\n  // true after we extend this to restyle\n\n  var componentArrayFull = _nestedProperty(fullLayout, componentType).get();\n\n  var deletes = [];\n  var firstIndexChange = -1;\n  var maxIndex = componentArray.length;\n  var i;\n  var j;\n  var componentNum;\n  var objEdits;\n  var objKeys;\n  var objVal;\n  var adding, prefix; // first make the add and edit changes\n\n  for (i = 0; i < componentNums.length; i++) {\n    componentNum = componentNums[i];\n    objEdits = edits[componentNum];\n    objKeys = Object.keys(objEdits);\n    objVal = objEdits[''], adding = isAddVal(objVal);\n\n    if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {\n      Loggers.warn('index out of range', componentType, componentNum);\n      continue;\n    }\n\n    if (objVal !== undefined) {\n      if (objKeys.length > 1) {\n        Loggers.warn('Insertion & removal are incompatible with edits to the same index.', componentType, componentNum);\n      }\n\n      if (isRemoveVal(objVal)) {\n        deletes.push(componentNum);\n      } else if (adding) {\n        if (objVal === 'add') objVal = {};\n        componentArray.splice(componentNum, 0, objVal);\n        if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});\n      } else {\n        Loggers.warn('Unrecognized full object edit value', componentType, componentNum, objVal);\n      }\n\n      if (firstIndexChange === -1) firstIndexChange = componentNum;\n    } else {\n      for (j = 0; j < objKeys.length; j++) {\n        prefix = componentType + '[' + componentNum + '].';\n\n        _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);\n      }\n    }\n  } // now do deletes\n\n\n  for (i = deletes.length - 1; i >= 0; i--) {\n    componentArray.splice(deletes[i], 1); // TODO: this drops private keys that had been stored in componentArrayFull\n    // does this have any ill effects?\n\n    if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);\n  }\n\n  if (!componentArray.length) np.set(null);else if (!componentArrayIn) np.set(componentArray);\n  if (replotLater) return false;\n  supplyComponentDefaults(layout, fullLayout); // finally draw all the components we need to\n  // if we added or removed any, redraw all after it\n\n  if (drawOne !== noop) {\n    var indicesToDraw;\n\n    if (firstIndexChange === -1) {\n      // there's no re-indexing to do, so only redraw components that changed\n      indicesToDraw = componentNums;\n    } else {\n      // in case the component array was shortened, we still need do call\n      // drawOne on the latter items so they get properly removed\n      maxIndex = Math.max(componentArray.length, maxIndex);\n      indicesToDraw = [];\n\n      for (i = 0; i < componentNums.length; i++) {\n        componentNum = componentNums[i];\n        if (componentNum >= firstIndexChange) break;\n        indicesToDraw.push(componentNum);\n      }\n\n      for (i = firstIndexChange; i < maxIndex; i++) {\n        indicesToDraw.push(i);\n      }\n    }\n\n    for (i = 0; i < indicesToDraw.length; i++) {\n      drawOne(gd, indicesToDraw[i]);\n    }\n  } else draw(gd);\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}