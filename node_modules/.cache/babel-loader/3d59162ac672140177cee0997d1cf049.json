{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar draw = require('./draw').draw;\n\nmodule.exports = function calcAutorange(gd) {\n  var fullLayout = gd._fullLayout;\n  var annotationList = Lib.filterVisible(fullLayout.annotations);\n\n  if (annotationList.length && gd._fullData.length) {\n    return Lib.syncOrAsync([draw, annAutorange], gd);\n  }\n};\n\nfunction annAutorange(gd) {\n  var fullLayout = gd._fullLayout; // find the bounding boxes for each of these annotations'\n  // relative to their anchor points\n  // use the arrow and the text bg rectangle,\n  // as the whole anno may include hidden text in its bbox\n\n  Lib.filterVisible(fullLayout.annotations).forEach(function (ann) {\n    var xa = Axes.getFromId(gd, ann.xref);\n    var ya = Axes.getFromId(gd, ann.yref);\n    ann._extremes = {};\n    if (xa) calcAxisExpansion(ann, xa);\n    if (ya) calcAxisExpansion(ann, ya);\n  });\n}\n\nfunction calcAxisExpansion(ann, ax) {\n  var axId = ax._id;\n  var letter = axId.charAt(0);\n  var pos = ann[letter];\n  var apos = ann['a' + letter];\n  var ref = ann[letter + 'ref'];\n  var aref = ann['a' + letter + 'ref'];\n  var padplus = ann['_' + letter + 'padplus'];\n  var padminus = ann['_' + letter + 'padminus'];\n  var shift = {\n    x: 1,\n    y: -1\n  }[letter] * ann[letter + 'shift'];\n  var headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;\n  var headPlus = headSize + shift;\n  var headMinus = headSize - shift;\n  var startHeadSize = 3 * ann.startarrowsize * ann.arrowwidth || 0;\n  var startHeadPlus = startHeadSize + shift;\n  var startHeadMinus = startHeadSize - shift;\n  var extremes;\n\n  if (aref === ref) {\n    // expand for the arrowhead (padded by arrowhead)\n    var extremeArrowHead = Axes.findExtremes(ax, [ax.r2c(pos)], {\n      ppadplus: headPlus,\n      ppadminus: headMinus\n    }); // again for the textbox (padded by textbox)\n\n    var extremeText = Axes.findExtremes(ax, [ax.r2c(apos)], {\n      ppadplus: Math.max(padplus, startHeadPlus),\n      ppadminus: Math.max(padminus, startHeadMinus)\n    });\n    extremes = {\n      min: [extremeArrowHead.min[0], extremeText.min[0]],\n      max: [extremeArrowHead.max[0], extremeText.max[0]]\n    };\n  } else {\n    startHeadPlus = apos ? startHeadPlus + apos : startHeadPlus;\n    startHeadMinus = apos ? startHeadMinus - apos : startHeadMinus;\n    extremes = Axes.findExtremes(ax, [ax.r2c(pos)], {\n      ppadplus: Math.max(padplus, headPlus, startHeadPlus),\n      ppadminus: Math.max(padminus, headMinus, startHeadMinus)\n    });\n  }\n\n  ann._extremes[axId] = extremes;\n}","map":null,"metadata":{},"sourceType":"script"}