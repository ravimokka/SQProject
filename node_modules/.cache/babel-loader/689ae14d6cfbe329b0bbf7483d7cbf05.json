{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar polygon = require('../../lib/polygon');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\n\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\n\nvar style = require('./style').style;\n\nfunction plot(gd, geo, calcData) {\n  for (var i = 0; i < calcData.length; i++) {\n    calcGeoJSON(calcData[i], geo.topojson);\n  }\n\n  var choroplethLayer = geo.layers.backplot.select('.choroplethlayer');\n  Lib.makeTraceGroups(choroplethLayer, calcData, 'trace choropleth').each(function (calcTrace) {\n    var sel = d3.select(this);\n    var paths = sel.selectAll('path.choroplethlocation').data(Lib.identity);\n    paths.enter().append('path').classed('choroplethlocation', true);\n    paths.exit().remove(); // call style here within topojson request callback\n\n    style(gd, calcTrace);\n  });\n}\n\nfunction calcGeoJSON(calcTrace, topojson) {\n  var trace = calcTrace[0].trace;\n  var len = calcTrace.length;\n  var features = getTopojsonFeatures(trace, topojson);\n\n  for (var i = 0; i < len; i++) {\n    var calcPt = calcTrace[i];\n    var feature = locationToFeature(trace.locationmode, calcPt.loc, features);\n\n    if (!feature) {\n      calcPt.geojson = null;\n      continue;\n    }\n\n    calcPt.geojson = feature;\n    calcPt.ct = feature.properties.ct;\n    calcPt._polygons = feature2polygons(feature);\n  }\n}\n\nfunction feature2polygons(feature) {\n  var geometry = feature.geometry;\n  var coords = geometry.coordinates;\n  var loc = feature.id;\n  var polygons = [];\n  var appendPolygon, j, k, m;\n\n  function doesCrossAntiMerdian(pts) {\n    for (var l = 0; l < pts.length - 1; l++) {\n      if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n    }\n\n    return null;\n  }\n\n  if (loc === 'RUS' || loc === 'FJI') {\n    // Russia and Fiji have landmasses that cross the antimeridian,\n    // we need to add +360 to their longitude coordinates, so that\n    // polygon 'contains' doesn't get confused when crossing the antimeridian.\n    //\n    // Note that other countries have polygons on either side of the antimeridian\n    // (e.g. some Aleutian island for the USA), but those don't confuse\n    // the 'contains' method; these are skipped here.\n    appendPolygon = function (_pts) {\n      var pts;\n\n      if (doesCrossAntiMerdian(_pts) === null) {\n        pts = _pts;\n      } else {\n        pts = new Array(_pts.length);\n\n        for (m = 0; m < _pts.length; m++) {\n          // do nut mutate calcdata[i][j].geojson !!\n          pts[m] = [_pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0], _pts[m][1]];\n        }\n      }\n\n      polygons.push(polygon.tester(pts));\n    };\n  } else if (loc === 'ATA') {\n    // Antarctica has a landmass that wraps around every longitudes which\n    // confuses the 'contains' methods.\n    appendPolygon = function (pts) {\n      var crossAntiMeridianIndex = doesCrossAntiMerdian(pts); // polygon that do not cross anti-meridian need no special handling\n\n      if (crossAntiMeridianIndex === null) {\n        return polygons.push(polygon.tester(pts));\n      } // stitch polygon by adding pt over South Pole,\n      // so that it covers the projected region covers all latitudes\n      //\n      // Note that the algorithm below only works for polygons that\n      // start and end on longitude -180 (like the ones built by\n      // https://github.com/etpinard/sane-topojson).\n\n\n      var stitch = new Array(pts.length + 1);\n      var si = 0;\n\n      for (m = 0; m < pts.length; m++) {\n        if (m > crossAntiMeridianIndex) {\n          stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n        } else if (m === crossAntiMeridianIndex) {\n          stitch[si++] = pts[m];\n          stitch[si++] = [pts[m][0], -90];\n        } else {\n          stitch[si++] = pts[m];\n        }\n      } // polygon.tester by default appends pt[0] to the points list,\n      // we must remove it here, to avoid a jump in longitude from 180 to -180,\n      // that would confuse the 'contains' method\n\n\n      var tester = polygon.tester(stitch);\n      tester.pts.pop();\n      polygons.push(tester);\n    };\n  } else {\n    // otherwise using same array ref is fine\n    appendPolygon = function (pts) {\n      polygons.push(polygon.tester(pts));\n    };\n  }\n\n  switch (geometry.type) {\n    case 'MultiPolygon':\n      for (j = 0; j < coords.length; j++) {\n        for (k = 0; k < coords[j].length; k++) {\n          appendPolygon(coords[j][k]);\n        }\n      }\n\n      break;\n\n    case 'Polygon':\n      for (j = 0; j < coords.length; j++) {\n        appendPolygon(coords[j]);\n      }\n\n      break;\n  }\n\n  return polygons;\n}\n\nmodule.exports = {\n  plot: plot,\n  feature2polygons: feature2polygons\n};","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/traces/choropleth/plot.js"],"names":["d3","require","Lib","polygon","getTopojsonFeatures","locationToFeature","style","plot","gd","geo","calcData","i","length","calcGeoJSON","topojson","choroplethLayer","layers","backplot","select","makeTraceGroups","each","calcTrace","sel","paths","selectAll","data","identity","enter","append","classed","exit","remove","trace","len","features","calcPt","feature","locationmode","loc","geojson","ct","properties","_polygons","feature2polygons","geometry","coords","coordinates","id","polygons","appendPolygon","j","k","m","doesCrossAntiMerdian","pts","l","_pts","Array","push","tester","crossAntiMeridianIndex","stitch","si","pop","type","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar polygon = require('../../lib/polygon');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\nvar style = require('./style').style;\n\nfunction plot(gd, geo, calcData) {\n    for(var i = 0; i < calcData.length; i++) {\n        calcGeoJSON(calcData[i], geo.topojson);\n    }\n\n    var choroplethLayer = geo.layers.backplot.select('.choroplethlayer');\n    Lib.makeTraceGroups(choroplethLayer, calcData, 'trace choropleth').each(function(calcTrace) {\n        var sel = d3.select(this);\n\n        var paths = sel.selectAll('path.choroplethlocation')\n            .data(Lib.identity);\n\n        paths.enter().append('path')\n            .classed('choroplethlocation', true);\n\n        paths.exit().remove();\n\n        // call style here within topojson request callback\n        style(gd, calcTrace);\n    });\n}\n\nfunction calcGeoJSON(calcTrace, topojson) {\n    var trace = calcTrace[0].trace;\n    var len = calcTrace.length;\n    var features = getTopojsonFeatures(trace, topojson);\n\n    for(var i = 0; i < len; i++) {\n        var calcPt = calcTrace[i];\n        var feature = locationToFeature(trace.locationmode, calcPt.loc, features);\n\n        if(!feature) {\n            calcPt.geojson = null;\n            continue;\n        }\n\n        calcPt.geojson = feature;\n        calcPt.ct = feature.properties.ct;\n        calcPt._polygons = feature2polygons(feature);\n    }\n}\n\nfunction feature2polygons(feature) {\n    var geometry = feature.geometry;\n    var coords = geometry.coordinates;\n    var loc = feature.id;\n\n    var polygons = [];\n    var appendPolygon, j, k, m;\n\n    function doesCrossAntiMerdian(pts) {\n        for(var l = 0; l < pts.length - 1; l++) {\n            if(pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n        }\n        return null;\n    }\n\n    if(loc === 'RUS' || loc === 'FJI') {\n        // Russia and Fiji have landmasses that cross the antimeridian,\n        // we need to add +360 to their longitude coordinates, so that\n        // polygon 'contains' doesn't get confused when crossing the antimeridian.\n        //\n        // Note that other countries have polygons on either side of the antimeridian\n        // (e.g. some Aleutian island for the USA), but those don't confuse\n        // the 'contains' method; these are skipped here.\n        appendPolygon = function(_pts) {\n            var pts;\n\n            if(doesCrossAntiMerdian(_pts) === null) {\n                pts = _pts;\n            } else {\n                pts = new Array(_pts.length);\n                for(m = 0; m < _pts.length; m++) {\n                    // do nut mutate calcdata[i][j].geojson !!\n                    pts[m] = [\n                        _pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0],\n                        _pts[m][1]\n                    ];\n                }\n            }\n\n            polygons.push(polygon.tester(pts));\n        };\n    } else if(loc === 'ATA') {\n        // Antarctica has a landmass that wraps around every longitudes which\n        // confuses the 'contains' methods.\n        appendPolygon = function(pts) {\n            var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n            // polygon that do not cross anti-meridian need no special handling\n            if(crossAntiMeridianIndex === null) {\n                return polygons.push(polygon.tester(pts));\n            }\n\n            // stitch polygon by adding pt over South Pole,\n            // so that it covers the projected region covers all latitudes\n            //\n            // Note that the algorithm below only works for polygons that\n            // start and end on longitude -180 (like the ones built by\n            // https://github.com/etpinard/sane-topojson).\n            var stitch = new Array(pts.length + 1);\n            var si = 0;\n\n            for(m = 0; m < pts.length; m++) {\n                if(m > crossAntiMeridianIndex) {\n                    stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n                } else if(m === crossAntiMeridianIndex) {\n                    stitch[si++] = pts[m];\n                    stitch[si++] = [pts[m][0], -90];\n                } else {\n                    stitch[si++] = pts[m];\n                }\n            }\n\n            // polygon.tester by default appends pt[0] to the points list,\n            // we must remove it here, to avoid a jump in longitude from 180 to -180,\n            // that would confuse the 'contains' method\n            var tester = polygon.tester(stitch);\n            tester.pts.pop();\n            polygons.push(tester);\n        };\n    } else {\n        // otherwise using same array ref is fine\n        appendPolygon = function(pts) {\n            polygons.push(polygon.tester(pts));\n        };\n    }\n\n    switch(geometry.type) {\n        case 'MultiPolygon':\n            for(j = 0; j < coords.length; j++) {\n                for(k = 0; k < coords[j].length; k++) {\n                    appendPolygon(coords[j][k]);\n                }\n            }\n            break;\n        case 'Polygon':\n            for(j = 0; j < coords.length; j++) {\n                appendPolygon(coords[j]);\n            }\n            break;\n    }\n\n    return polygons;\n}\n\nmodule.exports = {\n    plot: plot,\n    feature2polygons: feature2polygons\n};\n"]},"metadata":{},"sourceType":"script"}