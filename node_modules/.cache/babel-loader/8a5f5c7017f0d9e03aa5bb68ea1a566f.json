{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar tinycolor = require('tinycolor2');\n\nvar baseTraceAttrs = require('../plots/attributes');\n\nvar colorscales = require('../components/colorscale/scales');\n\nvar DESELECTDIM = require('../constants/interactions').DESELECTDIM;\n\nvar nestedProperty = require('./nested_property');\n\nvar counterRegex = require('./regex').counter;\n\nvar modHalf = require('./mod').modHalf;\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\n\nexports.valObjectMeta = {\n  data_array: {\n    // You can use *dflt=[] to force said array to exist though.\n    description: ['An {array} of data.', 'The value MUST be an {array}, or we ignore it.', 'Note that typed arrays (e.g. Float32Array) are supported.'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt'],\n    coerceFunction: function (v, propOut, dflt) {\n      // TODO maybe `v: {type: 'float32', vals: [/* ... */]}` also\n      if (isArrayOrTypedArray(v)) propOut.set(v);else if (dflt !== undefined) propOut.set(dflt);\n    }\n  },\n  enumerated: {\n    description: ['Enumerated value type. The available values are listed', 'in `values`.'].join(' '),\n    requiredOpts: ['values'],\n    otherOpts: ['dflt', 'coerceNumber', 'arrayOk'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      if (opts.coerceNumber) v = +v;\n      if (opts.values.indexOf(v) === -1) propOut.set(dflt);else propOut.set(v);\n    },\n    validateFunction: function (v, opts) {\n      if (opts.coerceNumber) v = +v;\n      var values = opts.values;\n\n      for (var i = 0; i < values.length; i++) {\n        var k = String(values[i]);\n\n        if (k.charAt(0) === '/' && k.charAt(k.length - 1) === '/') {\n          var regex = new RegExp(k.substr(1, k.length - 2));\n          if (regex.test(v)) return true;\n        } else if (v === values[i]) return true;\n      }\n\n      return false;\n    }\n  },\n  'boolean': {\n    description: 'A boolean (true/false) value.',\n    requiredOpts: [],\n    otherOpts: ['dflt'],\n    coerceFunction: function (v, propOut, dflt) {\n      if (v === true || v === false) propOut.set(v);else propOut.set(dflt);\n    }\n  },\n  number: {\n    description: ['A number or a numeric value', '(e.g. a number inside a string).', 'When applicable, values greater (less) than `max` (`min`)', 'are coerced to the `dflt`.'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt', 'min', 'max', 'arrayOk'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      if (!isNumeric(v) || opts.min !== undefined && v < opts.min || opts.max !== undefined && v > opts.max) {\n        propOut.set(dflt);\n      } else propOut.set(+v);\n    }\n  },\n  integer: {\n    description: ['An integer or an integer inside a string.', 'When applicable, values greater (less) than `max` (`min`)', 'are coerced to the `dflt`.'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt', 'min', 'max', 'arrayOk'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      if (v % 1 || !isNumeric(v) || opts.min !== undefined && v < opts.min || opts.max !== undefined && v > opts.max) {\n        propOut.set(dflt);\n      } else propOut.set(+v);\n    }\n  },\n  string: {\n    description: ['A string value.', 'Numbers are converted to strings except for attributes with', '`strict` set to true.'].join(' '),\n    requiredOpts: [],\n    // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)\n    otherOpts: ['dflt', 'noBlank', 'strict', 'arrayOk', 'values'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      if (typeof v !== 'string') {\n        var okToCoerce = typeof v === 'number';\n        if (opts.strict === true || !okToCoerce) propOut.set(dflt);else propOut.set(String(v));\n      } else if (opts.noBlank && !v) propOut.set(dflt);else propOut.set(v);\n    }\n  },\n  color: {\n    description: ['A string describing color.', 'Supported formats:', '- hex (e.g. \\'#d3d3d3\\')', '- rgb (e.g. \\'rgb(255, 0, 0)\\')', '- rgba (e.g. \\'rgb(255, 0, 0, 0.5)\\')', '- hsl (e.g. \\'hsl(0, 100%, 50%)\\')', '- hsv (e.g. \\'hsv(0, 100%, 100%)\\')', '- named colors (full list: http://www.w3.org/TR/css3-color/#svg-color)'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt', 'arrayOk'],\n    coerceFunction: function (v, propOut, dflt) {\n      if (tinycolor(v).isValid()) propOut.set(v);else propOut.set(dflt);\n    }\n  },\n  colorlist: {\n    description: ['A list of colors.', 'Must be an {array} containing valid colors.'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt'],\n    coerceFunction: function (v, propOut, dflt) {\n      function isColor(color) {\n        return tinycolor(color).isValid();\n      }\n\n      if (!Array.isArray(v) || !v.length) propOut.set(dflt);else if (v.every(isColor)) propOut.set(v);else propOut.set(dflt);\n    }\n  },\n  colorscale: {\n    description: ['A Plotly colorscale either picked by a name:', '(any of', Object.keys(colorscales.scales).join(', '), ')', 'customized as an {array} of 2-element {arrays} where', 'the first element is the normalized color level value', '(starting at *0* and ending at *1*),', 'and the second item is a valid color string.'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt'],\n    coerceFunction: function (v, propOut, dflt) {\n      propOut.set(colorscales.get(v, dflt));\n    }\n  },\n  angle: {\n    description: ['A number (in degree) between -180 and 180.'].join(' '),\n    requiredOpts: [],\n    otherOpts: ['dflt'],\n    coerceFunction: function (v, propOut, dflt) {\n      if (v === 'auto') propOut.set('auto');else if (!isNumeric(v)) propOut.set(dflt);else propOut.set(modHalf(+v, 360));\n    }\n  },\n  subplotid: {\n    description: ['An id string of a subplot type (given by dflt), optionally', 'followed by an integer >1. e.g. if dflt=\\'geo\\', we can have', '\\'geo\\', \\'geo2\\', \\'geo3\\', ...'].join(' '),\n    requiredOpts: ['dflt'],\n    otherOpts: ['regex'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      var regex = opts.regex || counterRegex(dflt);\n\n      if (typeof v === 'string' && regex.test(v)) {\n        propOut.set(v);\n        return;\n      }\n\n      propOut.set(dflt);\n    },\n    validateFunction: function (v, opts) {\n      var dflt = opts.dflt;\n      if (v === dflt) return true;\n      if (typeof v !== 'string') return false;\n      if (counterRegex(dflt).test(v)) return true;\n      return false;\n    }\n  },\n  flaglist: {\n    description: ['A string representing a combination of flags', '(order does not matter here).', 'Combine any of the available `flags` with *+*.', '(e.g. (\\'lines+markers\\')).', 'Values in `extras` cannot be combined.'].join(' '),\n    requiredOpts: ['flags'],\n    otherOpts: ['dflt', 'extras', 'arrayOk'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      if (typeof v !== 'string') {\n        propOut.set(dflt);\n        return;\n      }\n\n      if ((opts.extras || []).indexOf(v) !== -1) {\n        propOut.set(v);\n        return;\n      }\n\n      var vParts = v.split('+');\n      var i = 0;\n\n      while (i < vParts.length) {\n        var vi = vParts[i];\n\n        if (opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {\n          vParts.splice(i, 1);\n        } else i++;\n      }\n\n      if (!vParts.length) propOut.set(dflt);else propOut.set(vParts.join('+'));\n    }\n  },\n  any: {\n    description: 'Any type.',\n    requiredOpts: [],\n    otherOpts: ['dflt', 'values', 'arrayOk'],\n    coerceFunction: function (v, propOut, dflt) {\n      if (v === undefined) propOut.set(dflt);else propOut.set(v);\n    }\n  },\n  info_array: {\n    description: ['An {array} of plot information.'].join(' '),\n    requiredOpts: ['items'],\n    // set `dimensions=2` for a 2D array or '1-2' for either\n    // `items` may be a single object instead of an array, in which case\n    // `freeLength` must be true.\n    // if `dimensions='1-2'` and items is a 1D array, then the value can\n    // either be a matching 1D array or an array of such matching 1D arrays\n    otherOpts: ['dflt', 'freeLength', 'dimensions'],\n    coerceFunction: function (v, propOut, dflt, opts) {\n      // simplified coerce function just for array items\n      function coercePart(v, opts, dflt) {\n        var out;\n        var propPart = {\n          set: function (v) {\n            out = v;\n          }\n        };\n        if (dflt === undefined) dflt = opts.dflt;\n        exports.valObjectMeta[opts.valType].coerceFunction(v, propPart, dflt, opts);\n        return out;\n      }\n\n      var twoD = opts.dimensions === 2 || opts.dimensions === '1-2' && Array.isArray(v) && Array.isArray(v[0]);\n\n      if (!Array.isArray(v)) {\n        propOut.set(dflt);\n        return;\n      }\n\n      var items = opts.items;\n      var vOut = [];\n      var arrayItems = Array.isArray(items);\n      var arrayItems2D = arrayItems && twoD && Array.isArray(items[0]);\n      var innerItemsOnly = twoD && arrayItems && !arrayItems2D;\n      var len = arrayItems && !innerItemsOnly ? items.length : v.length;\n      var i, j, row, item, len2, vNew;\n      dflt = Array.isArray(dflt) ? dflt : [];\n\n      if (twoD) {\n        for (i = 0; i < len; i++) {\n          vOut[i] = [];\n          row = Array.isArray(v[i]) ? v[i] : [];\n          if (innerItemsOnly) len2 = items.length;else if (arrayItems) len2 = items[i].length;else len2 = row.length;\n\n          for (j = 0; j < len2; j++) {\n            if (innerItemsOnly) item = items[j];else if (arrayItems) item = items[i][j];else item = items;\n            vNew = coercePart(row[j], item, (dflt[i] || [])[j]);\n            if (vNew !== undefined) vOut[i][j] = vNew;\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          vNew = coercePart(v[i], arrayItems ? items[i] : items, dflt[i]);\n          if (vNew !== undefined) vOut[i] = vNew;\n        }\n      }\n\n      propOut.set(vOut);\n    },\n    validateFunction: function (v, opts) {\n      if (!Array.isArray(v)) return false;\n      var items = opts.items;\n      var arrayItems = Array.isArray(items);\n      var twoD = opts.dimensions === 2; // when free length is off, input and declared lengths must match\n\n      if (!opts.freeLength && v.length !== items.length) return false; // valid when all input items are valid\n\n      for (var i = 0; i < v.length; i++) {\n        if (twoD) {\n          if (!Array.isArray(v[i]) || !opts.freeLength && v[i].length !== items[i].length) {\n            return false;\n          }\n\n          for (var j = 0; j < v[i].length; j++) {\n            if (!validate(v[i][j], arrayItems ? items[i][j] : items)) {\n              return false;\n            }\n          }\n        } else if (!validate(v[i], arrayItems ? items[i] : items)) return false;\n      }\n\n      return true;\n    }\n  }\n};\n/**\n * Ensures that container[attribute] has a valid value.\n *\n * attributes[attribute] is an object with possible keys:\n * - valType: data_array, enumerated, boolean, ... as in valObjectMeta\n * - values: (enumerated only) array of allowed vals\n * - min, max: (number, integer only) inclusive bounds on allowed vals\n *      either or both may be omitted\n * - dflt: if attribute is invalid or missing, use this default\n *      if dflt is provided as an argument to lib.coerce it takes precedence\n *      as a convenience, returns the value it finally set\n */\n\nexports.coerce = function (containerIn, containerOut, attributes, attribute, dflt) {\n  var opts = nestedProperty(attributes, attribute).get();\n  var propIn = nestedProperty(containerIn, attribute);\n  var propOut = nestedProperty(containerOut, attribute);\n  var v = propIn.get();\n  var template = containerOut._template;\n\n  if (v === undefined && template) {\n    v = nestedProperty(template, attribute).get(); // already used the template value, so short-circuit the second check\n\n    template = 0;\n  }\n\n  if (dflt === undefined) dflt = opts.dflt;\n  /**\n   * arrayOk: value MAY be an array, then we do no value checking\n   * at this point, because it can be more complicated than the\n   * individual form (eg. some array vals can be numbers, even if the\n   * single values must be color strings)\n   */\n\n  if (opts.arrayOk && isArrayOrTypedArray(v)) {\n    propOut.set(v);\n    return v;\n  }\n\n  var coerceFunction = exports.valObjectMeta[opts.valType].coerceFunction;\n  coerceFunction(v, propOut, dflt, opts);\n  var out = propOut.get(); // in case v was provided but invalid, try the template again so it still\n  // overrides the regular default\n\n  if (template && out === dflt && !validate(v, opts)) {\n    v = nestedProperty(template, attribute).get();\n    coerceFunction(v, propOut, dflt, opts);\n    out = propOut.get();\n  }\n\n  return out;\n};\n/**\n * Variation on coerce\n *\n * Uses coerce to get attribute value if user input is valid,\n * returns attribute default if user input it not valid or\n * returns false if there is no user input.\n */\n\n\nexports.coerce2 = function (containerIn, containerOut, attributes, attribute, dflt) {\n  var propIn = nestedProperty(containerIn, attribute);\n  var propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt);\n  var valIn = propIn.get();\n  return valIn !== undefined && valIn !== null ? propOut : false;\n};\n/*\n * Shortcut to coerce the three font attributes\n *\n * 'coerce' is a lib.coerce wrapper with implied first three arguments\n */\n\n\nexports.coerceFont = function (coerce, attr, dfltObj) {\n  var out = {};\n  dfltObj = dfltObj || {};\n  out.family = coerce(attr + '.family', dfltObj.family);\n  out.size = coerce(attr + '.size', dfltObj.size);\n  out.color = coerce(attr + '.color', dfltObj.color);\n  return out;\n};\n/** Coerce shortcut for 'hoverinfo'\n * handling 1-vs-multi-trace dflt logic\n *\n * @param {object} traceIn : user trace object\n * @param {object} traceOut : full trace object (requires _module ref)\n * @param {object} layoutOut : full layout object (require _dataLength ref)\n * @return {any} : the coerced value\n */\n\n\nexports.coerceHoverinfo = function (traceIn, traceOut, layoutOut) {\n  var moduleAttrs = traceOut._module.attributes;\n  var attrs = moduleAttrs.hoverinfo ? moduleAttrs : baseTraceAttrs;\n  var valObj = attrs.hoverinfo;\n  var dflt;\n\n  if (layoutOut._dataLength === 1) {\n    var flags = valObj.dflt === 'all' ? valObj.flags.slice() : valObj.dflt.split('+');\n    flags.splice(flags.indexOf('name'), 1);\n    dflt = flags.join('+');\n  }\n\n  return exports.coerce(traceIn, traceOut, attrs, 'hoverinfo', dflt);\n};\n/** Coerce shortcut for [un]selected.marker.opacity,\n *  which has special default logic, to ensure that it corresponds to the\n *  default selection behavior while allowing to be overtaken by any other\n *  [un]selected attribute.\n *\n *  N.B. This must be called *after* coercing all the other [un]selected attrs,\n *  to give the intended result.\n *\n * @param {object} traceOut : fullData item\n * @param {function} coerce : lib.coerce wrapper with implied first three arguments\n */\n\n\nexports.coerceSelectionMarkerOpacity = function (traceOut, coerce) {\n  if (!traceOut.marker) return;\n  var mo = traceOut.marker.opacity; // you can still have a `marker` container with no markers if there's text\n\n  if (mo === undefined) return;\n  var smoDflt;\n  var usmoDflt; // Don't give [un]selected.marker.opacity a default value if\n  // marker.opacity is an array: handle this during style step.\n  //\n  // Only give [un]selected.marker.opacity a default value if you don't\n  // set any other [un]selected attributes.\n\n  if (!isArrayOrTypedArray(mo) && !traceOut.selected && !traceOut.unselected) {\n    smoDflt = mo;\n    usmoDflt = DESELECTDIM * mo;\n  }\n\n  coerce('selected.marker.opacity', smoDflt);\n  coerce('unselected.marker.opacity', usmoDflt);\n};\n\nfunction validate(value, opts) {\n  var valObjectDef = exports.valObjectMeta[opts.valType];\n  if (opts.arrayOk && isArrayOrTypedArray(value)) return true;\n\n  if (valObjectDef.validateFunction) {\n    return valObjectDef.validateFunction(value, opts);\n  }\n\n  var failed = {};\n  var out = failed;\n  var propMock = {\n    set: function (v) {\n      out = v;\n    }\n  }; // 'failed' just something mutable that won't be === anything else\n\n  valObjectDef.coerceFunction(value, propMock, failed, opts);\n  return out !== failed;\n}\n\nexports.validate = validate;","map":null,"metadata":{},"sourceType":"script"}