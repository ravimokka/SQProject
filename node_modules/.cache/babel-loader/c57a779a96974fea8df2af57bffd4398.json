{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"Brush\"] = factory();else root[\"Brush\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * g2-brush\n       * @author sima.zhang1990@gmail.com\n       */\n      var Brush = __webpack_require__(1);\n\n      module.exports = Brush;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * g2-brush\n       * @author sima.zhang1990@gmail.com\n       */\n\n\n      var Util = __webpack_require__(2);\n\n      var BRUSH_TYPES = ['X', 'Y', 'XY', 'POLYGON'];\n\n      var Brush = function () {\n        function Brush(cfg) {\n          _classCallCheck(this, Brush);\n          /**\n           * keep the first mousedown point\n           * @type {object}\n           */\n\n\n          this.startPoint = null;\n          /**\n           * keep the brush state\n           * @type {Boolean}\n           */\n\n          this.brushing = false;\n          /**\n           * keep the drag state\n           * @type {Boolean}\n           */\n\n          this.dragging = false;\n          /**\n           * the brush shape\n           * @type {G.Shape}\n           */\n\n          this.brushShape = null;\n          /**\n           * the brush container\n           * @type {G.Group}\n           */\n\n          this.container = null;\n          /**\n           * keep polygon path\n           * @type {String}\n           */\n\n          this.polygonPath = null;\n          /**\n           * brush style\n           * @type {Object}\n           */\n\n          this.style = {\n            fill: '#C5D4EB',\n            opacity: 0.3,\n            lineWidth: 1,\n            stroke: '#82A6DD'\n          };\n          /**\n           * brush type\n           * @type {string}\n           */\n\n          this.type = 'XY';\n          /**\n           * is brushShape can be dragable, default is false\n           * @type {Boolean}\n           */\n\n          this.dragable = false;\n          this.dragoffX = 0;\n          this.dragoffY = 0;\n          /**\n           * is limited in plot, default value is true\n           * @type {Boolean}\n           */\n\n          this.inPlot = true;\n          /**\n           * xField\n           * @type {string}\n           */\n\n          this.xField = null;\n          /**\n           * yFiels\n           * @type {string}\n           */\n\n          this.yField = null;\n          /**\n           * Whether to filter the data，default is true\n           * @type {Boolean}\n           */\n\n          this.filter = !cfg.dragable;\n          this.onBrushstart = null;\n          this.onBrushmove = null;\n          this.onBrushend = null;\n          this.onDragstart = null;\n          this.onDragmove = null;\n          this.onDragend = null;\n\n          this._init(cfg);\n        }\n\n        Brush.prototype._init = function _init(cfg) {\n          Util.mix(this, cfg);\n          this.type = this.type.toUpperCase();\n\n          if (BRUSH_TYPES.indexOf(this.type) === -1) {\n            this.type = 'XY';\n          }\n\n          var canvas = this.canvas;\n\n          if (canvas) {\n            var plotRange = void 0;\n            canvas.get('children').map(function (child) {\n              if (child.get('type') === 'plotBack') {\n                plotRange = child.get('plotRange');\n                return false;\n              }\n\n              return child;\n            });\n            this.plot = {\n              start: plotRange.bl,\n              end: plotRange.tr\n            };\n            this.bindCanvasEvent();\n          }\n\n          if (this.chart) {\n            var chart = this.chart;\n            var coord = chart.get('coord');\n            this.plot = {\n              start: coord.start,\n              end: coord.end\n            };\n\n            var xScales = chart._getScales('x');\n\n            var yScales = chart._getScales('y');\n\n            this.xScale = this.xField ? xScales[this.xField] : chart.getXScale();\n            this.yScale = this.yField ? yScales[this.yField] : chart.getYScales()[0];\n          }\n        };\n\n        Brush.prototype.clearEvents = function clearEvents() {\n          this.onMouseDownListener && this.onMouseDownListener.remove();\n          this.onMouseMoveListener && this.onMouseMoveListener.remove();\n          this.onMouseupListener && this.onMouseupListener.remove();\n        };\n\n        Brush.prototype.bindCanvasEvent = function bindCanvasEvent() {\n          var canvas = this.canvas;\n          var canvasDOM = canvas.get('canvasDOM');\n          this.clearEvents();\n          this.onMouseDownListener = Util.addEventListener(canvasDOM, 'mousedown', Util.wrapBehavior(this, '_onCanvasMouseDown'));\n          this.onMouseMoveListener = Util.addEventListener(canvasDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));\n          this.onMouseUpListener = Util.addEventListener(canvasDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp'));\n        };\n\n        Brush.prototype._onCanvasMouseDown = function _onCanvasMouseDown(ev) {\n          var me = this;\n          var canvas = me.canvas,\n              type = me.type,\n              brushShape = me.brushShape;\n\n          if (!type) {\n            return;\n          }\n\n          var startPoint = {\n            x: ev.offsetX,\n            y: ev.offsetY\n          };\n          var isInPlot = me.plot && me.inPlot;\n          var canvasDOM = canvas.get('canvasDOM');\n          var pixelRatio = canvas.get('pixelRatio');\n\n          if (me.selection) {\n            me.selection = null;\n          }\n\n          if (me.dragable && brushShape && !brushShape.get('destroyed')) {\n            // allow drag the brushShape\n            if (brushShape.isHit(startPoint.x * pixelRatio, startPoint.y * pixelRatio)) {\n              canvasDOM.style.cursor = 'move';\n              me.selection = brushShape;\n              me.dragging = true;\n\n              if (type === 'X') {\n                me.dragoffX = startPoint.x - brushShape.attr('x');\n                me.dragoffY = 0;\n              } else if (type === 'Y') {\n                me.dragoffX = 0;\n                me.dragoffY = startPoint.y - brushShape.attr('y');\n              } else if (type === 'XY') {\n                me.dragoffX = startPoint.x - brushShape.attr('x');\n                me.dragoffY = startPoint.y - brushShape.attr('y');\n              } else if (type === 'POLYGON') {\n                var box = brushShape.getBBox();\n                me.dragoffX = startPoint.x - box.minX;\n                me.dragoffY = startPoint.y - box.minY;\n              }\n\n              if (isInPlot) {\n                me.selection.attr('clip', canvas.addShape('rect', {\n                  attrs: {\n                    x: this.plot.start.x,\n                    y: this.plot.end.y,\n                    width: this.plot.end.x - this.plot.start.x,\n                    height: this.plot.start.y - this.plot.end.y,\n                    fill: '#fff',\n                    fillOpacity: 0\n                  }\n                }));\n              }\n\n              me.onDragstart && me.onDragstart(ev);\n            }\n\n            me.prePoint = startPoint;\n          }\n\n          if (!me.dragging) {\n            // brush start\n            me.onBrushstart && me.onBrushstart(startPoint);\n            var container = me.container;\n\n            if (isInPlot) {\n              var _me$plot = me.plot,\n                  start = _me$plot.start,\n                  end = _me$plot.end;\n\n              if (startPoint.x < start.x || startPoint.x > end.x || startPoint.y < end.y || startPoint.y > start.y) {\n                return;\n              }\n            }\n\n            canvasDOM.style.cursor = 'crosshair';\n            me.startPoint = startPoint;\n            me.brushShape = null;\n            me.brushing = true;\n\n            if (!container) {\n              container = canvas.addGroup({\n                zIndex: 5 // upper\n\n              });\n              container.initTransform();\n            } else {\n              container.clear();\n            }\n\n            me.container = container;\n\n            if (type === 'POLYGON') {\n              me.polygonPath = 'M ' + startPoint.x + ' ' + startPoint.y;\n            }\n          }\n        };\n\n        Brush.prototype._onCanvasMouseMove = function _onCanvasMouseMove(ev) {\n          var me = this;\n          var brushing = me.brushing,\n              dragging = me.dragging,\n              type = me.type,\n              plot = me.plot,\n              startPoint = me.startPoint,\n              xScale = me.xScale,\n              yScale = me.yScale,\n              canvas = me.canvas;\n\n          if (!brushing && !dragging) {\n            return;\n          }\n\n          var currentPoint = {\n            x: ev.offsetX,\n            y: ev.offsetY\n          };\n          var canvasDOM = canvas.get('canvasDOM');\n\n          if (brushing) {\n            canvasDOM.style.cursor = 'crosshair';\n            var start = plot.start,\n                end = plot.end;\n            var polygonPath = me.polygonPath;\n            var brushShape = me.brushShape;\n            var container = me.container;\n\n            if (me.plot && me.inPlot) {\n              currentPoint = me._limitCoordScope(currentPoint);\n            }\n\n            var rectStartX = void 0;\n            var rectStartY = void 0;\n            var rectWidth = void 0;\n            var rectHeight = void 0;\n\n            if (type === 'Y') {\n              rectStartX = start.x;\n              rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;\n              rectWidth = Math.abs(start.x - end.x);\n              rectHeight = Math.abs(startPoint.y - currentPoint.y);\n            } else if (type === 'X') {\n              rectStartX = currentPoint.x >= startPoint.x ? startPoint.x : currentPoint.x;\n              rectStartY = end.y;\n              rectWidth = Math.abs(startPoint.x - currentPoint.x);\n              rectHeight = Math.abs(end.y - start.y);\n            } else if (type === 'XY') {\n              if (currentPoint.x >= startPoint.x) {\n                rectStartX = startPoint.x;\n                rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;\n              } else {\n                rectStartX = currentPoint.x;\n                rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;\n              }\n\n              rectWidth = Math.abs(startPoint.x - currentPoint.x);\n              rectHeight = Math.abs(startPoint.y - currentPoint.y);\n            } else if (type === 'POLYGON') {\n              polygonPath += 'L ' + currentPoint.x + ' ' + currentPoint.y;\n              me.polygonPath = polygonPath;\n\n              if (!brushShape) {\n                brushShape = container.addShape('path', {\n                  attrs: Util.mix(me.style, {\n                    path: polygonPath\n                  })\n                });\n              } else {\n                !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape.__attrs, {\n                  path: polygonPath\n                }));\n              }\n            }\n\n            if (type !== 'POLYGON') {\n              if (!brushShape) {\n                brushShape = container.addShape('rect', {\n                  attrs: Util.mix(me.style, {\n                    x: rectStartX,\n                    y: rectStartY,\n                    width: rectWidth,\n                    height: rectHeight\n                  })\n                });\n              } else {\n                !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape.__attrs, {\n                  x: rectStartX,\n                  y: rectStartY,\n                  width: rectWidth,\n                  height: rectHeight\n                }));\n              }\n            }\n\n            me.brushShape = brushShape;\n          } else if (dragging) {\n            canvasDOM.style.cursor = 'move';\n            var selection = me.selection;\n\n            if (selection && !selection.get('destroyed')) {\n              if (type === 'POLYGON') {\n                var prePoint = me.prePoint;\n                me.selection.translate(currentPoint.x - prePoint.x, currentPoint.y - prePoint.y);\n              } else {\n                me.dragoffX && selection.attr('x', currentPoint.x - me.dragoffX);\n                me.dragoffY && selection.attr('y', currentPoint.y - me.dragoffY);\n              }\n            }\n          }\n\n          me.prePoint = currentPoint;\n          canvas.draw();\n\n          var _me$_getSelected = me._getSelected(),\n              data = _me$_getSelected.data,\n              shapes = _me$_getSelected.shapes,\n              xValues = _me$_getSelected.xValues,\n              yValues = _me$_getSelected.yValues;\n\n          var eventObj = {\n            data: data,\n            shapes: shapes,\n            x: currentPoint.x,\n            y: currentPoint.y\n          };\n\n          if (xScale) {\n            eventObj[xScale.field] = xValues;\n          }\n\n          if (yScale) {\n            eventObj[yScale.field] = yValues;\n          }\n\n          me.onDragmove && me.onDragmove(eventObj);\n          me.onBrushmove && me.onBrushmove(eventObj);\n        };\n\n        Brush.prototype._onCanvasMouseUp = function _onCanvasMouseUp(ev) {\n          var me = this;\n          var data = me.data,\n              shapes = me.shapes,\n              xValues = me.xValues,\n              yValues = me.yValues,\n              canvas = me.canvas,\n              type = me.type,\n              startPoint = me.startPoint,\n              chart = me.chart,\n              container = me.container,\n              xScale = me.xScale,\n              yScale = me.yScale;\n          var offsetX = ev.offsetX,\n              offsetY = ev.offsetY;\n          var canvasDOM = canvas.get('canvasDOM');\n          canvasDOM.style.cursor = 'default';\n\n          if (Math.abs(startPoint.x - offsetX) <= 1 && Math.abs(startPoint.y - offsetY) <= 1) {\n            // 防止点击事件\n            me.brushing = false;\n            me.dragging = false;\n            return;\n          }\n\n          var eventObj = {\n            data: data,\n            shapes: shapes,\n            x: offsetX,\n            y: offsetY\n          };\n\n          if (xScale) {\n            eventObj[xScale.field] = xValues;\n          }\n\n          if (yScale) {\n            eventObj[yScale.field] = yValues;\n          }\n\n          if (me.dragging) {\n            me.dragging = false;\n            me.onDragend && me.onDragend(eventObj);\n          } else if (me.brushing) {\n            me.brushing = false;\n            var brushShape = me.brushShape;\n            var polygonPath = me.polygonPath;\n\n            if (type === 'POLYGON') {\n              polygonPath += 'z';\n              brushShape && !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape.__attrs, {\n                path: polygonPath\n              }));\n              me.polygonPath = polygonPath;\n              canvas.draw();\n            }\n\n            if (me.onBrushend) {\n              me.onBrushend(eventObj);\n            } else if (chart && me.filter) {\n              container.clear(); // clear the brush\n              // filter data\n\n              if (type === 'X') {\n                xScale && chart.filter(xScale.field, function (val) {\n                  return xValues.indexOf(val) > -1;\n                });\n              } else if (type === 'Y') {\n                yScale && chart.filter(yScale.field, function (val) {\n                  return yValues.indexOf(val) > -1;\n                });\n              } else {\n                xScale && chart.filter(xScale.field, function (val) {\n                  return xValues.indexOf(val) > -1;\n                });\n                yScale && chart.filter(yScale.field, function (val) {\n                  return yValues.indexOf(val) > -1;\n                });\n              }\n\n              chart.repaint();\n            }\n          }\n        };\n\n        Brush.prototype.setType = function setType(type) {\n          if (!type) {\n            return;\n          }\n\n          this.type = type.toUpperCase();\n        };\n\n        Brush.prototype.destroy = function destroy() {\n          this.clearEvents();\n        };\n\n        Brush.prototype._limitCoordScope = function _limitCoordScope(point) {\n          var plot = this.plot;\n          var start = plot.start,\n              end = plot.end;\n\n          if (point.x < start.x) {\n            point.x = start.x;\n          }\n\n          if (point.x > end.x) {\n            point.x = end.x;\n          }\n\n          if (point.y < end.y) {\n            point.y = end.y;\n          }\n\n          if (point.y > start.y) {\n            point.y = start.y;\n          }\n\n          return point;\n        };\n\n        Brush.prototype._getSelected = function _getSelected() {\n          var chart = this.chart,\n              xScale = this.xScale,\n              yScale = this.yScale,\n              brushShape = this.brushShape,\n              canvas = this.canvas;\n          var pixelRatio = canvas.get('pixelRatio');\n          var selectedShapes = [];\n          var xValues = [];\n          var yValues = [];\n          var selectedData = [];\n\n          if (chart) {\n            var geoms = chart.get('geoms');\n            geoms.map(function (geom) {\n              var shapes = geom.getShapes();\n              shapes.map(function (shape) {\n                var shapeData = shape.get('origin');\n\n                if (!Array.isArray(shapeData)) {\n                  // 线图、区域图等\n                  shapeData = [shapeData];\n                }\n\n                shapeData.map(function (each) {\n                  if (brushShape.isHit(each.x * pixelRatio, each.y * pixelRatio)) {\n                    selectedShapes.push(shape);\n                    var origin = each._origin;\n                    selectedData.push(origin);\n                    xScale && xValues.push(origin[xScale.field]);\n                    yScale && yValues.push(origin[yScale.field]);\n                  }\n\n                  return each;\n                });\n                return shape;\n              });\n              return geom;\n            });\n          }\n\n          this.shapes = selectedShapes;\n          this.xValues = xValues;\n          this.yValues = yValues;\n          this.data = selectedData;\n          return {\n            data: selectedData,\n            xValues: xValues,\n            yValues: yValues,\n            shapes: selectedShapes\n          };\n        };\n\n        return Brush;\n      }();\n\n      module.exports = Brush;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      function _mix(dist, obj) {\n        for (var k in obj) {\n          if (obj.hasOwnProperty(k) && k !== 'constructor' && obj[k] !== undefined) {\n            dist[k] = obj[k];\n          }\n        }\n      }\n\n      var Util = {\n        mix: function mix(dist, obj1, obj2, obj3) {\n          if (obj1) {\n            _mix(dist, obj1);\n          }\n\n          if (obj2) {\n            _mix(dist, obj2);\n          }\n\n          if (obj3) {\n            _mix(dist, obj3);\n          }\n\n          return dist;\n        },\n\n        /**\n         * 添加事件监听器\n         * @param  {Object} target DOM对象\n         * @param  {String} eventType 事件名\n         * @param  {Funtion} callback 回调函数\n         * @return {Object} 返回对象\n         */\n        addEventListener: function addEventListener(target, eventType, callback) {\n          if (target.addEventListener) {\n            target.addEventListener(eventType, callback, false);\n            return {\n              remove: function remove() {\n                target.removeEventListener(eventType, callback, false);\n              }\n            };\n          } else if (target.attachEvent) {\n            target.attachEvent('on' + eventType, callback);\n            return {\n              remove: function remove() {\n                target.detachEvent('on' + eventType, callback);\n              }\n            };\n          }\n        },\n\n        /**\n         * 封装事件，便于使用上下文this,和便于解除事件时使用\n         * @protected\n         * @param  {Object} obj   对象\n         * @param  {String} action 事件名称\n         * @return {Function}        返回事件处理函数\n         */\n        wrapBehavior: function wrapBehavior(obj, action) {\n          if (obj['_wrap_' + action]) {\n            return obj['_wrap_' + action];\n          }\n\n          var method = function method(e) {\n            obj[action](e);\n          };\n\n          obj['_wrap_' + action] = method;\n          return method;\n        },\n\n        /**\n         * 获取封装的事件\n         * @protected\n         * @param  {Object} obj   对象\n         * @param  {String} action 事件名称\n         * @return {Function}        返回事件处理函数\n         */\n        getWrapBehavior: function getWrapBehavior(obj, action) {\n          return obj['_wrap_' + action];\n        }\n      };\n      module.exports = Util;\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}