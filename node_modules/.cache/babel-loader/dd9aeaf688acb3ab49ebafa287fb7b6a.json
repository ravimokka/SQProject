{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n/* global MathJax:false */\n\nvar d3 = require('d3');\n\nvar Lib = require('../lib');\n\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\n\nvar LINE_SPACING = require('../constants/alignment').LINE_SPACING; // text converter\n\n\nfunction getSize(_selection, _dimension) {\n  return _selection.node().getBoundingClientRect()[_dimension];\n}\n\nvar FIND_TEX = /([^$]*)([$]+[^$]*[$]+)([^$]*)/;\n\nexports.convertToTspans = function (_context, gd, _callback) {\n  var str = _context.text(); // Until we get tex integrated more fully (so it can be used along with non-tex)\n  // allow some elements to prohibit it by attaching 'data-notex' to the original\n\n\n  var tex = !_context.attr('data-notex') && typeof MathJax !== 'undefined' && str.match(FIND_TEX);\n  var parent = d3.select(_context.node().parentNode);\n  if (parent.empty()) return;\n  var svgClass = _context.attr('class') ? _context.attr('class').split(' ')[0] : 'text';\n  svgClass += '-math';\n  parent.selectAll('svg.' + svgClass).remove();\n  parent.selectAll('g.' + svgClass + '-group').remove();\n\n  _context.style('display', null).attr({\n    // some callers use data-unformatted *from the <text> element* in 'cancel'\n    // so we need it here even if we're going to turn it into math\n    // these two (plus style and text-anchor attributes) form the key we're\n    // going to use for Drawing.bBox\n    'data-unformatted': str,\n    'data-math': 'N'\n  });\n\n  function showText() {\n    if (!parent.empty()) {\n      svgClass = _context.attr('class') + '-math';\n      parent.select('svg.' + svgClass).remove();\n    }\n\n    _context.text('').style('white-space', 'pre');\n\n    var hasLink = buildSVGText(_context.node(), str);\n\n    if (hasLink) {\n      // at least in Chrome, pointer-events does not seem\n      // to be honored in children of <text> elements\n      // so if we have an anchor, we have to make the\n      // whole element respond\n      _context.style('pointer-events', 'all');\n    }\n\n    exports.positionText(_context);\n    if (_callback) _callback.call(_context);\n  }\n\n  if (tex) {\n    (gd && gd._promises || []).push(new Promise(function (resolve) {\n      _context.style('display', 'none');\n\n      var fontSize = parseInt(_context.node().style.fontSize, 10);\n      var config = {\n        fontSize: fontSize\n      };\n      texToSVG(tex[2], config, function (_svgEl, _glyphDefs, _svgBBox) {\n        parent.selectAll('svg.' + svgClass).remove();\n        parent.selectAll('g.' + svgClass + '-group').remove();\n\n        var newSvg = _svgEl && _svgEl.select('svg');\n\n        if (!newSvg || !newSvg.node()) {\n          showText();\n          resolve();\n          return;\n        }\n\n        var mathjaxGroup = parent.append('g').classed(svgClass + '-group', true).attr({\n          'pointer-events': 'none',\n          'data-unformatted': str,\n          'data-math': 'Y'\n        });\n        mathjaxGroup.node().appendChild(newSvg.node()); // stitch the glyph defs\n\n        if (_glyphDefs && _glyphDefs.node()) {\n          newSvg.node().insertBefore(_glyphDefs.node().cloneNode(true), newSvg.node().firstChild);\n        }\n\n        newSvg.attr({\n          'class': svgClass,\n          height: _svgBBox.height,\n          preserveAspectRatio: 'xMinYMin meet'\n        }).style({\n          overflow: 'visible',\n          'pointer-events': 'none'\n        });\n        var fill = _context.node().style.fill || 'black';\n        var g = newSvg.select('g');\n        g.attr({\n          fill: fill,\n          stroke: fill\n        });\n        var newSvgW = getSize(g, 'width');\n        var newSvgH = getSize(g, 'height');\n        var newX = +_context.attr('x') - newSvgW * {\n          start: 0,\n          middle: 0.5,\n          end: 1\n        }[_context.attr('text-anchor') || 'start']; // font baseline is about 1/4 fontSize below centerline\n\n        var textHeight = fontSize || getSize(_context, 'height');\n        var dy = -textHeight / 4;\n\n        if (svgClass[0] === 'y') {\n          mathjaxGroup.attr({\n            transform: 'rotate(' + [-90, +_context.attr('x'), +_context.attr('y')] + ') translate(' + [-newSvgW / 2, dy - newSvgH / 2] + ')'\n          });\n          newSvg.attr({\n            x: +_context.attr('x'),\n            y: +_context.attr('y')\n          });\n        } else if (svgClass[0] === 'l') {\n          newSvg.attr({\n            x: _context.attr('x'),\n            y: dy - newSvgH / 2\n          });\n        } else if (svgClass[0] === 'a' && svgClass.indexOf('atitle') !== 0) {\n          newSvg.attr({\n            x: 0,\n            y: dy\n          });\n        } else {\n          newSvg.attr({\n            x: newX,\n            y: +_context.attr('y') + dy - newSvgH / 2\n          });\n        }\n\n        if (_callback) _callback.call(_context, mathjaxGroup);\n        resolve(mathjaxGroup);\n      });\n    }));\n  } else showText();\n\n  return _context;\n}; // MathJax\n\n\nvar LT_MATCH = /(<|&lt;|&#60;)/g;\nvar GT_MATCH = /(>|&gt;|&#62;)/g;\n\nfunction cleanEscapesForTex(s) {\n  return s.replace(LT_MATCH, '\\\\lt ').replace(GT_MATCH, '\\\\gt ');\n}\n\nfunction texToSVG(_texString, _config, _callback) {\n  var originalRenderer, originalConfig, originalProcessSectionDelay, tmpDiv;\n  MathJax.Hub.Queue(function () {\n    originalConfig = Lib.extendDeepAll({}, MathJax.Hub.config);\n    originalProcessSectionDelay = MathJax.Hub.processSectionDelay;\n\n    if (MathJax.Hub.processSectionDelay !== undefined) {\n      // MathJax 2.5+\n      MathJax.Hub.processSectionDelay = 0;\n    }\n\n    return MathJax.Hub.Config({\n      messageStyle: 'none',\n      tex2jax: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      displayAlign: 'left'\n    });\n  }, function () {\n    // Get original renderer\n    originalRenderer = MathJax.Hub.config.menuSettings.renderer;\n\n    if (originalRenderer !== 'SVG') {\n      return MathJax.Hub.setRenderer('SVG');\n    }\n  }, function () {\n    var randomID = 'math-output-' + Lib.randstr({}, 64);\n    tmpDiv = d3.select('body').append('div').attr({\n      id: randomID\n    }).style({\n      visibility: 'hidden',\n      position: 'absolute'\n    }).style({\n      'font-size': _config.fontSize + 'px'\n    }).text(cleanEscapesForTex(_texString));\n    return MathJax.Hub.Typeset(tmpDiv.node());\n  }, function () {\n    var glyphDefs = d3.select('body').select('#MathJax_SVG_glyphs');\n\n    if (tmpDiv.select('.MathJax_SVG').empty() || !tmpDiv.select('svg').node()) {\n      Lib.log('There was an error in the tex syntax.', _texString);\n\n      _callback();\n    } else {\n      var svgBBox = tmpDiv.select('svg').node().getBoundingClientRect();\n\n      _callback(tmpDiv.select('.MathJax_SVG'), glyphDefs, svgBBox);\n    }\n\n    tmpDiv.remove();\n\n    if (originalRenderer !== 'SVG') {\n      return MathJax.Hub.setRenderer(originalRenderer);\n    }\n  }, function () {\n    if (originalProcessSectionDelay !== undefined) {\n      MathJax.Hub.processSectionDelay = originalProcessSectionDelay;\n    }\n\n    return MathJax.Hub.Config(originalConfig);\n  });\n}\n\nvar TAG_STYLES = {\n  // would like to use baseline-shift for sub/sup but FF doesn't support it\n  // so we need to use dy along with the uber hacky shift-back-to\n  // baseline below\n  sup: 'font-size:70%',\n  sub: 'font-size:70%',\n  b: 'font-weight:bold',\n  i: 'font-style:italic',\n  a: 'cursor:pointer',\n  span: '',\n  em: 'font-style:italic;font-weight:bold'\n}; // baseline shifts for sub and sup\n\nvar SHIFT_DY = {\n  sub: '0.3em',\n  sup: '-0.6em'\n}; // reset baseline by adding a tspan (empty except for a zero-width space)\n// with dy of -70% * SHIFT_DY (because font-size=70%)\n\nvar RESET_DY = {\n  sub: '-0.21em',\n  sup: '0.42em'\n};\nvar ZERO_WIDTH_SPACE = '\\u200b';\n/*\n * Whitelist of protocols in user-supplied urls. Mostly we want to avoid javascript\n * and related attack vectors. The empty items are there for IE, that in various\n * versions treats relative paths as having different flavors of no protocol, while\n * other browsers have these explicitly inherit the protocol of the page they're in.\n */\n\nvar PROTOCOLS = ['http:', 'https:', 'mailto:', '', undefined, ':'];\nvar NEWLINES = exports.NEWLINES = /(\\r\\n?|\\n)/g;\nvar SPLIT_TAGS = /(<[^<>]*>)/;\nvar ONE_TAG = /<(\\/?)([^ >]*)(\\s+(.*))?>/i;\nvar BR_TAG = /<br(\\s+.*)?>/i;\nexports.BR_TAG_ALL = /<br(\\s+.*)?>/gi;\n/*\n * style and href: pull them out of either single or double quotes. Also\n * - target: (_blank|_self|_parent|_top|framename)\n *     note that you can't use target to get a popup but if you use popup,\n *     a `framename` will be passed along as the name of the popup window.\n *     per the spec, cannot contain whitespace.\n *     for backward compatibility we default to '_blank'\n * - popup: a custom one for us to enable popup (new window) links. String\n *     for window.open -> strWindowFeatures, like 'menubar=yes,width=500,height=550'\n *     note that at least in Chrome, you need to give at least one property\n *     in this string or the page will open in a new tab anyway. We follow this\n *     convention and will not make a popup if this string is empty.\n *     per the spec, cannot contain whitespace.\n *\n * Because we hack in other attributes with style (sub & sup), drop any trailing\n * semicolon in user-supplied styles so we can consistently append the tag-dependent style\n *\n * These are for tag attributes; Chrome anyway will convert entities in\n * attribute values, but not in attribute names\n * you can test this by for example:\n * > p = document.createElement('p')\n * > p.innerHTML = '<span styl&#x65;=\"font-color:r&#x65;d;\">Hi</span>'\n * > p.innerHTML\n * <- '<span styl&#x65;=\"font-color:red;\">Hi</span>'\n */\n\nvar STYLEMATCH = /(^|[\\s\"'])style\\s*=\\s*(\"([^\"]*);?\"|'([^']*);?')/i;\nvar HREFMATCH = /(^|[\\s\"'])href\\s*=\\s*(\"([^\"]*)\"|'([^']*)')/i;\nvar TARGETMATCH = /(^|[\\s\"'])target\\s*=\\s*(\"([^\"\\s]*)\"|'([^'\\s]*)')/i;\nvar POPUPMATCH = /(^|[\\s\"'])popup\\s*=\\s*(\"([\\w=,]*)\"|'([\\w=,]*)')/i; // dedicated matcher for these quoted regexes, that can return their results\n// in two different places\n\nfunction getQuotedMatch(_str, re) {\n  if (!_str) return null;\n\n  var match = _str.match(re);\n\n  var result = match && (match[3] || match[4]);\n  return result && convertEntities(result);\n}\n\nvar COLORMATCH = /(^|;)\\s*color:/;\n/**\n * Strip string of tags\n *\n * @param {string} _str : input string\n * @param {object} opts :\n * - len {number} max length of output string\n * - allowedTags {array} list of pseudo-html tags to NOT strip\n * @return {string}\n */\n\nexports.plainText = function (_str, opts) {\n  opts = opts || {};\n  var len = opts.len !== undefined && opts.len !== -1 ? opts.len : Infinity;\n  var allowedTags = opts.allowedTags !== undefined ? opts.allowedTags : ['br'];\n  var ellipsis = '...';\n  var eLen = ellipsis.length;\n\n  var oldParts = _str.split(SPLIT_TAGS);\n\n  var newParts = [];\n  var prevTag = '';\n  var l = 0;\n\n  for (var i = 0; i < oldParts.length; i++) {\n    var p = oldParts[i];\n    var match = p.match(ONE_TAG);\n    var tagType = match && match[2].toLowerCase();\n\n    if (tagType) {\n      // N.B. tags do not count towards string length\n      if (allowedTags.indexOf(tagType) !== -1) {\n        newParts.push(p);\n        prevTag = tagType;\n      }\n    } else {\n      var pLen = p.length;\n\n      if (l + pLen < len) {\n        newParts.push(p);\n        l += pLen;\n      } else if (l < len) {\n        var pLen2 = len - l;\n\n        if (prevTag && (prevTag !== 'br' || pLen2 <= eLen || pLen <= eLen)) {\n          newParts.pop();\n        }\n\n        if (len > eLen) {\n          newParts.push(p.substr(0, pLen2 - eLen) + ellipsis);\n        } else {\n          newParts.push(p.substr(0, pLen2));\n        }\n\n        break;\n      }\n\n      prevTag = '';\n    }\n  }\n\n  return newParts.join('');\n};\n/*\n * N.B. HTML entities are listed without the leading '&' and trailing ';'\n * https://www.freeformatter.com/html-entities.html\n *\n * FWIW if we wanted to support the full set, it has 2261 entries:\n * https://www.w3.org/TR/html5/entities.json\n * though I notice that some of these are duplicates and/or are missing \";\"\n * eg: \"&amp;\", \"&amp\", \"&AMP;\", and \"&AMP\" all map to \"&\"\n * We no longer need to include numeric entities here, these are now handled\n * by String.fromCodePoint/fromCharCode\n *\n * Anyway the only ones that are really important to allow are the HTML special\n * chars <, >, and &, because these ones can trigger special processing if not\n * replaced by the corresponding entity.\n */\n\n\nvar entityToUnicode = {\n  mu: 'μ',\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  nbsp: ' ',\n  times: '×',\n  plusmn: '±',\n  deg: '°'\n}; // NOTE: in general entities can contain uppercase too (so [a-zA-Z]) but all the\n// ones we support use only lowercase. If we ever change that, update the regex.\n\nvar ENTITY_MATCH = /&(#\\d+|#x[\\da-fA-F]+|[a-z]+);/g;\n\nfunction convertEntities(_str) {\n  return _str.replace(ENTITY_MATCH, function (fullMatch, innerMatch) {\n    var outChar;\n\n    if (innerMatch.charAt(0) === '#') {\n      // cannot use String.fromCodePoint in IE\n      outChar = fromCodePoint(innerMatch.charAt(1) === 'x' ? parseInt(innerMatch.substr(2), 16) : parseInt(innerMatch.substr(1), 10));\n    } else outChar = entityToUnicode[innerMatch]; // as in regular HTML, if we didn't decode the entity just\n    // leave the raw text in place.\n\n\n    return outChar || fullMatch;\n  });\n}\n\nexports.convertEntities = convertEntities;\n\nfunction fromCodePoint(code) {\n  // Don't allow overflow. In Chrome this turns into � but I feel like it's\n  // more useful to just not convert it at all.\n  if (code > 0x10FFFF) return;\n  var stringFromCodePoint = String.fromCodePoint;\n  if (stringFromCodePoint) return stringFromCodePoint(code); // IE doesn't have String.fromCodePoint\n  // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint\n\n  var stringFromCharCode = String.fromCharCode;\n  if (code <= 0xFFFF) return stringFromCharCode(code);\n  return stringFromCharCode((code >> 10) + 0xD7C0, code % 0x400 + 0xDC00);\n}\n/*\n * buildSVGText: convert our pseudo-html into SVG tspan elements, and attach these\n * to containerNode\n *\n * @param {svg text element} containerNode: the <text> node to insert this text into\n * @param {string} str: the pseudo-html string to convert to svg\n *\n * @returns {bool}: does the result contain any links? We need to handle the text element\n *   somewhat differently if it does, so just keep track of this when it happens.\n */\n\n\nfunction buildSVGText(containerNode, str) {\n  /*\n   * Normalize behavior between IE and others wrt newlines and whitespace:pre\n   * this combination makes IE barf https://github.com/plotly/plotly.js/issues/746\n   * Chrome and FF display \\n, \\r, or \\r\\n as a space in this mode.\n   * I feel like at some point we turned these into <br> but currently we don't so\n   * I'm just going to cement what we do now in Chrome and FF\n   */\n  str = str.replace(NEWLINES, ' ');\n  var hasLink = false; // as we're building the text, keep track of what elements we're nested inside\n  // nodeStack will be an array of {node, type, style, href, target, popup}\n  // where only type: 'a' gets the last 3 and node is only added when it's created\n\n  var nodeStack = [];\n  var currentNode;\n  var currentLine = -1;\n\n  function newLine() {\n    currentLine++;\n    var lineNode = document.createElementNS(xmlnsNamespaces.svg, 'tspan');\n    d3.select(lineNode).attr({\n      class: 'line',\n      dy: currentLine * LINE_SPACING + 'em'\n    });\n    containerNode.appendChild(lineNode);\n    currentNode = lineNode;\n    var oldNodeStack = nodeStack;\n    nodeStack = [{\n      node: lineNode\n    }];\n\n    if (oldNodeStack.length > 1) {\n      for (var i = 1; i < oldNodeStack.length; i++) {\n        enterNode(oldNodeStack[i]);\n      }\n    }\n  }\n\n  function enterNode(nodeSpec) {\n    var type = nodeSpec.type;\n    var nodeAttrs = {};\n    var nodeType;\n\n    if (type === 'a') {\n      nodeType = 'a';\n      var target = nodeSpec.target;\n      var href = nodeSpec.href;\n      var popup = nodeSpec.popup;\n\n      if (href) {\n        nodeAttrs = {\n          'xlink:xlink:show': target === '_blank' || target.charAt(0) !== '_' ? 'new' : 'replace',\n          target: target,\n          'xlink:xlink:href': href\n        };\n\n        if (popup) {\n          // security: href and target are not inserted as code but\n          // as attributes. popup is, but limited to /[A-Za-z0-9_=,]/\n          nodeAttrs.onclick = 'window.open(this.href.baseVal,this.target.baseVal,\"' + popup + '\");return false;';\n        }\n      }\n    } else nodeType = 'tspan';\n\n    if (nodeSpec.style) nodeAttrs.style = nodeSpec.style;\n    var newNode = document.createElementNS(xmlnsNamespaces.svg, nodeType);\n\n    if (type === 'sup' || type === 'sub') {\n      addTextNode(currentNode, ZERO_WIDTH_SPACE);\n      currentNode.appendChild(newNode);\n      var resetter = document.createElementNS(xmlnsNamespaces.svg, 'tspan');\n      addTextNode(resetter, ZERO_WIDTH_SPACE);\n      d3.select(resetter).attr('dy', RESET_DY[type]);\n      nodeAttrs.dy = SHIFT_DY[type];\n      currentNode.appendChild(newNode);\n      currentNode.appendChild(resetter);\n    } else {\n      currentNode.appendChild(newNode);\n    }\n\n    d3.select(newNode).attr(nodeAttrs);\n    currentNode = nodeSpec.node = newNode;\n    nodeStack.push(nodeSpec);\n  }\n\n  function addTextNode(node, text) {\n    node.appendChild(document.createTextNode(text));\n  }\n\n  function exitNode(type) {\n    // A bare closing tag can't close the root node. If we encounter this it\n    // means there's an extra closing tag that can just be ignored:\n    if (nodeStack.length === 1) {\n      Lib.log('Ignoring unexpected end tag </' + type + '>.', str);\n      return;\n    }\n\n    var innerNode = nodeStack.pop();\n\n    if (type !== innerNode.type) {\n      Lib.log('Start tag <' + innerNode.type + '> doesnt match end tag <' + type + '>. Pretending it did match.', str);\n    }\n\n    currentNode = nodeStack[nodeStack.length - 1].node;\n  }\n\n  var hasLines = BR_TAG.test(str);\n  if (hasLines) newLine();else {\n    currentNode = containerNode;\n    nodeStack = [{\n      node: containerNode\n    }];\n  }\n  var parts = str.split(SPLIT_TAGS);\n\n  for (var i = 0; i < parts.length; i++) {\n    var parti = parts[i];\n    var match = parti.match(ONE_TAG);\n    var tagType = match && match[2].toLowerCase();\n    var tagStyle = TAG_STYLES[tagType];\n\n    if (tagType === 'br') {\n      newLine();\n    } else if (tagStyle === undefined) {\n      addTextNode(currentNode, convertEntities(parti));\n    } else {\n      // tag - open or close\n      if (match[1]) {\n        exitNode(tagType);\n      } else {\n        var extra = match[4];\n        var nodeSpec = {\n          type: tagType\n        }; // now add style, from both the tag name and any extra css\n        // Most of the svg css that users will care about is just like html,\n        // but font color is different (uses fill). Let our users ignore this.\n\n        var css = getQuotedMatch(extra, STYLEMATCH);\n\n        if (css) {\n          css = css.replace(COLORMATCH, '$1 fill:');\n          if (tagStyle) css += ';' + tagStyle;\n        } else if (tagStyle) css = tagStyle;\n\n        if (css) nodeSpec.style = css;\n\n        if (tagType === 'a') {\n          hasLink = true;\n          var href = getQuotedMatch(extra, HREFMATCH);\n\n          if (href) {\n            // check safe protocols\n            var dummyAnchor = document.createElement('a');\n            dummyAnchor.href = href;\n\n            if (PROTOCOLS.indexOf(dummyAnchor.protocol) !== -1) {\n              // Decode href to allow both already encoded and not encoded\n              // URIs. Without decoding prior encoding, an already encoded\n              // URI would be encoded twice producing a semantically different URI.\n              nodeSpec.href = encodeURI(decodeURI(href));\n              nodeSpec.target = getQuotedMatch(extra, TARGETMATCH) || '_blank';\n              nodeSpec.popup = getQuotedMatch(extra, POPUPMATCH);\n            }\n          }\n        }\n\n        enterNode(nodeSpec);\n      }\n    }\n  }\n\n  return hasLink;\n}\n\nexports.lineCount = function lineCount(s) {\n  return s.selectAll('tspan.line').size() || 1;\n};\n\nexports.positionText = function positionText(s, x, y) {\n  return s.each(function () {\n    var text = d3.select(this);\n\n    function setOrGet(attr, val) {\n      if (val === undefined) {\n        val = text.attr(attr);\n\n        if (val === null) {\n          text.attr(attr, 0);\n          val = 0;\n        }\n      } else text.attr(attr, val);\n\n      return val;\n    }\n\n    var thisX = setOrGet('x', x);\n    var thisY = setOrGet('y', y);\n\n    if (this.nodeName === 'text') {\n      text.selectAll('tspan.line').attr({\n        x: thisX,\n        y: thisY\n      });\n    }\n  });\n};\n\nfunction alignHTMLWith(_base, container, options) {\n  var alignH = options.horizontalAlign;\n  var alignV = options.verticalAlign || 'top';\n\n  var bRect = _base.node().getBoundingClientRect();\n\n  var cRect = container.node().getBoundingClientRect();\n  var thisRect;\n  var getTop;\n  var getLeft;\n\n  if (alignV === 'bottom') {\n    getTop = function () {\n      return bRect.bottom - thisRect.height;\n    };\n  } else if (alignV === 'middle') {\n    getTop = function () {\n      return bRect.top + (bRect.height - thisRect.height) / 2;\n    };\n  } else {\n    // default: top\n    getTop = function () {\n      return bRect.top;\n    };\n  }\n\n  if (alignH === 'right') {\n    getLeft = function () {\n      return bRect.right - thisRect.width;\n    };\n  } else if (alignH === 'center') {\n    getLeft = function () {\n      return bRect.left + (bRect.width - thisRect.width) / 2;\n    };\n  } else {\n    // default: left\n    getLeft = function () {\n      return bRect.left;\n    };\n  }\n\n  return function () {\n    thisRect = this.node().getBoundingClientRect();\n    this.style({\n      top: getTop() - cRect.top + 'px',\n      left: getLeft() - cRect.left + 'px',\n      'z-index': 1000\n    });\n    return this;\n  };\n}\n/*\n * Editable title\n * @param {d3.selection} context: the element being edited. Normally text,\n *   but if it isn't, you should provide the styling options\n * @param {object} options:\n *   @param {div} options.gd: graphDiv\n *   @param {d3.selection} options.delegate: item to bind events to if not this\n *   @param {boolean} options.immediate: start editing now (true) or on click (false, default)\n *   @param {string} options.fill: font color if not as shown\n *   @param {string} options.background: background color if not as shown\n *   @param {string} options.text: initial text, if not as shown\n *   @param {string} options.horizontalAlign: alignment of the edit box wrt. the bound element\n *   @param {string} options.verticalAlign: alignment of the edit box wrt. the bound element\n */\n\n\nexports.makeEditable = function (context, options) {\n  var gd = options.gd;\n  var _delegate = options.delegate;\n  var dispatch = d3.dispatch('edit', 'input', 'cancel');\n  var handlerElement = _delegate || context;\n  context.style({\n    'pointer-events': _delegate ? 'none' : 'all'\n  });\n  if (context.size() !== 1) throw new Error('boo');\n\n  function handleClick() {\n    appendEditable();\n    context.style({\n      opacity: 0\n    }); // also hide any mathjax svg\n\n    var svgClass = handlerElement.attr('class');\n    var mathjaxClass;\n    if (svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';else mathjaxClass = '[class*=-math-group]';\n\n    if (mathjaxClass) {\n      d3.select(context.node().parentNode).select(mathjaxClass).style({\n        opacity: 0\n      });\n    }\n  }\n\n  function selectElementContents(_el) {\n    var el = _el.node();\n\n    var range = document.createRange();\n    range.selectNodeContents(el);\n    var sel = window.getSelection();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    el.focus();\n  }\n\n  function appendEditable() {\n    var plotDiv = d3.select(gd);\n    var container = plotDiv.select('.svg-container');\n    var div = container.append('div');\n    var cStyle = context.node().style;\n    var fontSize = parseFloat(cStyle.fontSize || 12);\n    var initialText = options.text;\n    if (initialText === undefined) initialText = context.attr('data-unformatted');\n    div.classed('plugin-editable editable', true).style({\n      position: 'absolute',\n      'font-family': cStyle.fontFamily || 'Arial',\n      'font-size': fontSize,\n      color: options.fill || cStyle.fill || 'black',\n      opacity: 1,\n      'background-color': options.background || 'transparent',\n      outline: '#ffffff33 1px solid',\n      margin: [-fontSize / 8 + 1, 0, 0, -1].join('px ') + 'px',\n      padding: '0',\n      'box-sizing': 'border-box'\n    }).attr({\n      contenteditable: true\n    }).text(initialText).call(alignHTMLWith(context, container, options)).on('blur', function () {\n      gd._editing = false;\n      context.text(this.textContent).style({\n        opacity: 1\n      });\n      var svgClass = d3.select(this).attr('class');\n      var mathjaxClass;\n      if (svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';else mathjaxClass = '[class*=-math-group]';\n\n      if (mathjaxClass) {\n        d3.select(context.node().parentNode).select(mathjaxClass).style({\n          opacity: 0\n        });\n      }\n\n      var text = this.textContent;\n      d3.select(this).transition().duration(0).remove();\n      d3.select(document).on('mouseup', null);\n      dispatch.edit.call(context, text);\n    }).on('focus', function () {\n      var editDiv = this;\n      gd._editing = true;\n      d3.select(document).on('mouseup', function () {\n        if (d3.event.target === editDiv) return false;\n        if (document.activeElement === div.node()) div.node().blur();\n      });\n    }).on('keyup', function () {\n      if (d3.event.which === 27) {\n        gd._editing = false;\n        context.style({\n          opacity: 1\n        });\n        d3.select(this).style({\n          opacity: 0\n        }).on('blur', function () {\n          return false;\n        }).transition().remove();\n        dispatch.cancel.call(context, this.textContent);\n      } else {\n        dispatch.input.call(context, this.textContent);\n        d3.select(this).call(alignHTMLWith(context, container, options));\n      }\n    }).on('keydown', function () {\n      if (d3.event.which === 13) this.blur();\n    }).call(selectElementContents);\n  }\n\n  if (options.immediate) handleClick();else handlerElement.on('click', handleClick);\n  return d3.rebind(context, dispatch, 'on');\n};","map":null,"metadata":{},"sourceType":"script"}