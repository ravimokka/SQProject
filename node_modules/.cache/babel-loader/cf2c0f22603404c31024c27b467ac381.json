{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/*\n * Generated by https://github.com/etpinard/d3-geo-projection-picker\n *\n * which is hand-picks projection from https://github.com/d3/d3-geo-projection\n *\n * into a CommonJS require-able module.\n */\n'use strict';\n/* eslint-disable */\n\nfunction addProjectionsToD3(d3) {\n  d3.geo.project = function (object, projection) {\n    var stream = projection.stream;\n    if (!stream) throw new Error(\"not yet supported\");\n    return (object && d3_geo_projectObjectType.hasOwnProperty(object.type) ? d3_geo_projectObjectType[object.type] : d3_geo_projectGeometry)(object, stream);\n  };\n\n  function d3_geo_projectFeature(object, stream) {\n    return {\n      type: \"Feature\",\n      id: object.id,\n      properties: object.properties,\n      geometry: d3_geo_projectGeometry(object.geometry, stream)\n    };\n  }\n\n  function d3_geo_projectGeometry(geometry, stream) {\n    if (!geometry) return null;\n    if (geometry.type === \"GeometryCollection\") return {\n      type: \"GeometryCollection\",\n      geometries: object.geometries.map(function (geometry) {\n        return d3_geo_projectGeometry(geometry, stream);\n      })\n    };\n    if (!d3_geo_projectGeometryType.hasOwnProperty(geometry.type)) return null;\n    var sink = d3_geo_projectGeometryType[geometry.type];\n    d3.geo.stream(geometry, stream(sink));\n    return sink.result();\n  }\n\n  var d3_geo_projectObjectType = {\n    Feature: d3_geo_projectFeature,\n    FeatureCollection: function (object, stream) {\n      return {\n        type: \"FeatureCollection\",\n        features: object.features.map(function (feature) {\n          return d3_geo_projectFeature(feature, stream);\n        })\n      };\n    }\n  };\n  var d3_geo_projectPoints = [],\n      d3_geo_projectLines = [];\n  var d3_geo_projectPoint = {\n    point: function (x, y) {\n      d3_geo_projectPoints.push([x, y]);\n    },\n    result: function () {\n      var result = !d3_geo_projectPoints.length ? null : d3_geo_projectPoints.length < 2 ? {\n        type: \"Point\",\n        coordinates: d3_geo_projectPoints[0]\n      } : {\n        type: \"MultiPoint\",\n        coordinates: d3_geo_projectPoints\n      };\n      d3_geo_projectPoints = [];\n      return result;\n    }\n  };\n  var d3_geo_projectLine = {\n    lineStart: d3_geo_projectNoop,\n    point: function (x, y) {\n      d3_geo_projectPoints.push([x, y]);\n    },\n    lineEnd: function () {\n      if (d3_geo_projectPoints.length) d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];\n    },\n    result: function () {\n      var result = !d3_geo_projectLines.length ? null : d3_geo_projectLines.length < 2 ? {\n        type: \"LineString\",\n        coordinates: d3_geo_projectLines[0]\n      } : {\n        type: \"MultiLineString\",\n        coordinates: d3_geo_projectLines\n      };\n      d3_geo_projectLines = [];\n      return result;\n    }\n  };\n  var d3_geo_projectPolygon = {\n    polygonStart: d3_geo_projectNoop,\n    lineStart: d3_geo_projectNoop,\n    point: function (x, y) {\n      d3_geo_projectPoints.push([x, y]);\n    },\n    lineEnd: function () {\n      var n = d3_geo_projectPoints.length;\n\n      if (n) {\n        do d3_geo_projectPoints.push(d3_geo_projectPoints[0].slice()); while (++n < 4);\n\n        d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];\n      }\n    },\n    polygonEnd: d3_geo_projectNoop,\n    result: function () {\n      if (!d3_geo_projectLines.length) return null;\n      var polygons = [],\n          holes = [];\n      d3_geo_projectLines.forEach(function (ring) {\n        if (d3_geo_projectClockwise(ring)) polygons.push([ring]);else holes.push(ring);\n      });\n      holes.forEach(function (hole) {\n        var point = hole[0];\n        polygons.some(function (polygon) {\n          if (d3_geo_projectContains(polygon[0], point)) {\n            polygon.push(hole);\n            return true;\n          }\n        }) || polygons.push([hole]);\n      });\n      d3_geo_projectLines = [];\n      return !polygons.length ? null : polygons.length > 1 ? {\n        type: \"MultiPolygon\",\n        coordinates: polygons\n      } : {\n        type: \"Polygon\",\n        coordinates: polygons[0]\n      };\n    }\n  };\n  var d3_geo_projectGeometryType = {\n    Point: d3_geo_projectPoint,\n    MultiPoint: d3_geo_projectPoint,\n    LineString: d3_geo_projectLine,\n    MultiLineString: d3_geo_projectLine,\n    Polygon: d3_geo_projectPolygon,\n    MultiPolygon: d3_geo_projectPolygon,\n    Sphere: d3_geo_projectPolygon\n  };\n\n  function d3_geo_projectNoop() {}\n\n  function d3_geo_projectClockwise(ring) {\n    if ((n = ring.length) < 4) return false;\n    var i = 0,\n        n,\n        area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n\n    while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n\n    return area <= 0;\n  }\n\n  function d3_geo_projectContains(ring, point) {\n    var x = point[0],\n        y = point[1],\n        contains = false;\n\n    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n      var pi = ring[i],\n          xi = pi[0],\n          yi = pi[1],\n          pj = ring[j],\n          xj = pj[0],\n          yj = pj[1];\n      if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;\n    }\n\n    return contains;\n  }\n\n  var ε = 1e-6,\n      ε2 = ε * ε,\n      π = Math.PI,\n      halfπ = π / 2,\n      sqrtπ = Math.sqrt(π),\n      radians = π / 180,\n      degrees = 180 / π;\n\n  function sinci(x) {\n    return x ? x / Math.sin(x) : 1;\n  }\n\n  function sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n\n  function asin(x) {\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n  }\n\n  function acos(x) {\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n  }\n\n  function asqrt(x) {\n    return x > 0 ? Math.sqrt(x) : 0;\n  }\n\n  var projection = d3.geo.projection,\n      projectionMutator = d3.geo.projectionMutator;\n\n  d3.geo.interrupt = function (project) {\n    var lobes = [[[[-π, 0], [0, halfπ], [π, 0]]], [[[-π, 0], [0, -halfπ], [π, 0]]]];\n    var bounds;\n\n    function forward(λ, φ) {\n      var sign = φ < 0 ? -1 : +1,\n          hemilobes = lobes[+(φ < 0)];\n\n      for (var i = 0, n = hemilobes.length - 1; i < n && λ > hemilobes[i][2][0]; ++i);\n\n      var coordinates = project(λ - hemilobes[i][1][0], φ);\n      coordinates[0] += project(hemilobes[i][1][0], sign * φ > sign * hemilobes[i][0][1] ? hemilobes[i][0][1] : φ)[0];\n      return coordinates;\n    }\n\n    function reset() {\n      bounds = lobes.map(function (hemilobes) {\n        return hemilobes.map(function (lobe) {\n          var x0 = project(lobe[0][0], lobe[0][1])[0],\n              x1 = project(lobe[2][0], lobe[2][1])[0],\n              y0 = project(lobe[1][0], lobe[0][1])[1],\n              y1 = project(lobe[1][0], lobe[1][1])[1],\n              t;\n          if (y0 > y1) t = y0, y0 = y1, y1 = t;\n          return [[x0, y0], [x1, y1]];\n        });\n      });\n    }\n\n    if (project.invert) forward.invert = function (x, y) {\n      var hemibounds = bounds[+(y < 0)],\n          hemilobes = lobes[+(y < 0)];\n\n      for (var i = 0, n = hemibounds.length; i < n; ++i) {\n        var b = hemibounds[i];\n\n        if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {\n          var coordinates = project.invert(x - project(hemilobes[i][1][0], 0)[0], y);\n          coordinates[0] += hemilobes[i][1][0];\n          return pointEqual(forward(coordinates[0], coordinates[1]), [x, y]) ? coordinates : null;\n        }\n      }\n    };\n    var projection = d3.geo.projection(forward),\n        stream_ = projection.stream;\n\n    projection.stream = function (stream) {\n      var rotate = projection.rotate(),\n          rotateStream = stream_(stream),\n          sphereStream = (projection.rotate([0, 0]), stream_(stream));\n      projection.rotate(rotate);\n\n      rotateStream.sphere = function () {\n        d3.geo.stream(sphere(), sphereStream);\n      };\n\n      return rotateStream;\n    };\n\n    projection.lobes = function (_) {\n      if (!arguments.length) return lobes.map(function (lobes) {\n        return lobes.map(function (lobe) {\n          return [[lobe[0][0] * 180 / π, lobe[0][1] * 180 / π], [lobe[1][0] * 180 / π, lobe[1][1] * 180 / π], [lobe[2][0] * 180 / π, lobe[2][1] * 180 / π]];\n        });\n      });\n      lobes = _.map(function (lobes) {\n        return lobes.map(function (lobe) {\n          return [[lobe[0][0] * π / 180, lobe[0][1] * π / 180], [lobe[1][0] * π / 180, lobe[1][1] * π / 180], [lobe[2][0] * π / 180, lobe[2][1] * π / 180]];\n        });\n      });\n      reset();\n      return projection;\n    };\n\n    function sphere() {\n      var ε = 1e-6,\n          coordinates = [];\n\n      for (var i = 0, n = lobes[0].length; i < n; ++i) {\n        var lobe = lobes[0][i],\n            λ0 = lobe[0][0] * 180 / π,\n            φ0 = lobe[0][1] * 180 / π,\n            φ1 = lobe[1][1] * 180 / π,\n            λ2 = lobe[2][0] * 180 / π,\n            φ2 = lobe[2][1] * 180 / π;\n        coordinates.push(resample([[λ0 + ε, φ0 + ε], [λ0 + ε, φ1 - ε], [λ2 - ε, φ1 - ε], [λ2 - ε, φ2 + ε]], 30));\n      }\n\n      for (var i = lobes[1].length - 1; i >= 0; --i) {\n        var lobe = lobes[1][i],\n            λ0 = lobe[0][0] * 180 / π,\n            φ0 = lobe[0][1] * 180 / π,\n            φ1 = lobe[1][1] * 180 / π,\n            λ2 = lobe[2][0] * 180 / π,\n            φ2 = lobe[2][1] * 180 / π;\n        coordinates.push(resample([[λ2 - ε, φ2 - ε], [λ2 - ε, φ1 + ε], [λ0 + ε, φ1 + ε], [λ0 + ε, φ0 - ε]], 30));\n      }\n\n      return {\n        type: \"Polygon\",\n        coordinates: [d3.merge(coordinates)]\n      };\n    }\n\n    function resample(coordinates, m) {\n      var i = -1,\n          n = coordinates.length,\n          p0 = coordinates[0],\n          p1,\n          dx,\n          dy,\n          resampled = [];\n\n      while (++i < n) {\n        p1 = coordinates[i];\n        dx = (p1[0] - p0[0]) / m;\n        dy = (p1[1] - p0[1]) / m;\n\n        for (var j = 0; j < m; ++j) resampled.push([p0[0] + j * dx, p0[1] + j * dy]);\n\n        p0 = p1;\n      }\n\n      resampled.push(p1);\n      return resampled;\n    }\n\n    function pointEqual(a, b) {\n      return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;\n    }\n\n    return projection;\n  };\n\n  function eckert4(λ, φ) {\n    var k = (2 + halfπ) * Math.sin(φ);\n    φ /= 2;\n\n    for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {\n      var cosφ = Math.cos(φ);\n      φ -= δ = (φ + Math.sin(φ) * (cosφ + 2) - k) / (2 * cosφ * (1 + cosφ));\n    }\n\n    return [2 / Math.sqrt(π * (4 + π)) * λ * (1 + Math.cos(φ)), 2 * Math.sqrt(π / (4 + π)) * Math.sin(φ)];\n  }\n\n  eckert4.invert = function (x, y) {\n    var A = .5 * y * Math.sqrt((4 + π) / π),\n        k = asin(A),\n        c = Math.cos(k);\n    return [x / (2 / Math.sqrt(π * (4 + π)) * (1 + c)), asin((k + A * (c + 2)) / (2 + halfπ))];\n  };\n\n  (d3.geo.eckert4 = function () {\n    return projection(eckert4);\n  }).raw = eckert4;\n  var hammerAzimuthalEqualArea = d3.geo.azimuthalEqualArea.raw;\n\n  function hammer(A, B) {\n    if (arguments.length < 2) B = A;\n    if (B === 1) return hammerAzimuthalEqualArea;\n    if (B === Infinity) return hammerQuarticAuthalic;\n\n    function forward(λ, φ) {\n      var coordinates = hammerAzimuthalEqualArea(λ / B, φ);\n      coordinates[0] *= A;\n      return coordinates;\n    }\n\n    forward.invert = function (x, y) {\n      var coordinates = hammerAzimuthalEqualArea.invert(x / A, y);\n      coordinates[0] *= B;\n      return coordinates;\n    };\n\n    return forward;\n  }\n\n  function hammerProjection() {\n    var B = 2,\n        m = projectionMutator(hammer),\n        p = m(B);\n\n    p.coefficient = function (_) {\n      if (!arguments.length) return B;\n      return m(B = +_);\n    };\n\n    return p;\n  }\n\n  function hammerQuarticAuthalic(λ, φ) {\n    return [λ * Math.cos(φ) / Math.cos(φ /= 2), 2 * Math.sin(φ)];\n  }\n\n  hammerQuarticAuthalic.invert = function (x, y) {\n    var φ = 2 * asin(y / 2);\n    return [x * Math.cos(φ / 2) / Math.cos(φ), φ];\n  };\n\n  (d3.geo.hammer = hammerProjection).raw = hammer;\n\n  function kavrayskiy7(λ, φ) {\n    return [3 * λ / (2 * π) * Math.sqrt(π * π / 3 - φ * φ), φ];\n  }\n\n  kavrayskiy7.invert = function (x, y) {\n    return [2 / 3 * π * x / Math.sqrt(π * π / 3 - y * y), y];\n  };\n\n  (d3.geo.kavrayskiy7 = function () {\n    return projection(kavrayskiy7);\n  }).raw = kavrayskiy7;\n\n  function miller(λ, φ) {\n    return [λ, 1.25 * Math.log(Math.tan(π / 4 + .4 * φ))];\n  }\n\n  miller.invert = function (x, y) {\n    return [x, 2.5 * Math.atan(Math.exp(.8 * y)) - .625 * π];\n  };\n\n  (d3.geo.miller = function () {\n    return projection(miller);\n  }).raw = miller;\n\n  function mollweideBromleyθ(Cp) {\n    return function (θ) {\n      var Cpsinθ = Cp * Math.sin(θ),\n          i = 30,\n          δ;\n\n      do θ -= δ = (θ + Math.sin(θ) - Cpsinθ) / (1 + Math.cos(θ)); while (Math.abs(δ) > ε && --i > 0);\n\n      return θ / 2;\n    };\n  }\n\n  function mollweideBromley(Cx, Cy, Cp) {\n    var θ = mollweideBromleyθ(Cp);\n\n    function forward(λ, φ) {\n      return [Cx * λ * Math.cos(φ = θ(φ)), Cy * Math.sin(φ)];\n    }\n\n    forward.invert = function (x, y) {\n      var θ = asin(y / Cy);\n      return [x / (Cx * Math.cos(θ)), asin((2 * θ + Math.sin(2 * θ)) / Cp)];\n    };\n\n    return forward;\n  }\n\n  var mollweideθ = mollweideBromleyθ(π),\n      mollweide = mollweideBromley(Math.SQRT2 / halfπ, Math.SQRT2, π);\n  (d3.geo.mollweide = function () {\n    return projection(mollweide);\n  }).raw = mollweide;\n\n  function naturalEarth(λ, φ) {\n    var φ2 = φ * φ,\n        φ4 = φ2 * φ2;\n    return [λ * (.8707 - .131979 * φ2 + φ4 * (-.013791 + φ4 * (.003971 * φ2 - .001529 * φ4))), φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4)))];\n  }\n\n  naturalEarth.invert = function (x, y) {\n    var φ = y,\n        i = 25,\n        δ;\n\n    do {\n      var φ2 = φ * φ,\n          φ4 = φ2 * φ2;\n      φ -= δ = (φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4))) - y) / (1.007226 + φ2 * (.015085 * 3 + φ4 * (-.044475 * 7 + .028874 * 9 * φ2 - .005916 * 11 * φ4)));\n    } while (Math.abs(δ) > ε && --i > 0);\n\n    return [x / (.8707 + (φ2 = φ * φ) * (-.131979 + φ2 * (-.013791 + φ2 * φ2 * φ2 * (.003971 - .001529 * φ2)))), φ];\n  };\n\n  (d3.geo.naturalEarth = function () {\n    return projection(naturalEarth);\n  }).raw = naturalEarth;\n  var robinsonConstants = [[.9986, -.062], [1, 0], [.9986, .062], [.9954, .124], [.99, .186], [.9822, .248], [.973, .31], [.96, .372], [.9427, .434], [.9216, .4958], [.8962, .5571], [.8679, .6176], [.835, .6769], [.7986, .7346], [.7597, .7903], [.7186, .8435], [.6732, .8936], [.6213, .9394], [.5722, .9761], [.5322, 1]];\n  robinsonConstants.forEach(function (d) {\n    d[1] *= 1.0144;\n  });\n\n  function robinson(λ, φ) {\n    var i = Math.min(18, Math.abs(φ) * 36 / π),\n        i0 = Math.floor(i),\n        di = i - i0,\n        ax = (k = robinsonConstants[i0])[0],\n        ay = k[1],\n        bx = (k = robinsonConstants[++i0])[0],\n        by = k[1],\n        cx = (k = robinsonConstants[Math.min(19, ++i0)])[0],\n        cy = k[1],\n        k;\n    return [λ * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (φ > 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)];\n  }\n\n  robinson.invert = function (x, y) {\n    var yy = y / halfπ,\n        φ = yy * 90,\n        i = Math.min(18, Math.abs(φ / 5)),\n        i0 = Math.max(0, Math.floor(i));\n\n    do {\n      var ay = robinsonConstants[i0][1],\n          by = robinsonConstants[i0 + 1][1],\n          cy = robinsonConstants[Math.min(19, i0 + 2)][1],\n          u = cy - ay,\n          v = cy - 2 * by + ay,\n          t = 2 * (Math.abs(yy) - by) / u,\n          c = v / u,\n          di = t * (1 - c * t * (1 - 2 * c * t));\n\n      if (di >= 0 || i0 === 1) {\n        φ = (y >= 0 ? 5 : -5) * (di + i);\n        var j = 50,\n            δ;\n\n        do {\n          i = Math.min(18, Math.abs(φ) / 5);\n          i0 = Math.floor(i);\n          di = i - i0;\n          ay = robinsonConstants[i0][1];\n          by = robinsonConstants[i0 + 1][1];\n          cy = robinsonConstants[Math.min(19, i0 + 2)][1];\n          φ -= (δ = (y >= 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;\n        } while (Math.abs(δ) > ε2 && --j > 0);\n\n        break;\n      }\n    } while (--i0 >= 0);\n\n    var ax = robinsonConstants[i0][0],\n        bx = robinsonConstants[i0 + 1][0],\n        cx = robinsonConstants[Math.min(19, i0 + 2)][0];\n    return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), φ * radians];\n  };\n\n  (d3.geo.robinson = function () {\n    return projection(robinson);\n  }).raw = robinson;\n\n  function sinusoidal(λ, φ) {\n    return [λ * Math.cos(φ), φ];\n  }\n\n  sinusoidal.invert = function (x, y) {\n    return [x / Math.cos(y), y];\n  };\n\n  (d3.geo.sinusoidal = function () {\n    return projection(sinusoidal);\n  }).raw = sinusoidal;\n\n  function aitoff(λ, φ) {\n    var cosφ = Math.cos(φ),\n        sinciα = sinci(acos(cosφ * Math.cos(λ /= 2)));\n    return [2 * cosφ * Math.sin(λ) * sinciα, Math.sin(φ) * sinciα];\n  }\n\n  aitoff.invert = function (x, y) {\n    if (x * x + 4 * y * y > π * π + ε) return;\n    var λ = x,\n        φ = y,\n        i = 25;\n\n    do {\n      var sinλ = Math.sin(λ),\n          sinλ_2 = Math.sin(λ / 2),\n          cosλ_2 = Math.cos(λ / 2),\n          sinφ = Math.sin(φ),\n          cosφ = Math.cos(φ),\n          sin_2φ = Math.sin(2 * φ),\n          sin2φ = sinφ * sinφ,\n          cos2φ = cosφ * cosφ,\n          sin2λ_2 = sinλ_2 * sinλ_2,\n          C = 1 - cos2φ * cosλ_2 * cosλ_2,\n          E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0,\n          F,\n          fx = 2 * E * cosφ * sinλ_2 - x,\n          fy = E * sinφ - y,\n          δxδλ = F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ),\n          δxδφ = F * (.5 * sinλ * sin_2φ - E * 2 * sinφ * sinλ_2),\n          δyδλ = F * .25 * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ),\n          δyδφ = F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ),\n          denominator = δxδφ * δyδλ - δyδφ * δxδλ;\n      if (!denominator) break;\n      var δλ = (fy * δxδφ - fx * δyδφ) / denominator,\n          δφ = (fx * δyδλ - fy * δxδλ) / denominator;\n      λ -= δλ, φ -= δφ;\n    } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);\n\n    return [λ, φ];\n  };\n\n  (d3.geo.aitoff = function () {\n    return projection(aitoff);\n  }).raw = aitoff;\n\n  function winkel3(λ, φ) {\n    var coordinates = aitoff(λ, φ);\n    return [(coordinates[0] + λ / halfπ) / 2, (coordinates[1] + φ) / 2];\n  }\n\n  winkel3.invert = function (x, y) {\n    var λ = x,\n        φ = y,\n        i = 25;\n\n    do {\n      var cosφ = Math.cos(φ),\n          sinφ = Math.sin(φ),\n          sin_2φ = Math.sin(2 * φ),\n          sin2φ = sinφ * sinφ,\n          cos2φ = cosφ * cosφ,\n          sinλ = Math.sin(λ),\n          cosλ_2 = Math.cos(λ / 2),\n          sinλ_2 = Math.sin(λ / 2),\n          sin2λ_2 = sinλ_2 * sinλ_2,\n          C = 1 - cos2φ * cosλ_2 * cosλ_2,\n          E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0,\n          F,\n          fx = .5 * (2 * E * cosφ * sinλ_2 + λ / halfπ) - x,\n          fy = .5 * (E * sinφ + φ) - y,\n          δxδλ = .5 * F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ) + .5 / halfπ,\n          δxδφ = F * (sinλ * sin_2φ / 4 - E * sinφ * sinλ_2),\n          δyδλ = .125 * F * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ),\n          δyδφ = .5 * F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ) + .5,\n          denominator = δxδφ * δyδλ - δyδφ * δxδλ,\n          δλ = (fy * δxδφ - fx * δyδφ) / denominator,\n          δφ = (fx * δyδλ - fy * δxδλ) / denominator;\n      λ -= δλ, φ -= δφ;\n    } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);\n\n    return [λ, φ];\n  };\n\n  (d3.geo.winkel3 = function () {\n    return projection(winkel3);\n  }).raw = winkel3;\n}\n\nmodule.exports = addProjectionsToD3;","map":null,"metadata":{},"sourceType":"script"}