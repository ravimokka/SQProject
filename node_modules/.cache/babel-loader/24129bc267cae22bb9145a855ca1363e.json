{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// this is the core work-horse\n//\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog) {\n  // selfIntersection is true/false depending on the phase of the overall algorithm\n  //\n  // segment creation\n  //\n  function segmentNew(start, end) {\n    return {\n      id: buildLog ? buildLog.segmentId() : -1,\n      start: start,\n      end: end,\n      myFill: {\n        above: null,\n        // is there fill above us?\n        below: null // is there fill below us?\n\n      },\n      otherFill: null\n    };\n  }\n\n  function segmentCopy(start, end, seg) {\n    return {\n      id: buildLog ? buildLog.segmentId() : -1,\n      start: start,\n      end: end,\n      myFill: {\n        above: seg.myFill.above,\n        below: seg.myFill.below\n      },\n      otherFill: null\n    };\n  } //\n  // event logic\n  //\n\n\n  var event_root = LinkedList.create();\n\n  function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {\n    // compare the selected points first\n    var comp = eps.pointsCompare(p1_1, p2_1);\n    if (comp !== 0) return comp; // the selected points are the same\n\n    if (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n      return 0; // then the segments are equal\n\n    if (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n      return p1_isStart ? 1 : -1; // favor the one that isn't the start\n    // otherwise, we'll have to calculate which one is below the other manually\n\n    return eps.pointAboveOrOnLine(p1_2, p2_isStart ? p2_1 : p2_2, // order matters\n    p2_isStart ? p2_2 : p2_1) ? 1 : -1;\n  }\n\n  function eventAdd(ev, other_pt) {\n    event_root.insertBefore(ev, function (here) {\n      // should ev be inserted before here?\n      var comp = eventCompare(ev.isStart, ev.pt, other_pt, here.isStart, here.pt, here.other.pt);\n      return comp < 0;\n    });\n  }\n\n  function eventAddSegmentStart(seg, primary) {\n    var ev_start = LinkedList.node({\n      isStart: true,\n      pt: seg.start,\n      seg: seg,\n      primary: primary,\n      other: null,\n      status: null\n    });\n    eventAdd(ev_start, seg.end);\n    return ev_start;\n  }\n\n  function eventAddSegmentEnd(ev_start, seg, primary) {\n    var ev_end = LinkedList.node({\n      isStart: false,\n      pt: seg.end,\n      seg: seg,\n      primary: primary,\n      other: ev_start,\n      status: null\n    });\n    ev_start.other = ev_end;\n    eventAdd(ev_end, ev_start.pt);\n  }\n\n  function eventAddSegment(seg, primary) {\n    var ev_start = eventAddSegmentStart(seg, primary);\n    eventAddSegmentEnd(ev_start, seg, primary);\n    return ev_start;\n  }\n\n  function eventUpdateEnd(ev, end) {\n    // slides an end backwards\n    //   (start)------------(end)    to:\n    //   (start)---(end)\n    if (buildLog) buildLog.segmentChop(ev.seg, end);\n    ev.other.remove();\n    ev.seg.end = end;\n    ev.other.pt = end;\n    eventAdd(ev.other, ev.pt);\n  }\n\n  function eventDivide(ev, pt) {\n    var ns = segmentCopy(pt, ev.seg.end, ev.seg);\n    eventUpdateEnd(ev, pt);\n    return eventAddSegment(ns, ev.primary);\n  }\n\n  function calculate(primaryPolyInverted, secondaryPolyInverted) {\n    // if selfIntersection is true then there is no secondary polygon, so that isn't used\n    //\n    // status logic\n    //\n    var status_root = LinkedList.create();\n\n    function statusCompare(ev1, ev2) {\n      var a1 = ev1.seg.start;\n      var a2 = ev1.seg.end;\n      var b1 = ev2.seg.start;\n      var b2 = ev2.seg.end;\n\n      if (eps.pointsCollinear(a1, b1, b2)) {\n        if (eps.pointsCollinear(a2, b1, b2)) return 1; //eventCompare(true, a1, a2, true, b1, b2);\n\n        return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n      }\n\n      return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n    }\n\n    function statusFindSurrounding(ev) {\n      return status_root.findTransition(function (here) {\n        var comp = statusCompare(ev, here.ev);\n        return comp > 0;\n      });\n    }\n\n    function checkIntersection(ev1, ev2) {\n      // returns the segment equal to ev1, or false if nothing equal\n      var seg1 = ev1.seg;\n      var seg2 = ev2.seg;\n      var a1 = seg1.start;\n      var a2 = seg1.end;\n      var b1 = seg2.start;\n      var b2 = seg2.end;\n      if (buildLog) buildLog.checkIntersection(seg1, seg2);\n      var i = eps.linesIntersect(a1, a2, b1, b2);\n\n      if (i === false) {\n        // segments are parallel or coincident\n        // if points aren't collinear, then the segments are parallel, so no intersections\n        if (!eps.pointsCollinear(a1, a2, b1)) return false; // otherwise, segments are on top of each other somehow (aka coincident)\n\n        if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1)) return false; // segments touch at endpoints... no intersection\n\n        var a1_equ_b1 = eps.pointsSame(a1, b1);\n        var a2_equ_b2 = eps.pointsSame(a2, b2);\n        if (a1_equ_b1 && a2_equ_b2) return ev2; // segments are exactly equal\n\n        var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n        var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2); // handy for debugging:\n        // buildLog.log({\n        //\ta1_equ_b1: a1_equ_b1,\n        //\ta2_equ_b2: a2_equ_b2,\n        //\ta1_between: a1_between,\n        //\ta2_between: a2_between\n        // });\n\n        if (a1_equ_b1) {\n          if (a2_between) {\n            //  (a1)---(a2)\n            //  (b1)----------(b2)\n            eventDivide(ev2, a2);\n          } else {\n            //  (a1)----------(a2)\n            //  (b1)---(b2)\n            eventDivide(ev1, b2);\n          }\n\n          return ev2;\n        } else if (a1_between) {\n          if (!a2_equ_b2) {\n            // make a2 equal to b2\n            if (a2_between) {\n              //         (a1)---(a2)\n              //  (b1)-----------------(b2)\n              eventDivide(ev2, a2);\n            } else {\n              //         (a1)----------(a2)\n              //  (b1)----------(b2)\n              eventDivide(ev1, b2);\n            }\n          } //         (a1)---(a2)\n          //  (b1)----------(b2)\n\n\n          eventDivide(ev2, a1);\n        }\n      } else {\n        // otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n        // is A divided between its endpoints? (exclusive)\n        if (i.alongA === 0) {\n          if (i.alongB === -1) // yes, at exactly b1\n            eventDivide(ev1, b1);else if (i.alongB === 0) // yes, somewhere between B's endpoints\n            eventDivide(ev1, i.pt);else if (i.alongB === 1) // yes, at exactly b2\n            eventDivide(ev1, b2);\n        } // is B divided between its endpoints? (exclusive)\n\n\n        if (i.alongB === 0) {\n          if (i.alongA === -1) // yes, at exactly a1\n            eventDivide(ev2, a1);else if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n            eventDivide(ev2, i.pt);else if (i.alongA === 1) // yes, at exactly a2\n            eventDivide(ev2, a2);\n        }\n      }\n\n      return false;\n    } //\n    // main event loop\n    //\n\n\n    var segments = [];\n\n    while (!event_root.isEmpty()) {\n      var ev = event_root.getHead();\n      if (buildLog) buildLog.vert(ev.pt[0]);\n\n      if (ev.isStart) {\n        if (buildLog) buildLog.segmentNew(ev.seg, ev.primary);\n        var surrounding = statusFindSurrounding(ev);\n        var above = surrounding.before ? surrounding.before.ev : null;\n        var below = surrounding.after ? surrounding.after.ev : null;\n\n        if (buildLog) {\n          buildLog.tempStatus(ev.seg, above ? above.seg : false, below ? below.seg : false);\n        }\n\n        function checkBothIntersections() {\n          if (above) {\n            var eve = checkIntersection(ev, above);\n            if (eve) return eve;\n          }\n\n          if (below) return checkIntersection(ev, below);\n          return false;\n        }\n\n        var eve = checkBothIntersections();\n\n        if (eve) {\n          // ev and eve are equal\n          // we'll keep eve and throw away ev\n          // merge ev.seg's fill information into eve.seg\n          if (selfIntersection) {\n            var toggle; // are we a toggling edge?\n\n            if (ev.seg.myFill.below === null) toggle = true;else toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // merge two segments that belong to the same polygon\n            // think of this as sandwiching two segments together, where `eve.seg` is\n            // the bottom -- this will cause the above fill flag to toggle\n\n            if (toggle) eve.seg.myFill.above = !eve.seg.myFill.above;\n          } else {\n            // merge two segments that belong to different polygons\n            // each segment has distinct knowledge, so no special logic is needed\n            // note that this can only happen once per segment in this phase, because we\n            // are guaranteed that all self-intersections are gone\n            eve.seg.otherFill = ev.seg.myFill;\n          }\n\n          if (buildLog) buildLog.segmentUpdate(eve.seg);\n          ev.other.remove();\n          ev.remove();\n        }\n\n        if (event_root.getHead() !== ev) {\n          // something was inserted before us in the event queue, so loop back around and\n          // process it before continuing\n          if (buildLog) buildLog.rewind(ev.seg);\n          continue;\n        } //\n        // calculate fill flags\n        //\n\n\n        if (selfIntersection) {\n          var toggle; // are we a toggling edge?\n\n          if (ev.seg.myFill.below === null) // if we are a new segment...\n            toggle = true; // then we toggle\n          else // we are a segment that has previous knowledge from a division\n            toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n          // next, calculate whether we are filled below us\n\n          if (!below) {\n            // if nothing is below us...\n            // we are filled below us if the polygon is inverted\n            ev.seg.myFill.below = primaryPolyInverted;\n          } else {\n            // otherwise, we know the answer -- it's the same if whatever is below\n            // us is filled above it\n            ev.seg.myFill.below = below.seg.myFill.above;\n          } // since now we know if we're filled below us, we can calculate whether\n          // we're filled above us by applying toggle to whatever is below us\n\n\n          if (toggle) ev.seg.myFill.above = !ev.seg.myFill.below;else ev.seg.myFill.above = ev.seg.myFill.below;\n        } else {\n          // now we fill in any missing transition information, since we are all-knowing\n          // at this point\n          if (ev.seg.otherFill === null) {\n            // if we don't have other information, then we need to figure out if we're\n            // inside the other polygon\n            var inside;\n\n            if (!below) {\n              // if nothing is below us, then we're inside if the other polygon is\n              // inverted\n              inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;\n            } else {\n              // otherwise, something is below us\n              // so copy the below segment's other polygon's above\n              if (ev.primary === below.primary) inside = below.seg.otherFill.above;else inside = below.seg.myFill.above;\n            }\n\n            ev.seg.otherFill = {\n              above: inside,\n              below: inside\n            };\n          }\n        }\n\n        if (buildLog) {\n          buildLog.status(ev.seg, above ? above.seg : false, below ? below.seg : false);\n        } // insert the status and remember it for later removal\n\n\n        ev.other.status = surrounding.insert(LinkedList.node({\n          ev: ev\n        }));\n      } else {\n        var st = ev.status;\n\n        if (st === null) {\n          throw new Error('PolyBool: Zero-length segment detected; your epsilon is ' + 'probably too small or too large');\n        } // removing the status will create two new adjacent edges, so we'll need to check\n        // for those\n\n\n        if (status_root.exists(st.prev) && status_root.exists(st.next)) checkIntersection(st.prev.ev, st.next.ev);\n        if (buildLog) buildLog.statusRemove(st.ev.seg); // remove the status\n\n        st.remove(); // if we've reached this point, we've calculated everything there is to know, so\n        // save the segment for reporting\n\n        if (!ev.primary) {\n          // make sure `seg.myFill` actually points to the primary polygon though\n          var s = ev.seg.myFill;\n          ev.seg.myFill = ev.seg.otherFill;\n          ev.seg.otherFill = s;\n        }\n\n        segments.push(ev.seg);\n      } // remove the event and continue\n\n\n      event_root.getHead().remove();\n    }\n\n    if (buildLog) buildLog.done();\n    return segments;\n  } // return the appropriate API depending on what we're doing\n\n\n  if (!selfIntersection) {\n    // performing combination of polygons, so only deal with already-processed segments\n    return {\n      calculate: function (segments1, inverted1, segments2, inverted2) {\n        // segmentsX come from the self-intersection API, or this API\n        // invertedX is whether we treat that list of segments as an inverted polygon or not\n        // returns segments that can be used for further operations\n        segments1.forEach(function (seg) {\n          eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n        });\n        segments2.forEach(function (seg) {\n          eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n        });\n        return calculate(inverted1, inverted2);\n      }\n    };\n  } // otherwise, performing self-intersection, so deal with regions\n\n\n  return {\n    addRegion: function (region) {\n      // regions are a list of points:\n      //  [ [0, 0], [100, 0], [50, 100] ]\n      // you can add multiple regions before running calculate\n      var pt1;\n      var pt2 = region[region.length - 1];\n\n      for (var i = 0; i < region.length; i++) {\n        pt1 = pt2;\n        pt2 = region[i];\n        var forward = eps.pointsCompare(pt1, pt2);\n        if (forward === 0) // points are equal, so we have a zero-length segment\n          continue; // just skip it\n\n        eventAddSegment(segmentNew(forward < 0 ? pt1 : pt2, forward < 0 ? pt2 : pt1), true);\n      }\n    },\n    calculate: function (inverted) {\n      // is the polygon inverted?\n      // returns segments\n      return calculate(inverted, false);\n    }\n  };\n}\n\nmodule.exports = Intersecter;","map":null,"metadata":{},"sourceType":"script"}