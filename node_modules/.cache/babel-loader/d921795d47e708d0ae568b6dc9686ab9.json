{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar Axes = require('./axes');\n/**\n * transitionAxes\n *\n * transition axes from one set of ranges to another, using a svg\n * transformations, similar to during panning.\n *\n * @param {DOM element | object} gd\n * @param {array} edits : array of 'edits', each item with\n * - plotinfo {object} subplot object\n * - xr0 {array} initial x-range\n * - xr1 {array} end x-range\n * - yr0 {array} initial y-range\n * - yr1 {array} end y-range\n * @param {object} transitionOpts\n * @param {function} makeOnCompleteCallback\n */\n\n\nmodule.exports = function transitionAxes(gd, edits, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout; // special case for redraw:false Plotly.animate that relies on this\n  // to update axis-referenced layout components\n\n  if (edits.length === 0) {\n    Axes.redrawComponents(gd);\n    return;\n  }\n\n  function unsetSubplotTransform(subplot) {\n    var xa = subplot.xaxis;\n    var ya = subplot.yaxis;\n\n    fullLayout._defs.select('#' + subplot.clipId + '> rect').call(Drawing.setTranslate, 0, 0).call(Drawing.setScale, 1, 1);\n\n    subplot.plot.call(Drawing.setTranslate, xa._offset, ya._offset).call(Drawing.setScale, 1, 1);\n    var traceGroups = subplot.plot.selectAll('.scatterlayer .trace'); // This is specifically directed at scatter traces, applying an inverse\n    // scale to individual points to counteract the scale of the trace\n    // as a whole:\n\n    traceGroups.selectAll('.point').call(Drawing.setPointGroupScale, 1, 1);\n    traceGroups.selectAll('.textpoint').call(Drawing.setTextPointsScale, 1, 1);\n    traceGroups.call(Drawing.hideOutsideRangePoints, subplot);\n  }\n\n  function updateSubplot(edit, progress) {\n    var plotinfo = edit.plotinfo;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var xlen = xa._length;\n    var ylen = ya._length;\n    var editX = !!edit.xr1;\n    var editY = !!edit.yr1;\n    var viewBox = [];\n\n    if (editX) {\n      var xr0 = Lib.simpleMap(edit.xr0, xa.r2l);\n      var xr1 = Lib.simpleMap(edit.xr1, xa.r2l);\n      var dx0 = xr0[1] - xr0[0];\n      var dx1 = xr1[1] - xr1[0];\n      viewBox[0] = (xr0[0] * (1 - progress) + progress * xr1[0] - xr0[0]) / (xr0[1] - xr0[0]) * xlen;\n      viewBox[2] = xlen * (1 - progress + progress * dx1 / dx0);\n      xa.range[0] = xa.l2r(xr0[0] * (1 - progress) + progress * xr1[0]);\n      xa.range[1] = xa.l2r(xr0[1] * (1 - progress) + progress * xr1[1]);\n    } else {\n      viewBox[0] = 0;\n      viewBox[2] = xlen;\n    }\n\n    if (editY) {\n      var yr0 = Lib.simpleMap(edit.yr0, ya.r2l);\n      var yr1 = Lib.simpleMap(edit.yr1, ya.r2l);\n      var dy0 = yr0[1] - yr0[0];\n      var dy1 = yr1[1] - yr1[0];\n      viewBox[1] = (yr0[1] * (1 - progress) + progress * yr1[1] - yr0[1]) / (yr0[0] - yr0[1]) * ylen;\n      viewBox[3] = ylen * (1 - progress + progress * dy1 / dy0);\n      ya.range[0] = xa.l2r(yr0[0] * (1 - progress) + progress * yr1[0]);\n      ya.range[1] = ya.l2r(yr0[1] * (1 - progress) + progress * yr1[1]);\n    } else {\n      viewBox[1] = 0;\n      viewBox[3] = ylen;\n    }\n\n    Axes.drawOne(gd, xa, {\n      skipTitle: true\n    });\n    Axes.drawOne(gd, ya, {\n      skipTitle: true\n    });\n    Axes.redrawComponents(gd, [xa._id, ya._id]);\n    var xScaleFactor = editX ? xlen / viewBox[2] : 1;\n    var yScaleFactor = editY ? ylen / viewBox[3] : 1;\n    var clipDx = editX ? viewBox[0] : 0;\n    var clipDy = editY ? viewBox[1] : 0;\n    var fracDx = editX ? viewBox[0] / viewBox[2] * xlen : 0;\n    var fracDy = editY ? viewBox[1] / viewBox[3] * ylen : 0;\n    var plotDx = xa._offset - fracDx;\n    var plotDy = ya._offset - fracDy;\n    plotinfo.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, 1 / xScaleFactor, 1 / yScaleFactor);\n    plotinfo.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, xScaleFactor, yScaleFactor); // apply an inverse scale to individual points to counteract\n    // the scale of the trace group.\n\n    Drawing.setPointGroupScale(plotinfo.zoomScalePts, 1 / xScaleFactor, 1 / yScaleFactor);\n    Drawing.setTextPointsScale(plotinfo.zoomScaleTxt, 1 / xScaleFactor, 1 / yScaleFactor);\n  }\n\n  var onComplete;\n\n  if (makeOnCompleteCallback) {\n    // This module makes the choice whether or not it notifies Plotly.transition\n    // about completion:\n    onComplete = makeOnCompleteCallback();\n  }\n\n  function transitionComplete() {\n    var aobj = {};\n\n    for (var i = 0; i < edits.length; i++) {\n      var edit = edits[i];\n      var xa = edit.plotinfo.xaxis;\n      var ya = edit.plotinfo.yaxis;\n      if (edit.xr1) aobj[xa._name + '.range'] = edit.xr1.slice();\n      if (edit.yr1) aobj[ya._name + '.range'] = edit.yr1.slice();\n    } // Signal that this transition has completed:\n\n\n    onComplete && onComplete();\n    return Registry.call('relayout', gd, aobj).then(function () {\n      for (var i = 0; i < edits.length; i++) {\n        unsetSubplotTransform(edits[i].plotinfo);\n      }\n    });\n  }\n\n  function transitionInterrupt() {\n    var aobj = {};\n\n    for (var i = 0; i < edits.length; i++) {\n      var edit = edits[i];\n      var xa = edit.plotinfo.xaxis;\n      var ya = edit.plotinfo.yaxis;\n      if (edit.xr0) aobj[xa._name + '.range'] = edit.xr0.slice();\n      if (edit.yr0) aobj[ya._name + '.range'] = edit.yr0.slice();\n    }\n\n    return Registry.call('relayout', gd, aobj).then(function () {\n      for (var i = 0; i < edits.length; i++) {\n        unsetSubplotTransform(edits[i].plotinfo);\n      }\n    });\n  }\n\n  var t1, t2, raf;\n  var easeFn = d3.ease(transitionOpts.easing);\n\n  gd._transitionData._interruptCallbacks.push(function () {\n    window.cancelAnimationFrame(raf);\n    raf = null;\n    return transitionInterrupt();\n  });\n\n  function doFrame() {\n    t2 = Date.now();\n    var tInterp = Math.min(1, (t2 - t1) / transitionOpts.duration);\n    var progress = easeFn(tInterp);\n\n    for (var i = 0; i < edits.length; i++) {\n      updateSubplot(edits[i], progress);\n    }\n\n    if (t2 - t1 > transitionOpts.duration) {\n      transitionComplete();\n      raf = window.cancelAnimationFrame(doFrame);\n    } else {\n      raf = window.requestAnimationFrame(doFrame);\n    }\n  }\n\n  t1 = Date.now();\n  raf = window.requestAnimationFrame(doFrame);\n  return Promise.resolve();\n};","map":null,"metadata":{},"sourceType":"script"}