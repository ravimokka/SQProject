{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as _ from 'lodash';\nvar QUICK_TYPE = [{\n  type: 'pie',\n  series: {\n    gemo: 'interval',\n    adjust: 'stack'\n  },\n  coord: {\n    type: 'theta'\n  }\n}, {\n  type: 'sector',\n  series: {\n    gemo: 'interval'\n  },\n  coord: {\n    type: 'polar'\n  }\n}, {\n  type: 'line',\n  series: {\n    gemo: 'line'\n  }\n}, {\n  type: 'smoothLine',\n  series: {\n    gemo: 'line',\n    shape: 'smooth'\n  }\n}, {\n  type: 'dashLine',\n  series: {\n    gemo: 'line',\n    shape: 'dash'\n  }\n}, {\n  type: 'stackLine',\n  series: {\n    gemo: 'line',\n    adjust: 'stack'\n  }\n}, {\n  type: 'area',\n  series: {\n    gemo: 'area'\n  }\n}, {\n  type: 'stackArea',\n  series: {\n    gemo: 'area',\n    adjust: 'stack'\n  }\n}, {\n  type: 'smoothArea',\n  series: {\n    gemo: 'area',\n    shape: 'smooth'\n  }\n}, {\n  type: 'interval',\n  series: {\n    gemo: 'interval'\n  }\n}, {\n  type: 'stackInterval',\n  series: {\n    gemo: 'interval',\n    adjust: 'stack'\n  }\n}, {\n  type: 'dodgeInterval',\n  series: {\n    gemo: 'interval',\n    shape: 'interval',\n    adjust: 'dodge'\n  }\n}, {\n  type: 'bar',\n  series: {\n    gemo: 'interval'\n  }\n}, {\n  type: 'stackBar',\n  series: {\n    gemo: 'interval',\n    shape: 'interval',\n    adjust: 'stack'\n  }\n}, {\n  type: 'dodgeBar',\n  series: {\n    gemo: 'interval',\n    shape: 'interval',\n    adjust: 'dodge'\n  }\n}, {\n  type: 'point',\n  series: {\n    gemo: 'point',\n    shape: 'hollowCircle'\n  }\n}, {\n  type: 'funnel',\n  series: {\n    gemo: 'interval',\n    adjust: 'symmetric',\n    shape: 'funnel'\n  }\n}, {\n  type: 'pyramid',\n  series: {\n    gemo: 'interval',\n    adjust: 'symmetric',\n    shape: 'pyramid'\n  }\n}, {\n  type: 'schema',\n  series: {\n    gemo: 'schema',\n    shape: 'box'\n  }\n}, {\n  type: 'box',\n  series: {\n    gemo: 'schema',\n    shape: 'box'\n  }\n}, {\n  type: 'candle',\n  series: {\n    gemo: 'schema',\n    shape: 'candle'\n  }\n}, {\n  type: 'polygon',\n  series: {\n    gemo: 'polygon'\n  }\n}, {\n  type: 'contour',\n  series: {\n    gemo: 'contour'\n  }\n}, {\n  type: 'heatmap',\n  series: {\n    gemo: 'heatmap'\n  }\n}, {\n  type: 'edge',\n  series: {\n    gemo: 'edge'\n  }\n}, {\n  type: 'sankey',\n  series: {\n    gemo: 'edge',\n    shape: 'sankey'\n  }\n}, {\n  type: 'errorBar',\n  series: {\n    gemo: 'schema',\n    shape: 'errorbar'\n  }\n}, {\n  type: 'jitterPoint',\n  series: {\n    gemo: 'point',\n    adjust: 'jitter'\n  }\n}, {\n  type: 'path',\n  series: {\n    gemo: 'path'\n  }\n}, {\n  type: 'venn',\n  series: {\n    gemo: 'venn'\n  }\n}];\nexport var process = function (series, coord) {\n  var quickType = {};\n\n  for (var _i = 0, QUICK_TYPE_1 = QUICK_TYPE; _i < QUICK_TYPE_1.length; _i++) {\n    var item = QUICK_TYPE_1[_i];\n    quickType[item.type] = item;\n  }\n\n  for (var i = 0; i < series.length; i++) {\n    var currType = quickType[series[i].quickType];\n\n    if (currType) {\n      series[i] = __assign({}, currType.series, series[i]);\n\n      if (coord && coord.type && _.get(currType, 'coord.type') && _.get(currType, 'coord.type') !== coord.type) {\n        throw new Error('quickType and coord had conflicted.');\n      }\n    }\n  }\n\n  return series;\n};","map":null,"metadata":{},"sourceType":"module"}