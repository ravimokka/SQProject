{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../registry');\n\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\n\n\nexports.getSubplotCalcData = function (calcData, type, subplotId) {\n  var basePlotModule = Registry.subplotsRegistry[type];\n  if (!basePlotModule) return [];\n  var attr = basePlotModule.attr;\n  var subplotCalcData = [];\n\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n    if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n  }\n\n  return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n *\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\n\n\nexports.getModuleCalcData = function (calcdata, arg1) {\n  var moduleCalcData = [];\n  var remainingCalcData = [];\n  var plotMethod;\n\n  if (typeof arg1 === 'string') {\n    plotMethod = Registry.getModule(arg1).plot;\n  } else if (typeof arg1 === 'function') {\n    plotMethod = arg1;\n  } else {\n    plotMethod = arg1.plot;\n  }\n\n  if (!plotMethod) {\n    return [moduleCalcData, calcdata];\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var trace = cd[0].trace; // N.B.\n    // - 'legendonly' traces do not make it past here\n    // - skip over 'visible' traces that got trimmed completely during calc transforms\n\n    if (trace.visible !== true || trace._length === 0) continue; // group calcdata trace not by 'module' (as the name of this function\n    // would suggest), but by 'module plot method' so that if some traces\n    // share the same module plot method (e.g. bar and histogram), we\n    // only call it one!\n\n    if (trace._module.plot === plotMethod) {\n      moduleCalcData.push(cd);\n    } else {\n      remainingCalcData.push(cd);\n    }\n  }\n\n  return [moduleCalcData, remainingCalcData];\n};\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\n\n\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n  if (!Registry.subplotsRegistry[type]) return [];\n  var attr = Registry.subplotsRegistry[type].attr;\n  var subplotData = [];\n  var trace, subplotX, subplotY;\n\n  if (type === 'gl2d') {\n    var spmatch = subplotId.match(SUBPLOT_PATTERN);\n    subplotX = 'x' + spmatch[1];\n    subplotY = 'y' + spmatch[2];\n  }\n\n  for (var i = 0; i < data.length; i++) {\n    trace = data[i];\n\n    if (type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n      if (trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n        subplotData.push(trace);\n      }\n    } else {\n      if (trace[attr] === subplotId) subplotData.push(trace);\n    }\n  }\n\n  return subplotData;\n};","map":null,"metadata":{},"sourceType":"script"}