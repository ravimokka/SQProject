{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\n\nvar Drawing = require('../../components/drawing');\n\nvar subTypes = require('./subtypes');\n\nvar linePoints = require('./line_points');\n\nvar linkTraces = require('./link_traces');\n\nvar polygonTester = require('../../lib/polygon').tester;\n\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0; // Link traces so the z-order of fill layers is correct\n\n  var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n  join = scatterLayer.selectAll('g.trace').data(cdscatterSorted, function (d) {\n    return d[0].trace.uid;\n  }); // Append new traces:\n\n  join.enter().append('g').attr('class', function (d) {\n    return 'trace scatter trace' + d[0].trace.uid;\n  }).style('stroke-miterlimit', 2);\n  join.order();\n  createFills(gd, join, plotinfo);\n\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      scatterLayer.selectAll('g.trace').each(function (d, i) {\n        plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (d, i) {\n      plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n    });\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  } // remove paths that didn't get used\n\n\n  scatterLayer.selectAll('path:not([d])').remove();\n};\n\nfunction createFills(gd, traceJoin, plotinfo) {\n  traceJoin.each(function (d) {\n    var fills = ensureSingle(d3.select(this), 'g', 'fills');\n    Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n    var trace = d[0].trace;\n    var fillData = [];\n    if (trace._ownfill) fillData.push('_ownFill');\n    if (trace._nexttrace) fillData.push('_nextFill');\n    var fillJoin = fills.selectAll('g').data(fillData, identity);\n    fillJoin.enter().append('g');\n    fillJoin.exit().each(function (d) {\n      trace[d] = null;\n    }).remove();\n    fillJoin.order().each(function (d) {\n      // make a path element inside the fill group, just so\n      // we can give it its own data later on and the group can\n      // keep its simple '_*Fill' data\n      trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n    });\n  });\n}\n\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n  var i; // Since this has been reorganized and we're executing this on individual traces,\n  // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n  // since it does an internal n^2 loop over comparisons with other traces:\n\n  selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n  function transition(selection) {\n    return hasTransition ? selection.transition() : selection;\n  }\n\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var trace = cdscatter[0].trace;\n  var line = trace.line;\n  var tr = d3.select(element);\n  var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n  var lines = ensureSingle(tr, 'g', 'lines');\n  var points = ensureSingle(tr, 'g', 'points');\n  var text = ensureSingle(tr, 'g', 'text'); // error bars are at the bottom\n\n  Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n  if (trace.visible !== true) return;\n  transition(tr).style('opacity', trace.opacity); // BUILD LINES AND FILLS\n\n  var ownFillEl3, tonext;\n  var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n  if (ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = ''; // store node for tweaking by selectPoints\n\n  cdscatter[0][plotinfo.isRangePlot ? 'nodeRangePlot3' : 'node3'] = tr;\n  var prevRevpath = '';\n  var prevPolygons = [];\n  var prevtrace = trace._prevtrace;\n\n  if (prevtrace) {\n    prevRevpath = prevtrace._prevRevpath || '';\n    tonext = prevtrace._nextFill;\n    prevPolygons = prevtrace._polygons;\n  }\n\n  var thispath;\n  var thisrevpath; // fullpath is all paths for this curve, joined together straight\n  // across gaps, for filling\n\n  var fullpath = ''; // revpath is fullpath reversed, for fill-to-next\n\n  var revpath = ''; // functions for converting a point array to a path\n\n  var pathfn, revpathbase, revpathfn; // variables used before and after the data join\n\n  var pt0, lastSegment, pt1, thisPolygons; // initialize line join data / method\n\n  var segments = [];\n  var makeUpdate = Lib.noop;\n  ownFillEl3 = trace._ownFill;\n\n  if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n    if (tonext) {\n      // This tells .style which trace to use for fill information:\n      tonext.datum(cdscatter);\n    }\n\n    if (['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n      pathfn = Drawing.steps(line.shape);\n      revpathbase = Drawing.steps(line.shape.split('').reverse().join(''));\n    } else if (line.shape === 'spline') {\n      pathfn = revpathbase = function (pts) {\n        var pLast = pts[pts.length - 1];\n\n        if (pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n          // identical start and end points: treat it as a\n          // closed curve so we don't get a kink\n          return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n        } else {\n          return Drawing.smoothopen(pts, line.smoothing);\n        }\n      };\n    } else {\n      pathfn = revpathbase = function (pts) {\n        return 'M' + pts.join('L');\n      };\n    }\n\n    revpathfn = function (pts) {\n      // note: this is destructive (reverses pts in place) so can't use pts after this\n      return revpathbase(pts.reverse());\n    };\n\n    segments = linePoints(cdscatter, {\n      xaxis: xa,\n      yaxis: ya,\n      connectGaps: trace.connectgaps,\n      baseTolerance: Math.max(line.width || 1, 3) / 4,\n      shape: line.shape,\n      simplify: line.simplify,\n      fill: trace.fill\n    }); // since we already have the pixel segments here, use them to make\n    // polygons for hover on fill\n    // TODO: can we skip this if hoveron!=fills? That would mean we\n    // need to redraw when you change hoveron...\n\n    thisPolygons = trace._polygons = new Array(segments.length);\n\n    for (i = 0; i < segments.length; i++) {\n      trace._polygons[i] = polygonTester(segments[i]);\n    }\n\n    if (segments.length) {\n      pt0 = segments[0][0];\n      lastSegment = segments[segments.length - 1];\n      pt1 = lastSegment[lastSegment.length - 1];\n    }\n\n    makeUpdate = function (isEnter) {\n      return function (pts) {\n        thispath = pathfn(pts);\n        thisrevpath = revpathfn(pts);\n\n        if (!fullpath) {\n          fullpath = thispath;\n          revpath = thisrevpath;\n        } else if (ownFillDir) {\n          fullpath += 'L' + thispath.substr(1);\n          revpath = thisrevpath + ('L' + revpath.substr(1));\n        } else {\n          fullpath += 'Z' + thispath;\n          revpath = thisrevpath + 'Z' + revpath;\n        }\n\n        if (subTypes.hasLines(trace) && pts.length > 1) {\n          var el = d3.select(this); // This makes the coloring work correctly:\n\n          el.datum(cdscatter);\n\n          if (isEnter) {\n            transition(el.style('opacity', 0).attr('d', thispath).call(Drawing.lineGroupStyle)).style('opacity', 1);\n          } else {\n            var sel = transition(el);\n            sel.attr('d', thispath);\n            Drawing.singleLineStyle(cdscatter, sel);\n          }\n        }\n      };\n    };\n  }\n\n  var lineJoin = lines.selectAll('.js-line').data(segments);\n  transition(lineJoin.exit()).style('opacity', 0).remove();\n  lineJoin.each(makeUpdate(false));\n  lineJoin.enter().append('path').classed('js-line', true).style('vector-effect', 'non-scaling-stroke').call(Drawing.lineGroupStyle).each(makeUpdate(true));\n  Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n\n  function clearFill(selection) {\n    transition(selection).attr('d', 'M0,0Z');\n  }\n\n  if (segments.length) {\n    if (ownFillEl3) {\n      ownFillEl3.datum(cdscatter);\n\n      if (pt0 && pt1) {\n        if (ownFillDir) {\n          if (ownFillDir === 'y') {\n            pt0[1] = pt1[1] = ya.c2p(0, true);\n          } else if (ownFillDir === 'x') {\n            pt0[0] = pt1[0] = xa.c2p(0, true);\n          } // fill to zero: full trace path, plus extension of\n          // the endpoints to the appropriate axis\n          // For the sake of animations, wrap the points around so that\n          // the points on the axes are the first two points. Otherwise\n          // animations get a little crazy if the number of points changes.\n\n\n          transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1)).call(Drawing.singleFillStyle);\n        } else {\n          // fill to self: just join the path to itself\n          transition(ownFillEl3).attr('d', fullpath + 'Z').call(Drawing.singleFillStyle);\n        }\n      }\n    } else if (tonext) {\n      if (trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n        // fill to next: full trace path, plus the previous path reversed\n        if (trace.fill === 'tonext') {\n          // tonext: for use by concentric shapes, like manually constructed\n          // contours, we just add the two paths closed on themselves.\n          // This makes strange results if one path is *not* entirely\n          // inside the other, but then that is a strange usage.\n          transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z').call(Drawing.singleFillStyle);\n        } else {\n          // tonextx/y: for now just connect endpoints with lines. This is\n          // the correct behavior if the endpoints are at the same value of\n          // y/x, but if they *aren't*, we should ideally do more complicated\n          // things depending on whether the new endpoint projects onto the\n          // existing curve or off the end of it\n          transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z').call(Drawing.singleFillStyle);\n        }\n\n        trace._polygons = trace._polygons.concat(prevPolygons);\n      } else {\n        clearFill(tonext);\n        trace._polygons = null;\n      }\n    }\n\n    trace._prevRevpath = revpath;\n    trace._prevPolygons = thisPolygons;\n  } else {\n    if (ownFillEl3) clearFill(ownFillEl3);else if (tonext) clearFill(tonext);\n    trace._polygons = trace._prevRevpath = trace._prevPolygons = null;\n  }\n\n  function visFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap && v.vis;\n    });\n  }\n\n  function visFilterWithGaps(d) {\n    return d.filter(function (v) {\n      return v.vis;\n    });\n  }\n\n  function gapFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap;\n    });\n  }\n\n  function keyFunc(d) {\n    return d.id;\n  } // Returns a function if the trace is keyed, otherwise returns undefined\n\n\n  function getKeyFunc(trace) {\n    if (trace.ids) {\n      return keyFunc;\n    }\n  }\n\n  function hideFilter() {\n    return false;\n  }\n\n  function makePoints(points, text, cdscatter) {\n    var join, selection, hasNode;\n    var trace = cdscatter[0].trace;\n    var showMarkers = subTypes.hasMarkers(trace);\n    var showText = subTypes.hasText(trace);\n    var keyFunc = getKeyFunc(trace);\n    var markerFilter = hideFilter;\n    var textFilter = hideFilter;\n\n    if (showMarkers || showText) {\n      var showFilter = identity; // if we're stacking, \"infer zero\" gap mode gets markers in the\n      // gap points - because we've inferred a zero there - but other\n      // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n      // we don't draw generated markers\n\n      var stackGroup = trace.stackgroup;\n      var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero';\n\n      if (trace.marker.maxdisplayed || trace._needsCull) {\n        showFilter = isInferZero ? visFilterWithGaps : visFilter;\n      } else if (stackGroup && !isInferZero) {\n        showFilter = gapFilter;\n      }\n\n      if (showMarkers) markerFilter = showFilter;\n      if (showText) textFilter = showFilter;\n    } // marker points\n\n\n    selection = points.selectAll('path.point');\n    join = selection.data(markerFilter, keyFunc);\n    var enter = join.enter().append('path').classed('point', true);\n\n    if (hasTransition) {\n      enter.call(Drawing.pointStyle, trace, gd).call(Drawing.translatePoints, xa, ya).style('opacity', 0).transition().style('opacity', 1);\n    }\n\n    join.order();\n    var styleFns;\n\n    if (showMarkers) {\n      styleFns = Drawing.makePointStyleFns(trace);\n    }\n\n    join.each(function (d) {\n      var el = d3.select(this);\n      var sel = transition(el);\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n      if (hasNode) {\n        Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n\n        if (trace.customdata) {\n          el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n        }\n      } else {\n        sel.remove();\n      }\n    });\n\n    if (hasTransition) {\n      join.exit().transition().style('opacity', 0).remove();\n    } else {\n      join.exit().remove();\n    } // text points\n\n\n    selection = text.selectAll('g');\n    join = selection.data(textFilter, keyFunc); // each text needs to go in its own 'g' in case\n    // it gets converted to mathjax\n\n    join.enter().append('g').classed('textpoint', true).append('text');\n    join.order();\n    join.each(function (d) {\n      var g = d3.select(this);\n      var sel = transition(g.select('text'));\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n      if (hasNode) {\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n      } else {\n        g.remove();\n      }\n    });\n    join.selectAll('text').call(Drawing.textPointStyle, trace, gd).each(function (d) {\n      // This just *has* to be totally custom becuase of SVG text positioning :(\n      // It's obviously copied from translatePoint; we just can't use that\n      var x = xa.c2p(d.x);\n      var y = ya.c2p(d.y);\n      d3.select(this).selectAll('tspan.line').each(function () {\n        transition(d3.select(this)).attr({\n          x: x,\n          y: y\n        });\n      });\n    });\n    join.exit().remove();\n  }\n\n  points.datum(cdscatter);\n  text.datum(cdscatter);\n  makePoints(points, text, cdscatter); // lastly, clip points groups of `cliponaxis !== false` traces\n  // on `plotinfo._hasClipOnAxisFalse === true` subplots\n\n  var hasClipOnAxisFalse = trace.cliponaxis === false;\n  var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n  Drawing.setClipUrl(points, clipUrl, gd);\n  Drawing.setClipUrl(text, clipUrl, gd);\n}\n\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n  var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n  var trace = cdscatter[0].trace;\n  if (!subTypes.hasMarkers(trace)) return; // if marker.maxdisplayed is used, select a maximum of\n  // mnum markers to show, from the set that are in the viewport\n\n  var mnum = trace.marker.maxdisplayed; // TODO: remove some as we get away from the viewport?\n\n  if (mnum === 0) return;\n  var cd = cdscatter.filter(function (v) {\n    return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n  });\n  var inc = Math.ceil(cd.length / mnum);\n  var tnum = 0;\n  cdscatterAll.forEach(function (cdj, j) {\n    var tracei = cdj[0].trace;\n\n    if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {\n      tnum++;\n    }\n  }); // if multiple traces use maxdisplayed, stagger which markers we\n  // display this formula offsets successive traces by 1/3 of the\n  // increment, adding an extra small amount after each triplet so\n  // it's not quite periodic\n\n  var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1); // for error bars: save in cd which markers to show\n  // so we don't have to repeat this\n\n  cdscatter.forEach(function (v) {\n    delete v.vis;\n  });\n  cd.forEach(function (v, i) {\n    if (Math.round((i + i0) % inc) === 0) v.vis = true;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}