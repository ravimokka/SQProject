{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../registry');\n\nvar Plots = require('../plots/plots');\n\nvar Lib = require('../lib');\n\nvar clearGlCanvases = require('../lib/clear_gl_canvases');\n\nvar Color = require('../components/color');\n\nvar Drawing = require('../components/drawing');\n\nvar Titles = require('../components/titles');\n\nvar ModeBar = require('../components/modebar');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar alignmentConstants = require('../constants/alignment');\n\nvar axisConstraints = require('../plots/cartesian/constraints');\n\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\n\nvar doAutoRange = require('../plots/cartesian/autorange').doAutoRange;\n\nvar SVG_TEXT_ANCHOR_START = 'start';\nvar SVG_TEXT_ANCHOR_MIDDLE = 'middle';\nvar SVG_TEXT_ANCHOR_END = 'end';\n\nexports.layoutStyles = function (gd) {\n  return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);\n};\n\nfunction overlappingDomain(xDomain, yDomain, domains) {\n  for (var i = 0; i < domains.length; i++) {\n    var existingX = domains[i][0];\n    var existingY = domains[i][1];\n\n    if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n      continue;\n    }\n\n    if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction lsInner(gd) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var pad = gs.p;\n  var axList = Axes.list(gd, '', true);\n  var i, subplot, plotinfo, ax, xa, ya;\n\n  fullLayout._paperdiv.style({\n    width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? '100%' : fullLayout.width + 'px',\n    height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? '100%' : fullLayout.height + 'px'\n  }).selectAll('.main-svg').call(Drawing.setSize, fullLayout.width, fullLayout.height);\n\n  gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n\n  exports.drawMainTitle(gd);\n  ModeBar.manage(gd); // _has('cartesian') means SVG specifically, not GL2D - but GL2D\n  // can still get here because it makes some of the SVG structure\n  // for shared features like selections.\n\n  if (!fullLayout._has('cartesian')) {\n    return Plots.previousPromises(gd);\n  }\n\n  function getLinePosition(ax, counterAx, side) {\n    var lwHalf = ax._lw / 2;\n\n    if (ax._id.charAt(0) === 'x') {\n      if (!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + lwHalf % 1;else if (side === 'top') return counterAx._offset - pad - lwHalf;\n      return counterAx._offset + counterAx._length + pad + lwHalf;\n    }\n\n    if (!counterAx) return gs.l + gs.w * (ax.position || 0) + lwHalf % 1;else if (side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;\n    return counterAx._offset - pad - lwHalf;\n  } // some preparation of axis position info\n\n\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    var counterAx = ax._anchorAxis; // clear axis line positions, to be set in the subplot loop below\n\n    ax._linepositions = {}; // stash crispRounded linewidth so we don't need to pass gd all over the place\n\n    ax._lw = Drawing.crispRound(gd, ax.linewidth, 1); // figure out the main axis line and main mirror line position.\n    // it's easier to follow the logic if we handle these separately from\n    // ax._linepositions, which are only used by mirror=allticks\n    // for non-main-subplot ticks, and mirror=all(ticks)? for zero line\n    // hiding logic\n\n    ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);\n    ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(ax, counterAx, alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;\n  } // figure out which backgrounds we need to draw,\n  // and in which layers to put them\n\n\n  var lowerBackgroundIDs = [];\n  var backgroundIds = [];\n  var lowerDomains = []; // no need to draw background when paper and plot color are the same color,\n  // activate mode just for large splom (which benefit the most from this\n  // optimization), but this could apply to all cartesian subplots.\n\n  var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;\n\n  for (subplot in fullLayout._plots) {\n    plotinfo = fullLayout._plots[subplot];\n\n    if (plotinfo.mainplot) {\n      // mainplot is a reference to the main plot this one is overlaid on\n      // so if it exists, this is an overlaid plot and we don't need to\n      // give it its own background\n      if (plotinfo.bg) {\n        plotinfo.bg.remove();\n      }\n\n      plotinfo.bg = undefined;\n    } else {\n      var xDomain = plotinfo.xaxis.domain;\n      var yDomain = plotinfo.yaxis.domain;\n      var plotgroup = plotinfo.plotgroup;\n\n      if (overlappingDomain(xDomain, yDomain, lowerDomains)) {\n        var pgNode = plotgroup.node();\n        var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');\n        pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);\n        backgroundIds.push(subplot);\n      } else {\n        plotgroup.select('rect.bg').remove();\n        lowerDomains.push([xDomain, yDomain]);\n\n        if (!noNeedForBg) {\n          lowerBackgroundIDs.push(subplot);\n          backgroundIds.push(subplot);\n        }\n      }\n    }\n  } // now create all the lower-layer backgrounds at once now that\n  // we have the list of subplots that need them\n\n\n  var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg').data(lowerBackgroundIDs);\n\n  lowerBackgrounds.enter().append('rect').classed('bg', true);\n  lowerBackgrounds.exit().remove();\n  lowerBackgrounds.each(function (subplot) {\n    fullLayout._plots[subplot].bg = d3.select(this);\n  }); // style all backgrounds\n\n  for (i = 0; i < backgroundIds.length; i++) {\n    plotinfo = fullLayout._plots[backgroundIds[i]];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n\n    if (plotinfo.bg) {\n      plotinfo.bg.call(Drawing.setRect, xa._offset - pad, ya._offset - pad, xa._length + 2 * pad, ya._length + 2 * pad).call(Color.fill, fullLayout.plot_bgcolor).style('stroke-width', 0);\n    }\n  }\n\n  if (!fullLayout._hasOnlyLargeSploms) {\n    for (subplot in fullLayout._plots) {\n      plotinfo = fullLayout._plots[subplot];\n      xa = plotinfo.xaxis;\n      ya = plotinfo.yaxis; // Clip so that data only shows up on the plot area.\n\n      var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n      var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function (s) {\n        s.classed('plotclip', true).append('rect');\n      });\n      plotinfo.clipRect = plotClip.select('rect').attr({\n        width: xa._length,\n        height: ya._length\n      });\n      Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);\n      var plotClipId;\n      var layerClipId;\n\n      if (plotinfo._hasClipOnAxisFalse) {\n        plotClipId = null;\n        layerClipId = clipId;\n      } else {\n        plotClipId = clipId;\n        layerClipId = null;\n      }\n\n      Drawing.setClipUrl(plotinfo.plot, plotClipId, gd); // stash layer clipId value (null or same as clipId)\n      // to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n      // downstream\n\n      plotinfo.layerClipId = layerClipId;\n    }\n  }\n\n  var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;\n  var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;\n  var extraSubplot;\n\n  function xLinePath(y) {\n    return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;\n  }\n\n  function xLinePathFree(y) {\n    return 'M' + xa._offset + ',' + y + 'h' + xa._length;\n  }\n\n  function yLinePath(x) {\n    return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;\n  }\n\n  function yLinePathFree(x) {\n    return 'M' + x + ',' + ya._offset + 'v' + ya._length;\n  }\n\n  function mainPath(ax, pathFn, pathFnFree) {\n    if (!ax.showline || subplot !== ax._mainSubplot) return '';\n    if (!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);\n    var out = pathFn(ax._mainLinePosition);\n    if (ax.mirror) out += pathFn(ax._mainMirrorPosition);\n    return out;\n  }\n\n  for (subplot in fullLayout._plots) {\n    plotinfo = fullLayout._plots[subplot];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n    /*\n     * x lines get longer where they meet y lines, to make a crisp corner.\n     * The x lines get the padding (margin.pad) plus the y line width to\n     * fill up the corner nicely. Free x lines are excluded - they always\n     * span exactly the data area of the plot\n     *\n     *  | XXXXX\n     *  | XXXXX\n     *  |\n     *  +------\n     *     x1\n     *    -----\n     *     x2\n     */\n\n    var xPath = 'M0,0';\n\n    if (shouldShowLinesOrTicks(xa, subplot)) {\n      leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);\n      xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);\n      rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);\n      xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);\n      xLinesYBottom = getLinePosition(xa, ya, 'bottom');\n      xLinesYTop = getLinePosition(xa, ya, 'top'); // save axis line positions for extra ticks to reference\n      // each subplot that gets ticks from \"allticks\" gets an entry:\n      //    [left or bottom, right or top]\n\n      extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;\n\n      if (extraSubplot && (xa.mirror === 'allticks' || xa.mirror === 'all')) {\n        xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];\n      }\n\n      xPath = mainPath(xa, xLinePath, xLinePathFree);\n\n      if (extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {\n        xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);\n      }\n\n      plotinfo.xlines.style('stroke-width', xa._lw + 'px').call(Color.stroke, xa.showline ? xa.linecolor : 'rgba(0,0,0,0)');\n    }\n\n    plotinfo.xlines.attr('d', xPath);\n    /*\n     * y lines that meet x axes get longer only by margin.pad, because\n     * the x axes fill in the corner space. Free y axes, like free x axes,\n     * always span exactly the data area of the plot\n     *\n     *   |   | XXXX\n     * y2| y1| XXXX\n     *   |   | XXXX\n     *       |\n     *       +-----\n     */\n\n    var yPath = 'M0,0';\n\n    if (shouldShowLinesOrTicks(ya, subplot)) {\n      connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);\n      yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);\n      connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);\n      yLinesYTop = ya._offset - (connectYTop ? pad : 0);\n      yLinesXLeft = getLinePosition(ya, xa, 'left');\n      yLinesXRight = getLinePosition(ya, xa, 'right');\n      extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;\n\n      if (extraSubplot && (ya.mirror === 'allticks' || ya.mirror === 'all')) {\n        ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];\n      }\n\n      yPath = mainPath(ya, yLinePath, yLinePathFree);\n\n      if (extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {\n        yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);\n      }\n\n      plotinfo.ylines.style('stroke-width', ya._lw + 'px').call(Color.stroke, ya.showline ? ya.linecolor : 'rgba(0,0,0,0)');\n    }\n\n    plotinfo.ylines.attr('d', yPath);\n  }\n\n  Axes.makeClipPaths(gd);\n  return Plots.previousPromises(gd);\n}\n\nfunction shouldShowLinesOrTicks(ax, subplot) {\n  return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');\n}\n/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */\n\n\nfunction shouldShowLineThisSide(ax, side, counterAx) {\n  // does counterAx get a line at all?\n  if (!counterAx.showline || !counterAx._lw) return false; // are we drawing *all* lines for counterAx?\n\n  if (counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;\n  var anchorAx = counterAx._anchorAxis; // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\n\n  if (!anchorAx) return false; // in order to handle cases where the user forgot to anchor this axis correctly\n  // (because its default anchor has the same domain on the relevant end)\n  // check whether the relevant position is the same.\n\n  var sideIndex = alignmentConstants.FROM_BL[side];\n\n  if (counterAx.side === side) {\n    return anchorAx.domain[sideIndex] === ax.domain[sideIndex];\n  }\n\n  return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];\n}\n/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */\n\n\nfunction findCounterAxisLineWidth(ax, side, counterAx, axList) {\n  if (shouldShowLineThisSide(ax, side, counterAx)) {\n    return counterAx._lw;\n  }\n\n  for (var i = 0; i < axList.length; i++) {\n    var axi = axList[i];\n\n    if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {\n      return axi._lw;\n    }\n  }\n\n  return 0;\n}\n\nexports.drawMainTitle = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var textAnchor = getMainTitleTextAnchor(fullLayout);\n  var dy = getMainTitleDy(fullLayout);\n  Titles.draw(gd, 'gtitle', {\n    propContainer: fullLayout,\n    propName: 'title.text',\n    placeholder: fullLayout._dfltTitle.plot,\n    attributes: {\n      x: getMainTitleX(fullLayout, textAnchor),\n      y: getMainTitleY(fullLayout, dy),\n      'text-anchor': textAnchor,\n      dy: dy\n    }\n  });\n};\n\nfunction getMainTitleX(fullLayout, textAnchor) {\n  var title = fullLayout.title;\n  var gs = fullLayout._size;\n  var hPadShift = 0;\n\n  if (textAnchor === SVG_TEXT_ANCHOR_START) {\n    hPadShift = title.pad.l;\n  } else if (textAnchor === SVG_TEXT_ANCHOR_END) {\n    hPadShift = -title.pad.r;\n  }\n\n  switch (title.xref) {\n    case 'paper':\n      return gs.l + gs.w * title.x + hPadShift;\n\n    case 'container':\n    default:\n      return fullLayout.width * title.x + hPadShift;\n  }\n}\n\nfunction getMainTitleY(fullLayout, dy) {\n  var title = fullLayout.title;\n  var gs = fullLayout._size;\n  var vPadShift = 0;\n\n  if (dy === '0em' || !dy) {\n    vPadShift = -title.pad.b;\n  } else if (dy === alignmentConstants.CAP_SHIFT + 'em') {\n    vPadShift = title.pad.t;\n  }\n\n  if (title.y === 'auto') {\n    return gs.t / 2;\n  } else {\n    switch (title.yref) {\n      case 'paper':\n        return gs.t + gs.h - gs.h * title.y + vPadShift;\n\n      case 'container':\n      default:\n        return fullLayout.height - fullLayout.height * title.y + vPadShift;\n    }\n  }\n}\n\nfunction getMainTitleTextAnchor(fullLayout) {\n  var title = fullLayout.title;\n  var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;\n\n  if (Lib.isRightAnchor(title)) {\n    textAnchor = SVG_TEXT_ANCHOR_END;\n  } else if (Lib.isLeftAnchor(title)) {\n    textAnchor = SVG_TEXT_ANCHOR_START;\n  }\n\n  return textAnchor;\n}\n\nfunction getMainTitleDy(fullLayout) {\n  var title = fullLayout.title;\n  var dy = '0em';\n\n  if (Lib.isTopAnchor(title)) {\n    dy = alignmentConstants.CAP_SHIFT + 'em';\n  } else if (Lib.isMiddleAnchor(title)) {\n    dy = alignmentConstants.MID_SHIFT + 'em';\n  }\n\n  return dy;\n}\n\nexports.doTraceStyle = function (gd) {\n  var calcdata = gd.calcdata;\n  var editStyleCalls = [];\n  var i;\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0] || {};\n    var trace = cd0.trace || {};\n\n    var _module = trace._module || {}; // See if we need to do arraysToCalcdata\n    // call it regardless of what change we made, in case\n    // supplyDefaults brought in an array that was already\n    // in gd.data but not in gd._fullData previously\n\n\n    var arraysToCalcdata = _module.arraysToCalcdata;\n    if (arraysToCalcdata) arraysToCalcdata(cd, trace);\n    var editStyle = _module.editStyle;\n    if (editStyle) editStyleCalls.push({\n      fn: editStyle,\n      cd0: cd0\n    });\n  }\n\n  if (editStyleCalls.length) {\n    for (i = 0; i < editStyleCalls.length; i++) {\n      var edit = editStyleCalls[i];\n      edit.fn(gd, edit.cd0);\n    }\n\n    clearGlCanvases(gd);\n    exports.redrawReglTraces(gd);\n  }\n\n  Plots.style(gd);\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\n\nexports.doColorBars = function (gd) {\n  Registry.getComponentMethod('colorbar', 'draw')(gd);\n  return Plots.previousPromises(gd);\n}; // force plot() to redo the layout and replot with the modified layout\n\n\nexports.layoutReplot = function (gd) {\n  var layout = gd.layout;\n  gd.layout = undefined;\n  return Registry.call('plot', gd, '', layout);\n};\n\nexports.doLegend = function (gd) {\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\n\nexports.doTicksRelayout = function (gd) {\n  Axes.draw(gd, 'redraw');\n\n  if (gd._fullLayout._hasOnlyLargeSploms) {\n    Registry.subplotsRegistry.splom.updateGrid(gd);\n    clearGlCanvases(gd);\n    exports.redrawReglTraces(gd);\n  }\n\n  exports.drawMainTitle(gd);\n  return Plots.previousPromises(gd);\n};\n\nexports.doModeBar = function (gd) {\n  var fullLayout = gd._fullLayout;\n  ModeBar.manage(gd);\n\n  for (var i = 0; i < fullLayout._basePlotModules.length; i++) {\n    var updateFx = fullLayout._basePlotModules[i].updateFx;\n    if (updateFx) updateFx(gd);\n  }\n\n  return Plots.previousPromises(gd);\n};\n\nexports.doCamera = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var sceneIds = fullLayout._subplots.gl3d;\n\n  for (var i = 0; i < sceneIds.length; i++) {\n    var sceneLayout = fullLayout[sceneIds[i]];\n    var scene = sceneLayout._scene;\n    scene.setViewport(sceneLayout);\n  }\n};\n\nexports.drawData = function (gd) {\n  var fullLayout = gd._fullLayout;\n  clearGlCanvases(gd); // loop over the base plot modules present on graph\n\n  var basePlotModules = fullLayout._basePlotModules;\n\n  for (var i = 0; i < basePlotModules.length; i++) {\n    basePlotModules[i].plot(gd);\n  }\n\n  exports.redrawReglTraces(gd); // styling separate from drawing\n\n  Plots.style(gd); // draw components that can be drawn on axes,\n  // and that do not push the margins\n\n  Registry.getComponentMethod('shapes', 'draw')(gd);\n  Registry.getComponentMethod('annotations', 'draw')(gd);\n  Registry.getComponentMethod('images', 'draw')(gd); // Mark the first render as complete\n\n  fullLayout._replotting = false;\n  return Plots.previousPromises(gd);\n}; // Draw (or redraw) all regl-based traces in one go,\n// useful during drag and selection where buffers of targeted traces are updated,\n// but all traces need to be redrawn following clearGlCanvases.\n//\n// Note that _module.plot for regl trace does NOT draw things\n// on the canvas, they only update the buffers.\n// Drawing is perform here.\n//\n// TODO try adding per-subplot option using gl.SCISSOR_TEST for\n// non-overlaying, disjoint subplots.\n//\n// TODO try to include parcoords in here.\n// https://github.com/plotly/plotly.js/issues/3069\n\n\nexports.redrawReglTraces = function (gd) {\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._has('regl')) {\n    var fullData = gd._fullData;\n    var cartesianIds = [];\n    var polarIds = [];\n    var i, sp;\n\n    if (fullLayout._hasOnlyLargeSploms) {\n      fullLayout._splomGrid.draw();\n    } // N.B.\n    // - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering\n    // - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces\n    //   of a given module are `visible !== true`\n\n\n    for (i = 0; i < fullData.length; i++) {\n      var trace = fullData[i];\n\n      if (trace.visible === true && trace._length !== 0) {\n        if (trace.type === 'splom') {\n          fullLayout._splomScenes[trace.uid].draw();\n        } else if (trace.type === 'scattergl') {\n          Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);\n        } else if (trace.type === 'scatterpolargl') {\n          Lib.pushUnique(polarIds, trace.subplot);\n        }\n      }\n    }\n\n    for (i = 0; i < cartesianIds.length; i++) {\n      sp = fullLayout._plots[cartesianIds[i]];\n      if (sp._scene) sp._scene.draw();\n    }\n\n    for (i = 0; i < polarIds.length; i++) {\n      sp = fullLayout[polarIds[i]]._subplot;\n      if (sp._scene) sp._scene.draw();\n    }\n  }\n};\n\nexports.doAutoRangeAndConstraints = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var axList = Axes.list(gd, '', true);\n  var matchGroups = fullLayout._axisMatchGroups || [];\n  var ax;\n  var axRng;\n\n  for (var i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    cleanAxisConstraints(gd, ax);\n    doAutoRange(gd, ax);\n  }\n\n  enforceAxisConstraints(gd);\n\n  groupLoop: for (var j = 0; j < matchGroups.length; j++) {\n    var group = matchGroups[j];\n    var rng = null;\n    var id;\n\n    for (id in group) {\n      ax = Axes.getFromId(gd, id);\n      if (ax.autorange === false) continue groupLoop;\n      axRng = Lib.simpleMap(ax.range, ax.r2l);\n\n      if (rng) {\n        if (rng[0] < rng[1]) {\n          rng[0] = Math.min(rng[0], axRng[0]);\n          rng[1] = Math.max(rng[1], axRng[1]);\n        } else {\n          rng[0] = Math.max(rng[0], axRng[0]);\n          rng[1] = Math.min(rng[1], axRng[1]);\n        }\n      } else {\n        rng = axRng;\n      }\n    }\n\n    for (id in group) {\n      ax = Axes.getFromId(gd, id);\n      ax.range = Lib.simpleMap(rng, ax.l2r);\n      ax._input.range = ax.range.slice();\n      ax.setScale();\n    }\n  }\n}; // An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\n\n\nexports.finalDraw = function (gd) {\n  // TODO: rangesliders really belong in marginPushers but they need to be\n  // drawn after data - can we at least get the margin pushing part separated\n  // out and done earlier?\n  Registry.getComponentMethod('rangeslider', 'draw')(gd); // TODO: rangeselector only needs to be here (in addition to drawMarginPushers)\n  // because the margins need to be fully determined before we can call\n  // autorange and update axis ranges (which rangeselector needs to know which\n  // button is active). Can we break out its automargin step from its draw step?\n\n  Registry.getComponentMethod('rangeselector', 'draw')(gd);\n};\n\nexports.drawMarginPushers = function (gd) {\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  Registry.getComponentMethod('rangeselector', 'draw')(gd);\n  Registry.getComponentMethod('sliders', 'draw')(gd);\n  Registry.getComponentMethod('updatemenus', 'draw')(gd);\n  Registry.getComponentMethod('colorbar', 'draw')(gd);\n};","map":null,"metadata":{},"sourceType":"script"}