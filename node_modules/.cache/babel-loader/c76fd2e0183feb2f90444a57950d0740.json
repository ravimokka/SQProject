{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar calc = require('./calc');\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var subplot = xa._id + ya._id;\n  var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n  if (!subplotStackOpts) return;\n  var calcTraces = gd.calcdata;\n  var i, j, k, i2, cd, cd0, posj, sumj, norm;\n  var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n  var hasAnyBlanks;\n\n  for (var stackGroup in subplotStackOpts) {\n    groupOpts = subplotStackOpts[stackGroup];\n    var indices = groupOpts.traceIndices; // can get here with no indices if the stack axis is non-numeric\n\n    if (!indices.length) continue;\n    interpolate = groupOpts.stackgaps === 'interpolate';\n    groupnorm = groupOpts.groupnorm;\n\n    if (groupOpts.orientation === 'v') {\n      posAttr = 'x';\n      valAttr = 'y';\n    } else {\n      posAttr = 'y';\n      valAttr = 'x';\n    }\n\n    hasAnyBlanks = new Array(indices.length);\n\n    for (i = 0; i < hasAnyBlanks.length; i++) {\n      hasAnyBlanks[i] = false;\n    } // Collect the complete set of all positions across ALL traces.\n    // Start with the first trace, then interleave items from later traces\n    // as needed.\n    // Fill in mising items as we go.\n\n\n    cd0 = calcTraces[indices[0]];\n    var allPositions = new Array(cd0.length);\n\n    for (i = 0; i < cd0.length; i++) {\n      allPositions[i] = cd0[i][posAttr];\n    }\n\n    for (i = 1; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n\n      for (j = k = 0; j < cd.length; j++) {\n        posj = cd[j][posAttr];\n\n        for (; posj > allPositions[k] && k < allPositions.length; k++) {\n          // the current trace is missing a position from some previous trace(s)\n          insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n          j++;\n        }\n\n        if (posj !== allPositions[k]) {\n          // previous trace(s) are missing a position from the current trace\n          for (i2 = 0; i2 < i; i2++) {\n            insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n          }\n\n          allPositions.splice(k, 0, posj);\n        }\n\n        k++;\n      }\n\n      for (; k < allPositions.length; k++) {\n        insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n        j++;\n      }\n    }\n\n    var serieslen = allPositions.length; // stack (and normalize)!\n\n    for (j = 0; j < cd0.length; j++) {\n      sumj = cd0[j][valAttr] = cd0[j].s;\n\n      for (i = 1; i < indices.length; i++) {\n        cd = calcTraces[indices[i]];\n        cd[0].trace._rawLength = cd[0].trace._length;\n        cd[0].trace._length = serieslen;\n        sumj += cd[j].s;\n        cd[j][valAttr] = sumj;\n      }\n\n      if (groupnorm) {\n        norm = (groupnorm === 'fraction' ? sumj : sumj / 100) || 1;\n\n        for (i = 0; i < indices.length; i++) {\n          var cdj = calcTraces[indices[i]][j];\n          cdj[valAttr] /= norm;\n          cdj.sNorm = cdj.s / norm;\n        }\n      }\n    } // autorange\n\n\n    for (i = 0; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n      var trace = cd[0].trace;\n      var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n      var arrayPad = Array.isArray(ppad);\n\n      if (ppad && hasAnyBlanks[i] || arrayPad) {\n        var ppadRaw = ppad;\n        ppad = new Array(serieslen);\n\n        for (j = 0; j < serieslen; j++) {\n          ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;\n        }\n      }\n\n      var x = new Array(serieslen);\n      var y = new Array(serieslen);\n\n      for (j = 0; j < serieslen; j++) {\n        x[j] = cd[j].x;\n        y[j] = cd[j].y;\n      }\n\n      calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad); // while we're here (in a loop over all traces in the stack)\n      // record the orientation, so hover can find it easily\n\n      cd[0].t.orientation = groupOpts.orientation;\n    }\n  }\n};\n\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n  hasAnyBlanks[traceIndex] = true;\n  var newEntry = {\n    i: null,\n    gap: true,\n    s: 0\n  };\n  newEntry[posAttr] = position;\n  calcTrace.splice(index, 0, newEntry); // Even if we're not interpolating, if one trace has multiple\n  // values at the same position and this trace only has one value there,\n  // we just duplicate that one value rather than insert a zero.\n  // We also make it look like a real point - because it's ambiguous which\n  // one really is the real one!\n\n  if (index && position === calcTrace[index - 1][posAttr]) {\n    var prevEntry = calcTrace[index - 1];\n    newEntry.s = prevEntry.s; // TODO is it going to cause any problems to have multiple\n    // calcdata points with the same index?\n\n    newEntry.i = prevEntry.i;\n    newEntry.gap = prevEntry.gap;\n  } else if (interpolate) {\n    newEntry.s = getInterp(calcTrace, index, position, posAttr);\n  }\n\n  if (!index) {\n    // t and trace need to stay on the first cd entry\n    calcTrace[0].t = calcTrace[1].t;\n    calcTrace[0].trace = calcTrace[1].trace;\n    delete calcTrace[1].t;\n    delete calcTrace[1].trace;\n  }\n}\n\nfunction getInterp(calcTrace, index, position, posAttr) {\n  var pt0 = calcTrace[index - 1];\n  var pt1 = calcTrace[index + 1];\n  if (!pt1) return pt0.s;\n  if (!pt0) return pt1.s;\n  return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}","map":null,"metadata":{},"sourceType":"script"}