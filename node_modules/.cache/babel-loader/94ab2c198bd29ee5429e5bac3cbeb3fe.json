{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nmodule.exports = ScrollBox;\n\nvar d3 = require('d3');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Lib = require('../../lib');\n/**\n * Helper class to setup a scroll box\n *\n * @class\n * @param           gd          Plotly's graph div\n * @param           container   Container to be scroll-boxed (as a D3 selection)\n * @param {string}  id          Id for the clip path to implement the scroll box\n */\n\n\nfunction ScrollBox(gd, container, id) {\n  this.gd = gd;\n  this.container = container;\n  this.id = id; // See ScrollBox.prototype.enable for further definition\n\n  this.position = null; // scrollbox position\n\n  this.translateX = null; // scrollbox horizontal translation\n\n  this.translateY = null; // scrollbox vertical translation\n\n  this.hbar = null; // horizontal scrollbar D3 selection\n\n  this.vbar = null; // vertical scrollbar D3 selection\n  // <rect> element to capture pointer events\n\n  this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);\n  this.bg.exit().on('.drag', null).on('wheel', null).remove();\n  this.bg.enter().append('rect').classed('scrollbox-bg', true).style('pointer-events', 'all').attr({\n    opacity: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  });\n} // scroll bar dimensions\n\n\nScrollBox.barWidth = 2;\nScrollBox.barLength = 20;\nScrollBox.barRadius = 2;\nScrollBox.barPad = 1;\nScrollBox.barColor = '#808BA4';\n/**\n * If needed, setup a clip path and scrollbars\n *\n * @method\n * @param {Object}  position\n * @param {number}  position.l  Left side position (in pixels)\n * @param {number}  position.t  Top side (in pixels)\n * @param {number}  position.w  Width (in pixels)\n * @param {number}  position.h  Height (in pixels)\n * @param {string}  [position.direction='down']\n *                  Either 'down', 'left', 'right' or 'up'\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */\n\nScrollBox.prototype.enable = function enable(position, translateX, translateY) {\n  var fullLayout = this.gd._fullLayout;\n  var fullWidth = fullLayout.width;\n  var fullHeight = fullLayout.height; // compute position of scrollbox\n\n  this.position = position;\n  var l = this.position.l;\n  var w = this.position.w;\n  var t = this.position.t;\n  var h = this.position.h;\n  var direction = this.position.direction;\n  var isDown = direction === 'down';\n  var isLeft = direction === 'left';\n  var isRight = direction === 'right';\n  var isUp = direction === 'up';\n  var boxW = w;\n  var boxH = h;\n  var boxL, boxR;\n  var boxT, boxB;\n\n  if (!isDown && !isLeft && !isRight && !isUp) {\n    this.position.direction = 'down';\n    isDown = true;\n  }\n\n  var isVertical = isDown || isUp;\n\n  if (isVertical) {\n    boxL = l;\n    boxR = boxL + boxW;\n\n    if (isDown) {\n      // anchor to top side\n      boxT = t;\n      boxB = Math.min(boxT + boxH, fullHeight);\n      boxH = boxB - boxT;\n    } else {\n      // anchor to bottom side\n      boxB = t + boxH;\n      boxT = Math.max(boxB - boxH, 0);\n      boxH = boxB - boxT;\n    }\n  } else {\n    boxT = t;\n    boxB = boxT + boxH;\n\n    if (isLeft) {\n      // anchor to right side\n      boxR = l + boxW;\n      boxL = Math.max(boxR - boxW, 0);\n      boxW = boxR - boxL;\n    } else {\n      // anchor to left side\n      boxL = l;\n      boxR = Math.min(boxL + boxW, fullWidth);\n      boxW = boxR - boxL;\n    }\n  }\n\n  this._box = {\n    l: boxL,\n    t: boxT,\n    w: boxW,\n    h: boxH\n  }; // compute position of horizontal scroll bar\n\n  var needsHorizontalScrollBar = w > boxW;\n  var hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad;\n  var hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad; // draw horizontal scrollbar on the bottom side\n\n  var hbarL = l;\n  var hbarT = t + h;\n  if (hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;\n  var hbar = this.container.selectAll('rect.scrollbar-horizontal').data(needsHorizontalScrollBar ? [0] : []);\n  hbar.exit().on('.drag', null).remove();\n  hbar.enter().append('rect').classed('scrollbar-horizontal', true).call(Color.fill, ScrollBox.barColor);\n\n  if (needsHorizontalScrollBar) {\n    this.hbar = hbar.attr({\n      'rx': ScrollBox.barRadius,\n      'ry': ScrollBox.barRadius,\n      'x': hbarL,\n      'y': hbarT,\n      'width': hbarW,\n      'height': hbarH\n    }); // hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax\n\n    this._hbarXMin = hbarL + hbarW / 2;\n    this._hbarTranslateMax = boxW - hbarW;\n  } else {\n    delete this.hbar;\n    delete this._hbarXMin;\n    delete this._hbarTranslateMax;\n  } // compute position of vertical scroll bar\n\n\n  var needsVerticalScrollBar = h > boxH;\n  var vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad;\n  var vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad; // draw vertical scrollbar on the right side\n\n  var vbarL = l + w;\n  var vbarT = t;\n  if (vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;\n  var vbar = this.container.selectAll('rect.scrollbar-vertical').data(needsVerticalScrollBar ? [0] : []);\n  vbar.exit().on('.drag', null).remove();\n  vbar.enter().append('rect').classed('scrollbar-vertical', true).call(Color.fill, ScrollBox.barColor);\n\n  if (needsVerticalScrollBar) {\n    this.vbar = vbar.attr({\n      'rx': ScrollBox.barRadius,\n      'ry': ScrollBox.barRadius,\n      'x': vbarL,\n      'y': vbarT,\n      'width': vbarW,\n      'height': vbarH\n    }); // vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax\n\n    this._vbarYMin = vbarT + vbarH / 2;\n    this._vbarTranslateMax = boxH - vbarH;\n  } else {\n    delete this.vbar;\n    delete this._vbarYMin;\n    delete this._vbarTranslateMax;\n  } // setup a clip path (if scroll bars are needed)\n\n\n  var clipId = this.id;\n  var clipL = boxL - 0.5;\n  var clipR = needsVerticalScrollBar ? boxR + vbarW + 0.5 : boxR + 0.5;\n  var clipT = boxT - 0.5;\n  var clipB = needsHorizontalScrollBar ? boxB + hbarH + 0.5 : boxB + 0.5;\n\n  var clipPath = fullLayout._topdefs.selectAll('#' + clipId).data(needsHorizontalScrollBar || needsVerticalScrollBar ? [0] : []);\n\n  clipPath.exit().remove();\n  clipPath.enter().append('clipPath').attr('id', clipId).append('rect');\n\n  if (needsHorizontalScrollBar || needsVerticalScrollBar) {\n    this._clipRect = clipPath.select('rect').attr({\n      x: Math.floor(clipL),\n      y: Math.floor(clipT),\n      width: Math.ceil(clipR) - Math.floor(clipL),\n      height: Math.ceil(clipB) - Math.floor(clipT)\n    });\n    this.container.call(Drawing.setClipUrl, clipId, this.gd);\n    this.bg.attr({\n      x: l,\n      y: t,\n      width: w,\n      height: h\n    });\n  } else {\n    this.bg.attr({\n      width: 0,\n      height: 0\n    });\n    this.container.on('wheel', null).on('.drag', null).call(Drawing.setClipUrl, null);\n    delete this._clipRect;\n  } // set up drag listeners (if scroll bars are needed)\n\n\n  if (needsHorizontalScrollBar || needsVerticalScrollBar) {\n    var onBoxDrag = d3.behavior.drag().on('dragstart', function () {\n      d3.event.sourceEvent.preventDefault();\n    }).on('drag', this._onBoxDrag.bind(this));\n    this.container.on('wheel', null).on('wheel', this._onBoxWheel.bind(this)).on('.drag', null).call(onBoxDrag);\n    var onBarDrag = d3.behavior.drag().on('dragstart', function () {\n      d3.event.sourceEvent.preventDefault();\n      d3.event.sourceEvent.stopPropagation();\n    }).on('drag', this._onBarDrag.bind(this));\n\n    if (needsHorizontalScrollBar) {\n      this.hbar.on('.drag', null).call(onBarDrag);\n    }\n\n    if (needsVerticalScrollBar) {\n      this.vbar.on('.drag', null).call(onBarDrag);\n    }\n  } // set scrollbox translation\n\n\n  this.setTranslate(translateX, translateY);\n};\n/**\n * If present, remove clip-path and scrollbars\n *\n * @method\n */\n\n\nScrollBox.prototype.disable = function disable() {\n  if (this.hbar || this.vbar) {\n    this.bg.attr({\n      width: 0,\n      height: 0\n    });\n    this.container.on('wheel', null).on('.drag', null).call(Drawing.setClipUrl, null);\n    delete this._clipRect;\n  }\n\n  if (this.hbar) {\n    this.hbar.on('.drag', null);\n    this.hbar.remove();\n    delete this.hbar;\n    delete this._hbarXMin;\n    delete this._hbarTranslateMax;\n  }\n\n  if (this.vbar) {\n    this.vbar.on('.drag', null);\n    this.vbar.remove();\n    delete this.vbar;\n    delete this._vbarYMin;\n    delete this._vbarTranslateMax;\n  }\n};\n/**\n * Handles scroll box drag events\n *\n * @method\n */\n\n\nScrollBox.prototype._onBoxDrag = function _onBoxDrag() {\n  var translateX = this.translateX;\n  var translateY = this.translateY;\n\n  if (this.hbar) {\n    translateX -= d3.event.dx;\n  }\n\n  if (this.vbar) {\n    translateY -= d3.event.dy;\n  }\n\n  this.setTranslate(translateX, translateY);\n};\n/**\n * Handles scroll box wheel events\n *\n * @method\n */\n\n\nScrollBox.prototype._onBoxWheel = function _onBoxWheel() {\n  var translateX = this.translateX;\n  var translateY = this.translateY;\n\n  if (this.hbar) {\n    translateX += d3.event.deltaY;\n  }\n\n  if (this.vbar) {\n    translateY += d3.event.deltaY;\n  }\n\n  this.setTranslate(translateX, translateY);\n};\n/**\n * Handles scroll bar drag events\n *\n * @method\n */\n\n\nScrollBox.prototype._onBarDrag = function _onBarDrag() {\n  var translateX = this.translateX;\n  var translateY = this.translateY;\n\n  if (this.hbar) {\n    var xMin = translateX + this._hbarXMin;\n    var xMax = xMin + this._hbarTranslateMax;\n    var x = Lib.constrain(d3.event.x, xMin, xMax);\n    var xf = (x - xMin) / (xMax - xMin);\n    var translateXMax = this.position.w - this._box.w;\n    translateX = xf * translateXMax;\n  }\n\n  if (this.vbar) {\n    var yMin = translateY + this._vbarYMin;\n    var yMax = yMin + this._vbarTranslateMax;\n    var y = Lib.constrain(d3.event.y, yMin, yMax);\n    var yf = (y - yMin) / (yMax - yMin);\n    var translateYMax = this.position.h - this._box.h;\n    translateY = yf * translateYMax;\n  }\n\n  this.setTranslate(translateX, translateY);\n};\n/**\n * Set clip path and scroll bar translate transform\n *\n * @method\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */\n\n\nScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {\n  // store translateX and translateY (needed by mouse event handlers)\n  var translateXMax = this.position.w - this._box.w;\n  var translateYMax = this.position.h - this._box.h;\n  translateX = Lib.constrain(translateX || 0, 0, translateXMax);\n  translateY = Lib.constrain(translateY || 0, 0, translateYMax);\n  this.translateX = translateX;\n  this.translateY = translateY;\n  this.container.call(Drawing.setTranslate, this._box.l - this.position.l - translateX, this._box.t - this.position.t - translateY);\n\n  if (this._clipRect) {\n    this._clipRect.attr({\n      x: Math.floor(this.position.l + translateX - 0.5),\n      y: Math.floor(this.position.t + translateY - 0.5)\n    });\n  }\n\n  if (this.hbar) {\n    var xf = translateX / translateXMax;\n    this.hbar.call(Drawing.setTranslate, translateX + xf * this._hbarTranslateMax, translateY);\n  }\n\n  if (this.vbar) {\n    var yf = translateY / translateYMax;\n    this.vbar.call(Drawing.setTranslate, translateX, translateY + yf * this._vbarTranslateMax);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}