{"ast":null,"code":"import bbox from \"./bbox\";\nexport default function (topology, n) {\n  if (!((n = Math.floor(n)) >= 2)) throw new Error(\"n must be ≥2\");\n  if (topology.transform) throw new Error(\"already quantized\");\n  var bb = bbox(topology),\n      name,\n      dx = bb[0],\n      kx = (bb[2] - dx) / (n - 1) || 1,\n      dy = bb[1],\n      ky = (bb[3] - dy) / (n - 1) || 1;\n\n  function quantizePoint(p) {\n    p[0] = Math.round((p[0] - dx) / kx);\n    p[1] = Math.round((p[1] - dy) / ky);\n  }\n\n  function quantizeGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\":\n        o.geometries.forEach(quantizeGeometry);\n        break;\n\n      case \"Point\":\n        quantizePoint(o.coordinates);\n        break;\n\n      case \"MultiPoint\":\n        o.coordinates.forEach(quantizePoint);\n        break;\n    }\n  }\n\n  topology.arcs.forEach(function (arc) {\n    var i = 1,\n        j = 1,\n        n = arc.length,\n        pi = arc[0],\n        x0 = pi[0] = Math.round((pi[0] - dx) / kx),\n        y0 = pi[1] = Math.round((pi[1] - dy) / ky),\n        pj,\n        x1,\n        y1;\n\n    for (; i < n; ++i) {\n      pi = arc[i];\n      x1 = Math.round((pi[0] - dx) / kx);\n      y1 = Math.round((pi[1] - dy) / ky);\n\n      if (x1 !== x0 || y1 !== y0) {\n        pj = arc[j++];\n        pj[0] = x1 - x0, x0 = x1;\n        pj[1] = y1 - y0, y0 = y1;\n      }\n    }\n\n    if (j < 2) {\n      pj = arc[j++];\n      pj[0] = 0;\n      pj[1] = 0;\n    }\n\n    arc.length = j;\n  });\n\n  for (name in topology.objects) {\n    quantizeGeometry(topology.objects[name]);\n  }\n\n  topology.transform = {\n    scale: [kx, ky],\n    translate: [dx, dy]\n  };\n  return topology;\n}","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/topojson-client/src/quantize.js"],"names":["bbox","topology","n","Math","floor","Error","transform","bb","name","dx","kx","dy","ky","quantizePoint","p","round","quantizeGeometry","o","type","geometries","forEach","coordinates","arcs","arc","i","j","length","pi","x0","y0","pj","x1","y1","objects","scale","translate"],"mappings":"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","sourcesContent":["import bbox from \"./bbox\";\n\nexport default function(topology, n) {\n  if (!((n = Math.floor(n)) >= 2)) throw new Error(\"n must be ≥2\");\n  if (topology.transform) throw new Error(\"already quantized\");\n  var bb = bbox(topology), name,\n      dx = bb[0], kx = (bb[2] - dx) / (n - 1) || 1,\n      dy = bb[1], ky = (bb[3] - dy) / (n - 1) || 1;\n\n  function quantizePoint(p) {\n    p[0] = Math.round((p[0] - dx) / kx);\n    p[1] = Math.round((p[1] - dy) / ky);\n  }\n\n  function quantizeGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(quantizeGeometry); break;\n      case \"Point\": quantizePoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(quantizePoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = 1,\n        j = 1,\n        n = arc.length,\n        pi = arc[0],\n        x0 = pi[0] = Math.round((pi[0] - dx) / kx),\n        y0 = pi[1] = Math.round((pi[1] - dy) / ky),\n        pj,\n        x1,\n        y1;\n\n    for (; i < n; ++i) {\n      pi = arc[i];\n      x1 = Math.round((pi[0] - dx) / kx);\n      y1 = Math.round((pi[1] - dy) / ky);\n      if (x1 !== x0 || y1 !== y0) {\n        pj = arc[j++];\n        pj[0] = x1 - x0, x0 = x1;\n        pj[1] = y1 - y0, y0 = y1;\n      }\n    }\n\n    if (j < 2) {\n      pj = arc[j++];\n      pj[0] = 0;\n      pj[1] = 0;\n    }\n\n    arc.length = j;\n  });\n\n  for (name in topology.objects) {\n    quantizeGeometry(topology.objects[name]);\n  }\n\n  topology.transform = {\n    scale: [kx, ky],\n    translate: [dx, dy]\n  };\n\n  return topology;\n}\n"]},"metadata":{},"sourceType":"module"}