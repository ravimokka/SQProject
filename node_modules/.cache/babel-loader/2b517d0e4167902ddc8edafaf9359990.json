{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\nfunction SegmentChainer(segments, eps, buildLog) {\n  var chains = [];\n  var regions = [];\n  segments.forEach(function (seg) {\n    var pt1 = seg.start;\n    var pt2 = seg.end;\n\n    if (eps.pointsSame(pt1, pt2)) {\n      console.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' + 'probably too small or too large');\n      return;\n    }\n\n    if (buildLog) buildLog.chainStart(seg); // search for two chains that this segment matches\n\n    var first_match = {\n      index: 0,\n      matches_head: false,\n      matches_pt1: false\n    };\n    var second_match = {\n      index: 0,\n      matches_head: false,\n      matches_pt1: false\n    };\n    var next_match = first_match;\n\n    function setMatch(index, matches_head, matches_pt1) {\n      // return true if we've matched twice\n      next_match.index = index;\n      next_match.matches_head = matches_head;\n      next_match.matches_pt1 = matches_pt1;\n\n      if (next_match === first_match) {\n        next_match = second_match;\n        return false;\n      }\n\n      next_match = null;\n      return true; // we've matched twice, we're done here\n    }\n\n    for (var i = 0; i < chains.length; i++) {\n      var chain = chains[i];\n      var head = chain[0];\n      var head2 = chain[1];\n      var tail = chain[chain.length - 1];\n      var tail2 = chain[chain.length - 2];\n\n      if (eps.pointsSame(head, pt1)) {\n        if (setMatch(i, true, true)) break;\n      } else if (eps.pointsSame(head, pt2)) {\n        if (setMatch(i, true, false)) break;\n      } else if (eps.pointsSame(tail, pt1)) {\n        if (setMatch(i, false, true)) break;\n      } else if (eps.pointsSame(tail, pt2)) {\n        if (setMatch(i, false, false)) break;\n      }\n    }\n\n    if (next_match === first_match) {\n      // we didn't match anything, so create a new chain\n      chains.push([pt1, pt2]);\n      if (buildLog) buildLog.chainNew(pt1, pt2);\n      return;\n    }\n\n    if (next_match === second_match) {\n      // we matched a single chain\n      if (buildLog) buildLog.chainMatch(first_match.index); // add the other point to the apporpriate end, and check to see if we've closed the\n      // chain into a loop\n\n      var index = first_match.index;\n      var pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\n      var addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n      var chain = chains[index];\n      var grow = addToHead ? chain[0] : chain[chain.length - 1];\n      var grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n      var oppo = addToHead ? chain[chain.length - 1] : chain[0];\n      var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n      if (eps.pointsCollinear(grow2, grow, pt)) {\n        // grow isn't needed because it's directly between grow2 and pt:\n        // grow2 ---grow---> pt\n        if (addToHead) {\n          if (buildLog) buildLog.chainRemoveHead(first_match.index, pt);\n          chain.shift();\n        } else {\n          if (buildLog) buildLog.chainRemoveTail(first_match.index, pt);\n          chain.pop();\n        }\n\n        grow = grow2; // old grow is gone... new grow is what grow2 was\n      }\n\n      if (eps.pointsSame(oppo, pt)) {\n        // we're closing the loop, so remove chain from chains\n        chains.splice(index, 1);\n\n        if (eps.pointsCollinear(oppo2, oppo, grow)) {\n          // oppo isn't needed because it's directly between oppo2 and grow:\n          // oppo2 ---oppo--->grow\n          if (addToHead) {\n            if (buildLog) buildLog.chainRemoveTail(first_match.index, grow);\n            chain.pop();\n          } else {\n            if (buildLog) buildLog.chainRemoveHead(first_match.index, grow);\n            chain.shift();\n          }\n        }\n\n        if (buildLog) buildLog.chainClose(first_match.index); // we have a closed chain!\n\n        regions.push(chain);\n        return;\n      } // not closing a loop, so just add it to the apporpriate side\n\n\n      if (addToHead) {\n        if (buildLog) buildLog.chainAddHead(first_match.index, pt);\n        chain.unshift(pt);\n      } else {\n        if (buildLog) buildLog.chainAddTail(first_match.index, pt);\n        chain.push(pt);\n      }\n\n      return;\n    } // otherwise, we matched two chains, so we need to combine those chains together\n\n\n    function reverseChain(index) {\n      if (buildLog) buildLog.chainReverse(index);\n      chains[index].reverse(); // gee, that's easy\n    }\n\n    function appendChain(index1, index2) {\n      // index1 gets index2 appended to it, and index2 is removed\n      var chain1 = chains[index1];\n      var chain2 = chains[index2];\n      var tail = chain1[chain1.length - 1];\n      var tail2 = chain1[chain1.length - 2];\n      var head = chain2[0];\n      var head2 = chain2[1];\n\n      if (eps.pointsCollinear(tail2, tail, head)) {\n        // tail isn't needed because it's directly between tail2 and head\n        // tail2 ---tail---> head\n        if (buildLog) buildLog.chainRemoveTail(index1, tail);\n        chain1.pop();\n        tail = tail2; // old tail is gone... new tail is what tail2 was\n      }\n\n      if (eps.pointsCollinear(tail, head, head2)) {\n        // head isn't needed because it's directly between tail and head2\n        // tail ---head---> head2\n        if (buildLog) buildLog.chainRemoveHead(index2, head);\n        chain2.shift();\n      }\n\n      if (buildLog) buildLog.chainJoin(index1, index2);\n      chains[index1] = chain1.concat(chain2);\n      chains.splice(index2, 1);\n    }\n\n    var F = first_match.index;\n    var S = second_match.index;\n    if (buildLog) buildLog.chainConnect(F, S);\n    var reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\n    if (first_match.matches_head) {\n      if (second_match.matches_head) {\n        if (reverseF) {\n          // <<<< F <<<< --- >>>> S >>>>\n          reverseChain(F); // >>>> F >>>> --- >>>> S >>>>\n\n          appendChain(F, S);\n        } else {\n          // <<<< F <<<< --- >>>> S >>>>\n          reverseChain(S); // <<<< F <<<< --- <<<< S <<<<   logically same as:\n          // >>>> S >>>> --- >>>> F >>>>\n\n          appendChain(S, F);\n        }\n      } else {\n        // <<<< F <<<< --- <<<< S <<<<   logically same as:\n        // >>>> S >>>> --- >>>> F >>>>\n        appendChain(S, F);\n      }\n    } else {\n      if (second_match.matches_head) {\n        // >>>> F >>>> --- >>>> S >>>>\n        appendChain(F, S);\n      } else {\n        if (reverseF) {\n          // >>>> F >>>> --- <<<< S <<<<\n          reverseChain(F); // <<<< F <<<< --- <<<< S <<<<   logically same as:\n          // >>>> S >>>> --- >>>> F >>>>\n\n          appendChain(S, F);\n        } else {\n          // >>>> F >>>> --- <<<< S <<<<\n          reverseChain(S); // >>>> F >>>> --- >>>> S >>>>\n\n          appendChain(F, S);\n        }\n      }\n    }\n  });\n  return regions;\n}\n\nmodule.exports = SegmentChainer;","map":null,"metadata":{},"sourceType":"script"}