{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar isPlainObject = Lib.isPlainObject;\n\nvar PlotSchema = require('./plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar plotAttributes = require('../plots/attributes');\n\nvar Template = require('./plot_template');\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n/**\n * Plotly.makeTemplate: create a template off an existing figure to reuse\n * style attributes on other figures.\n *\n * Note: separated from the rest of templates because otherwise we get circular\n * references due to PlotSchema.\n *\n * @param {object|DOM element|string} figure: The figure to base the template on\n *     should contain a trace array `figure.data`\n *     and a layout object `figure.layout`\n * @returns {object} template: the extracted template - can then be used as\n *     `layout.template` in another figure.\n */\n\n\nexports.makeTemplate = function (figure) {\n  figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);\n  figure = Lib.extendDeep({\n    _context: dfltConfig\n  }, {\n    data: figure.data,\n    layout: figure.layout\n  });\n  Plots.supplyDefaults(figure);\n  var data = figure.data || [];\n  var layout = figure.layout || {}; // copy over a few items to help follow the schema\n\n  layout._basePlotModules = figure._fullLayout._basePlotModules;\n  layout._modules = figure._fullLayout._modules;\n  var template = {\n    data: {},\n    layout: {}\n  };\n  /*\n   * Note: we do NOT validate template values, we just take what's in the\n   * user inputs data and layout, not the validated values in fullData and\n   * fullLayout. Even if we were to validate here, there's no guarantee that\n   * these values would still be valid when applied to a new figure, which\n   * may contain different trace modes, different axes, etc. So it's\n   * important that when applying a template we still validate the template\n   * values, rather than just using them as defaults.\n   */\n\n  data.forEach(function (trace) {\n    // TODO: What if no style info is extracted for this trace. We may\n    // not want an empty object as the null value.\n    // TODO: allow transforms to contribute to templates?\n    // as it stands they are ignored, which may be for the best...\n    var traceTemplate = {};\n    walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));\n    var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');\n    var typeTemplates = template.data[traceType];\n    if (!typeTemplates) typeTemplates = template.data[traceType] = [];\n    typeTemplates.push(traceTemplate);\n  });\n  walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));\n  /*\n   * Compose the new template with an existing one to the same effect\n   *\n   * NOTE: there's a possibility of slightly different behavior: if the plot\n   * has an invalid value and the old template has a valid value for the same\n   * attribute, the plot will use the old template value but this routine\n   * will pull the invalid value (resulting in the original default).\n   * In the general case it's not possible to solve this with a single value,\n   * since valid options can be context-dependent. It could be solved with\n   * a *list* of values, but that would be huge complexity for little gain.\n   */\n\n  delete template.layout.template;\n  var oldTemplate = layout.template;\n\n  if (isPlainObject(oldTemplate)) {\n    var oldLayoutTemplate = oldTemplate.layout;\n    var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;\n\n    if (isPlainObject(oldLayoutTemplate)) {\n      mergeTemplates(oldLayoutTemplate, template.layout);\n    }\n\n    var oldDataTemplate = oldTemplate.data;\n\n    if (isPlainObject(oldDataTemplate)) {\n      for (traceType in template.data) {\n        oldTypeTemplates = oldDataTemplate[traceType];\n\n        if (Array.isArray(oldTypeTemplates)) {\n          typeTemplates = template.data[traceType];\n          typeLen = typeTemplates.length;\n          oldTypeLen = oldTypeTemplates.length;\n\n          for (i = 0; i < typeLen; i++) {\n            mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);\n          }\n\n          for (i = typeLen; i < oldTypeLen; i++) {\n            typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));\n          }\n        }\n      }\n\n      for (traceType in oldDataTemplate) {\n        if (!(traceType in template.data)) {\n          template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);\n        }\n      }\n    }\n  }\n\n  return template;\n};\n\nfunction mergeTemplates(oldTemplate, newTemplate) {\n  // we don't care about speed here, just make sure we have a totally\n  // distinct object from the previous template\n  oldTemplate = Lib.extendDeep({}, oldTemplate); // sort keys so we always get annotationdefaults before annotations etc\n  // so arrayTemplater will work right\n\n  var oldKeys = Object.keys(oldTemplate).sort();\n  var i, j;\n\n  function mergeOne(oldVal, newVal, key) {\n    if (isPlainObject(newVal) && isPlainObject(oldVal)) {\n      mergeTemplates(oldVal, newVal);\n    } else if (Array.isArray(newVal) && Array.isArray(oldVal)) {\n      // Note: omitted `inclusionAttr` from arrayTemplater here,\n      // it's irrelevant as we only want the resulting `_template`.\n      var templater = Template.arrayTemplater({\n        _template: oldTemplate\n      }, key);\n\n      for (j = 0; j < newVal.length; j++) {\n        var item = newVal[j];\n\n        var oldItem = templater.newItem(item)._template;\n\n        if (oldItem) mergeTemplates(oldItem, item);\n      }\n\n      var defaultItems = templater.defaultItems();\n\n      for (j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template); // templateitemname only applies to receiving plots\n\n\n      for (j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;\n    }\n  }\n\n  for (i = 0; i < oldKeys.length; i++) {\n    var key = oldKeys[i];\n    var oldVal = oldTemplate[key];\n\n    if (key in newTemplate) {\n      mergeOne(oldVal, newTemplate[key], key);\n    } else newTemplate[key] = oldVal; // if this is a base key from the old template (eg xaxis), look for\n    // extended keys (eg xaxis2) in the new template to merge into\n\n\n    if (getBaseKey(key) === key) {\n      for (var key2 in newTemplate) {\n        var baseKey2 = getBaseKey(key2);\n\n        if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {\n          mergeOne(oldVal, newTemplate[key2], key);\n        }\n      }\n    }\n  }\n}\n\nfunction getBaseKey(key) {\n  return key.replace(/[0-9]+$/, '');\n}\n\nfunction walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {\n  var pathAttr = basePath && getAttributeInfo(basePath);\n\n  for (var key in parent) {\n    var child = parent[key];\n    var nextPath = getNextPath(parent, key, path);\n    var nextBasePath = getNextPath(parent, key, basePath);\n    var attr = getAttributeInfo(nextBasePath);\n\n    if (!attr) {\n      var baseKey = getBaseKey(key);\n\n      if (baseKey !== key) {\n        nextBasePath = getNextPath(parent, baseKey, basePath);\n        attr = getAttributeInfo(nextBasePath);\n      }\n    } // we'll get an attr if path starts with a valid part, then has an\n    // invalid ending. Make sure we got all the way to the end.\n\n\n    if (pathAttr && pathAttr === attr) continue;\n\n    if (!attr || attr._noTemplating || attr.valType === 'data_array' || attr.arrayOk && Array.isArray(child)) {\n      continue;\n    }\n\n    if (!attr.valType && isPlainObject(child)) {\n      walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);\n    } else if (attr._isLinkedToArray && Array.isArray(child)) {\n      var dfltDone = false;\n      var namedIndex = 0;\n      var usedNames = {};\n\n      for (var i = 0; i < child.length; i++) {\n        var item = child[i];\n\n        if (isPlainObject(item)) {\n          var name = item.name;\n\n          if (name) {\n            if (!usedNames[name]) {\n              // named array items: allow all attributes except data arrays\n              walkStyleKeys(item, templateOut, getAttributeInfo, getNextPath(child, namedIndex, nextPath), getNextPath(child, namedIndex, nextBasePath));\n              namedIndex++;\n              usedNames[name] = 1;\n            }\n          } else if (!dfltDone) {\n            var dfltKey = Template.arrayDefaultKey(key);\n            var dfltPath = getNextPath(parent, dfltKey, path); // getAttributeInfo will fail if we try to use dfltKey directly.\n            // Instead put this item into the next array element, then\n            // pull it out and move it to dfltKey.\n\n            var pathInArray = getNextPath(child, namedIndex, nextPath);\n            walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray, getNextPath(child, namedIndex, nextBasePath));\n            var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);\n            var dfltProp = Lib.nestedProperty(templateOut, dfltPath);\n            dfltProp.set(itemPropInArray.get());\n            itemPropInArray.set(null);\n            dfltDone = true;\n          }\n        }\n      }\n    } else {\n      var templateProp = Lib.nestedProperty(templateOut, nextPath);\n      templateProp.set(child);\n    }\n  }\n}\n\nfunction getLayoutInfo(layout, path) {\n  return PlotSchema.getLayoutValObject(layout, Lib.nestedProperty({}, path).parts);\n}\n\nfunction getTraceInfo(trace, path) {\n  return PlotSchema.getTraceValObject(trace, Lib.nestedProperty({}, path).parts);\n}\n\nfunction getNextPath(parent, key, path) {\n  var nextPath;\n  if (!path) nextPath = key;else if (Array.isArray(parent)) nextPath = path + '[' + key + ']';else nextPath = path + '.' + key;\n  return nextPath;\n}\n/**\n * validateTemplate: Test for consistency between the given figure and\n * a template, either already included in the figure or given separately.\n * Note that not every issue we identify here is necessarily a problem,\n * it depends on what you're using the template for.\n *\n * @param {object|DOM element} figure: the plot, with {data, layout} members,\n *     to test the template against\n * @param {Optional(object)} template: the template, with its own {data, layout},\n *     to test. If omitted, we will look for a template already attached as the\n *     plot's `layout.template` attribute.\n *\n * @returns {array} array of error objects each containing:\n *  - {string} code\n *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')\n *  - {string} msg\n *      a full readable description of the issue.\n */\n\n\nexports.validateTemplate = function (figureIn, template) {\n  var figure = Lib.extendDeep({}, {\n    _context: dfltConfig,\n    data: figureIn.data,\n    layout: figureIn.layout\n  });\n  var layout = figure.layout || {};\n  if (!isPlainObject(template)) template = layout.template || {};\n  var layoutTemplate = template.layout;\n  var dataTemplate = template.data;\n  var errorList = [];\n  figure.layout = layout;\n  figure.layout.template = template;\n  Plots.supplyDefaults(figure);\n  var fullLayout = figure._fullLayout;\n  var fullData = figure._fullData;\n  var layoutPaths = {};\n\n  function crawlLayoutForContainers(obj, paths) {\n    for (var key in obj) {\n      if (key.charAt(0) !== '_' && isPlainObject(obj[key])) {\n        var baseKey = getBaseKey(key);\n        var nextPaths = [];\n        var i;\n\n        for (i = 0; i < paths.length; i++) {\n          nextPaths.push(getNextPath(obj, key, paths[i]));\n          if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));\n        }\n\n        for (i = 0; i < nextPaths.length; i++) {\n          layoutPaths[nextPaths[i]] = 1;\n        }\n\n        crawlLayoutForContainers(obj[key], nextPaths);\n      }\n    }\n  }\n\n  function crawlLayoutTemplateForContainers(obj, path) {\n    for (var key in obj) {\n      if (key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {\n        var nextPath = getNextPath(obj, key, path);\n\n        if (layoutPaths[nextPath]) {\n          crawlLayoutTemplateForContainers(obj[key], nextPath);\n        } else {\n          errorList.push({\n            code: 'unused',\n            path: nextPath\n          });\n        }\n      }\n    }\n  }\n\n  if (!isPlainObject(layoutTemplate)) {\n    errorList.push({\n      code: 'layout'\n    });\n  } else {\n    crawlLayoutForContainers(fullLayout, ['layout']);\n    crawlLayoutTemplateForContainers(layoutTemplate, 'layout');\n  }\n\n  if (!isPlainObject(dataTemplate)) {\n    errorList.push({\n      code: 'data'\n    });\n  } else {\n    var typeCount = {};\n    var traceType;\n\n    for (var i = 0; i < fullData.length; i++) {\n      var fullTrace = fullData[i];\n      traceType = fullTrace.type;\n      typeCount[traceType] = (typeCount[traceType] || 0) + 1;\n\n      if (!fullTrace._fullInput._template) {\n        // this takes care of the case of traceType in the data but not\n        // the template\n        errorList.push({\n          code: 'missing',\n          index: fullTrace._fullInput.index,\n          traceType: traceType\n        });\n      }\n    }\n\n    for (traceType in dataTemplate) {\n      var templateCount = dataTemplate[traceType].length;\n      var dataCount = typeCount[traceType] || 0;\n\n      if (templateCount > dataCount) {\n        errorList.push({\n          code: 'unused',\n          traceType: traceType,\n          templateCount: templateCount,\n          dataCount: dataCount\n        });\n      } else if (dataCount > templateCount) {\n        errorList.push({\n          code: 'reused',\n          traceType: traceType,\n          templateCount: templateCount,\n          dataCount: dataCount\n        });\n      }\n    }\n  } // _template: false is when someone tried to modify an array item\n  // but there was no template with matching name\n\n\n  function crawlForMissingTemplates(obj, path) {\n    for (var key in obj) {\n      if (key.charAt(0) === '_') continue;\n      var val = obj[key];\n      var nextPath = getNextPath(obj, key, path);\n\n      if (isPlainObject(val)) {\n        if (Array.isArray(obj) && val._template === false && val.templateitemname) {\n          errorList.push({\n            code: 'missing',\n            path: nextPath,\n            templateitemname: val.templateitemname\n          });\n        }\n\n        crawlForMissingTemplates(val, nextPath);\n      } else if (Array.isArray(val) && hasPlainObject(val)) {\n        crawlForMissingTemplates(val, nextPath);\n      }\n    }\n  }\n\n  crawlForMissingTemplates({\n    data: fullData,\n    layout: fullLayout\n  }, '');\n  if (errorList.length) return errorList.map(format);\n};\n\nfunction hasPlainObject(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (isPlainObject(arr[i])) return true;\n  }\n}\n\nfunction format(opts) {\n  var msg;\n\n  switch (opts.code) {\n    case 'data':\n      msg = 'The template has no key data.';\n      break;\n\n    case 'layout':\n      msg = 'The template has no key layout.';\n      break;\n\n    case 'missing':\n      if (opts.path) {\n        msg = 'There are no templates for item ' + opts.path + ' with name ' + opts.templateitemname;\n      } else {\n        msg = 'There are no templates for trace ' + opts.index + ', of type ' + opts.traceType + '.';\n      }\n\n      break;\n\n    case 'unused':\n      if (opts.path) {\n        msg = 'The template item at ' + opts.path + ' was not used in constructing the plot.';\n      } else if (opts.dataCount) {\n        msg = 'Some of the templates of type ' + opts.traceType + ' were not used. The template has ' + opts.templateCount + ' traces, the data only has ' + opts.dataCount + ' of this type.';\n      } else {\n        msg = 'The template has ' + opts.templateCount + ' traces of type ' + opts.traceType + ' but there are none in the data.';\n      }\n\n      break;\n\n    case 'reused':\n      msg = 'Some of the templates of type ' + opts.traceType + ' were used more than once. The template has ' + opts.templateCount + ' traces, the data has ' + opts.dataCount + ' of this type.';\n      break;\n  }\n\n  opts.msg = msg;\n  return opts;\n}","map":null,"metadata":{},"sourceType":"script"}