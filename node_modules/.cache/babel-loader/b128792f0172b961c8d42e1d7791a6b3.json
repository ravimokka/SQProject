{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\nfunction Epsilon(eps) {\n  if (typeof eps !== 'number') eps = 0.0000000001; // sane default? sure why not\n\n  var my = {\n    epsilon: function (v) {\n      if (typeof v === 'number') eps = v;\n      return eps;\n    },\n    pointAboveOrOnLine: function (pt, left, right) {\n      var Ax = left[0];\n      var Ay = left[1];\n      var Bx = right[0];\n      var By = right[1];\n      var Cx = pt[0];\n      var Cy = pt[1];\n      return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n    },\n    pointBetween: function (p, left, right) {\n      // p must be collinear with left->right\n      // returns false if p == left, p == right, or left == right\n      var d_py_ly = p[1] - left[1];\n      var d_rx_lx = right[0] - left[0];\n      var d_px_lx = p[0] - left[0];\n      var d_ry_ly = right[1] - left[1];\n      var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly; // if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n      // if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\n      if (dot < eps) return false;\n      var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly; // if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n      // therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\n      if (dot - sqlen > -eps) return false;\n      return true;\n    },\n    pointsSameX: function (p1, p2) {\n      return Math.abs(p1[0] - p2[0]) < eps;\n    },\n    pointsSameY: function (p1, p2) {\n      return Math.abs(p1[1] - p2[1]) < eps;\n    },\n    pointsSame: function (p1, p2) {\n      return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n    },\n    pointsCompare: function (p1, p2) {\n      // returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n      if (my.pointsSameX(p1, p2)) return my.pointsSameY(p1, p2) ? 0 : p1[1] < p2[1] ? -1 : 1;\n      return p1[0] < p2[0] ? -1 : 1;\n    },\n    pointsCollinear: function (pt1, pt2, pt3) {\n      // does pt1->pt2->pt3 make a straight line?\n      // essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n      // if slopes are equal, then they must be collinear, because they share pt2\n      var dx1 = pt1[0] - pt2[0];\n      var dy1 = pt1[1] - pt2[1];\n      var dx2 = pt2[0] - pt3[0];\n      var dy2 = pt2[1] - pt3[1];\n      return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n    },\n    linesIntersect: function (a0, a1, b0, b1) {\n      // returns false if the lines are coincident (e.g., parallel or on top of each other)\n      //\n      // returns an object if the lines intersect:\n      //   {\n      //     pt: [x, y],    where the intersection point is at\n      //     alongA: where intersection point is along A,\n      //     alongB: where intersection point is along B\n      //   }\n      //\n      //  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n      //\n      //  with the following meaning:\n      //\n      //    -2   intersection point is before segment's first point\n      //    -1   intersection point is directly on segment's first point\n      //     0   intersection point is between segment's first and second points (exclusive)\n      //     1   intersection point is directly on segment's second point\n      //     2   intersection point is after segment's second point\n      var adx = a1[0] - a0[0];\n      var ady = a1[1] - a0[1];\n      var bdx = b1[0] - b0[0];\n      var bdy = b1[1] - b0[1];\n      var axb = adx * bdy - ady * bdx;\n      if (Math.abs(axb) < eps) return false; // lines are coincident\n\n      var dx = a0[0] - b0[0];\n      var dy = a0[1] - b0[1];\n      var A = (bdx * dy - bdy * dx) / axb;\n      var B = (adx * dy - ady * dx) / axb;\n      var ret = {\n        alongA: 0,\n        alongB: 0,\n        pt: [a0[0] + A * adx, a0[1] + A * ady]\n      }; // categorize where intersection point is along A and B\n\n      if (A <= -eps) ret.alongA = -2;else if (A < eps) ret.alongA = -1;else if (A - 1 <= -eps) ret.alongA = 0;else if (A - 1 < eps) ret.alongA = 1;else ret.alongA = 2;\n      if (B <= -eps) ret.alongB = -2;else if (B < eps) ret.alongB = -1;else if (B - 1 <= -eps) ret.alongB = 0;else if (B - 1 < eps) ret.alongB = 1;else ret.alongB = 2;\n      return ret;\n    },\n    pointInsideRegion: function (pt, region) {\n      var x = pt[0];\n      var y = pt[1];\n      var last_x = region[region.length - 1][0];\n      var last_y = region[region.length - 1][1];\n      var inside = false;\n\n      for (var i = 0; i < region.length; i++) {\n        var curr_x = region[i][0];\n        var curr_y = region[i][1]; // if y is between curr_y and last_y, and\n        // x is to the right of the boundary created by the line\n\n        if (curr_y - y > eps != last_y - y > eps && (last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps) inside = !inside;\n        last_x = curr_x;\n        last_y = curr_y;\n      }\n\n      return inside;\n    }\n  };\n  return my;\n}\n\nmodule.exports = Epsilon;","map":null,"metadata":{},"sourceType":"script"}