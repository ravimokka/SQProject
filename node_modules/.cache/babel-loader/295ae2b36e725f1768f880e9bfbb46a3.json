{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar Plots = require('../plots/plots');\n\nvar PlotSchema = require('./plot_schema');\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar isPlainObject = Lib.isPlainObject;\nvar isArray = Array.isArray;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */\n\nmodule.exports = function validate(data, layout) {\n  var schema = PlotSchema.get();\n  var errorList = [];\n  var gd = {\n    _context: Lib.extendFlat({}, dfltConfig)\n  };\n  var dataIn, layoutIn;\n\n  if (isArray(data)) {\n    gd.data = Lib.extendDeep([], data);\n    dataIn = data;\n  } else {\n    gd.data = [];\n    dataIn = [];\n    errorList.push(format('array', 'data'));\n  }\n\n  if (isPlainObject(layout)) {\n    gd.layout = Lib.extendDeep({}, layout);\n    layoutIn = layout;\n  } else {\n    gd.layout = {};\n    layoutIn = {};\n\n    if (arguments.length > 1) {\n      errorList.push(format('object', 'layout'));\n    }\n  } // N.B. dataIn and layoutIn are in general not the same as\n  // gd.data and gd.layout after supplyDefaults as some attributes\n  // in gd.data and gd.layout (still) get mutated during this step.\n\n\n  Plots.supplyDefaults(gd);\n  var dataOut = gd._fullData;\n  var len = dataIn.length;\n\n  for (var i = 0; i < len; i++) {\n    var traceIn = dataIn[i];\n    var base = ['data', i];\n\n    if (!isPlainObject(traceIn)) {\n      errorList.push(format('object', base));\n      continue;\n    }\n\n    var traceOut = dataOut[i];\n    var traceType = traceOut.type;\n    var traceSchema = schema.traces[traceType].attributes; // PlotSchema does something fancy with trace 'type', reset it here\n    // to make the trace schema compatible with Lib.validate.\n\n    traceSchema.type = {\n      valType: 'enumerated',\n      values: [traceType]\n    };\n\n    if (traceOut.visible === false && traceIn.visible !== false) {\n      errorList.push(format('invisible', base));\n    }\n\n    crawl(traceIn, traceOut, traceSchema, errorList, base);\n    var transformsIn = traceIn.transforms;\n    var transformsOut = traceOut.transforms;\n\n    if (transformsIn) {\n      if (!isArray(transformsIn)) {\n        errorList.push(format('array', base, ['transforms']));\n      }\n\n      base.push('transforms');\n\n      for (var j = 0; j < transformsIn.length; j++) {\n        var path = ['transforms', j];\n        var transformType = transformsIn[j].type;\n\n        if (!isPlainObject(transformsIn[j])) {\n          errorList.push(format('object', base, path));\n          continue;\n        }\n\n        var transformSchema = schema.transforms[transformType] ? schema.transforms[transformType].attributes : {}; // add 'type' to transform schema to validate the transform type\n\n        transformSchema.type = {\n          valType: 'enumerated',\n          values: Object.keys(schema.transforms)\n        };\n        crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);\n      }\n    }\n  }\n\n  var layoutOut = gd._fullLayout;\n  var layoutSchema = fillLayoutSchema(schema, dataOut);\n  crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout'); // return undefined if no validation errors were found\n\n  return errorList.length === 0 ? void 0 : errorList;\n};\n\nfunction crawl(objIn, objOut, schema, list, base, path) {\n  path = path || [];\n  var keys = Object.keys(objIn);\n\n  for (var i = 0; i < keys.length; i++) {\n    var k = keys[i]; // transforms are handled separately\n\n    if (k === 'transforms') continue;\n    var p = path.slice();\n    p.push(k);\n    var valIn = objIn[k];\n    var valOut = objOut[k];\n    var nestedSchema = getNestedSchema(schema, k);\n    var isInfoArray = (nestedSchema || {}).valType === 'info_array';\n    var isColorscale = (nestedSchema || {}).valType === 'colorscale';\n    var items = (nestedSchema || {}).items;\n\n    if (!isInSchema(schema, k)) {\n      list.push(format('schema', base, p));\n    } else if (isPlainObject(valIn) && isPlainObject(valOut)) {\n      crawl(valIn, valOut, nestedSchema, list, base, p);\n    } else if (isInfoArray && isArray(valIn)) {\n      if (valIn.length > valOut.length) {\n        list.push(format('unused', base, p.concat(valOut.length)));\n      }\n\n      var len = valOut.length;\n      var arrayItems = Array.isArray(items);\n      if (arrayItems) len = Math.min(len, items.length);\n      var m, n, item, valInPart, valOutPart;\n\n      if (nestedSchema.dimensions === 2) {\n        for (n = 0; n < len; n++) {\n          if (isArray(valIn[n])) {\n            if (valIn[n].length > valOut[n].length) {\n              list.push(format('unused', base, p.concat(n, valOut[n].length)));\n            }\n\n            var len2 = valOut[n].length;\n\n            for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {\n              item = arrayItems ? items[n][m] : items;\n              valInPart = valIn[n][m];\n              valOutPart = valOut[n][m];\n\n              if (!Lib.validate(valInPart, item)) {\n                list.push(format('value', base, p.concat(n, m), valInPart));\n              } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {\n                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));\n              }\n            }\n          } else {\n            list.push(format('array', base, p.concat(n), valIn[n]));\n          }\n        }\n      } else {\n        for (n = 0; n < len; n++) {\n          item = arrayItems ? items[n] : items;\n          valInPart = valIn[n];\n          valOutPart = valOut[n];\n\n          if (!Lib.validate(valInPart, item)) {\n            list.push(format('value', base, p.concat(n), valInPart));\n          } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {\n            list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));\n          }\n        }\n      }\n    } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {\n      var _nestedSchema = items[Object.keys(items)[0]];\n      var indexList = [];\n\n      var j, _p; // loop over valOut items while keeping track of their\n      // corresponding input container index (given by _index)\n\n\n      for (j = 0; j < valOut.length; j++) {\n        var _index = valOut[j]._index || j;\n\n        _p = p.slice();\n\n        _p.push(_index);\n\n        if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {\n          indexList.push(_index);\n          var valInj = valIn[_index];\n          var valOutj = valOut[j];\n\n          if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {\n            list.push(format('invisible', base, _p));\n          } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);\n        }\n      } // loop over valIn to determine where it went wrong for some items\n\n\n      for (j = 0; j < valIn.length; j++) {\n        _p = p.slice();\n\n        _p.push(j);\n\n        if (!isPlainObject(valIn[j])) {\n          list.push(format('object', base, _p, valIn[j]));\n        } else if (indexList.indexOf(j) === -1) {\n          list.push(format('unused', base, _p));\n        }\n      }\n    } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {\n      list.push(format('object', base, p, valIn));\n    } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {\n      list.push(format('array', base, p, valIn));\n    } else if (!(k in objOut)) {\n      list.push(format('unused', base, p, valIn));\n    } else if (!Lib.validate(valIn, nestedSchema)) {\n      list.push(format('value', base, p, valIn));\n    } else if (nestedSchema.valType === 'enumerated' && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {\n      list.push(format('dynamic', base, p, valIn, valOut));\n    }\n  }\n\n  return list;\n} // the 'full' layout schema depends on the traces types presents\n\n\nfunction fillLayoutSchema(schema, dataOut) {\n  var layoutSchema = schema.layout.layoutAttributes;\n\n  for (var i = 0; i < dataOut.length; i++) {\n    var traceOut = dataOut[i];\n    var traceSchema = schema.traces[traceOut.type];\n    var traceLayoutAttr = traceSchema.layoutAttributes;\n\n    if (traceLayoutAttr) {\n      if (traceOut.subplot) {\n        Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);\n      } else {\n        Lib.extendFlat(layoutSchema, traceLayoutAttr);\n      }\n    }\n  }\n\n  return layoutSchema;\n} // validation error codes\n\n\nvar code2msgFunc = {\n  object: function (base, astr) {\n    var prefix;\n    if (base === 'layout' && astr === '') prefix = 'The layout argument';else if (base[0] === 'data' && astr === '') {\n      prefix = 'Trace ' + base[1] + ' in the data argument';\n    } else prefix = inBase(base) + 'key ' + astr;\n    return prefix + ' must be linked to an object container';\n  },\n  array: function (base, astr) {\n    var prefix;\n    if (base === 'data') prefix = 'The data argument';else prefix = inBase(base) + 'key ' + astr;\n    return prefix + ' must be linked to an array container';\n  },\n  schema: function (base, astr) {\n    return inBase(base) + 'key ' + astr + ' is not part of the schema';\n  },\n  unused: function (base, astr, valIn) {\n    var target = isPlainObject(valIn) ? 'container' : 'key';\n    return inBase(base) + target + ' ' + astr + ' did not get coerced';\n  },\n  dynamic: function (base, astr, valIn, valOut) {\n    return [inBase(base) + 'key', astr, '(set to \\'' + valIn + '\\')', 'got reset to', '\\'' + valOut + '\\'', 'during defaults.'].join(' ');\n  },\n  invisible: function (base, astr) {\n    return (astr ? inBase(base) + 'item ' + astr : 'Trace ' + base[1]) + ' got defaulted to be not visible';\n  },\n  value: function (base, astr, valIn) {\n    return [inBase(base) + 'key ' + astr, 'is set to an invalid value (' + valIn + ')'].join(' ');\n  }\n};\n\nfunction inBase(base) {\n  if (isArray(base)) return 'In data trace ' + base[1] + ', ';\n  return 'In ' + base + ', ';\n}\n\nfunction format(code, base, path, valIn, valOut) {\n  path = path || '';\n  var container, trace; // container is either 'data' or 'layout\n  // trace is the trace index if 'data', null otherwise\n\n  if (isArray(base)) {\n    container = base[0];\n    trace = base[1];\n  } else {\n    container = base;\n    trace = null;\n  }\n\n  var astr = convertPathToAttributeString(path);\n  var msg = code2msgFunc[code](base, astr, valIn, valOut); // log to console if logger config option is enabled\n\n  Lib.log(msg);\n  return {\n    code: code,\n    container: container,\n    trace: trace,\n    path: path,\n    astr: astr,\n    msg: msg\n  };\n}\n\nfunction isInSchema(schema, key) {\n  var parts = splitKey(key);\n  var keyMinusId = parts.keyMinusId;\n  var id = parts.id;\n\n  if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {\n    return true;\n  }\n\n  return key in schema;\n}\n\nfunction getNestedSchema(schema, key) {\n  if (key in schema) return schema[key];\n  var parts = splitKey(key);\n  return schema[parts.keyMinusId];\n}\n\nvar idRegex = Lib.counterRegex('([a-z]+)');\n\nfunction splitKey(key) {\n  var idMatch = key.match(idRegex);\n  return {\n    keyMinusId: idMatch && idMatch[1],\n    id: idMatch && idMatch[2]\n  };\n}\n\nfunction convertPathToAttributeString(path) {\n  if (!isArray(path)) return String(path);\n  var astr = '';\n\n  for (var i = 0; i < path.length; i++) {\n    var p = path[i];\n\n    if (typeof p === 'number') {\n      astr = astr.substr(0, astr.length - 1) + '[' + p + ']';\n    } else {\n      astr += p;\n    }\n\n    if (i < path.length - 1) astr += '.';\n  }\n\n  return astr;\n}","map":null,"metadata":{},"sourceType":"script"}