{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\nvar zoomstartStyle = {\n  cursor: 'pointer'\n};\nvar zoomendStyle = {\n  cursor: 'auto'\n};\n\nfunction createGeoZoom(geo, geoLayout) {\n  var projection = geo.projection;\n  var zoomConstructor;\n\n  if (geoLayout._isScoped) {\n    zoomConstructor = zoomScoped;\n  } else if (geoLayout._isClipped) {\n    zoomConstructor = zoomClipped;\n  } else {\n    zoomConstructor = zoomNonClipped;\n  } // TODO add a conic-specific zoom\n\n\n  return zoomConstructor(geo, projection);\n}\n\nmodule.exports = createGeoZoom; // common to all zoom types\n\nfunction initZoom(geo, projection) {\n  return d3.behavior.zoom().translate(projection.translate()).scale(projection.scale());\n} // sync zoom updates with user & full layout\n\n\nfunction sync(geo, projection, cb) {\n  var id = geo.id;\n  var gd = geo.graphDiv;\n  var layout = gd.layout;\n  var userOpts = layout[id];\n  var fullLayout = gd._fullLayout;\n  var fullOpts = fullLayout[id];\n  var preGUI = {};\n  var eventData = {};\n\n  function set(propStr, val) {\n    preGUI[id + '.' + propStr] = Lib.nestedProperty(userOpts, propStr).get();\n    Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, preGUI);\n    var fullNp = Lib.nestedProperty(fullOpts, propStr);\n\n    if (fullNp.get() !== val) {\n      fullNp.set(val);\n      Lib.nestedProperty(userOpts, propStr).set(val);\n      eventData[id + '.' + propStr] = val;\n    }\n  }\n\n  cb(set);\n  set('projection.scale', projection.scale() / geo.fitScale);\n  gd.emit('plotly_relayout', eventData);\n} // zoom for scoped projections\n\n\nfunction zoomScoped(geo, projection) {\n  var zoom = initZoom(geo, projection);\n\n  function handleZoomstart() {\n    d3.select(this).style(zoomstartStyle);\n  }\n\n  function handleZoom() {\n    projection.scale(d3.event.scale).translate(d3.event.translate);\n    geo.render();\n    var center = projection.invert(geo.midPt);\n    geo.graphDiv.emit('plotly_relayouting', {\n      'geo.projection.scale': projection.scale() / geo.fitScale,\n      'geo.center.lon': center[0],\n      'geo.center.lat': center[1]\n    });\n  }\n\n  function syncCb(set) {\n    var center = projection.invert(geo.midPt);\n    set('center.lon', center[0]);\n    set('center.lat', center[1]);\n  }\n\n  function handleZoomend() {\n    d3.select(this).style(zoomendStyle);\n    sync(geo, projection, syncCb);\n  }\n\n  zoom.on('zoomstart', handleZoomstart).on('zoom', handleZoom).on('zoomend', handleZoomend);\n  return zoom;\n} // zoom for non-clipped projections\n\n\nfunction zoomNonClipped(geo, projection) {\n  var zoom = initZoom(geo, projection);\n  var INSIDETOLORANCEPXS = 2;\n  var mouse0, rotate0, translate0, lastRotate, zoomPoint, mouse1, rotate1, point1, didZoom;\n\n  function position(x) {\n    return projection.invert(x);\n  }\n\n  function outside(x) {\n    var pos = position(x);\n    if (!pos) return true;\n    var pt = projection(pos);\n    return Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS || Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS;\n  }\n\n  function handleZoomstart() {\n    d3.select(this).style(zoomstartStyle);\n    mouse0 = d3.mouse(this);\n    rotate0 = projection.rotate();\n    translate0 = projection.translate();\n    lastRotate = rotate0;\n    zoomPoint = position(mouse0);\n  }\n\n  function handleZoom() {\n    mouse1 = d3.mouse(this);\n\n    if (outside(mouse0)) {\n      zoom.scale(projection.scale());\n      zoom.translate(projection.translate());\n      return;\n    }\n\n    projection.scale(d3.event.scale);\n    projection.translate([translate0[0], d3.event.translate[1]]);\n\n    if (!zoomPoint) {\n      mouse0 = mouse1;\n      zoomPoint = position(mouse0);\n    } else if (position(mouse1)) {\n      point1 = position(mouse1);\n      rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];\n      projection.rotate(rotate1);\n      lastRotate = rotate1;\n    }\n\n    didZoom = true;\n    geo.render();\n    var rotate = projection.rotate();\n    var center = projection.invert(geo.midPt);\n    geo.graphDiv.emit('plotly_relayouting', {\n      'geo.projection.scale': projection.scale() / geo.fitScale,\n      'geo.center.lon': center[0],\n      'geo.center.lat': center[1],\n      'geo.projection.rotation.lon': -rotate[0]\n    });\n  }\n\n  function handleZoomend() {\n    d3.select(this).style(zoomendStyle);\n    if (didZoom) sync(geo, projection, syncCb);\n  }\n\n  function syncCb(set) {\n    var rotate = projection.rotate();\n    var center = projection.invert(geo.midPt);\n    set('projection.rotation.lon', -rotate[0]);\n    set('center.lon', center[0]);\n    set('center.lat', center[1]);\n  }\n\n  zoom.on('zoomstart', handleZoomstart).on('zoom', handleZoom).on('zoomend', handleZoomend);\n  return zoom;\n} // zoom for clipped projections\n// inspired by https://www.jasondavies.com/maps/d3.geo.zoom.js\n\n\nfunction zoomClipped(geo, projection) {\n  var view = {\n    r: projection.rotate(),\n    k: projection.scale()\n  };\n  var zoom = initZoom(geo, projection);\n  var event = d3eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend');\n  var zooming = 0;\n  var zoomOn = zoom.on;\n  var zoomPoint;\n  zoom.on('zoomstart', function () {\n    d3.select(this).style(zoomstartStyle);\n    var mouse0 = d3.mouse(this);\n    var rotate0 = projection.rotate();\n    var lastRotate = rotate0;\n    var translate0 = projection.translate();\n    var q = quaternionFromEuler(rotate0);\n    zoomPoint = position(projection, mouse0);\n    zoomOn.call(zoom, 'zoom', function () {\n      var mouse1 = d3.mouse(this);\n      projection.scale(view.k = d3.event.scale);\n\n      if (!zoomPoint) {\n        // if no zoomPoint, the mouse wasn't over the actual geography yet\n        // maybe this point is the start... we'll find out next time!\n        mouse0 = mouse1;\n        zoomPoint = position(projection, mouse0);\n      } else if (position(projection, mouse1)) {\n        // check if the point is on the map\n        // if not, don't do anything new but scale\n        // if it is, then we can assume between will exist below\n        // so we don't need the 'bank' function, whatever that is.\n        // go back to original projection temporarily\n        // except for scale... that's kind of independent?\n        projection.rotate(rotate0).translate(translate0); // calculate the new params\n\n        var point1 = position(projection, mouse1);\n        var between = rotateBetween(zoomPoint, point1);\n        var newEuler = eulerFromQuaternion(multiply(q, between));\n        var rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);\n\n        if (!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) || !isFinite(rotateAngles[2])) {\n          rotateAngles = lastRotate;\n        } // update the projection\n\n\n        projection.rotate(rotateAngles);\n        lastRotate = rotateAngles;\n      }\n\n      zoomed(event.of(this, arguments));\n    });\n    zoomstarted(event.of(this, arguments));\n  }).on('zoomend', function () {\n    d3.select(this).style(zoomendStyle);\n    zoomOn.call(zoom, 'zoom', null);\n    zoomended(event.of(this, arguments));\n    sync(geo, projection, syncCb);\n  }).on('zoom.redraw', function () {\n    geo.render();\n\n    var _rotate = projection.rotate();\n\n    geo.graphDiv.emit('plotly_relayouting', {\n      'geo.projection.scale': projection.scale() / geo.fitScale,\n      'geo.projection.rotation.lon': -_rotate[0],\n      'geo.projection.rotation.lat': -_rotate[1]\n    });\n  });\n\n  function zoomstarted(dispatch) {\n    if (!zooming++) dispatch({\n      type: 'zoomstart'\n    });\n  }\n\n  function zoomed(dispatch) {\n    dispatch({\n      type: 'zoom'\n    });\n  }\n\n  function zoomended(dispatch) {\n    if (! --zooming) dispatch({\n      type: 'zoomend'\n    });\n  }\n\n  function syncCb(set) {\n    var _rotate = projection.rotate();\n\n    set('projection.rotation.lon', -_rotate[0]);\n    set('projection.rotation.lat', -_rotate[1]);\n  }\n\n  return d3.rebind(zoom, event, 'on');\n} // -- helper functions for zoomClipped\n\n\nfunction position(projection, point) {\n  var spherical = projection.invert(point);\n  return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);\n}\n\nfunction quaternionFromEuler(euler) {\n  var lambda = 0.5 * euler[0] * radians;\n  var phi = 0.5 * euler[1] * radians;\n  var gamma = 0.5 * euler[2] * radians;\n  var sinLambda = Math.sin(lambda);\n  var cosLambda = Math.cos(lambda);\n  var sinPhi = Math.sin(phi);\n  var cosPhi = Math.cos(phi);\n  var sinGamma = Math.sin(gamma);\n  var cosGamma = Math.cos(gamma);\n  return [cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma, sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma, cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma, cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma];\n}\n\nfunction multiply(a, b) {\n  var a0 = a[0];\n  var a1 = a[1];\n  var a2 = a[2];\n  var a3 = a[3];\n  var b0 = b[0];\n  var b1 = b[1];\n  var b2 = b[2];\n  var b3 = b[3];\n  return [a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3, a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2, a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1, a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0];\n}\n\nfunction rotateBetween(a, b) {\n  if (!a || !b) return;\n  var axis = cross(a, b);\n  var norm = Math.sqrt(dot(axis, axis));\n  var halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b))));\n  var k = Math.sin(halfgamma) / norm;\n  return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];\n} // input:\n//   rotateAngles: a calculated set of Euler angles\n//   pt: a point (cartesian in 3-space) to keep fixed\n//   roll0: an initial roll, to be preserved\n// output:\n//   a set of Euler angles that preserve the projection of pt\n//     but set roll (output[2]) equal to roll0\n//     note that this doesn't depend on the particular projection,\n//     just on the rotation angles\n\n\nfunction unRoll(rotateAngles, pt, lastRotate) {\n  // calculate the fixed point transformed by these Euler angles\n  // but with the desired roll undone\n  var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);\n  ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);\n  ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);\n  var x = pt[0];\n  var y = pt[1];\n  var z = pt[2];\n  var f = ptRotated[0];\n  var g = ptRotated[1];\n  var h = ptRotated[2]; // the following essentially solves:\n  // ptRotated = rotateCartesian(rotateCartesian(pt, 2, newYaw), 1, newPitch)\n  // for newYaw and newPitch, as best it can\n\n  var theta = Math.atan2(y, x) * degrees;\n  var a = Math.sqrt(x * x + y * y);\n  var b;\n  var newYaw1;\n\n  if (Math.abs(g) > a) {\n    newYaw1 = (g > 0 ? 90 : -90) - theta;\n    b = 0;\n  } else {\n    newYaw1 = Math.asin(g / a) * degrees - theta;\n    b = Math.sqrt(a * a - g * g);\n  }\n\n  var newYaw2 = 180 - newYaw1 - 2 * theta;\n  var newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees;\n  var newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees; // which is closest to lastRotate[0,1]: newYaw/Pitch or newYaw2/Pitch2?\n\n  var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1);\n  var dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);\n  if (dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];else return [newYaw2, newPitch2, lastRotate[2]];\n}\n\nfunction angleDistance(yaw0, pitch0, yaw1, pitch1) {\n  var dYaw = angleMod(yaw1 - yaw0);\n  var dPitch = angleMod(pitch1 - pitch0);\n  return Math.sqrt(dYaw * dYaw + dPitch * dPitch);\n} // reduce an angle in degrees to [-180,180]\n\n\nfunction angleMod(angle) {\n  return (angle % 360 + 540) % 360 - 180;\n} // rotate a cartesian vector\n// axis is 0 (x), 1 (y), or 2 (z)\n// angle is in degrees\n\n\nfunction rotateCartesian(vector, axis, angle) {\n  var angleRads = angle * radians;\n  var vectorOut = vector.slice();\n  var ax1 = axis === 0 ? 1 : 0;\n  var ax2 = axis === 2 ? 1 : 2;\n  var cosa = Math.cos(angleRads);\n  var sina = Math.sin(angleRads);\n  vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;\n  vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;\n  return vectorOut;\n}\n\nfunction eulerFromQuaternion(q) {\n  return [Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees, Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees, Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0] * radians;\n  var phi = spherical[1] * radians;\n  var cosPhi = Math.cos(phi);\n  return [cosPhi * Math.cos(lambda), cosPhi * Math.sin(lambda), Math.sin(phi)];\n}\n\nfunction dot(a, b) {\n  var s = 0;\n\n  for (var i = 0, n = a.length; i < n; ++i) s += a[i] * b[i];\n\n  return s;\n}\n\nfunction cross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n} // Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\n\n\nfunction d3eventDispatch(target) {\n  var i = 0;\n  var n = arguments.length;\n  var argumentz = [];\n\n  while (++i < n) argumentz.push(arguments[i]);\n\n  var dispatch = d3.dispatch.apply(null, argumentz); // Creates a dispatch context for the specified `thiz` (typically, the target\n  // DOM element that received the source event) and `argumentz` (typically, the\n  // data `d` and index `i` of the target element). The returned function can be\n  // used to dispatch an event to any registered listeners; the function takes a\n  // single argument as input, being the event to dispatch. The event must have\n  // a \"type\" attribute which corresponds to a type registered in the\n  // constructor. This context will automatically populate the \"sourceEvent\" and\n  // \"target\" attributes of the event, as well as setting the `d3.event` global\n  // for the duration of the notification.\n\n  dispatch.of = function (thiz, argumentz) {\n    return function (e1) {\n      var e0;\n\n      try {\n        e0 = e1.sourceEvent = d3.event;\n        e1.target = target;\n        d3.event = e1;\n        dispatch[e1.type].apply(thiz, argumentz);\n      } finally {\n        d3.event = e0;\n      }\n    };\n  };\n\n  return dispatch;\n}","map":null,"metadata":{},"sourceType":"script"}