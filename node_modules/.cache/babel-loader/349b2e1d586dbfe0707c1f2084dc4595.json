{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\n/**\n * aggNums() returns the result of an aggregate function applied to an array of\n * values, where non-numerical values have been tossed out.\n *\n * @param {function} f - aggregation function (e.g., Math.min)\n * @param {Number} v - initial value (continuing from previous calls)\n *      if there's no continuing value, use null for selector-type\n *      functions (max,min), or 0 for summations\n * @param {Array} a - array to aggregate (may be nested, we will recurse,\n *                    but all elements must have the same dimension)\n * @param {Number} len - maximum length of a to aggregate\n * @return {Number} - result of f applied to a starting from v\n */\n\n\nexports.aggNums = function (f, v, a, len) {\n  var i, b;\n  if (!len || len > a.length) len = a.length;\n  if (!isNumeric(v)) v = false;\n\n  if (isArrayOrTypedArray(a[0])) {\n    b = new Array(len);\n\n    for (i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);\n\n    a = b;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (!isNumeric(v)) v = a[i];else if (isNumeric(a[i])) v = f(+v, +a[i]);\n  }\n\n  return v;\n};\n/**\n * mean & std dev functions using aggNums, so it handles non-numerics nicely\n * even need to use aggNums instead of .length, to toss out non-numerics\n */\n\n\nexports.len = function (data) {\n  return exports.aggNums(function (a) {\n    return a + 1;\n  }, 0, data);\n};\n\nexports.mean = function (data, len) {\n  if (!len) len = exports.len(data);\n  return exports.aggNums(function (a, b) {\n    return a + b;\n  }, 0, data) / len;\n};\n\nexports.midRange = function (numArr) {\n  if (numArr === undefined || numArr.length === 0) return undefined;\n  return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;\n};\n\nexports.variance = function (data, len, mean) {\n  if (!len) len = exports.len(data);\n  if (!isNumeric(mean)) mean = exports.mean(data, len);\n  return exports.aggNums(function (a, b) {\n    return a + Math.pow(b - mean, 2);\n  }, 0, data) / len;\n};\n\nexports.stdev = function (data, len, mean) {\n  return Math.sqrt(exports.variance(data, len, mean));\n};\n/**\n * median of a finite set of numbers\n * reference page: https://en.wikipedia.org/wiki/Median#Finite_set_of_numbers\n**/\n\n\nexports.median = function (data) {\n  var b = data.slice().sort();\n  return exports.interp(b, 0.5);\n};\n/**\n * interp() computes a percentile (quantile) for a given distribution.\n * We interpolate the distribution (to compute quantiles, we follow method #10 here:\n * http://www.amstat.org/publications/jse/v14n3/langford.html).\n * Typically the index or rank (n * arr.length) may be non-integer.\n * For reference: ends are clipped to the extreme values in the array;\n * For box plots: index you get is half a point too high (see\n * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition\n * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).\n *\n * @param {Array} arr - This array contains the values that make up the distribution.\n * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.\n * For example, the 50th percentile (or median) corresponds to n = 0.5\n * @return {Number} - percentile\n */\n\n\nexports.interp = function (arr, n) {\n  if (!isNumeric(n)) throw 'n should be a finite number';\n  n = n * arr.length - 0.5;\n  if (n < 0) return arr[0];\n  if (n > arr.length - 1) return arr[arr.length - 1];\n  var frac = n % 1;\n  return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];\n};","map":null,"metadata":{},"sourceType":"script"}