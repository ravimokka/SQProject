{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nvar fillText = require('../../lib').fillText;\n\nvar attributes = require('./attributes');\n\nmodule.exports = function hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var geo = pointData.subplot;\n  var isLonLatOverEdges = geo.projection.isLonLatOverEdges;\n  var project = geo.project;\n\n  function distFn(d) {\n    var lonlat = d.lonlat;\n    if (lonlat[0] === BADNUM) return Infinity;\n    if (isLonLatOverEdges(lonlat)) return Infinity;\n    var pt = project(lonlat);\n    var px = project([xval, yval]);\n    var dx = Math.abs(pt[0] - px[0]);\n    var dy = Math.abs(pt[1] - px[1]);\n    var rad = Math.max(3, d.mrc || 0); // N.B. d.mrc is the calculated marker radius\n    // which is only set for trace with 'markers' mode.\n\n    return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n  }\n\n  Fx.getClosest(cd, distFn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n  if (pointData.index === false) return;\n  var di = cd[pointData.index];\n  var lonlat = di.lonlat;\n  var pos = [xa.c2p(lonlat), ya.c2p(lonlat)];\n  var rad = di.mrc || 1;\n  pointData.x0 = pos[0] - rad;\n  pointData.x1 = pos[0] + rad;\n  pointData.y0 = pos[1] - rad;\n  pointData.y1 = pos[1] + rad;\n  pointData.loc = di.loc;\n  pointData.lon = lonlat[0];\n  pointData.lat = lonlat[1];\n  var ax = geo.mockAxis;\n  pointData.lonLabel = Axes.tickText(ax, ax.c2l(pointData.lon), 'hover').text;\n  pointData.latLabel = Axes.tickText(ax, ax.c2l(pointData.lat), 'hover').text;\n  pointData.color = getTraceColor(trace, di);\n  pointData.extraText = getExtraText(trace, di, pointData, cd[0].t.labels);\n  pointData.hovertemplate = trace.hovertemplate;\n  return [pointData];\n};\n\nfunction getExtraText(trace, pt, pointData, labels) {\n  if (trace.hovertemplate) return;\n  var hoverinfo = pt.hi || trace.hoverinfo;\n  var parts = hoverinfo === 'all' ? attributes.hoverinfo.flags : hoverinfo.split('+');\n  var hasLocation = parts.indexOf('location') !== -1 && Array.isArray(trace.locations);\n  var hasLon = parts.indexOf('lon') !== -1;\n  var hasLat = parts.indexOf('lat') !== -1;\n  var hasText = parts.indexOf('text') !== -1;\n  var text = [];\n\n  function format(val) {\n    return val + '\\u00B0';\n  }\n\n  if (hasLocation) {\n    text.push(pt.loc);\n  } else if (hasLon && hasLat) {\n    text.push('(' + format(pointData.lonLabel) + ', ' + format(pointData.latLabel) + ')');\n  } else if (hasLon) {\n    text.push(labels.lon + format(pointData.lonLabel));\n  } else if (hasLat) {\n    text.push(labels.lat + format(pointData.latLabel));\n  }\n\n  if (hasText) {\n    fillText(pt, trace, text);\n  }\n\n  return text.join('<br>');\n}","map":null,"metadata":{},"sourceType":"script"}