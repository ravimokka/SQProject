{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\n\nvar Color = require('../color');\n\nvar Colorscale = require('../colorscale');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nvar alignment = require('../../constants/alignment');\n\nvar LINE_SPACING = alignment.LINE_SPACING;\n\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar subTypes = require('../../traces/scatter/subtypes');\n\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\n\nvar drawing = module.exports = {};\n\nvar appendArrayPointValue = require('../fx/helpers').appendArrayPointValue; // -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\n\ndrawing.font = function (s, family, size, color) {\n  // also allow the form font(s, {family, size, color})\n  if (Lib.isPlainObject(family)) {\n    color = family.color;\n    size = family.size;\n    family = family.family;\n  }\n\n  if (family) s.style('font-family', family);\n  if (size + 1) s.style('font-size', size + 'px');\n  if (color) s.call(Color.fill, color);\n};\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\n\n\ndrawing.setPosition = function (s, x, y) {\n  s.attr('x', x).attr('y', y);\n};\n\ndrawing.setSize = function (s, w, h) {\n  s.attr('width', w).attr('height', h);\n};\n\ndrawing.setRect = function (s, x, y, w, h) {\n  s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\n\n\ndrawing.translatePoint = function (d, sel, xa, ya) {\n  var x = xa.c2p(d.x);\n  var y = ya.c2p(d.y);\n\n  if (isNumeric(x) && isNumeric(y) && sel.node()) {\n    // for multiline text this works better\n    if (sel.node().nodeName === 'text') {\n      sel.attr('x', x).attr('y', y);\n    } else {\n      sel.attr('transform', 'translate(' + x + ',' + y + ')');\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\ndrawing.translatePoints = function (s, xa, ya) {\n  s.each(function (d) {\n    var sel = d3.select(this);\n    drawing.translatePoint(d, sel, xa, ya);\n  });\n};\n\ndrawing.hideOutsideRangePoint = function (d, sel, xa, ya, xcalendar, ycalendar) {\n  sel.attr('display', xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : 'none');\n};\n\ndrawing.hideOutsideRangePoints = function (traceGroups, subplot) {\n  if (!subplot._hasClipOnAxisFalse) return;\n  var xa = subplot.xaxis;\n  var ya = subplot.yaxis;\n  traceGroups.each(function (d) {\n    var trace = d[0].trace;\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n    traceGroups.selectAll(selector).each(function (d) {\n      drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n    });\n  });\n};\n\ndrawing.crispRound = function (gd, lineWidth, dflt) {\n  // for lines that disable antialiasing we want to\n  // make sure the width is an integer, and at least 1 if it's nonzero\n  if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0; // but not for static plots - these don't get antialiased anyway.\n\n  if (gd._context.staticPlot) return lineWidth;\n  if (lineWidth < 1) return 1;\n  return Math.round(lineWidth);\n};\n\ndrawing.singleLineStyle = function (d, s, lw, lc, ld) {\n  s.style('fill', 'none');\n  var line = (((d || [])[0] || {}).trace || {}).line || {};\n  var lw1 = lw || line.width || 0;\n  var dash = ld || line.dash || '';\n  Color.stroke(s, lc || line.color);\n  drawing.dashLine(s, dash, lw1);\n};\n\ndrawing.lineGroupStyle = function (s, lw, lc, ld) {\n  s.style('fill', 'none').each(function (d) {\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n    d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);\n  });\n};\n\ndrawing.dashLine = function (s, dash, lineWidth) {\n  lineWidth = +lineWidth || 0;\n  dash = drawing.dashStyle(dash, lineWidth);\n  s.style({\n    'stroke-dasharray': dash,\n    'stroke-width': lineWidth + 'px'\n  });\n};\n\ndrawing.dashStyle = function (dash, lineWidth) {\n  lineWidth = +lineWidth || 1;\n  var dlw = Math.max(lineWidth, 3);\n  if (dash === 'solid') dash = '';else if (dash === 'dot') dash = dlw + 'px,' + dlw + 'px';else if (dash === 'dash') dash = 3 * dlw + 'px,' + 3 * dlw + 'px';else if (dash === 'longdash') dash = 5 * dlw + 'px,' + 5 * dlw + 'px';else if (dash === 'dashdot') {\n    dash = 3 * dlw + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n  } else if (dash === 'longdashdot') {\n    dash = 5 * dlw + 'px,' + 2 * dlw + 'px,' + dlw + 'px,' + 2 * dlw + 'px';\n  } // otherwise user wrote the dasharray themselves - leave it be\n\n  return dash;\n}; // Same as fillGroupStyle, except in this case the selection may be a transition\n\n\ndrawing.singleFillStyle = function (sel) {\n  var node = d3.select(sel.node());\n  var data = node.data();\n  var fillcolor = (((data[0] || [])[0] || {}).trace || {}).fillcolor;\n\n  if (fillcolor) {\n    sel.call(Color.fill, fillcolor);\n  }\n};\n\ndrawing.fillGroupStyle = function (s) {\n  s.style('stroke-width', 0).each(function (d) {\n    var shape = d3.select(this); // N.B. 'd' won't be a calcdata item when\n    // fill !== 'none' on a segment-less and marker-less trace\n\n    if (d[0].trace) {\n      shape.call(Color.fill, d[0].trace.fillcolor);\n    }\n  });\n};\n\nvar SYMBOLDEFS = require('./symbol_defs');\n\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\nObject.keys(SYMBOLDEFS).forEach(function (k) {\n  var symDef = SYMBOLDEFS[k];\n  drawing.symbolList = drawing.symbolList.concat([symDef.n, k, symDef.n + 100, k + '-open']);\n  drawing.symbolNames[symDef.n] = k;\n  drawing.symbolFuncs[symDef.n] = symDef.f;\n\n  if (symDef.needLine) {\n    drawing.symbolNeedLines[symDef.n] = true;\n  }\n\n  if (symDef.noDot) {\n    drawing.symbolNoDot[symDef.n] = true;\n  } else {\n    drawing.symbolList = drawing.symbolList.concat([symDef.n + 200, k + '-dot', symDef.n + 300, k + '-open-dot']);\n  }\n\n  if (symDef.noFill) {\n    drawing.symbolNoFill[symDef.n] = true;\n  }\n});\nvar MAXSYMBOL = drawing.symbolNames.length; // add a dot in the middle of the symbol\n\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\n\ndrawing.symbolNumber = function (v) {\n  if (typeof v === 'string') {\n    var vbase = 0;\n\n    if (v.indexOf('-open') > 0) {\n      vbase = 100;\n      v = v.replace('-open', '');\n    }\n\n    if (v.indexOf('-dot') > 0) {\n      vbase += 200;\n      v = v.replace('-dot', '');\n    }\n\n    v = drawing.symbolNames.indexOf(v);\n\n    if (v >= 0) {\n      v += vbase;\n    }\n  }\n\n  if (v % 100 >= MAXSYMBOL || v >= 400) {\n    return 0;\n  }\n\n  return Math.floor(Math.max(v, 0));\n};\n\nfunction makePointPath(symbolNumber, r) {\n  var base = symbolNumber % 100;\n  return drawing.symbolFuncs[base](r) + (symbolNumber >= 200 ? DOTPATH : '');\n}\n\nvar HORZGRADIENT = {\n  x1: 1,\n  x2: 0,\n  y1: 0,\n  y2: 0\n};\nvar VERTGRADIENT = {\n  x1: 0,\n  x2: 0,\n  y1: 1,\n  y2: 0\n};\nvar stopFormatter = d3.format('~.1f');\nvar gradientInfo = {\n  radial: {\n    node: 'radialGradient'\n  },\n  radialreversed: {\n    node: 'radialGradient',\n    reversed: true\n  },\n  horizontal: {\n    node: 'linearGradient',\n    attrs: HORZGRADIENT\n  },\n  horizontalreversed: {\n    node: 'linearGradient',\n    attrs: HORZGRADIENT,\n    reversed: true\n  },\n  vertical: {\n    node: 'linearGradient',\n    attrs: VERTGRADIENT\n  },\n  verticalreversed: {\n    node: 'linearGradient',\n    attrs: VERTGRADIENT,\n    reversed: true\n  }\n};\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\n\ndrawing.gradient = function (sel, gd, gradientID, type, colorscale, prop) {\n  var len = colorscale.length;\n  var info = gradientInfo[type];\n  var colorStops = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    if (info.reversed) {\n      colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n    } else {\n      colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n    }\n  }\n\n  var fullID = 'g' + gd._fullLayout._uid + '-' + gradientID;\n\n  var gradient = gd._fullLayout._defs.select('.gradients').selectAll('#' + fullID).data([type + colorStops.join(';')], Lib.identity);\n\n  gradient.exit().remove();\n  gradient.enter().append(info.node).each(function () {\n    var el = d3.select(this);\n    if (info.attrs) el.attr(info.attrs);\n    el.attr('id', fullID);\n    var stops = el.selectAll('stop').data(colorStops);\n    stops.exit().remove();\n    stops.enter().append('stop');\n    stops.each(function (d) {\n      var tc = tinycolor(d[1]);\n      d3.select(this).attr({\n        offset: d[0] + '%',\n        'stop-color': Color.tinyRGB(tc),\n        'stop-opacity': tc.getAlpha()\n      });\n    });\n  });\n  sel.style(prop, getFullUrl(fullID, gd)).style(prop + '-opacity', null);\n};\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\n\n\ndrawing.initGradients = function (gd) {\n  var gradientsGroup = Lib.ensureSingle(gd._fullLayout._defs, 'g', 'gradients');\n  gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n};\n\ndrawing.pointStyle = function (s, trace, gd) {\n  if (!s.size()) return;\n  var fns = drawing.makePointStyleFns(trace);\n  s.each(function (d) {\n    drawing.singlePointStyle(d, d3.select(this), trace, fns, gd);\n  });\n};\n\ndrawing.singlePointStyle = function (d, sel, trace, fns, gd) {\n  var marker = trace.marker;\n  var markerLine = marker.line;\n  sel.style('opacity', fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === undefined ? marker.opacity : d.mo);\n\n  if (fns.ms2mrc) {\n    var r; // handle multi-trace graph edit case\n\n    if (d.ms === 'various' || marker.size === 'various') {\n      r = 3;\n    } else {\n      r = fns.ms2mrc(d.ms);\n    } // store the calculated size so hover can use it\n\n\n    d.mrc = r;\n\n    if (fns.selectedSizeFn) {\n      r = d.mrc = fns.selectedSizeFn(d);\n    } // turn the symbol into a sanitized number\n\n\n    var x = drawing.symbolNumber(d.mx || marker.symbol) || 0; // save if this marker is open\n    // because that impacts how to handle colors\n\n    d.om = x % 200 >= 100;\n    sel.attr('d', makePointPath(x, r));\n  }\n\n  var perPointGradient = false;\n  var fillColor, lineColor, lineWidth; // 'so' is suspected outliers, for box plots\n\n  if (d.so) {\n    lineWidth = markerLine.outlierwidth;\n    lineColor = markerLine.outliercolor;\n    fillColor = marker.outliercolor;\n  } else {\n    var markerLineWidth = (markerLine || {}).width;\n    lineWidth = (d.mlw + 1 || markerLineWidth + 1 || // TODO: we need the latter for legends... can we get rid of it?\n    (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;\n    if ('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc); // weird case: array wasn't long enough to apply to every point\n    else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;else lineColor = markerLine.color;\n\n    if (Lib.isArrayOrTypedArray(marker.color)) {\n      fillColor = Color.defaultLine;\n      perPointGradient = true;\n    }\n\n    if ('mc' in d) {\n      fillColor = d.mcc = fns.markerScale(d.mc);\n    } else {\n      fillColor = marker.color || 'rgba(0,0,0,0)';\n    }\n\n    if (fns.selectedColorFn) {\n      fillColor = fns.selectedColorFn(d);\n    }\n  }\n\n  if (d.om) {\n    // open markers can't have zero linewidth, default to 1px,\n    // and use fill color as stroke color\n    sel.call(Color.stroke, fillColor).style({\n      'stroke-width': (lineWidth || 1) + 'px',\n      fill: 'none'\n    });\n  } else {\n    sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n    var markerGradient = marker.gradient;\n    var gradientType = d.mgt;\n    if (gradientType) perPointGradient = true;else gradientType = markerGradient && markerGradient.type; // for legend - arrays will propagate through here, but we don't need\n    // to treat it as per-point.\n\n    if (Array.isArray(gradientType)) {\n      gradientType = gradientType[0];\n      if (!gradientInfo[gradientType]) gradientType = 0;\n    }\n\n    if (gradientType && gradientType !== 'none') {\n      var gradientColor = d.mgc;\n      if (gradientColor) perPointGradient = true;else gradientColor = markerGradient.color;\n      var gradientID = trace.uid;\n      if (perPointGradient) gradientID += '-' + d.i;\n      drawing.gradient(sel, gd, gradientID, gradientType, [[0, gradientColor], [1, fillColor]], 'fill');\n    } else {\n      Color.fill(sel, fillColor);\n    }\n\n    if (lineWidth) {\n      Color.stroke(sel, lineColor);\n    }\n  }\n};\n\ndrawing.makePointStyleFns = function (trace) {\n  var out = {};\n  var marker = trace.marker; // allow array marker and marker line colors to be\n  // scaled by given max and min to colorscales\n\n  out.markerScale = drawing.tryColorscale(marker, '');\n  out.lineScale = drawing.tryColorscale(marker, 'line');\n\n  if (Registry.traceIs(trace, 'symbols')) {\n    out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function () {\n      return (marker.size || 6) / 2;\n    };\n  }\n\n  if (trace.selectedpoints) {\n    Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n  }\n\n  return out;\n};\n\ndrawing.makeSelectedPointStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var marker = trace.marker || {};\n  var selectedMarker = selectedAttrs.marker || {};\n  var unselectedMarker = unselectedAttrs.marker || {};\n  var mo = marker.opacity;\n  var smo = selectedMarker.opacity;\n  var usmo = unselectedMarker.opacity;\n  var smoIsDefined = smo !== undefined;\n  var usmoIsDefined = usmo !== undefined;\n\n  if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n    out.selectedOpacityFn = function (d) {\n      var base = d.mo === undefined ? marker.opacity : d.mo;\n\n      if (d.selected) {\n        return smoIsDefined ? smo : base;\n      } else {\n        return usmoIsDefined ? usmo : DESELECTDIM * base;\n      }\n    };\n  }\n\n  var mc = marker.color;\n  var smc = selectedMarker.color;\n  var usmc = unselectedMarker.color;\n\n  if (smc || usmc) {\n    out.selectedColorFn = function (d) {\n      var base = d.mcc || mc;\n\n      if (d.selected) {\n        return smc || base;\n      } else {\n        return usmc || base;\n      }\n    };\n  }\n\n  var ms = marker.size;\n  var sms = selectedMarker.size;\n  var usms = unselectedMarker.size;\n  var smsIsDefined = sms !== undefined;\n  var usmsIsDefined = usms !== undefined;\n\n  if (Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n    out.selectedSizeFn = function (d) {\n      var base = d.mrc || ms / 2;\n\n      if (d.selected) {\n        return smsIsDefined ? sms / 2 : base;\n      } else {\n        return usmsIsDefined ? usms / 2 : base;\n      }\n    };\n  }\n\n  return out;\n};\n\ndrawing.makeSelectedTextStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var textFont = trace.textfont || {};\n  var selectedTextFont = selectedAttrs.textfont || {};\n  var unselectedTextFont = unselectedAttrs.textfont || {};\n  var tc = textFont.color;\n  var stc = selectedTextFont.color;\n  var utc = unselectedTextFont.color;\n\n  out.selectedTextColorFn = function (d) {\n    var base = d.tc || tc;\n\n    if (d.selected) {\n      return stc || base;\n    } else {\n      if (utc) return utc;else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n    }\n  };\n\n  return out;\n};\n\ndrawing.selectedPointStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedPointStyleFns(trace);\n  var marker = trace.marker || {};\n  var seq = [];\n\n  if (fns.selectedOpacityFn) {\n    seq.push(function (pt, d) {\n      pt.style('opacity', fns.selectedOpacityFn(d));\n    });\n  }\n\n  if (fns.selectedColorFn) {\n    seq.push(function (pt, d) {\n      Color.fill(pt, fns.selectedColorFn(d));\n    });\n  }\n\n  if (fns.selectedSizeFn) {\n    seq.push(function (pt, d) {\n      var mx = d.mx || marker.symbol || 0;\n      var mrc2 = fns.selectedSizeFn(d);\n      pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2)); // save for Drawing.selectedTextStyle\n\n      d.mrc2 = mrc2;\n    });\n  }\n\n  if (seq.length) {\n    s.each(function (d) {\n      var pt = d3.select(this);\n\n      for (var i = 0; i < seq.length; i++) {\n        seq[i](pt, d);\n      }\n    });\n  }\n};\n\ndrawing.tryColorscale = function (marker, prefix) {\n  var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n\n  if (cont) {\n    var colorArray = cont.color;\n\n    if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n      return Colorscale.makeColorScaleFuncFromTrace(cont);\n    }\n  }\n\n  return Lib.identity;\n};\n\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  end: -1,\n  middle: 0,\n  bottom: 1,\n  top: -1\n};\n\nfunction textPointPosition(s, textPosition, fontSize, markerRadius) {\n  var group = d3.select(s.node().parentNode);\n  var v = textPosition.indexOf('top') !== -1 ? 'top' : textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n  var h = textPosition.indexOf('left') !== -1 ? 'end' : textPosition.indexOf('right') !== -1 ? 'start' : 'middle'; // if markers are shown, offset a little more than\n  // the nominal marker size\n  // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n\n  var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n  var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n  var dx = TEXTOFFSETSIGN[h] * r;\n  var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2; // fix the overall text group position\n\n  s.attr('text-anchor', h);\n  group.attr('transform', 'translate(' + dx + ',' + dy + ')');\n}\n\nfunction extracTextFontSize(d, trace) {\n  var fontSize = d.ts || trace.textfont.size;\n  return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;\n} // draw text at points\n\n\ndrawing.textPointStyle = function (s, trace, gd, inLegend) {\n  if (!s.size()) return;\n  var selectedTextColorFn;\n\n  if (trace.selectedpoints) {\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n    selectedTextColorFn = fns.selectedTextColorFn;\n  }\n\n  var template = trace.texttemplate; // If styling text in legends, do not use texttemplate\n\n  if (inLegend) template = false;\n  s.each(function (d) {\n    var p = d3.select(this);\n    var text = Lib.extractOption(d, trace, template ? 'txt' : 'tx', template ? 'texttemplate' : 'text');\n\n    if (!text && text !== 0) {\n      p.remove();\n      return;\n    }\n\n    if (template) {\n      var pt = {};\n      appendArrayPointValue(pt, trace, d.i);\n      text = Lib.texttemplateString(text, {}, gd._fullLayout._d3locale, pt, d, trace._meta || {});\n    }\n\n    var pos = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;\n    p.call(drawing.font, d.tf || trace.textfont.family, fontSize, fontColor).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);\n  });\n};\n\ndrawing.selectedTextStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedTextStyleFns(trace);\n  s.each(function (d) {\n    var tx = d3.select(this);\n    var tc = fns.selectedTextColorFn(d);\n    var tp = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    Color.fill(tx, tc);\n    textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc);\n  });\n}; // generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\n\nvar CatmullRomExp = 0.5;\n\ndrawing.smoothopen = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L');\n  }\n\n  var path = 'M' + pts[0];\n  var tangents = [];\n  var i;\n\n  for (i = 1; i < pts.length - 1; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n\n  path += 'Q' + tangents[0][0] + ' ' + pts[1];\n\n  for (i = 2; i < pts.length - 1; i++) {\n    path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n  }\n\n  path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n  return path;\n};\n\ndrawing.smoothclosed = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L') + 'Z';\n  }\n\n  var path = 'M' + pts[0];\n  var pLast = pts.length - 1;\n  var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n  var i;\n\n  for (i = 1; i < pLast; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n\n  tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));\n\n  for (i = 1; i <= pLast; i++) {\n    path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n  }\n\n  path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n  return path;\n};\n\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n  var d1x = prevpt[0] - thispt[0];\n  var d1y = prevpt[1] - thispt[1];\n  var d2x = nextpt[0] - thispt[0];\n  var d2y = nextpt[1] - thispt[1];\n  var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n  var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n  var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n  var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n  var denom1 = 3 * d2a * (d1a + d2a);\n  var denom2 = 3 * d1a * (d1a + d2a);\n  return [[d3.round(thispt[0] + (denom1 && numx / denom1), 2), d3.round(thispt[1] + (denom1 && numy / denom1), 2)], [d3.round(thispt[0] - (denom2 && numx / denom2), 2), d3.round(thispt[1] - (denom2 && numy / denom2), 2)]];\n} // step paths - returns a generator function for paths\n// with the given step shape\n\n\nvar STEPPATH = {\n  hv: function (p0, p1) {\n    return 'H' + d3.round(p1[0], 2) + 'V' + d3.round(p1[1], 2);\n  },\n  vh: function (p0, p1) {\n    return 'V' + d3.round(p1[1], 2) + 'H' + d3.round(p1[0], 2);\n  },\n  hvh: function (p0, p1) {\n    return 'H' + d3.round((p0[0] + p1[0]) / 2, 2) + 'V' + d3.round(p1[1], 2) + 'H' + d3.round(p1[0], 2);\n  },\n  vhv: function (p0, p1) {\n    return 'V' + d3.round((p0[1] + p1[1]) / 2, 2) + 'H' + d3.round(p1[0], 2) + 'V' + d3.round(p1[1], 2);\n  }\n};\n\nvar STEPLINEAR = function (p0, p1) {\n  return 'L' + d3.round(p1[0], 2) + ',' + d3.round(p1[1], 2);\n};\n\ndrawing.steps = function (shape) {\n  var onestep = STEPPATH[shape] || STEPLINEAR;\n  return function (pts) {\n    var path = 'M' + d3.round(pts[0][0], 2) + ',' + d3.round(pts[0][1], 2);\n\n    for (var i = 1; i < pts.length; i++) {\n      path += onestep(pts[i - 1], pts[i]);\n    }\n\n    return path;\n  };\n}; // off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\n\n\ndrawing.makeTester = function () {\n  var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function (s) {\n    s.attr(xmlnsNamespaces.svgAttrs).style({\n      position: 'absolute',\n      left: '-10000px',\n      top: '-10000px',\n      width: '9000px',\n      height: '9000px',\n      'z-index': '1'\n    });\n  }); // browsers differ on how they describe the bounding rect of\n  // the svg if its contents spill over... so make a 1x1px\n  // reference point we can measure off of.\n\n  var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function (s) {\n    s.attr('d', 'M0,0H1V1H0Z').style({\n      'stroke-width': 0,\n      fill: 'black'\n    });\n  });\n  drawing.tester = tester;\n  drawing.testref = testref;\n};\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\n\n\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\n\ndrawing.bBox = function (node, inTester, hash) {\n  /*\n   * Cache elements we've already measured so we don't have to\n   * remeasure the same thing many times\n   * We have a few bBox callers though who pass a node larger than\n   * a <text> or a MathJax <g>, such as an axis group containing many labels.\n   * These will not generate a hash (unless we figure out an appropriate\n   * hash key for them) and thus we will not hash them.\n   */\n  if (!hash) hash = nodeHash(node);\n  var out;\n\n  if (hash) {\n    out = drawing.savedBBoxes[hash];\n    if (out) return Lib.extendFlat({}, out);\n  } else if (node.childNodes.length === 1) {\n    /*\n     * If we have only one child element, which is itself hashable, make\n     * a new hash from this element plus its x,y,transform\n     * These bounding boxes *include* x,y,transform - mostly for use by\n     * callers trying to avoid overlaps (ie titles)\n     */\n    var innerNode = node.childNodes[0];\n    hash = nodeHash(innerNode);\n\n    if (hash) {\n      var x = +innerNode.getAttribute('x') || 0;\n      var y = +innerNode.getAttribute('y') || 0;\n      var transform = innerNode.getAttribute('transform');\n\n      if (!transform) {\n        // in this case, just varying x and y, don't bother caching\n        // the final bBox because the alteration is quick.\n        var innerBB = drawing.bBox(innerNode, false, hash);\n\n        if (x) {\n          innerBB.left += x;\n          innerBB.right += x;\n        }\n\n        if (y) {\n          innerBB.top += y;\n          innerBB.bottom += y;\n        }\n\n        return innerBB;\n      }\n      /*\n       * else we have a transform - rather than make a complicated\n       * (and error-prone and probably slow) transform parser/calculator,\n       * just continue on calculating the boundingClientRect of the group\n       * and use the new composite hash to cache it.\n       * That said, `innerNode.transform.baseVal` is an array of\n       * `SVGTransform` objects, that *do* seem to have a nice matrix\n       * multiplication interface that we could use to avoid making\n       * another getBoundingClientRect call...\n       */\n\n\n      hash += '~' + x + '~' + y + '~' + transform;\n      out = drawing.savedBBoxes[hash];\n      if (out) return Lib.extendFlat({}, out);\n    }\n  }\n\n  var testNode, tester;\n\n  if (inTester) {\n    testNode = node;\n  } else {\n    tester = drawing.tester.node(); // copy the node to test into the tester\n\n    testNode = node.cloneNode(true);\n    tester.appendChild(testNode);\n  } // standardize its position (and newline tspans if any)\n\n\n  d3.select(testNode).attr('transform', null).call(svgTextUtils.positionText, 0, 0);\n  var testRect = testNode.getBoundingClientRect();\n  var refRect = drawing.testref.node().getBoundingClientRect();\n  if (!inTester) tester.removeChild(testNode);\n  var bb = {\n    height: testRect.height,\n    width: testRect.width,\n    left: testRect.left - refRect.left,\n    top: testRect.top - refRect.top,\n    right: testRect.right - refRect.left,\n    bottom: testRect.bottom - refRect.top\n  }; // make sure we don't have too many saved boxes,\n  // or a long session could overload on memory\n  // by saving boxes for long-gone elements\n\n  if (savedBBoxesCount >= maxSavedBBoxes) {\n    drawing.savedBBoxes = {};\n    savedBBoxesCount = 0;\n  } // cache this bbox\n\n\n  if (hash) drawing.savedBBoxes[hash] = bb;\n  savedBBoxesCount++;\n  return Lib.extendFlat({}, bb);\n}; // capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\n\n\nfunction nodeHash(node) {\n  var inputText = node.getAttribute('data-unformatted');\n  if (inputText === null) return;\n  return inputText + node.getAttribute('data-math') + node.getAttribute('text-anchor') + node.getAttribute('style');\n}\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\n\n\ndrawing.setClipUrl = function (s, localId, gd) {\n  s.attr('clip-path', getFullUrl(localId, gd));\n};\n\nfunction getFullUrl(localId, gd) {\n  if (!localId) return null;\n  var context = gd._context;\n  var baseUrl = context._exportedPlot ? '' : context._baseUrl || '';\n  return 'url(\\'' + baseUrl + '#' + localId + '\\')';\n}\n\ndrawing.getTranslate = function (element) {\n  // Note the separator [^\\d] between x and y in this regex\n  // We generally use ',' but IE will convert it to ' '\n  var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 0,\n    y: +translate[1] || 0\n  };\n};\n\ndrawing.setTranslate = function (element, x, y) {\n  var re = /(\\btranslate\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 0;\n  y = y || 0;\n  transform = transform.replace(re, '').trim();\n  transform += ' translate(' + x + ', ' + y + ')';\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\n\ndrawing.getScale = function (element) {\n  var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 1,\n    y: +translate[1] || 1\n  };\n};\n\ndrawing.setScale = function (element, x, y) {\n  var re = /(\\bscale\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 1;\n  y = y || 1;\n  transform = transform.replace(re, '').trim();\n  transform += ' scale(' + x + ', ' + y + ')';\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\n\nvar SCALE_RE = /\\s*sc.*/;\n\ndrawing.setPointGroupScale = function (selection, xScale, yScale) {\n  xScale = xScale || 1;\n  yScale = yScale || 1;\n  if (!selection) return; // The same scale transform for every point:\n\n  var scale = xScale === 1 && yScale === 1 ? '' : ' scale(' + xScale + ',' + yScale + ')';\n  selection.each(function () {\n    var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n    t += scale;\n    t = t.trim();\n    this.setAttribute('transform', t);\n  });\n};\n\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\n\ndrawing.setTextPointsScale = function (selection, xScale, yScale) {\n  if (!selection) return;\n  selection.each(function () {\n    var transforms;\n    var el = d3.select(this);\n    var text = el.select('text');\n    if (!text.node()) return;\n    var x = parseFloat(text.attr('x') || 0);\n    var y = parseFloat(text.attr('y') || 0);\n    var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n\n    if (xScale === 1 && yScale === 1) {\n      transforms = [];\n    } else {\n      transforms = ['translate(' + x + ',' + y + ')', 'scale(' + xScale + ',' + yScale + ')', 'translate(' + -x + ',' + -y + ')'];\n    }\n\n    if (existingTransform) {\n      transforms.push(existingTransform);\n    }\n\n    el.attr('transform', transforms.join(' '));\n  });\n};","map":null,"metadata":{},"sourceType":"script"}