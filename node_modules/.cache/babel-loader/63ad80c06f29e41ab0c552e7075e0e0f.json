{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n  var lgroupToTraces = {};\n  var lgroups = [];\n  var hasOneNonBlankGroup = false;\n  var slicesShown = {};\n  var lgroupi = 0;\n  var maxNameLength = 0;\n  var i, j;\n\n  function addOneItem(legendGroup, legendItem) {\n    // each '' legend group is treated as a separate group\n    if (legendGroup === '' || !helpers.isGrouped(opts)) {\n      // TODO: check this against fullData legendgroups?\n      var uniqueGroup = '~~i' + lgroupi;\n      lgroups.push(uniqueGroup);\n      lgroupToTraces[uniqueGroup] = [[legendItem]];\n      lgroupi++;\n    } else if (lgroups.indexOf(legendGroup) === -1) {\n      lgroups.push(legendGroup);\n      hasOneNonBlankGroup = true;\n      lgroupToTraces[legendGroup] = [[legendItem]];\n    } else {\n      lgroupToTraces[legendGroup].push([legendItem]);\n    }\n  } // build an { legendgroup: [cd0, cd0], ... } object\n\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var lgroup = trace.legendgroup;\n    if (!trace.visible || !trace.showlegend) continue;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      if (!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n      for (j = 0; j < cd.length; j++) {\n        var labelj = cd[j].label;\n\n        if (!slicesShown[lgroup][labelj]) {\n          addOneItem(lgroup, {\n            label: labelj,\n            color: cd[j].color,\n            i: cd[j].i,\n            trace: trace,\n            pts: cd[j].pts\n          });\n          slicesShown[lgroup][labelj] = true;\n          maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n        }\n      }\n    } else {\n      addOneItem(lgroup, cd0);\n      maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n    }\n  } // won't draw a legend in this case\n\n\n  if (!lgroups.length) return []; // rearrange lgroupToTraces into a d3-friendly array of arrays\n\n  var lgroupsLength = lgroups.length;\n  var ltraces;\n  var legendData;\n\n  if (hasOneNonBlankGroup && helpers.isGrouped(opts)) {\n    legendData = new Array(lgroupsLength);\n\n    for (i = 0; i < lgroupsLength; i++) {\n      ltraces = lgroupToTraces[lgroups[i]];\n      legendData[i] = helpers.isReversed(opts) ? ltraces.reverse() : ltraces;\n    }\n  } else {\n    // collapse all groups into one if all groups are blank\n    legendData = [new Array(lgroupsLength)];\n\n    for (i = 0; i < lgroupsLength; i++) {\n      ltraces = lgroupToTraces[lgroups[i]][0];\n      legendData[0][helpers.isReversed(opts) ? lgroupsLength - i - 1 : i] = ltraces;\n    }\n\n    lgroupsLength = 1;\n  } // number of legend groups - needed in legend/draw.js\n\n\n  opts._lgroupsLength = lgroupsLength; // maximum name/label length - needed in legend/draw.js\n\n  opts._maxNameLength = maxNameLength;\n  return legendData;\n};","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/components/legend/get_legend_data.js"],"names":["Registry","require","helpers","module","exports","getLegendData","calcdata","opts","lgroupToTraces","lgroups","hasOneNonBlankGroup","slicesShown","lgroupi","maxNameLength","i","j","addOneItem","legendGroup","legendItem","isGrouped","uniqueGroup","push","indexOf","length","cd","cd0","trace","lgroup","legendgroup","visible","showlegend","traceIs","labelj","label","color","pts","Math","max","name","lgroupsLength","ltraces","legendData","Array","isReversed","reverse","_lgroupsLength","_maxNameLength"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n    var lgroupToTraces = {};\n    var lgroups = [];\n    var hasOneNonBlankGroup = false;\n    var slicesShown = {};\n    var lgroupi = 0;\n    var maxNameLength = 0;\n    var i, j;\n\n    function addOneItem(legendGroup, legendItem) {\n        // each '' legend group is treated as a separate group\n        if(legendGroup === '' || !helpers.isGrouped(opts)) {\n            // TODO: check this against fullData legendgroups?\n            var uniqueGroup = '~~i' + lgroupi;\n            lgroups.push(uniqueGroup);\n            lgroupToTraces[uniqueGroup] = [[legendItem]];\n            lgroupi++;\n        } else if(lgroups.indexOf(legendGroup) === -1) {\n            lgroups.push(legendGroup);\n            hasOneNonBlankGroup = true;\n            lgroupToTraces[legendGroup] = [[legendItem]];\n        } else {\n            lgroupToTraces[legendGroup].push([legendItem]);\n        }\n    }\n\n    // build an { legendgroup: [cd0, cd0], ... } object\n    for(i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var lgroup = trace.legendgroup;\n\n        if(!trace.visible || !trace.showlegend) continue;\n\n        if(Registry.traceIs(trace, 'pie-like')) {\n            if(!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n            for(j = 0; j < cd.length; j++) {\n                var labelj = cd[j].label;\n\n                if(!slicesShown[lgroup][labelj]) {\n                    addOneItem(lgroup, {\n                        label: labelj,\n                        color: cd[j].color,\n                        i: cd[j].i,\n                        trace: trace,\n                        pts: cd[j].pts\n                    });\n\n                    slicesShown[lgroup][labelj] = true;\n                    maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n                }\n            }\n        } else {\n            addOneItem(lgroup, cd0);\n            maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n        }\n    }\n\n    // won't draw a legend in this case\n    if(!lgroups.length) return [];\n\n    // rearrange lgroupToTraces into a d3-friendly array of arrays\n    var lgroupsLength = lgroups.length;\n    var ltraces;\n    var legendData;\n\n    if(hasOneNonBlankGroup && helpers.isGrouped(opts)) {\n        legendData = new Array(lgroupsLength);\n\n        for(i = 0; i < lgroupsLength; i++) {\n            ltraces = lgroupToTraces[lgroups[i]];\n            legendData[i] = helpers.isReversed(opts) ? ltraces.reverse() : ltraces;\n        }\n    } else {\n        // collapse all groups into one if all groups are blank\n        legendData = [new Array(lgroupsLength)];\n\n        for(i = 0; i < lgroupsLength; i++) {\n            ltraces = lgroupToTraces[lgroups[i]][0];\n            legendData[0][helpers.isReversed(opts) ? lgroupsLength - i - 1 : i] = ltraces;\n        }\n        lgroupsLength = 1;\n    }\n\n    // number of legend groups - needed in legend/draw.js\n    opts._lgroupsLength = lgroupsLength;\n    // maximum name/label length - needed in legend/draw.js\n    opts._maxNameLength = maxNameLength;\n\n    return legendData;\n};\n"]},"metadata":{},"sourceType":"script"}