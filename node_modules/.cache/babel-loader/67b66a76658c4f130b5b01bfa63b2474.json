{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../registry');\n\nvar PlotSchema = require('../plot_api/plot_schema');\n\nvar Template = require('../plot_api/plot_template');\n\nvar Lib = require('../lib');\n\nvar Color = require('../components/color');\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nvar axisIDs = require('./cartesian/axis_ids');\n\nvar animationAttrs = require('./animation_attributes');\n\nvar frameAttrs = require('./frame_attributes');\n\nvar getModuleCalcData = require('../plots/get_data').getModuleCalcData;\n\nvar relinkPrivateKeys = Lib.relinkPrivateKeys;\nvar _ = Lib._;\nvar plots = module.exports = {}; // Expose registry methods on Plots for backward-compatibility\n\nLib.extendFlat(plots, Registry);\nplots.attributes = require('./attributes');\nplots.attributes.type.values = plots.allTypes;\nplots.fontAttrs = require('./font_attributes');\nplots.layoutAttributes = require('./layout_attributes'); // TODO make this a plot attribute?\n\nplots.fontWeight = 'normal';\nvar transformsRegistry = plots.transformsRegistry;\n\nvar commandModule = require('./command');\n\nplots.executeAPICommand = commandModule.executeAPICommand;\nplots.computeAPICommandBindings = commandModule.computeAPICommandBindings;\nplots.manageCommandObserver = commandModule.manageCommandObserver;\nplots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings; // in some cases the browser doesn't seem to know how big\n// the text is at first, so it needs to draw it,\n// then wait a little, then draw it again\n\nplots.redrawText = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n\n  var hasPolar = fullLayout._has && fullLayout._has('polar');\n\n  var hasLegacyPolar = !hasPolar && gd.data && gd.data[0] && gd.data[0].r; // do not work if polar is present\n\n  if (hasLegacyPolar) return;\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      Registry.getComponentMethod('annotations', 'draw')(gd);\n      Registry.getComponentMethod('legend', 'draw')(gd);\n      Registry.getComponentMethod('colorbar', 'draw')(gd);\n      resolve(plots.previousPromises(gd));\n    }, 300);\n  });\n}; // resize plot about the container size\n\n\nplots.resize = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  return new Promise(function (resolve, reject) {\n    if (!gd || Lib.isHidden(gd)) {\n      reject(new Error('Resize must be passed a displayed plot div element.'));\n    }\n\n    if (gd._redrawTimer) clearTimeout(gd._redrawTimer);\n    gd._redrawTimer = setTimeout(function () {\n      // return if there is nothing to resize or is hidden\n      if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {\n        resolve(gd);\n        return;\n      }\n\n      delete gd.layout.width;\n      delete gd.layout.height; // autosizing doesn't count as a change that needs saving\n\n      var oldchanged = gd.changed; // nor should it be included in the undo queue\n\n      gd.autoplay = true;\n      Registry.call('relayout', gd, {\n        autosize: true\n      }).then(function () {\n        gd.changed = oldchanged;\n        resolve(gd);\n      });\n    }, 100);\n  });\n}; // for use in Lib.syncOrAsync, check if there are any\n// pending promises in this plot and wait for them\n\n\nplots.previousPromises = function (gd) {\n  if ((gd._promises || []).length) {\n    return Promise.all(gd._promises).then(function () {\n      gd._promises = [];\n    });\n  }\n};\n/**\n * Adds the 'Edit chart' link.\n * Note that now Plotly.plot() calls this so it can regenerate whenever it replots\n *\n * Add source links to your graph inside the 'showSources' config argument.\n */\n\n\nplots.addLinks = function (gd) {\n  // Do not do anything if showLink and showSources are not set to true in config\n  if (!gd._context.showLink && !gd._context.showSources) return;\n  var fullLayout = gd._fullLayout;\n  var linkContainer = Lib.ensureSingle(fullLayout._paper, 'text', 'js-plot-link-container', function (s) {\n    s.style({\n      'font-family': '\"Open Sans\", Arial, sans-serif',\n      'font-size': '12px',\n      'fill': Color.defaultLine,\n      'pointer-events': 'all'\n    }).each(function () {\n      var links = d3.select(this);\n      links.append('tspan').classed('js-link-to-tool', true);\n      links.append('tspan').classed('js-link-spacer', true);\n      links.append('tspan').classed('js-sourcelinks', true);\n    });\n  }); // The text node inside svg\n\n  var text = linkContainer.node();\n  var attrs = {\n    y: fullLayout._paper.attr('height') - 9\n  }; // If text's width is bigger than the layout\n  // Check that text is a child node or document.body\n  // because otherwise IE/Edge might throw an exception\n  // when calling getComputedTextLength().\n  // Apparently offsetParent is null for invisibles.\n\n  if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {\n    // Align the text at the left\n    attrs['text-anchor'] = 'start';\n    attrs.x = 5;\n  } else {\n    // Align the text at the right\n    attrs['text-anchor'] = 'end';\n    attrs.x = fullLayout._paper.attr('width') - 7;\n  }\n\n  linkContainer.attr(attrs);\n  var toolspan = linkContainer.select('.js-link-to-tool');\n  var spacespan = linkContainer.select('.js-link-spacer');\n  var sourcespan = linkContainer.select('.js-sourcelinks');\n  if (gd._context.showSources) gd._context.showSources(gd); // 'view in plotly' link for embedded plots\n\n  if (gd._context.showLink) positionPlayWithData(gd, toolspan); // separator if we have both sources and tool link\n\n  spacespan.text(toolspan.text() && sourcespan.text() ? ' - ' : '');\n}; // note that now this function is only adding the brand in\n// iframes and 3rd-party apps\n\n\nfunction positionPlayWithData(gd, container) {\n  container.text('');\n  var link = container.append('a').attr({\n    'xlink:xlink:href': '#',\n    'class': 'link--impt link--embedview',\n    'font-weight': 'bold'\n  }).text(gd._context.linkText + ' ' + String.fromCharCode(187));\n\n  if (gd._context.sendData) {\n    link.on('click', function () {\n      plots.sendDataToCloud(gd);\n    });\n  } else {\n    var path = window.location.pathname.split('/');\n    var query = window.location.search;\n    link.attr({\n      'xlink:xlink:show': 'new',\n      'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query\n    });\n  }\n}\n\nplots.sendDataToCloud = function (gd) {\n  gd.emit('plotly_beforeexport');\n  var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;\n  var hiddenformDiv = d3.select(gd).append('div').attr('id', 'hiddenform').style('display', 'none');\n  var hiddenform = hiddenformDiv.append('form').attr({\n    action: baseUrl + '/external',\n    method: 'post',\n    target: '_blank'\n  });\n  var hiddenformInput = hiddenform.append('input').attr({\n    type: 'text',\n    name: 'data'\n  });\n  hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');\n  hiddenform.node().submit();\n  hiddenformDiv.remove();\n  gd.emit('plotly_afterexport');\n  return false;\n};\n\nvar d3FormatKeys = ['days', 'shortDays', 'months', 'shortMonths', 'periods', 'dateTime', 'date', 'time', 'decimal', 'thousands', 'grouping', 'currency'];\nvar extraFormatKeys = ['year', 'month', 'dayMonth', 'dayMonthYear'];\n/*\n * Fill in default values\n * @param {DOM element} gd\n * @param {object} opts\n * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks\n *   compatible with the new gd._fullData we finish by linking the new _fullData traces\n *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,\n *   if there are calcTransforms on the trace, we first remap data arrays from the old full\n *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)\n *\n * gd.data, gd.layout:\n *   are precisely what the user specified (except as modified by cleanData/cleanLayout),\n *   these fields shouldn't be modified (except for filling in some auto values)\n *   nor used directly after the supply defaults step.\n *\n * gd._fullData, gd._fullLayout:\n *   are complete descriptions of how to draw the plot,\n *   use these fields in all required computations.\n *\n * gd._fullLayout._modules\n *   is a list of all the trace modules required to draw the plot.\n *\n * gd._fullLayout._visibleModules\n *   subset of _modules, a list of modules corresponding to visible:true traces.\n *\n * gd._fullLayout._basePlotModules\n *   is a list of all the plot modules required to draw the plot.\n *\n * gd._fullLayout._transformModules\n *   is a list of all the transform modules invoked.\n *\n */\n\nplots.supplyDefaults = function (gd, opts) {\n  var skipUpdateCalc = opts && opts.skipUpdateCalc;\n  var oldFullLayout = gd._fullLayout || {};\n\n  if (oldFullLayout._skipDefaults) {\n    delete oldFullLayout._skipDefaults;\n    return;\n  }\n\n  var newFullLayout = gd._fullLayout = {};\n  var newLayout = gd.layout || {};\n  var oldFullData = gd._fullData || [];\n  var newFullData = gd._fullData = [];\n  var newData = gd.data || [];\n  var oldCalcdata = gd.calcdata || [];\n  var context = gd._context || {};\n  var i; // Create all the storage space for frames, but only if doesn't already exist\n\n  if (!gd._transitionData) plots.createTransitionData(gd); // So we only need to do this once (and since we have gd here)\n  // get the translated placeholder titles.\n  // These ones get used as default values so need to be known at supplyDefaults\n  // others keep their blank defaults but render the placeholder as desired later\n  // TODO: make these work the same way, only inserting the placeholder text at draw time?\n  // The challenge is that this has slightly different behavior right now in editable mode:\n  // using the placeholder as default makes this text permanently (but lightly) visible,\n  // but explicit '' for these titles gives you a placeholder that's hidden until you mouse\n  // over it - so you're not distracted by it if you really don't want a title, but if you do\n  // and you're new to plotly you may not be able to find it.\n  // When editable=false the two behave the same, no title is drawn.\n\n  newFullLayout._dfltTitle = {\n    plot: _(gd, 'Click to enter Plot title'),\n    x: _(gd, 'Click to enter X axis title'),\n    y: _(gd, 'Click to enter Y axis title'),\n    colorbar: _(gd, 'Click to enter Colorscale title'),\n    annotation: _(gd, 'new text')\n  };\n  newFullLayout._traceWord = _(gd, 'trace');\n  var formatObj = getFormatObj(gd, d3FormatKeys); // stash the token from context so mapbox subplots can use it as default\n\n  newFullLayout._mapboxAccessToken = context.mapboxAccessToken; // first fill in what we can of layout without looking at data\n  // because fullData needs a few things from layout\n\n  if (oldFullLayout._initialAutoSizeIsDone) {\n    // coerce the updated layout while preserving width and height\n    var oldWidth = oldFullLayout.width;\n    var oldHeight = oldFullLayout.height;\n    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n    if (!newLayout.width) newFullLayout.width = oldWidth;\n    if (!newLayout.height) newFullLayout.height = oldHeight;\n    plots.sanitizeMargins(newFullLayout);\n  } else {\n    // coerce the updated layout and autosize if needed\n    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n    var missingWidthOrHeight = !newLayout.width || !newLayout.height;\n    var autosize = newFullLayout.autosize;\n    var autosizable = context.autosizable;\n    var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);\n    if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout); // for backwards-compatibility with Plotly v1.x.x\n\n    if (!autosize && missingWidthOrHeight) {\n      newLayout.width = newFullLayout.width;\n      newLayout.height = newFullLayout.height;\n    }\n  }\n\n  newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);\n  newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);\n  newFullLayout._initialAutoSizeIsDone = true; // keep track of how many traces are inputted\n\n  newFullLayout._dataLength = newData.length; // clear the lists of trace and baseplot modules, and subplots\n\n  newFullLayout._modules = [];\n  newFullLayout._visibleModules = [];\n  newFullLayout._basePlotModules = [];\n  var subplots = newFullLayout._subplots = emptySubplotLists(); // initialize axis and subplot hash objects for splom-generated grids\n\n  var splomAxes = newFullLayout._splomAxes = {\n    x: {},\n    y: {}\n  };\n  var splomSubplots = newFullLayout._splomSubplots = {}; // initialize splom grid defaults\n\n  newFullLayout._splomGridDflt = {}; // for stacked area traces to share config across traces\n\n  newFullLayout._scatterStackOpts = {}; // for the first scatter trace on each subplot (so it knows tonext->tozero)\n\n  newFullLayout._firstScatter = {}; // for grouped bar/box/violin trace to share config across traces\n\n  newFullLayout._alignmentOpts = {}; // track color axes referenced in the data\n\n  newFullLayout._colorAxes = {}; // for traces to request a default rangeslider on their x axes\n  // eg set `_requestRangeslider.x2 = true` for xaxis2\n\n  newFullLayout._requestRangeslider = {}; // pull uids from old data to use as new defaults\n\n  newFullLayout._traceUids = getTraceUids(oldFullData, newData); // then do the data\n\n  newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;\n  plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout); // redo grid size defaults with info about splom x/y axes,\n  // and fill in generated cartesian axes and subplots\n\n  var splomXa = Object.keys(splomAxes.x);\n  var splomYa = Object.keys(splomAxes.y);\n\n  if (splomXa.length > 1 && splomYa.length > 1) {\n    Registry.getComponentMethod('grid', 'sizeDefaults')(newLayout, newFullLayout);\n\n    for (i = 0; i < splomXa.length; i++) {\n      Lib.pushUnique(subplots.xaxis, splomXa[i]);\n    }\n\n    for (i = 0; i < splomYa.length; i++) {\n      Lib.pushUnique(subplots.yaxis, splomYa[i]);\n    }\n\n    for (var k in splomSubplots) {\n      Lib.pushUnique(subplots.cartesian, k);\n    }\n  } // attach helper method to check whether a plot type is present on graph\n\n\n  newFullLayout._has = plots._hasPlotType.bind(newFullLayout);\n\n  if (oldFullData.length === newFullData.length) {\n    for (i = 0; i < newFullData.length; i++) {\n      relinkPrivateKeys(newFullData[i], oldFullData[i]);\n    }\n  } // finally, fill in the pieces of layout that may need to look at data\n\n\n  plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData); // Special cases that introduce interactions between traces.\n  // This is after relinkPrivateKeys so we can use those in crossTraceDefaults\n  // and after layout module defaults, so we can use eg barmode\n\n  var _modules = newFullLayout._visibleModules;\n  var crossTraceDefaultsFuncs = [];\n\n  for (i = 0; i < _modules.length; i++) {\n    var funci = _modules[i].crossTraceDefaults; // some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)\n\n    if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);\n  }\n\n  for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {\n    crossTraceDefaultsFuncs[i](newFullData, newFullLayout);\n  } // turn on flag to optimize large splom-only graphs\n  // mostly by omitting SVG layers during Cartesian.drawFramework\n\n\n  newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === 'splom' && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0; // TODO remove in v2.0.0\n  // add has-plot-type refs to fullLayout for backward compatibility\n\n  newFullLayout._hasCartesian = newFullLayout._has('cartesian');\n  newFullLayout._hasGeo = newFullLayout._has('geo');\n  newFullLayout._hasGL3D = newFullLayout._has('gl3d');\n  newFullLayout._hasGL2D = newFullLayout._has('gl2d');\n  newFullLayout._hasTernary = newFullLayout._has('ternary');\n  newFullLayout._hasPie = newFullLayout._has('pie'); // relink / initialize subplot axis objects\n\n  plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout); // clean subplots and other artifacts from previous plot calls\n\n  plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout); // clear selection outline until we implement persistent selection,\n  // don't clear them though when drag handlers (e.g. listening to\n  // `plotly_selecting`) update the graph.\n  // we should try to come up with a better solution when implementing\n  // https://github.com/plotly/plotly.js/issues/1851\n\n  if (oldFullLayout._zoomlayer && !gd._dragging) {\n    oldFullLayout._zoomlayer.selectAll('.select-outline').remove();\n  } // fill in meta helpers\n\n\n  fillMetaTextHelpers(newFullData, newFullLayout); // relink functions and _ attributes to promote consistency between plots\n\n  relinkPrivateKeys(newFullLayout, oldFullLayout); // colorscale crossTraceDefaults needs newFullLayout with relinked keys\n\n  Registry.getComponentMethod('colorscale', 'crossTraceDefaults')(newFullData, newFullLayout); // For persisting GUI-driven changes in layout\n  // _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys\n\n  if (!newFullLayout._preGUI) newFullLayout._preGUI = {}; // track trace GUI changes by uid rather than by trace index\n\n  if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};\n  var tracePreGUI = newFullLayout._tracePreGUI;\n  var uids = {};\n  var uid;\n\n  for (uid in tracePreGUI) uids[uid] = 'old';\n\n  for (i = 0; i < newFullData.length; i++) {\n    uid = newFullData[i]._fullInput.uid;\n    if (!uids[uid]) tracePreGUI[uid] = {};\n    uids[uid] = 'new';\n  }\n\n  for (uid in uids) {\n    if (uids[uid] === 'old') delete tracePreGUI[uid];\n  } // set up containers for margin calculations\n\n\n  initMargins(newFullLayout); // collect and do some initial calculations for rangesliders\n\n  Registry.getComponentMethod('rangeslider', 'makeData')(newFullLayout); // update object references in calcdata\n\n  if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {\n    plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);\n  }\n};\n\nplots.supplyDefaultsUpdateCalc = function (oldCalcdata, newFullData) {\n  for (var i = 0; i < newFullData.length; i++) {\n    var newTrace = newFullData[i];\n    var cd0 = (oldCalcdata[i] || [])[0];\n\n    if (cd0 && cd0.trace) {\n      var oldTrace = cd0.trace;\n\n      if (oldTrace._hasCalcTransform) {\n        var arrayAttrs = oldTrace._arrayAttrs;\n        var j, astr, oldArrayVal;\n\n        for (j = 0; j < arrayAttrs.length; j++) {\n          astr = arrayAttrs[j];\n          oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();\n          Lib.nestedProperty(newTrace, astr).set(oldArrayVal);\n        }\n      }\n\n      cd0.trace = newTrace;\n    }\n  }\n};\n/**\n * Create a list of uid strings satisfying (in this order of importance):\n * 1. all unique, all strings\n * 2. matches input uids if provided\n * 3. matches previous data uids\n */\n\n\nfunction getTraceUids(oldFullData, newData) {\n  var len = newData.length;\n  var oldFullInput = [];\n  var i, prevFullInput;\n\n  for (i = 0; i < oldFullData.length; i++) {\n    var thisFullInput = oldFullData[i]._fullInput;\n    if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);\n    prevFullInput = thisFullInput;\n  }\n\n  var oldLen = oldFullInput.length;\n  var out = new Array(len);\n  var seenUids = {};\n\n  function setUid(uid, i) {\n    out[i] = uid;\n    seenUids[uid] = 1;\n  }\n\n  function tryUid(uid, i) {\n    if (uid && typeof uid === 'string' && !seenUids[uid]) {\n      setUid(uid, i);\n      return true;\n    }\n  }\n\n  for (i = 0; i < len; i++) {\n    var newUid = newData[i].uid;\n    if (typeof newUid === 'number') newUid = String(newUid);\n    if (tryUid(newUid, i)) continue;\n    if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;\n    setUid(Lib.randstr(seenUids), i);\n  }\n\n  return out;\n}\n/**\n * Make a container for collecting subplots we need to display.\n *\n * Finds all subplot types we need to enumerate once and caches it,\n * but makes a new output object each time.\n * Single-trace subplots (which have no `id`) such as pie, table, etc\n * do not need to be collected because we just draw all visible traces.\n */\n\n\nfunction emptySubplotLists() {\n  var collectableSubplotTypes = Registry.collectableSubplotTypes;\n  var out = {};\n  var i, j;\n\n  if (!collectableSubplotTypes) {\n    collectableSubplotTypes = [];\n    var subplotsRegistry = Registry.subplotsRegistry;\n\n    for (var subplotType in subplotsRegistry) {\n      var subplotModule = subplotsRegistry[subplotType];\n      var subplotAttr = subplotModule.attr;\n\n      if (subplotAttr) {\n        collectableSubplotTypes.push(subplotType); // special case, currently just for cartesian:\n        // we need to enumerate axes, not just subplots\n\n        if (Array.isArray(subplotAttr)) {\n          for (j = 0; j < subplotAttr.length; j++) {\n            Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < collectableSubplotTypes.length; i++) {\n    out[collectableSubplotTypes[i]] = [];\n  }\n\n  return out;\n}\n/**\n * getFormatObj: use _context to get the format object from locale.\n * Used to get d3.locale argument object and extraFormat argument object\n *\n * Regarding d3.locale argument :\n * decimal and thousands can be overridden later by layout.separators\n * grouping and currency are not presently used by our automatic number\n * formatting system but can be used by custom formats.\n *\n * @returns {object} d3.locale format object\n */\n\n\nfunction getFormatObj(gd, formatKeys) {\n  var locale = gd._context.locale;\n  if (!locale) locale === 'en-US';\n  var formatDone = false;\n  var formatObj = {};\n\n  function includeFormat(newFormat) {\n    var formatFinished = true;\n\n    for (var i = 0; i < formatKeys.length; i++) {\n      var formatKey = formatKeys[i];\n\n      if (!formatObj[formatKey]) {\n        if (newFormat[formatKey]) {\n          formatObj[formatKey] = newFormat[formatKey];\n        } else formatFinished = false;\n      }\n    }\n\n    if (formatFinished) formatDone = true;\n  } // same as localize, look for format parts in each format spec in the chain\n\n\n  for (var i = 0; i < 2; i++) {\n    var locales = gd._context.locales;\n\n    for (var j = 0; j < 2; j++) {\n      var formatj = (locales[locale] || {}).format;\n\n      if (formatj) {\n        includeFormat(formatj);\n        if (formatDone) break;\n      }\n\n      locales = Registry.localeRegistry;\n    }\n\n    var baseLocale = locale.split('-')[0];\n    if (formatDone || baseLocale === locale) break;\n    locale = baseLocale;\n  } // lastly pick out defaults from english (non-US, as DMY is so much more common)\n\n\n  if (!formatDone) includeFormat(Registry.localeRegistry.en.format);\n  return formatObj;\n}\n/**\n * getFormatter: combine the final separators with the locale formatting object\n * we pulled earlier to generate number and time formatters\n * TODO: remove separators in v2, only use locale, so we don't need this step?\n *\n * @param {object} formatObj: d3.locale format object\n * @param {string} separators: length-2 string to override decimal and thousands\n *   separators in number formatting\n *\n * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions\n *   for numbers and time\n */\n\n\nfunction getFormatter(formatObj, separators) {\n  formatObj.decimal = separators.charAt(0);\n  formatObj.thousands = separators.charAt(1);\n  return d3.locale(formatObj);\n}\n\nfunction fillMetaTextHelpers(newFullData, newFullLayout) {\n  var _meta;\n\n  var meta4data = [];\n\n  if (newFullLayout.meta) {\n    _meta = newFullLayout._meta = {\n      meta: newFullLayout.meta,\n      layout: {\n        meta: newFullLayout.meta\n      }\n    };\n  }\n\n  for (var i = 0; i < newFullData.length; i++) {\n    var trace = newFullData[i];\n\n    if (trace.meta) {\n      meta4data[trace.index] = trace._meta = {\n        meta: trace.meta\n      };\n    } else if (newFullLayout.meta) {\n      trace._meta = {\n        meta: newFullLayout.meta\n      };\n    }\n\n    if (newFullLayout.meta) {\n      trace._meta.layout = {\n        meta: newFullLayout.meta\n      };\n    }\n  }\n\n  if (meta4data.length) {\n    if (!_meta) {\n      _meta = newFullLayout._meta = {};\n    }\n\n    _meta.data = meta4data;\n  }\n} // Create storage for all of the data related to frames and transitions:\n\n\nplots.createTransitionData = function (gd) {\n  // Set up the default keyframe if it doesn't exist:\n  if (!gd._transitionData) {\n    gd._transitionData = {};\n  }\n\n  if (!gd._transitionData._frames) {\n    gd._transitionData._frames = [];\n  }\n\n  if (!gd._transitionData._frameHash) {\n    gd._transitionData._frameHash = {};\n  }\n\n  if (!gd._transitionData._counter) {\n    gd._transitionData._counter = 0;\n  }\n\n  if (!gd._transitionData._interruptCallbacks) {\n    gd._transitionData._interruptCallbacks = [];\n  }\n}; // helper function to be bound to fullLayout to check\n// whether a certain plot type is present on plot\n// or trace has a category\n\n\nplots._hasPlotType = function (category) {\n  var i; // check base plot modules\n\n  var basePlotModules = this._basePlotModules || [];\n\n  for (i = 0; i < basePlotModules.length; i++) {\n    if (basePlotModules[i].name === category) return true;\n  } // check trace modules (including non-visible:true)\n\n\n  var modules = this._modules || [];\n\n  for (i = 0; i < modules.length; i++) {\n    var name = modules[i].name;\n    if (name === category) return true; // N.B. this is modules[i] along with 'categories' as a hash object\n\n    var _module = Registry.modules[name];\n    if (_module && _module.categories[category]) return true;\n  }\n\n  return false;\n};\n\nplots.cleanPlot = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var i, j;\n  var basePlotModules = oldFullLayout._basePlotModules || [];\n\n  for (i = 0; i < basePlotModules.length; i++) {\n    var _module = basePlotModules[i];\n\n    if (_module.clean) {\n      _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\n    }\n  }\n\n  var hadGl = oldFullLayout._has && oldFullLayout._has('gl');\n\n  var hasGl = newFullLayout._has && newFullLayout._has('gl');\n\n  if (hadGl && !hasGl) {\n    if (oldFullLayout._glcontainer !== undefined) {\n      oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();\n\n      oldFullLayout._glcontainer.selectAll('.no-webgl').remove();\n\n      oldFullLayout._glcanvas = null;\n    }\n  }\n\n  var hasInfoLayer = !!oldFullLayout._infolayer;\n\n  oldLoop: for (i = 0; i < oldFullData.length; i++) {\n    var oldTrace = oldFullData[i];\n    var oldUid = oldTrace.uid;\n\n    for (j = 0; j < newFullData.length; j++) {\n      var newTrace = newFullData[j];\n      if (oldUid === newTrace.uid) continue oldLoop;\n    } // clean old colorbars\n\n\n    if (hasInfoLayer) {\n      oldFullLayout._infolayer.select('.cb' + oldUid).remove();\n    }\n  }\n};\n\nplots.linkSubplots = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var i, j;\n  var oldSubplots = oldFullLayout._plots || {};\n  var newSubplots = newFullLayout._plots = {};\n  var newSubplotList = newFullLayout._subplots;\n  var mockGd = {\n    _fullData: newFullData,\n    _fullLayout: newFullLayout\n  };\n  var ids = newSubplotList.cartesian.concat(newSubplotList.gl2d || []);\n\n  for (i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    var oldSubplot = oldSubplots[id];\n    var xaxis = axisIDs.getFromId(mockGd, id, 'x');\n    var yaxis = axisIDs.getFromId(mockGd, id, 'y');\n    var plotinfo; // link or create subplot object\n\n    if (oldSubplot) {\n      plotinfo = newSubplots[id] = oldSubplot;\n    } else {\n      plotinfo = newSubplots[id] = {};\n      plotinfo.id = id;\n    } // add these axis ids to each others' subplot lists\n\n\n    xaxis._counterAxes.push(yaxis._id);\n\n    yaxis._counterAxes.push(xaxis._id);\n\n    xaxis._subplotsWith.push(id);\n\n    yaxis._subplotsWith.push(id); // update x and y axis layout object refs\n\n\n    plotinfo.xaxis = xaxis;\n    plotinfo.yaxis = yaxis; // By default, we clip at the subplot level,\n    // but if one trace on a given subplot has *cliponaxis* set to false,\n    // we need to clip at the trace module layer level;\n    // find this out here, once of for all.\n\n    plotinfo._hasClipOnAxisFalse = false;\n\n    for (j = 0; j < newFullData.length; j++) {\n      var trace = newFullData[j];\n\n      if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {\n        plotinfo._hasClipOnAxisFalse = true;\n        break;\n      }\n    }\n  } // while we're at it, link overlaying axes to their main axes and\n  // anchored axes to the axes they're anchored to\n\n\n  var axList = axisIDs.list(mockGd, null, true);\n  var ax;\n\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    var mainAx = null;\n\n    if (ax.overlaying) {\n      mainAx = axisIDs.getFromId(mockGd, ax.overlaying); // you cannot overlay an axis that's already overlaying another\n\n      if (mainAx && mainAx.overlaying) {\n        ax.overlaying = false;\n        mainAx = null;\n      }\n    }\n\n    ax._mainAxis = mainAx || ax;\n    /*\n     * For now force overlays to overlay completely... so they\n     * can drag together correctly and share backgrounds.\n     * Later perhaps we make separate axis domain and\n     * tick/line domain or something, so they can still share\n     * the (possibly larger) dragger and background but don't\n     * have to both be drawn over that whole domain\n     */\n\n    if (mainAx) ax.domain = mainAx.domain.slice();\n    ax._anchorAxis = ax.anchor === 'free' ? null : axisIDs.getFromId(mockGd, ax.anchor);\n  } // finally, we can find the main subplot for each axis\n  // (on which the ticks & labels are drawn)\n\n\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n\n    ax._counterAxes.sort(axisIDs.idSort);\n\n    ax._subplotsWith.sort(Lib.subplotSort);\n\n    ax._mainSubplot = findMainSubplot(ax, newFullLayout); // find \"full\" domain span of counter axes,\n    // this loop can be costly, so only compute it when required\n\n    if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf('across') !== -1 || ax.automargin && ax.mirror && ax.anchor !== 'free' || Registry.getComponentMethod('rangeslider', 'isVisible')(ax))) {\n      var min = 1;\n      var max = 0;\n\n      for (j = 0; j < ax._counterAxes.length; j++) {\n        var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);\n        min = Math.min(min, ax2.domain[0]);\n        max = Math.max(max, ax2.domain[1]);\n      }\n\n      if (min < max) {\n        ax._counterDomainMin = min;\n        ax._counterDomainMax = max;\n      }\n    }\n  }\n};\n\nfunction findMainSubplot(ax, fullLayout) {\n  var mockGd = {\n    _fullLayout: fullLayout\n  };\n  var isX = ax._id.charAt(0) === 'x';\n  var anchorAx = ax._mainAxis._anchorAxis;\n  var mainSubplotID = '';\n  var nextBestMainSubplotID = '';\n  var anchorID = ''; // First try the main ID with the anchor\n\n  if (anchorAx) {\n    anchorID = anchorAx._mainAxis._id;\n    mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;\n  } // Then look for a subplot with the counteraxis overlaying the anchor\n  // If that fails just use the first subplot including this axis\n\n\n  if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {\n    mainSubplotID = '';\n    var counterIDs = ax._counterAxes;\n\n    for (var j = 0; j < counterIDs.length; j++) {\n      var counterPart = counterIDs[j];\n      var id = isX ? ax._id + counterPart : counterPart + ax._id;\n      if (!nextBestMainSubplotID) nextBestMainSubplotID = id;\n      var counterAx = axisIDs.getFromId(mockGd, counterPart);\n\n      if (anchorID && counterAx.overlaying === anchorID) {\n        mainSubplotID = id;\n        break;\n      }\n    }\n  }\n\n  return mainSubplotID || nextBestMainSubplotID;\n} // This function clears any trace attributes with valType: color and\n// no set dflt filed in the plot schema. This is needed because groupby (which\n// is the only transform for which this currently applies) supplies parent\n// trace defaults, then expanded trace defaults. The result is that `null`\n// colors are default-supplied and inherited as a color instead of a null.\n// The result is that expanded trace default colors have no effect, with\n// the final result that groups are indistinguishable. This function clears\n// those colors so that individual groupby groups get unique colors.\n\n\nplots.clearExpandedTraceDefaultColors = function (trace) {\n  var colorAttrs, path, i; // This uses weird closure state in order to satisfy the linter rule\n  // that we can't create functions in a loop.\n\n  function locateColorAttrs(attr, attrName, attrs, level) {\n    path[level] = attrName;\n    path.length = level + 1;\n\n    if (attr.valType === 'color' && attr.dflt === undefined) {\n      colorAttrs.push(path.join('.'));\n    }\n  }\n\n  path = []; // Get the cached colorAttrs:\n\n  colorAttrs = trace._module._colorAttrs; // Or else compute and cache the colorAttrs on the module:\n\n  if (!colorAttrs) {\n    trace._module._colorAttrs = colorAttrs = [];\n    PlotSchema.crawl(trace._module.attributes, locateColorAttrs);\n  }\n\n  for (i = 0; i < colorAttrs.length; i++) {\n    var origprop = Lib.nestedProperty(trace, '_input.' + colorAttrs[i]);\n\n    if (!origprop.get()) {\n      Lib.nestedProperty(trace, colorAttrs[i]).set(null);\n    }\n  }\n};\n\nplots.supplyDataDefaults = function (dataIn, dataOut, layout, fullLayout) {\n  var modules = fullLayout._modules;\n  var visibleModules = fullLayout._visibleModules;\n  var basePlotModules = fullLayout._basePlotModules;\n  var cnt = 0;\n  var colorCnt = 0;\n  var i, fullTrace, trace;\n  fullLayout._transformModules = [];\n\n  function pushModule(fullTrace) {\n    dataOut.push(fullTrace);\n    var _module = fullTrace._module;\n    if (!_module) return;\n    Lib.pushUnique(modules, _module);\n    if (fullTrace.visible === true) Lib.pushUnique(visibleModules, _module);\n    Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);\n    cnt++; // TODO: do we really want color not to increment for explicitly invisible traces?\n    // This logic is weird, but matches previous behavior: traces that you explicitly\n    // set to visible:false do not increment the color, but traces WE determine to be\n    // empty or invalid (and thus set to visible:false) DO increment color.\n    // I kind of think we should just let all traces increment color, visible or not.\n    // see mock: axes-autotype-empty vs. a test of restyling visible: false that\n    // I can't find right now...\n\n    if (fullTrace._input.visible !== false) colorCnt++;\n  }\n\n  var carpetIndex = {};\n  var carpetDependents = [];\n  var dataTemplate = (layout.template || {}).data || {};\n  var templater = Template.traceTemplater(dataTemplate);\n\n  for (i = 0; i < dataIn.length; i++) {\n    trace = dataIn[i]; // reuse uid we may have pulled out of oldFullData\n    // Note: templater supplies trace type\n\n    fullTrace = templater.newTrace(trace);\n    fullTrace.uid = fullLayout._traceUids[i];\n    plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);\n    fullTrace.index = i;\n    fullTrace._input = trace;\n    fullTrace._expandedIndex = cnt;\n\n    if (fullTrace.transforms && fullTrace.transforms.length) {\n      var sdInvisible = trace.visible !== false && fullTrace.visible === false;\n      var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);\n\n      for (var j = 0; j < expandedTraces.length; j++) {\n        var expandedTrace = expandedTraces[j]; // No further templating during transforms.\n\n        var fullExpandedTrace = {\n          _template: fullTrace._template,\n          type: fullTrace.type,\n          // set uid using parent uid and expanded index\n          // to promote consistency between update calls\n          uid: fullTrace.uid + j\n        }; // If the first supplyDefaults created `visible: false`,\n        // clear it before running supplyDefaults a second time,\n        // because sometimes there are items we still want to coerce\n        // inside trace modules before determining that the trace is\n        // again `visible: false`, for example partial visibilities\n        // in `splom` traces.\n\n        if (sdInvisible && expandedTrace.visible === false) {\n          delete expandedTrace.visible;\n        }\n\n        plots.supplyTraceDefaults(expandedTrace, fullExpandedTrace, cnt, fullLayout, i); // relink private (i.e. underscore) keys expanded trace to full expanded trace so\n        // that transform supply-default methods can set _ keys for future use.\n\n        relinkPrivateKeys(fullExpandedTrace, expandedTrace); // add info about parent data trace\n\n        fullExpandedTrace.index = i;\n        fullExpandedTrace._input = trace;\n        fullExpandedTrace._fullInput = fullTrace; // add info about the expanded data\n\n        fullExpandedTrace._expandedIndex = cnt;\n        fullExpandedTrace._expandedInput = expandedTrace;\n        pushModule(fullExpandedTrace);\n      }\n    } else {\n      // add identify refs for consistency with transformed traces\n      fullTrace._fullInput = fullTrace;\n      fullTrace._expandedInput = fullTrace;\n      pushModule(fullTrace);\n    }\n\n    if (Registry.traceIs(fullTrace, 'carpetAxis')) {\n      carpetIndex[fullTrace.carpet] = fullTrace;\n    }\n\n    if (Registry.traceIs(fullTrace, 'carpetDependent')) {\n      carpetDependents.push(i);\n    }\n  }\n\n  for (i = 0; i < carpetDependents.length; i++) {\n    fullTrace = dataOut[carpetDependents[i]];\n    if (!fullTrace.visible) continue;\n    var carpetAxis = carpetIndex[fullTrace.carpet];\n    fullTrace._carpet = carpetAxis;\n\n    if (!carpetAxis || !carpetAxis.visible) {\n      fullTrace.visible = false;\n      continue;\n    }\n\n    fullTrace.xaxis = carpetAxis.xaxis;\n    fullTrace.yaxis = carpetAxis.yaxis;\n  }\n};\n\nplots.supplyAnimationDefaults = function (opts) {\n  opts = opts || {};\n  var i;\n  var optsOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);\n  }\n\n  coerce('mode');\n  coerce('direction');\n  coerce('fromcurrent');\n\n  if (Array.isArray(opts.frame)) {\n    optsOut.frame = [];\n\n    for (i = 0; i < opts.frame.length; i++) {\n      optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});\n    }\n  } else {\n    optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});\n  }\n\n  if (Array.isArray(opts.transition)) {\n    optsOut.transition = [];\n\n    for (i = 0; i < opts.transition.length; i++) {\n      optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});\n    }\n  } else {\n    optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});\n  }\n\n  return optsOut;\n};\n\nplots.supplyAnimationFrameDefaults = function (opts) {\n  var optsOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);\n  }\n\n  coerce('duration');\n  coerce('redraw');\n  return optsOut;\n};\n\nplots.supplyAnimationTransitionDefaults = function (opts) {\n  var optsOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);\n  }\n\n  coerce('duration');\n  coerce('easing');\n  return optsOut;\n};\n\nplots.supplyFrameDefaults = function (frameIn) {\n  var frameOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);\n  }\n\n  coerce('group');\n  coerce('name');\n  coerce('traces');\n  coerce('baseframe');\n  coerce('data');\n  coerce('layout');\n  return frameOut;\n};\n\nplots.supplyTraceDefaults = function (traceIn, traceOut, colorIndex, layout, traceInIndex) {\n  var colorway = layout.colorway || Color.defaults;\n  var defaultColor = colorway[colorIndex % colorway.length];\n  var i;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);\n  }\n\n  var visible = coerce('visible');\n  coerce('type');\n  coerce('name', layout._traceWord + ' ' + traceInIndex);\n  coerce('uirevision', layout.uirevision); // we want even invisible traces to make their would-be subplots visible\n  // so coerce the subplot id(s) now no matter what\n\n  var _module = plots.getModule(traceOut);\n\n  traceOut._module = _module;\n\n  if (_module) {\n    var basePlotModule = _module.basePlotModule;\n    var subplotAttr = basePlotModule.attr;\n    var subplotAttrs = basePlotModule.attributes;\n\n    if (subplotAttr && subplotAttrs) {\n      var subplots = layout._subplots;\n      var subplotId = ''; // TODO - currently if we draw an empty gl2d subplot, it draws\n      // nothing then gets stuck and you can't get it back without newPlot\n      // sort this out in the regl refactor? but for now just drop empty gl2d subplots\n\n      if (basePlotModule.name !== 'gl2d' || visible) {\n        if (Array.isArray(subplotAttr)) {\n          for (i = 0; i < subplotAttr.length; i++) {\n            var attri = subplotAttr[i];\n            var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);\n            if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);\n            subplotId += vali;\n          }\n        } else {\n          subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);\n        }\n\n        if (subplots[basePlotModule.name]) {\n          Lib.pushUnique(subplots[basePlotModule.name], subplotId);\n        }\n      }\n    }\n  }\n\n  if (visible) {\n    coerce('customdata');\n    coerce('ids');\n    coerce('meta');\n\n    if (Registry.traceIs(traceOut, 'showLegend')) {\n      traceOut._dfltShowLegend = true;\n      coerce('showlegend');\n      coerce('legendgroup');\n    } else {\n      traceOut._dfltShowLegend = false;\n    }\n\n    if (_module) {\n      _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);\n    }\n\n    if (!Registry.traceIs(traceOut, 'noOpacity')) {\n      coerce('opacity');\n    }\n\n    if (Registry.traceIs(traceOut, 'notLegendIsolatable')) {\n      // This clears out the legendonly state for traces like carpet that\n      // cannot be isolated in the legend\n      traceOut.visible = !!traceOut.visible;\n    }\n\n    if (!Registry.traceIs(traceOut, 'noHover')) {\n      if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout); // parcats support hover, but not hoverlabel stylings (yet)\n\n      if (traceOut.type !== 'parcats') {\n        Registry.getComponentMethod('fx', 'supplyDefaults')(traceIn, traceOut, defaultColor, layout);\n      }\n    }\n\n    if (_module && _module.selectPoints) {\n      coerce('selectedpoints');\n    }\n\n    plots.supplyTransformDefaults(traceIn, traceOut, layout);\n  }\n\n  return traceOut;\n};\n/**\n * hasMakesDataTransform: does this trace have a transform that makes its own\n * data, either by grabbing it from somewhere else or by creating it from input\n * parameters? If so, we should still keep going with supplyDefaults\n * even if the trace is invisible, which may just be because it has no data yet.\n */\n\n\nfunction hasMakesDataTransform(trace) {\n  var transforms = trace.transforms;\n\n  if (Array.isArray(transforms) && transforms.length) {\n    for (var i = 0; i < transforms.length; i++) {\n      var ti = transforms[i];\n\n      var _module = ti._module || transformsRegistry[ti.type];\n\n      if (_module && _module.makesData) return true;\n    }\n  }\n\n  return false;\n}\n\nplots.hasMakesDataTransform = hasMakesDataTransform;\n\nplots.supplyTransformDefaults = function (traceIn, traceOut, layout) {\n  // For now we only allow transforms on 1D traces, ie those that specify a _length.\n  // If we were to implement 2D transforms, we'd need to have each transform\n  // describe its own applicability and disable itself when it doesn't apply.\n  // Also allow transforms that make their own data, but not in globalTransforms\n  if (!(traceOut._length || hasMakesDataTransform(traceIn))) return;\n  var globalTransforms = layout._globalTransforms || [];\n  var transformModules = layout._transformModules || [];\n  if (!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;\n  var containerIn = traceIn.transforms || [];\n  var transformList = globalTransforms.concat(containerIn);\n  var containerOut = traceOut.transforms = [];\n\n  for (var i = 0; i < transformList.length; i++) {\n    var transformIn = transformList[i];\n    var type = transformIn.type;\n    var _module = transformsRegistry[type];\n    var transformOut;\n    /*\n     * Supply defaults may run twice. First pass runs all supply defaults steps\n     * and adds the _module to any output transforms.\n     * If transforms exist another pass is run so that any generated traces also\n     * go through supply defaults. This has the effect of rerunning\n     * supplyTransformDefaults. If the transform does not have a `transform`\n     * function it could not have generated any new traces and the second stage\n     * is unnecessary. We detect this case with the following variables.\n     */\n\n    var isFirstStage = !(transformIn._module && transformIn._module === _module);\n    var doLaterStages = _module && typeof _module.transform === 'function';\n    if (!_module) Lib.warn('Unrecognized transform type ' + type + '.');\n\n    if (_module && _module.supplyDefaults && (isFirstStage || doLaterStages)) {\n      transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);\n      transformOut.type = type;\n      transformOut._module = _module;\n      Lib.pushUnique(transformModules, _module);\n    } else {\n      transformOut = Lib.extendFlat({}, transformIn);\n    }\n\n    containerOut.push(transformOut);\n  }\n};\n\nfunction applyTransforms(fullTrace, fullData, layout, fullLayout) {\n  var container = fullTrace.transforms;\n  var dataOut = [fullTrace];\n\n  for (var i = 0; i < container.length; i++) {\n    var transform = container[i];\n    var _module = transformsRegistry[transform.type];\n\n    if (_module && _module.transform) {\n      dataOut = _module.transform(dataOut, {\n        transform: transform,\n        fullTrace: fullTrace,\n        fullData: fullData,\n        layout: layout,\n        fullLayout: fullLayout,\n        transformIndex: i\n      });\n    }\n  }\n\n  return dataOut;\n}\n\nplots.supplyLayoutGlobalDefaults = function (layoutIn, layoutOut, formatObj) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);\n  }\n\n  var template = layoutIn.template;\n\n  if (Lib.isPlainObject(template)) {\n    layoutOut.template = template;\n    layoutOut._template = template.layout;\n    layoutOut._dataTemplate = template.data;\n  }\n\n  var globalFont = Lib.coerceFont(coerce, 'font');\n  coerce('title.text', layoutOut._dfltTitle.plot);\n  Lib.coerceFont(coerce, 'title.font', {\n    family: globalFont.family,\n    size: Math.round(globalFont.size * 1.4),\n    color: globalFont.color\n  });\n  coerce('title.xref');\n  coerce('title.yref');\n  coerce('title.x');\n  coerce('title.y');\n  coerce('title.xanchor');\n  coerce('title.yanchor');\n  coerce('title.pad.t');\n  coerce('title.pad.r');\n  coerce('title.pad.b');\n  coerce('title.pad.l'); // Make sure that autosize is defaulted to *true*\n  // on layouts with no set width and height for backward compatibly,\n  // in particular https://plot.ly/javascript/responsive-fluid-layout/\n  //\n  // Before https://github.com/plotly/plotly.js/pull/635 ,\n  // layouts with no set width and height were set temporary set to 'initial'\n  // to pass through the autosize routine\n  //\n  // This behavior is subject to change in v2.\n\n  coerce('autosize', !(layoutIn.width && layoutIn.height));\n  coerce('width');\n  coerce('height');\n  coerce('margin.l');\n  coerce('margin.r');\n  coerce('margin.t');\n  coerce('margin.b');\n  coerce('margin.pad');\n  coerce('margin.autoexpand');\n  if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);\n  Registry.getComponentMethod('grid', 'sizeDefaults')(layoutIn, layoutOut);\n  coerce('paper_bgcolor');\n  coerce('separators', formatObj.decimal + formatObj.thousands);\n  coerce('hidesources');\n  coerce('colorway');\n  coerce('datarevision');\n  var uirevision = coerce('uirevision');\n  coerce('editrevision', uirevision);\n  coerce('selectionrevision', uirevision);\n  coerce('modebar.orientation');\n  coerce('modebar.bgcolor', Color.addOpacity(layoutOut.paper_bgcolor, 0.5));\n  var modebarDefaultColor = Color.contrast(Color.rgb(layoutOut.modebar.bgcolor));\n  coerce('modebar.color', Color.addOpacity(modebarDefaultColor, 0.3));\n  coerce('modebar.activecolor', Color.addOpacity(modebarDefaultColor, 0.7));\n  coerce('modebar.uirevision', uirevision);\n  coerce('meta'); // do not include defaults in fullLayout when users do not set transition\n\n  if (Lib.isPlainObject(layoutIn.transition)) {\n    coerce('transition.duration');\n    coerce('transition.easing');\n    coerce('transition.ordering');\n  }\n\n  Registry.getComponentMethod('calendars', 'handleDefaults')(layoutIn, layoutOut, 'calendar');\n  Registry.getComponentMethod('fx', 'supplyLayoutGlobalDefaults')(layoutIn, layoutOut, coerce);\n};\n\nplots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {\n  var context = gd._context || {};\n  var frameMargins = context.frameMargins;\n  var newWidth;\n  var newHeight;\n  var isPlotDiv = Lib.isPlotDiv(gd);\n  if (isPlotDiv) gd.emit('plotly_autosize'); // embedded in an iframe - just take the full iframe size\n  // if we get to this point, with no aspect ratio restrictions\n\n  if (context.fillFrame) {\n    newWidth = window.innerWidth;\n    newHeight = window.innerHeight; // somehow we get a few extra px height sometimes...\n    // just hide it\n\n    document.body.style.overflow = 'hidden';\n  } else {\n    // plotly.js - let the developers do what they want, either\n    // provide height and width for the container div,\n    // specify size in layout, or take the defaults,\n    // but don't enforce any ratio restrictions\n    var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};\n    newWidth = parseFloat(computedStyle.width) || parseFloat(computedStyle.maxWidth) || fullLayout.width;\n    newHeight = parseFloat(computedStyle.height) || parseFloat(computedStyle.maxHeight) || fullLayout.height;\n\n    if (isNumeric(frameMargins) && frameMargins > 0) {\n      var factor = 1 - 2 * frameMargins;\n      newWidth = Math.round(factor * newWidth);\n      newHeight = Math.round(factor * newHeight);\n    }\n  }\n\n  var minWidth = plots.layoutAttributes.width.min;\n  var minHeight = plots.layoutAttributes.height.min;\n  if (newWidth < minWidth) newWidth = minWidth;\n  if (newHeight < minHeight) newHeight = minHeight;\n  var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;\n  var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;\n\n  if (heightHasChanged || widthHasChanged) {\n    if (widthHasChanged) fullLayout.width = newWidth;\n    if (heightHasChanged) fullLayout.height = newHeight;\n  } // cache initial autosize value, used in relayout when\n  // width or height values are set to null\n\n\n  if (!gd._initialAutoSize) {\n    gd._initialAutoSize = {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  plots.sanitizeMargins(fullLayout);\n};\n\nplots.supplyLayoutModuleDefaults = function (layoutIn, layoutOut, fullData, transitionData) {\n  var componentsRegistry = Registry.componentsRegistry;\n  var basePlotModules = layoutOut._basePlotModules;\n\n  var component, i, _module;\n\n  var Cartesian = Registry.subplotsRegistry.cartesian; // check if any components need to add more base plot modules\n  // that weren't captured by traces\n\n  for (component in componentsRegistry) {\n    _module = componentsRegistry[component];\n\n    if (_module.includeBasePlot) {\n      _module.includeBasePlot(layoutIn, layoutOut);\n    }\n  } // make sure we *at least* have some cartesian axes\n\n\n  if (!basePlotModules.length) {\n    basePlotModules.push(Cartesian);\n  } // ensure all cartesian axes have at least one subplot\n\n\n  if (layoutOut._has('cartesian')) {\n    Registry.getComponentMethod('grid', 'contentDefaults')(layoutIn, layoutOut);\n    Cartesian.finalizeSubplots(layoutIn, layoutOut);\n  } // sort subplot lists\n\n\n  for (var subplotType in layoutOut._subplots) {\n    layoutOut._subplots[subplotType].sort(Lib.subplotSort);\n  } // base plot module layout defaults\n\n\n  for (i = 0; i < basePlotModules.length; i++) {\n    _module = basePlotModules[i]; // e.g. pie does not have a layout-defaults step\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  } // trace module layout defaults\n  // use _modules rather than _visibleModules so that even\n  // legendonly traces can include settings - eg barmode, which affects\n  // legend.traceorder default value.\n\n\n  var modules = layoutOut._modules;\n\n  for (i = 0; i < modules.length; i++) {\n    _module = modules[i];\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  } // transform module layout defaults\n\n\n  var transformModules = layoutOut._transformModules;\n\n  for (i = 0; i < transformModules.length; i++) {\n    _module = transformModules[i];\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);\n    }\n  }\n\n  for (component in componentsRegistry) {\n    _module = componentsRegistry[component];\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  }\n}; // Remove all plotly attributes from a div so it can be replotted fresh\n// TODO: these really need to be encapsulated into a much smaller set...\n\n\nplots.purge = function (gd) {\n  // note: we DO NOT remove _context because it doesn't change when we insert\n  // a new plot, and may have been set outside of our scope.\n  var fullLayout = gd._fullLayout || {};\n\n  if (fullLayout._glcontainer !== undefined) {\n    fullLayout._glcontainer.selectAll('.gl-canvas').remove();\n\n    fullLayout._glcontainer.remove();\n\n    fullLayout._glcanvas = null;\n  } // remove modebar\n\n\n  if (fullLayout._modeBar) fullLayout._modeBar.destroy();\n\n  if (gd._transitionData) {\n    // Ensure any dangling callbacks are simply dropped if the plot is purged.\n    // This is more or less only actually important for testing.\n    if (gd._transitionData._interruptCallbacks) {\n      gd._transitionData._interruptCallbacks.length = 0;\n    }\n\n    if (gd._transitionData._animationRaf) {\n      window.cancelAnimationFrame(gd._transitionData._animationRaf);\n    }\n  } // remove any planned throttles\n\n\n  Lib.clearThrottle(); // remove responsive handler\n\n  Lib.clearResponsive(gd); // data and layout\n\n  delete gd.data;\n  delete gd.layout;\n  delete gd._fullData;\n  delete gd._fullLayout;\n  delete gd.calcdata;\n  delete gd.framework;\n  delete gd.empty;\n  delete gd.fid;\n  delete gd.undoqueue; // action queue\n\n  delete gd.undonum;\n  delete gd.autoplay; // are we doing an action that doesn't go in undo queue?\n\n  delete gd.changed; // these get recreated on Plotly.plot anyway, but just to be safe\n  // (and to have a record of them...)\n\n  delete gd._promises;\n  delete gd._redrawTimer;\n  delete gd._hmlumcount;\n  delete gd._hmpixcount;\n  delete gd._transitionData;\n  delete gd._transitioning;\n  delete gd._initialAutoSize;\n  delete gd._transitioningWithDuration; // created during certain events, that *should* clean them up\n  // themselves, but may not if there was an error\n\n  delete gd._dragging;\n  delete gd._dragged;\n  delete gd._dragdata;\n  delete gd._hoverdata;\n  delete gd._snapshotInProgress;\n  delete gd._editing;\n  delete gd._mouseDownTime;\n  delete gd._legendMouseDownTime; // remove all event listeners\n\n  if (gd.removeAllListeners) gd.removeAllListeners();\n};\n\nplots.style = function (gd) {\n  var _modules = gd._fullLayout._visibleModules;\n  var styleModules = [];\n  var i; // some trace modules reuse the same style method,\n  // make sure to not unnecessary call them multiple times.\n\n  for (i = 0; i < _modules.length; i++) {\n    var _module = _modules[i];\n\n    if (_module.style) {\n      Lib.pushUnique(styleModules, _module.style);\n    }\n  }\n\n  for (i = 0; i < styleModules.length; i++) {\n    styleModules[i](gd);\n  }\n};\n\nplots.sanitizeMargins = function (fullLayout) {\n  // polar doesn't do margins...\n  if (!fullLayout || !fullLayout.margin) return;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var margin = fullLayout.margin;\n  var plotWidth = width - (margin.l + margin.r);\n  var plotHeight = height - (margin.t + margin.b);\n  var correction; // if margin.l + margin.r = 0 then plotWidth > 0\n  // as width >= 10 by supplyDefaults\n  // similarly for margin.t + margin.b\n\n  if (plotWidth < 0) {\n    correction = (width - 1) / (margin.l + margin.r);\n    margin.l = Math.floor(correction * margin.l);\n    margin.r = Math.floor(correction * margin.r);\n  }\n\n  if (plotHeight < 0) {\n    correction = (height - 1) / (margin.t + margin.b);\n    margin.t = Math.floor(correction * margin.t);\n    margin.b = Math.floor(correction * margin.b);\n  }\n};\n\nplots.clearAutoMarginIds = function (gd) {\n  gd._fullLayout._pushmarginIds = {};\n};\n\nplots.allowAutoMargin = function (gd, id) {\n  gd._fullLayout._pushmarginIds[id] = 1;\n};\n\nfunction initMargins(fullLayout) {\n  var margin = fullLayout.margin;\n\n  if (!fullLayout._size) {\n    var gs = fullLayout._size = {\n      l: Math.round(margin.l),\n      r: Math.round(margin.r),\n      t: Math.round(margin.t),\n      b: Math.round(margin.b),\n      p: Math.round(margin.pad)\n    };\n    gs.w = Math.round(fullLayout.width) - gs.l - gs.r;\n    gs.h = Math.round(fullLayout.height) - gs.t - gs.b;\n  }\n\n  if (!fullLayout._pushmargin) fullLayout._pushmargin = {};\n  if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};\n}\n/**\n * autoMargin: called by components that may need to expand the margins to\n * be rendered on-plot.\n *\n * @param {DOM element} gd\n * @param {string} id - an identifier unique (within this plot) to this object,\n *     so we can remove a previous margin expansion from the same object.\n * @param {object} o - the margin requirements of this object, or omit to delete\n *     this entry (like if it's hidden). Keys are:\n *     x, y: plot fraction of the anchor point.\n *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,\n *         you can specify both edges as plot fractions in each dimension\n *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]\n *     pad: extra pixels to add in all directions, default 12 (why?)\n */\n\n\nplots.autoMargin = function (gd, id, o) {\n  var fullLayout = gd._fullLayout;\n  var pushMargin = fullLayout._pushmargin;\n  var pushMarginIds = fullLayout._pushmarginIds;\n\n  if (fullLayout.margin.autoexpand !== false) {\n    if (!o) {\n      delete pushMargin[id];\n      delete pushMarginIds[id];\n    } else {\n      var pad = o.pad;\n\n      if (pad === undefined) {\n        var margin = fullLayout.margin; // if no explicit pad is given, use 12px unless there's a\n        // specified margin that's smaller than that\n\n        pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);\n      } // if the item is too big, just give it enough automargin to\n      // make sure you can still grab it and bring it back\n\n\n      if (o.l + o.r > fullLayout.width * 0.5) {\n        Lib.log('Margin push', id, 'is too big in x, dropping');\n        o.l = o.r = 0;\n      }\n\n      if (o.b + o.t > fullLayout.height * 0.5) {\n        Lib.log('Margin push', id, 'is too big in y, dropping');\n        o.b = o.t = 0;\n      }\n\n      var xl = o.xl !== undefined ? o.xl : o.x;\n      var xr = o.xr !== undefined ? o.xr : o.x;\n      var yt = o.yt !== undefined ? o.yt : o.y;\n      var yb = o.yb !== undefined ? o.yb : o.y;\n      pushMargin[id] = {\n        l: {\n          val: xl,\n          size: o.l + pad\n        },\n        r: {\n          val: xr,\n          size: o.r + pad\n        },\n        b: {\n          val: yb,\n          size: o.b + pad\n        },\n        t: {\n          val: yt,\n          size: o.t + pad\n        }\n      };\n      pushMarginIds[id] = 1;\n    }\n\n    if (!fullLayout._replotting) {\n      return plots.doAutoMargin(gd);\n    }\n  }\n};\n\nplots.doAutoMargin = function (gd) {\n  var fullLayout = gd._fullLayout;\n  if (!fullLayout._size) fullLayout._size = {};\n  initMargins(fullLayout);\n  var gs = fullLayout._size;\n  var margin = fullLayout.margin;\n  var oldMargins = Lib.extendFlat({}, gs); // adjust margins for outside components\n  // fullLayout.margin is the requested margin,\n  // fullLayout._size has margins and plotsize after adjustment\n\n  var ml = margin.l;\n  var mr = margin.r;\n  var mt = margin.t;\n  var mb = margin.b;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var pushMargin = fullLayout._pushmargin;\n  var pushMarginIds = fullLayout._pushmarginIds;\n\n  if (fullLayout.margin.autoexpand !== false) {\n    for (var k in pushMargin) {\n      if (!pushMarginIds[k]) delete pushMargin[k];\n    } // fill in the requested margins\n\n\n    pushMargin.base = {\n      l: {\n        val: 0,\n        size: ml\n      },\n      r: {\n        val: 1,\n        size: mr\n      },\n      t: {\n        val: 1,\n        size: mt\n      },\n      b: {\n        val: 0,\n        size: mb\n      }\n    }; // now cycle through all the combinations of l and r\n    // (and t and b) to find the required margins\n\n    for (var k1 in pushMargin) {\n      var pushleft = pushMargin[k1].l || {};\n      var pushbottom = pushMargin[k1].b || {};\n      var fl = pushleft.val;\n      var pl = pushleft.size;\n      var fb = pushbottom.val;\n      var pb = pushbottom.size;\n\n      for (var k2 in pushMargin) {\n        if (isNumeric(pl) && pushMargin[k2].r) {\n          var fr = pushMargin[k2].r.val;\n          var pr = pushMargin[k2].r.size;\n\n          if (fr > fl) {\n            var newL = (pl * fr + (pr - width) * fl) / (fr - fl);\n            var newR = (pr * (1 - fl) + (pl - width) * (1 - fr)) / (fr - fl);\n\n            if (newL >= 0 && newR >= 0 && width - (newL + newR) > 0 && newL + newR > ml + mr) {\n              ml = newL;\n              mr = newR;\n            }\n          }\n        }\n\n        if (isNumeric(pb) && pushMargin[k2].t) {\n          var ft = pushMargin[k2].t.val;\n          var pt = pushMargin[k2].t.size;\n\n          if (ft > fb) {\n            var newB = (pb * ft + (pt - height) * fb) / (ft - fb);\n            var newT = (pt * (1 - fb) + (pb - height) * (1 - ft)) / (ft - fb);\n\n            if (newB >= 0 && newT >= 0 && height - (newT + newB) > 0 && newB + newT > mb + mt) {\n              mb = newB;\n              mt = newT;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  gs.l = Math.round(ml);\n  gs.r = Math.round(mr);\n  gs.t = Math.round(mt);\n  gs.b = Math.round(mb);\n  gs.p = Math.round(margin.pad);\n  gs.w = Math.round(width) - gs.l - gs.r;\n  gs.h = Math.round(height) - gs.t - gs.b; // if things changed and we're not already redrawing, trigger a redraw\n\n  if (!fullLayout._replotting && plots.didMarginChange(oldMargins, gs)) {\n    if ('_redrawFromAutoMarginCount' in fullLayout) {\n      fullLayout._redrawFromAutoMarginCount++;\n    } else {\n      fullLayout._redrawFromAutoMarginCount = 1;\n    } // Always allow at least one redraw and give each margin-push\n    // call 3 loops to converge. Of course, for most cases this way too many,\n    // but let's keep things on the safe side until we fix our\n    // auto-margin pipeline problems:\n    // https://github.com/plotly/plotly.js/issues/2704\n\n\n    var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);\n\n    if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {\n      return Registry.call('plot', gd);\n    } else {\n      Lib.warn('Too many auto-margin redraws.');\n    }\n  }\n};\n\nvar marginKeys = ['l', 'r', 't', 'b', 'p', 'w', 'h'];\n\nplots.didMarginChange = function (margin0, margin1) {\n  for (var i = 0; i < marginKeys.length; i++) {\n    var k = marginKeys[i];\n    var m0 = margin0[k];\n    var m1 = margin1[k]; // use 1px tolerance in case we old/new differ only\n    // by rounding errors, which can lead to infinite loops\n\n    if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * JSONify the graph data and layout\n *\n * This function needs to recurse because some src can be inside\n * sub-objects.\n *\n * It also strips out functions and private (starts with _) elements.\n * Therefore, we can add temporary things to data and layout that don't\n * get saved.\n *\n * @param gd The graphDiv\n * @param {Boolean} dataonly If true, don't return layout.\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\n *      keepref: remove data for which there's a src present\n *          eg if there's xsrc present (and xsrc is well-formed,\n *          ie has : and some chars before it), strip out x\n *      keepdata: remove all src tags, don't remove the data itself\n *      keepall: keep data and src\n * @param {String} output If you specify 'object', the result will not be stringified\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\n * @returns {Object|String}\n */\n\n\nplots.graphJson = function (gd, dataonly, mode, output, useDefaults) {\n  // if the defaults aren't supplied yet, we need to do that...\n  if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {\n    plots.supplyDefaults(gd);\n  }\n\n  var data = useDefaults ? gd._fullData : gd.data;\n  var layout = useDefaults ? gd._fullLayout : gd.layout;\n  var frames = (gd._transitionData || {})._frames;\n\n  function stripObj(d) {\n    if (typeof d === 'function') {\n      return null;\n    }\n\n    if (Lib.isPlainObject(d)) {\n      var o = {};\n      var v, src;\n\n      for (v in d) {\n        // remove private elements and functions\n        // _ is for private, [ is a mistake ie [object Object]\n        if (typeof d[v] === 'function' || ['_', '['].indexOf(v.charAt(0)) !== -1) {\n          continue;\n        } // look for src/data matches and remove the appropriate one\n\n\n        if (mode === 'keepdata') {\n          // keepdata: remove all ...src tags\n          if (v.substr(v.length - 3) === 'src') {\n            continue;\n          }\n        } else if (mode === 'keepstream') {\n          // keep sourced data if it's being streamed.\n          // similar to keepref, but if the 'stream' object exists\n          // in a trace, we will keep the data array.\n          src = d[v + 'src'];\n\n          if (typeof src === 'string' && src.indexOf(':') > 0) {\n            if (!Lib.isPlainObject(d.stream)) {\n              continue;\n            }\n          }\n        } else if (mode !== 'keepall') {\n          // keepref: remove sourced data but only\n          // if the source tag is well-formed\n          src = d[v + 'src'];\n\n          if (typeof src === 'string' && src.indexOf(':') > 0) {\n            continue;\n          }\n        } // OK, we're including this... recurse into it\n\n\n        o[v] = stripObj(d[v]);\n      }\n\n      return o;\n    }\n\n    if (Array.isArray(d)) {\n      return d.map(stripObj);\n    }\n\n    if (Lib.isTypedArray(d)) {\n      return Lib.simpleMap(d, Lib.identity);\n    } // convert native dates to date strings...\n    // mostly for external users exporting to plotly\n\n\n    if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);\n    return d;\n  }\n\n  var obj = {\n    data: (data || []).map(function (v) {\n      var d = stripObj(v); // fit has some little arrays in it that don't contain data,\n      // just fit params and meta\n\n      if (dataonly) {\n        delete d.fit;\n      }\n\n      return d;\n    })\n  };\n\n  if (!dataonly) {\n    obj.layout = stripObj(layout);\n  }\n\n  if (gd.framework && gd.framework.isPolar) obj = gd.framework.getConfig();\n  if (frames) obj.frames = stripObj(frames);\n  return output === 'object' ? obj : JSON.stringify(obj);\n};\n/**\n * Modify a keyframe using a list of operations:\n *\n * @param {array of objects} operations\n *      Sequence of operations to be performed on the keyframes\n */\n\n\nplots.modifyFrames = function (gd, operations) {\n  var i, op, frame;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n\n  for (i = 0; i < operations.length; i++) {\n    op = operations[i];\n\n    switch (op.type) {\n      // No reason this couldn't exist, but is currently unused/untested:\n\n      /* case 'rename':\n          frame = _frames[op.index];\n          delete _frameHash[frame.name];\n          _frameHash[op.name] = frame;\n          frame.name = op.name;\n          break;*/\n      case 'replace':\n        frame = op.value;\n        var oldName = (_frames[op.index] || {}).name;\n        var newName = frame.name;\n        _frames[op.index] = _frameHash[newName] = frame;\n\n        if (newName !== oldName) {\n          // If name has changed in addition to replacement, then update\n          // the lookup table:\n          delete _frameHash[oldName];\n          _frameHash[newName] = frame;\n        }\n\n        break;\n\n      case 'insert':\n        frame = op.value;\n        _frameHash[frame.name] = frame;\n\n        _frames.splice(op.index, 0, frame);\n\n        break;\n\n      case 'delete':\n        frame = _frames[op.index];\n        delete _frameHash[frame.name];\n\n        _frames.splice(op.index, 1);\n\n        break;\n    }\n  }\n\n  return Promise.resolve();\n};\n/*\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\n * expand properties.\n *\n * @param {object} frameLookup\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\n * @param {string} frame\n *      The name of the keyframe to be computed\n *\n * Returns: a new object with the merged content\n */\n\n\nplots.computeFrame = function (gd, frameName) {\n  var frameLookup = gd._transitionData._frameHash;\n  var i, traceIndices, traceIndex, destIndex; // Null or undefined will fail on .toString(). We'll allow numbers since we\n  // make it clear frames must be given string names, but we'll allow numbers\n  // here since they're otherwise fine for looking up frames as long as they're\n  // properly cast to strings. We really just want to ensure here that this\n  // 1) doesn't fail, and\n  // 2) doens't give an incorrect answer (which String(frameName) would)\n\n  if (!frameName) {\n    throw new Error('computeFrame must be given a string frame name');\n  }\n\n  var framePtr = frameLookup[frameName.toString()]; // Return false if the name is invalid:\n\n  if (!framePtr) {\n    return false;\n  }\n\n  var frameStack = [framePtr];\n  var frameNameStack = [framePtr.name]; // Follow frame pointers:\n\n  while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {\n    // Avoid infinite loops:\n    if (frameNameStack.indexOf(framePtr.name) !== -1) break;\n    frameStack.push(framePtr);\n    frameNameStack.push(framePtr.name);\n  } // A new object for the merged result:\n\n\n  var result = {}; // Merge, starting with the last and ending with the desired frame:\n\n  while (framePtr = frameStack.pop()) {\n    if (framePtr.layout) {\n      result.layout = plots.extendLayout(result.layout, framePtr.layout);\n    }\n\n    if (framePtr.data) {\n      if (!result.data) {\n        result.data = [];\n      }\n\n      traceIndices = framePtr.traces;\n\n      if (!traceIndices) {\n        // If not defined, assume serial order starting at zero\n        traceIndices = [];\n\n        for (i = 0; i < framePtr.data.length; i++) {\n          traceIndices[i] = i;\n        }\n      }\n\n      if (!result.traces) {\n        result.traces = [];\n      }\n\n      for (i = 0; i < framePtr.data.length; i++) {\n        // Loop through this frames data, find out where it should go,\n        // and merge it!\n        traceIndex = traceIndices[i];\n\n        if (traceIndex === undefined || traceIndex === null) {\n          continue;\n        }\n\n        destIndex = result.traces.indexOf(traceIndex);\n\n        if (destIndex === -1) {\n          destIndex = result.data.length;\n          result.traces[destIndex] = traceIndex;\n        }\n\n        result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);\n      }\n    }\n  }\n\n  return result;\n};\n/*\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\n * deleteFrames already manages this data one at a time, so the only time this\n * is necessary is if you poke around manually in `gd._transitionData._frames`\n * and create and haven't updated the lookup table.\n */\n\n\nplots.recomputeFrameHash = function (gd) {\n  var hash = gd._transitionData._frameHash = {};\n  var frames = gd._transitionData._frames;\n\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n\n    if (frame && frame.name) {\n      hash[frame.name] = frame;\n    }\n  }\n};\n/**\n * Extend an object, treating container arrays very differently by extracting\n * their contents and merging them separately.\n *\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\n * arrays without knowledge of the plot schema, but so that we may also manually\n * recurse into known container arrays, such as transforms.\n *\n * See extendTrace and extendLayout below for usage.\n */\n\n\nplots.extendObjectWithContainers = function (dest, src, containerPaths) {\n  var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;\n  var copy = Lib.extendDeepNoArrays({}, src || {});\n  var expandedObj = Lib.expandObjectPaths(copy);\n  var containerObj = {}; // Step through and extract any container properties. Otherwise extendDeepNoArrays\n  // will clobber any existing properties with an empty array and then supplyDefaults\n  // will reset everything to defaults.\n\n  if (containerPaths && containerPaths.length) {\n    for (i = 0; i < containerPaths.length; i++) {\n      containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);\n      containerVal = containerProp.get();\n\n      if (containerVal === undefined) {\n        Lib.nestedProperty(containerObj, containerPaths[i]).set(null);\n      } else {\n        containerProp.set(null);\n        Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);\n      }\n    }\n  }\n\n  dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);\n\n  if (containerPaths && containerPaths.length) {\n    for (i = 0; i < containerPaths.length; i++) {\n      srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);\n      srcContainer = srcProp.get();\n      if (!srcContainer) continue;\n      destProp = Lib.nestedProperty(dest, containerPaths[i]);\n      destContainer = destProp.get();\n\n      if (!Array.isArray(destContainer)) {\n        destContainer = [];\n        destProp.set(destContainer);\n      }\n\n      for (j = 0; j < srcContainer.length; j++) {\n        var srcObj = srcContainer[j];\n        if (srcObj === null) destContainer[j] = null;else {\n          destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);\n        }\n      }\n\n      destProp.set(destContainer);\n    }\n  }\n\n  return dest;\n};\n\nplots.dataArrayContainers = ['transforms', 'dimensions'];\nplots.layoutArrayContainers = Registry.layoutArrayContainers;\n/*\n * Extend a trace definition. This method:\n *\n *  1. directly transfers any array references\n *  2. manually recurses into container arrays like transforms\n *\n * The result is the original object reference with the new contents merged in.\n */\n\nplots.extendTrace = function (destTrace, srcTrace) {\n  return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);\n};\n/*\n * Extend a layout definition. This method:\n *\n *  1. directly transfers any array references (not critically important for\n *     layout since there aren't really data arrays)\n *  2. manually recurses into container arrays like annotations\n *\n * The result is the original object reference with the new contents merged in.\n */\n\n\nplots.extendLayout = function (destLayout, srcLayout) {\n  return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);\n};\n/**\n * Transition to a set of new data and layout properties from Plotly.animate\n *\n * @param {DOM element} gd\n * @param {Object[]} data\n *      an array of data objects following the normal Plotly data definition format\n * @param {Object} layout\n *      a layout object, following normal Plotly layout format\n * @param {Number[]} traces\n *      indices of the corresponding traces specified in `data`\n * @param {Object} frameOpts\n *      options for the frame (i.e. whether to redraw post-transition)\n * @param {Object} transitionOpts\n *      options for the transition\n */\n\n\nplots.transition = function (gd, data, layout, traces, frameOpts, transitionOpts) {\n  var opts = {\n    redraw: frameOpts.redraw\n  };\n  var transitionedTraces = {};\n  var axEdits = [];\n\n  opts.prepareFn = function () {\n    var dataLength = Array.isArray(data) ? data.length : 0;\n    var traceIndices = traces.slice(0, dataLength);\n\n    for (var i = 0; i < traceIndices.length; i++) {\n      var traceIdx = traceIndices[i];\n      var trace = gd._fullData[traceIdx];\n      var _module = trace._module; // There's nothing to do if this module is not defined:\n\n      if (!_module) continue; // Don't register the trace as transitioned if it doesn't know what to do.\n      // If it *is* registered, it will receive a callback that it's responsible\n      // for calling in order to register the transition as having completed.\n\n      if (_module.animatable) {\n        var n = _module.basePlotModule.name;\n        if (!transitionedTraces[n]) transitionedTraces[n] = [];\n        transitionedTraces[n].push(traceIdx);\n      }\n\n      gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);\n    } // Follow the same procedure. Clone it so we don't mangle the input, then\n    // expand any object paths so we can merge deep into gd.layout:\n\n\n    var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout)); // Before merging though, we need to modify the incoming layout. We only\n    // know how to *transition* layout ranges, so it's imperative that a new\n    // range not be sent to the layout before the transition has started. So\n    // we must remove the things we can transition:\n\n    var axisAttrRe = /^[xy]axis[0-9]*$/;\n\n    for (var attr in layoutUpdate) {\n      if (!axisAttrRe.test(attr)) continue;\n      delete layoutUpdate[attr].range;\n    }\n\n    plots.extendLayout(gd.layout, layoutUpdate); // Supply defaults after applying the incoming properties. Note that any attempt\n    // to simplify this step and reduce the amount of work resulted in the reconstruction\n    // of essentially the whole supplyDefaults step, so that it seems sensible to just use\n    // supplyDefaults even though it's heavier than would otherwise be desired for\n    // transitions:\n    // first delete calcdata so supplyDefaults knows a calc step is coming\n\n    delete gd.calcdata;\n    plots.supplyDefaults(gd);\n    plots.doCalcdata(gd);\n    var newLayout = Lib.expandObjectPaths(layout);\n\n    if (newLayout) {\n      var subplots = gd._fullLayout._plots;\n\n      for (var k in subplots) {\n        var plotinfo = subplots[k];\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        var xr0 = xa.range.slice();\n        var yr0 = ya.range.slice();\n        var xr1 = null;\n        var yr1 = null;\n        var editX = null;\n        var editY = null;\n\n        if (Array.isArray(newLayout[xa._name + '.range'])) {\n          xr1 = newLayout[xa._name + '.range'].slice();\n        } else if (Array.isArray((newLayout[xa._name] || {}).range)) {\n          xr1 = newLayout[xa._name].range.slice();\n        }\n\n        if (Array.isArray(newLayout[ya._name + '.range'])) {\n          yr1 = newLayout[ya._name + '.range'].slice();\n        } else if (Array.isArray((newLayout[ya._name] || {}).range)) {\n          yr1 = newLayout[ya._name].range.slice();\n        }\n\n        if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {\n          editX = {\n            xr0: xr0,\n            xr1: xr1\n          };\n        }\n\n        if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {\n          editY = {\n            yr0: yr0,\n            yr1: yr1\n          };\n        }\n\n        if (editX || editY) {\n          axEdits.push(Lib.extendFlat({\n            plotinfo: plotinfo\n          }, editX, editY));\n        }\n      }\n    }\n\n    return Promise.resolve();\n  };\n\n  opts.runFn = function (makeCallback) {\n    var traceTransitionOpts;\n    var basePlotModules = gd._fullLayout._basePlotModules;\n    var hasAxisTransition = axEdits.length;\n    var i;\n\n    if (layout) {\n      for (i = 0; i < basePlotModules.length; i++) {\n        if (basePlotModules[i].transitionAxes) {\n          basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);\n        }\n      }\n    } // Here handle the exception that we refuse to animate scales and axes at the same\n    // time. In other words, if there's an axis transition, then set the data transition\n    // to instantaneous.\n\n\n    if (hasAxisTransition) {\n      traceTransitionOpts = Lib.extendFlat({}, transitionOpts);\n      traceTransitionOpts.duration = 0; // This means do not transition cartesian traces,\n      // this happens on layout-only (e.g. axis range) animations\n\n      delete transitionedTraces.cartesian;\n    } else {\n      traceTransitionOpts = transitionOpts;\n    } // Note that we pass a callback to *create* the callback that must be invoked on completion.\n    // This is since not all traces know about transitions, so it greatly simplifies matters if\n    // the trace is responsible for creating a callback, if needed, and then executing it when\n    // the time is right.\n\n\n    for (var n in transitionedTraces) {\n      var traceIndices = transitionedTraces[n];\n      var _module = gd._fullData[traceIndices[0]]._module;\n\n      _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);\n    }\n  };\n\n  return _transition(gd, transitionOpts, opts);\n};\n/**\n * Transition to a set of new data and layout properties from Plotly.react\n *\n * @param {DOM element} gd\n * @param {object} restyleFlags\n * - anim {'all'|'some'}\n * @param {object} relayoutFlags\n * - anim {'all'|'some'}\n * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout\n */\n\n\nplots.transitionFromReact = function (gd, restyleFlags, relayoutFlags, oldFullLayout) {\n  var fullLayout = gd._fullLayout;\n  var transitionOpts = fullLayout.transition;\n  var opts = {};\n  var axEdits = [];\n\n  opts.prepareFn = function () {\n    var subplots = fullLayout._plots; // no need to redraw at end of transition,\n    // if all changes are animatable\n\n    opts.redraw = false;\n    if (restyleFlags.anim === 'some') opts.redraw = true;\n    if (relayoutFlags.anim === 'some') opts.redraw = true;\n\n    for (var k in subplots) {\n      var plotinfo = subplots[k];\n      var xa = plotinfo.xaxis;\n      var ya = plotinfo.yaxis;\n\n      var xr0 = oldFullLayout[xa._name].range.slice();\n\n      var yr0 = oldFullLayout[ya._name].range.slice();\n\n      var xr1 = xa.range.slice();\n      var yr1 = ya.range.slice();\n      xa.setScale();\n      ya.setScale();\n      var editX = null;\n      var editY = null;\n\n      if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {\n        editX = {\n          xr0: xr0,\n          xr1: xr1\n        };\n      }\n\n      if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {\n        editY = {\n          yr0: yr0,\n          yr1: yr1\n        };\n      }\n\n      if (editX || editY) {\n        axEdits.push(Lib.extendFlat({\n          plotinfo: plotinfo\n        }, editX, editY));\n      }\n    }\n\n    return Promise.resolve();\n  };\n\n  opts.runFn = function (makeCallback) {\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var basePlotModules = fullLayout._basePlotModules;\n    var axisTransitionOpts;\n    var traceTransitionOpts;\n    var transitionedTraces;\n    var allTraceIndices = [];\n\n    for (var i = 0; i < fullData.length; i++) {\n      allTraceIndices.push(i);\n    }\n\n    function transitionAxes() {\n      for (var j = 0; j < basePlotModules.length; j++) {\n        if (basePlotModules[j].transitionAxes) {\n          basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);\n        }\n      }\n    }\n\n    function transitionTraces() {\n      for (var j = 0; j < basePlotModules.length; j++) {\n        basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);\n      }\n    }\n\n    if (axEdits.length && restyleFlags.anim) {\n      if (transitionOpts.ordering === 'traces first') {\n        axisTransitionOpts = Lib.extendFlat({}, transitionOpts, {\n          duration: 0\n        });\n        transitionedTraces = allTraceIndices;\n        traceTransitionOpts = transitionOpts;\n        setTimeout(transitionAxes, transitionOpts.duration);\n        transitionTraces();\n      } else {\n        axisTransitionOpts = transitionOpts;\n        transitionedTraces = null;\n        traceTransitionOpts = Lib.extendFlat({}, transitionOpts, {\n          duration: 0\n        });\n        setTimeout(transitionTraces, axisTransitionOpts.duration);\n        transitionAxes();\n      }\n    } else if (axEdits.length) {\n      axisTransitionOpts = transitionOpts;\n      transitionAxes();\n    } else if (restyleFlags.anim) {\n      transitionedTraces = allTraceIndices;\n      traceTransitionOpts = transitionOpts;\n      transitionTraces();\n    }\n  };\n\n  return _transition(gd, transitionOpts, opts);\n};\n/**\n * trace/layout transition wrapper that works\n * for transitions initiated by Plotly.animate and Plotly.react.\n *\n * @param {DOM element} gd\n * @param {object} transitionOpts\n * @param {object} opts\n * - redraw {boolean}\n * - prepareFn {function} *should return a Promise*\n * - runFn {function} ran inside executeTransitions\n */\n\n\nfunction _transition(gd, transitionOpts, opts) {\n  var aborted = false;\n\n  function executeCallbacks(list) {\n    var p = Promise.resolve();\n    if (!list) return p;\n\n    while (list.length) {\n      p = p.then(list.shift());\n    }\n\n    return p;\n  }\n\n  function flushCallbacks(list) {\n    if (!list) return;\n\n    while (list.length) {\n      list.shift();\n    }\n  }\n\n  function executeTransitions() {\n    gd.emit('plotly_transitioning', []);\n    return new Promise(function (resolve) {\n      // This flag is used to disabled things like autorange:\n      gd._transitioning = true; // When instantaneous updates are coming through quickly, it's too much to simply disable\n      // all interaction, so store this flag so we can disambiguate whether mouse interactions\n      // should be fully disabled or not:\n\n      if (transitionOpts.duration > 0) {\n        gd._transitioningWithDuration = true;\n      } // If another transition is triggered, this callback will be executed simply because it's\n      // in the interruptCallbacks queue. If this transition completes, it will instead flush\n      // that queue and forget about this callback.\n\n\n      gd._transitionData._interruptCallbacks.push(function () {\n        aborted = true;\n      });\n\n      if (opts.redraw) {\n        gd._transitionData._interruptCallbacks.push(function () {\n          return Registry.call('redraw', gd);\n        });\n      } // Emit this and make sure it happens last:\n\n\n      gd._transitionData._interruptCallbacks.push(function () {\n        gd.emit('plotly_transitioninterrupted', []);\n      }); // Construct callbacks that are executed on transition end. This ensures the d3 transitions\n      // are *complete* before anything else is done.\n\n\n      var numCallbacks = 0;\n      var numCompleted = 0;\n\n      function makeCallback() {\n        numCallbacks++;\n        return function () {\n          numCompleted++; // When all are complete, perform a redraw:\n\n          if (!aborted && numCompleted === numCallbacks) {\n            completeTransition(resolve);\n          }\n        };\n      }\n\n      opts.runFn(makeCallback); // If nothing else creates a callback, then this will trigger the completion in the next tick:\n\n      setTimeout(makeCallback());\n    });\n  }\n\n  function completeTransition(callback) {\n    // This a simple workaround for tests which purge the graph before animations\n    // have completed. That's not a very common case, so this is the simplest\n    // fix.\n    if (!gd._transitionData) return;\n    flushCallbacks(gd._transitionData._interruptCallbacks);\n    return Promise.resolve().then(function () {\n      if (opts.redraw) {\n        return Registry.call('redraw', gd);\n      }\n    }).then(function () {\n      // Set transitioning false again once the redraw has occurred. This is used, for example,\n      // to prevent the trailing redraw from autoranging:\n      gd._transitioning = false;\n      gd._transitioningWithDuration = false;\n      gd.emit('plotly_transitioned', []);\n    }).then(callback);\n  }\n\n  function interruptPreviousTransitions() {\n    // Fail-safe against purged plot:\n    if (!gd._transitionData) return; // If a transition is interrupted, set this to false. At the moment, the only thing that would\n    // interrupt a transition is another transition, so that it will momentarily be set to true\n    // again, but this determines whether autorange or dragbox work, so it's for the sake of\n    // cleanliness:\n\n    gd._transitioning = false;\n    return executeCallbacks(gd._transitionData._interruptCallbacks);\n  }\n\n  var seq = [plots.previousPromises, interruptPreviousTransitions, opts.prepareFn, plots.rehover, executeTransitions];\n  var transitionStarting = Lib.syncOrAsync(seq, gd);\n\n  if (!transitionStarting || !transitionStarting.then) {\n    transitionStarting = Promise.resolve();\n  }\n\n  return transitionStarting.then(function () {\n    return gd;\n  });\n}\n\nplots.doCalcdata = function (gd, traces) {\n  var axList = axisIDs.list(gd);\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n\n  var trace, _module, i, j; // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\n  // *all* needing doCalcdata:\n\n\n  var calcdata = new Array(fullData.length);\n  var oldCalcdata = (gd.calcdata || []).slice();\n  gd.calcdata = calcdata; // extra helper variables\n  // how many box/violins plots do we have (in case they're grouped)\n\n  fullLayout._numBoxes = 0;\n  fullLayout._numViolins = 0; // initialize violin per-scale-group stats container\n\n  fullLayout._violinScaleGroupStats = {}; // for calculating avg luminosity of heatmaps\n\n  gd._hmpixcount = 0;\n  gd._hmlumcount = 0; // for sharing colors across pies / sunbursts / treemap / funnelarea (and for legend)\n\n  fullLayout._piecolormap = {};\n  fullLayout._sunburstcolormap = {};\n  fullLayout._treemapcolormap = {};\n  fullLayout._funnelareacolormap = {}; // If traces were specified and this trace was not included,\n  // then transfer it over from the old calcdata:\n\n  for (i = 0; i < fullData.length; i++) {\n    if (Array.isArray(traces) && traces.indexOf(i) === -1) {\n      calcdata[i] = oldCalcdata[i];\n      continue;\n    }\n  }\n\n  for (i = 0; i < fullData.length; i++) {\n    trace = fullData[i];\n    trace._arrayAttrs = PlotSchema.findArrayAttributes(trace); // keep track of trace extremes (for autorange) in here\n\n    trace._extremes = {};\n  } // add polar axes to axis list\n\n\n  var polarIds = fullLayout._subplots.polar || [];\n\n  for (i = 0; i < polarIds.length; i++) {\n    axList.push(fullLayout[polarIds[i]].radialaxis, fullLayout[polarIds[i]].angularaxis);\n  }\n\n  var hasCalcTransform = false;\n\n  function transformCalci(i) {\n    trace = fullData[i];\n    _module = trace._module;\n\n    if (trace.visible === true && trace.transforms) {\n      // we need one round of trace module calc before\n      // the calc transform to 'fill in' the categories list\n      // used for example in the data-to-coordinate method\n      if (_module && _module.calc) {\n        var cdi = _module.calc(gd, trace); // must clear scene 'batches', so that 2nd\n        // _module.calc call starts from scratch\n\n\n        if (cdi[0] && cdi[0].t && cdi[0].t._scene) {\n          delete cdi[0].t._scene.dirty;\n        }\n      }\n\n      for (j = 0; j < trace.transforms.length; j++) {\n        var transform = trace.transforms[j];\n        _module = transformsRegistry[transform.type];\n\n        if (_module && _module.calcTransform) {\n          trace._hasCalcTransform = true;\n          hasCalcTransform = true;\n\n          _module.calcTransform(gd, trace, transform);\n        }\n      }\n    }\n  }\n\n  function calci(i, isContainer) {\n    trace = fullData[i];\n    _module = trace._module;\n    if (!!_module.isContainer !== isContainer) return;\n    var cd = [];\n\n    if (trace.visible === true && trace._length !== 0) {\n      // clear existing ref in case it got relinked\n      delete trace._indexToPoints; // keep ref of index-to-points map object of the *last* enabled transform,\n      // this index-to-points map object is required to determine the calcdata indices\n      // that correspond to input indices (e.g. from 'selectedpoints')\n\n      var transforms = trace.transforms || [];\n\n      for (j = transforms.length - 1; j >= 0; j--) {\n        if (transforms[j].enabled) {\n          trace._indexToPoints = transforms[j]._indexToPoints;\n          break;\n        }\n      }\n\n      if (_module && _module.calc) {\n        cd = _module.calc(gd, trace);\n      }\n    } // Make sure there is a first point.\n    //\n    // This ensures there is a calcdata item for every trace,\n    // even if cartesian logic doesn't handle it (for things like legends).\n\n\n    if (!Array.isArray(cd) || !cd[0]) {\n      cd = [{\n        x: BADNUM,\n        y: BADNUM\n      }];\n    } // add the trace-wide properties to the first point,\n    // per point properties to every point\n    // t is the holder for trace-wide properties\n\n\n    if (!cd[0].t) cd[0].t = {};\n    cd[0].trace = trace;\n    calcdata[i] = cd;\n  }\n\n  setupAxisCategories(axList, fullData); // 'transform' loop - must calc container traces first\n  // so that if their dependent traces can get transform properly\n\n  for (i = 0; i < fullData.length; i++) calci(i, true);\n\n  for (i = 0; i < fullData.length; i++) transformCalci(i); // clear stuff that should recomputed in 'regular' loop\n\n\n  if (hasCalcTransform) setupAxisCategories(axList, fullData); // 'regular' loop - make sure container traces (eg carpet) calc before\n  // contained traces (eg contourcarpet)\n\n  for (i = 0; i < fullData.length; i++) calci(i, true);\n\n  for (i = 0; i < fullData.length; i++) calci(i, false);\n\n  doCrossTraceCalc(gd); // Sort axis categories per value if specified\n\n  var sorted = sortAxisCategoriesByValue(axList, gd);\n\n  if (sorted.length) {\n    // how many box/violins plots do we have (in case they're grouped)\n    fullLayout._numBoxes = 0;\n    fullLayout._numViolins = 0; // If a sort operation was performed, run calc() again\n\n    for (i = 0; i < sorted.length; i++) calci(sorted[i], true);\n\n    for (i = 0; i < sorted.length; i++) calci(sorted[i], false);\n\n    doCrossTraceCalc(gd);\n  }\n\n  Registry.getComponentMethod('fx', 'calc')(gd);\n  Registry.getComponentMethod('errorbars', 'calc')(gd);\n};\n\nvar sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|median) (ascending|descending)/;\n\nfunction sortAxisCategoriesByValue(axList, gd) {\n  var affectedTraces = [];\n  var i, j, k, l, o;\n\n  function zMapCategory(type, ax, value) {\n    var axLetter = ax._id.charAt(0);\n\n    if (type === 'histogram2dcontour') {\n      var counterAxLetter = ax._counterAxes[0];\n      var counterAx = axisIDs.getFromId(gd, counterAxLetter);\n      var xCategorical = axLetter === 'x' || counterAxLetter === 'x' && counterAx.type === 'category';\n      var yCategorical = axLetter === 'y' || counterAxLetter === 'y' && counterAx.type === 'category';\n      return function (o, l) {\n        if (o === 0 || l === 0) return -1; // Skip first row and column\n\n        if (xCategorical && o === value[l].length - 1) return -1;\n        if (yCategorical && l === value.length - 1) return -1;\n        return (axLetter === 'y' ? l : o) - 1;\n      };\n    } else {\n      return function (o, l) {\n        return axLetter === 'y' ? l : o;\n      };\n    }\n  }\n\n  var aggFn = {\n    'min': function (values) {\n      return Lib.aggNums(Math.min, null, values);\n    },\n    'max': function (values) {\n      return Lib.aggNums(Math.max, null, values);\n    },\n    'sum': function (values) {\n      return Lib.aggNums(function (a, b) {\n        return a + b;\n      }, null, values);\n    },\n    'total': function (values) {\n      return Lib.aggNums(function (a, b) {\n        return a + b;\n      }, null, values);\n    },\n    'mean': function (values) {\n      return Lib.mean(values);\n    },\n    'median': function (values) {\n      return Lib.median(values);\n    }\n  };\n\n  for (i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    if (ax.type !== 'category') continue; // Order by value\n\n    var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);\n\n    if (match) {\n      var aggregator = match[1];\n      var order = match[2]; // Store values associated with each category\n\n      var categoriesValue = [];\n\n      for (j = 0; j < ax._categories.length; j++) {\n        categoriesValue.push([ax._categories[j], []]);\n      } // Collect values across traces\n\n\n      for (j = 0; j < ax._traceIndices.length; j++) {\n        var traceIndex = ax._traceIndices[j];\n        var fullTrace = gd._fullData[traceIndex];\n\n        var axLetter = ax._id.charAt(0); // Skip over invisible traces\n\n\n        if (fullTrace.visible !== true) continue;\n        var type = fullTrace.type;\n\n        if (Registry.traceIs(fullTrace, 'histogram')) {\n          delete fullTrace._xautoBinFinished;\n          delete fullTrace._yautoBinFinished;\n        }\n\n        var cd = gd.calcdata[traceIndex];\n\n        for (k = 0; k < cd.length; k++) {\n          var cdi = cd[k];\n          var cat, catIndex, value;\n\n          if (type === 'splom') {\n            // If `splom`, collect values across dimensions\n            // Find which dimension the current axis is representing\n            var currentDimensionIndex = fullTrace._axesDim[ax._id]; // Apply logic to associated x axis if it's defined\n\n            if (axLetter === 'y') {\n              var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];\n              if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];\n            }\n\n            var categories = cdi.trace.dimensions[currentDimensionIndex].values;\n\n            for (l = 0; l < categories.length; l++) {\n              cat = categories[l];\n              catIndex = ax._categoriesMap[cat]; // Collect associated values at index `l` over all other dimensions\n\n              for (o = 0; o < cdi.trace.dimensions.length; o++) {\n                if (o === currentDimensionIndex) continue;\n                var dimension = cdi.trace.dimensions[o];\n                categoriesValue[catIndex][1].push(dimension.values[l]);\n              }\n            }\n          } else if (type === 'scattergl') {\n            // If `scattergl`, collect all values stashed under cdi.t\n            for (l = 0; l < cdi.t.x.length; l++) {\n              if (axLetter === 'x') {\n                cat = cdi.t.x[l];\n                catIndex = cat;\n                value = cdi.t.y[l];\n              }\n\n              if (axLetter === 'y') {\n                cat = cdi.t.y[l];\n                catIndex = cat;\n                value = cdi.t.x[l];\n              }\n\n              categoriesValue[catIndex][1].push(value);\n            } // must clear scene 'batches', so that 2nd\n            // _module.calc call starts from scratch\n\n\n            if (cdi.t && cdi.t._scene) {\n              delete cdi.t._scene.dirty;\n            }\n          } else if (cdi.hasOwnProperty('z')) {\n            // If 2dMap, collect values in `z`\n            value = cdi.z;\n            var mapping = zMapCategory(fullTrace.type, ax, value);\n\n            for (l = 0; l < value.length; l++) {\n              for (o = 0; o < value[l].length; o++) {\n                catIndex = mapping(o, l);\n                if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);\n              }\n            }\n          } else {\n            // For all other 2d cartesian traces\n            if (axLetter === 'x') {\n              cat = cdi.p + 1 ? cdi.p : cdi.x;\n              value = cdi.s || cdi.v || cdi.y;\n            } else if (axLetter === 'y') {\n              cat = cdi.p + 1 ? cdi.p : cdi.y;\n              value = cdi.s || cdi.v || cdi.x;\n            }\n\n            if (!Array.isArray(value)) value = [value];\n\n            for (l = 0; l < value.length; l++) {\n              categoriesValue[cat][1].push(value[l]);\n            }\n          }\n        }\n      }\n\n      ax._categoriesValue = categoriesValue;\n      var categoriesAggregatedValue = [];\n\n      for (j = 0; j < categoriesValue.length; j++) {\n        categoriesAggregatedValue.push([categoriesValue[j][0], aggFn[aggregator](categoriesValue[j][1])]);\n      } // Sort by aggregated value\n\n\n      categoriesAggregatedValue.sort(function (a, b) {\n        return a[1] - b[1];\n      });\n      ax._categoriesAggregatedValue = categoriesAggregatedValue; // Set new category order\n\n      ax._initialCategories = categoriesAggregatedValue.map(function (c) {\n        return c[0];\n      }); // Reverse if descending\n\n      if (order === 'descending') {\n        ax._initialCategories.reverse();\n      } // Sort all matching axes\n\n\n      affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());\n    }\n  }\n\n  return affectedTraces;\n}\n\nfunction setupAxisCategories(axList, fullData) {\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    ax.clearCalc();\n\n    if (ax.type === 'multicategory') {\n      ax.setupMultiCategory(fullData);\n    }\n  }\n}\n\nfunction doCrossTraceCalc(gd) {\n  var fullLayout = gd._fullLayout;\n  var modules = fullLayout._visibleModules;\n  var hash = {};\n  var i, j, k; // position and range calculations for traces that\n  // depend on each other ie bars (stacked or grouped)\n  // and boxes (grouped) push each other out of the way\n\n  for (j = 0; j < modules.length; j++) {\n    var _module = modules[j];\n    var fn = _module.crossTraceCalc;\n\n    if (fn) {\n      var spType = _module.basePlotModule.name;\n\n      if (hash[spType]) {\n        Lib.pushUnique(hash[spType], fn);\n      } else {\n        hash[spType] = [fn];\n      }\n    }\n  }\n\n  for (k in hash) {\n    var methods = hash[k];\n    var subplots = fullLayout._subplots[k];\n\n    if (Array.isArray(subplots)) {\n      for (i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        var spInfo = k === 'cartesian' ? fullLayout._plots[sp] : fullLayout[sp];\n\n        for (j = 0; j < methods.length; j++) {\n          methods[j](gd, spInfo, sp);\n        }\n      }\n    } else {\n      for (j = 0; j < methods.length; j++) {\n        methods[j](gd);\n      }\n    }\n  }\n}\n\nplots.rehover = function (gd) {\n  if (gd._fullLayout._rehover) {\n    gd._fullLayout._rehover();\n  }\n};\n\nplots.redrag = function (gd) {\n  if (gd._fullLayout._redrag) {\n    gd._fullLayout._redrag();\n  }\n};\n\nplots.generalUpdatePerTraceModule = function (gd, subplot, subplotCalcData, subplotLayout) {\n  var traceHashOld = subplot.traceHash;\n  var traceHash = {};\n  var i; // build up moduleName -> calcData hash\n\n  for (i = 0; i < subplotCalcData.length; i++) {\n    var calcTraces = subplotCalcData[i];\n    var trace = calcTraces[0].trace; // skip over visible === false traces\n    // as they don't have `_module` ref\n\n    if (trace.visible) {\n      traceHash[trace.type] = traceHash[trace.type] || [];\n      traceHash[trace.type].push(calcTraces);\n    }\n  } // when a trace gets deleted, make sure that its module's\n  // plot method is called so that it is properly\n  // removed from the DOM.\n\n\n  for (var moduleNameOld in traceHashOld) {\n    if (!traceHash[moduleNameOld]) {\n      var fakeCalcTrace = traceHashOld[moduleNameOld][0];\n      var fakeTrace = fakeCalcTrace[0].trace;\n      fakeTrace.visible = false;\n      traceHash[moduleNameOld] = [fakeCalcTrace];\n    }\n  } // call module plot method\n\n\n  for (var moduleName in traceHash) {\n    var moduleCalcData = traceHash[moduleName];\n    var _module = moduleCalcData[0][0].trace._module;\n\n    _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);\n  } // update moduleName -> calcData hash\n\n\n  subplot.traceHash = traceHash;\n};\n\nplots.plotBasePlot = function (desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {\n  var _module = Registry.getModule(desiredType);\n\n  var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];\n\n  _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);\n};\n\nplots.cleanBasePlot = function (desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var had = oldFullLayout._has && oldFullLayout._has(desiredType);\n\n  var has = newFullLayout._has && newFullLayout._has(desiredType);\n\n  if (had && !has) {\n    oldFullLayout['_' + desiredType + 'layer'].selectAll('g.trace').remove();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}