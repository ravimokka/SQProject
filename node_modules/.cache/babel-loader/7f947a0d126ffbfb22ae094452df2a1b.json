{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\n\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\n\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar style = require('./style');\n\nmodule.exports = function plot(gd, geo, calcData) {\n  for (var i = 0; i < calcData.length; i++) {\n    calcGeoJSON(calcData[i], geo.topojson);\n  }\n\n  function removeBADNUM(d, node) {\n    if (d.lonlat[0] === BADNUM) {\n      d3.select(node).remove();\n    }\n  }\n\n  var scatterLayer = geo.layers.frontplot.select('.scatterlayer');\n  var gTraces = Lib.makeTraceGroups(scatterLayer, calcData, 'trace scattergeo'); // TODO find a way to order the inner nodes on update\n\n  gTraces.selectAll('*').remove();\n  gTraces.each(function (calcTrace) {\n    var s = d3.select(this);\n    var trace = calcTrace[0].trace;\n\n    if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n      var lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n      var lineData = trace.fill !== 'none' ? geoJsonUtils.makePolygon(lineCoords) : geoJsonUtils.makeLine(lineCoords);\n      s.selectAll('path.js-line').data([{\n        geojson: lineData,\n        trace: trace\n      }]).enter().append('path').classed('js-line', true).style('stroke-miterlimit', 2);\n    }\n\n    if (subTypes.hasMarkers(trace)) {\n      s.selectAll('path.point').data(Lib.identity).enter().append('path').classed('point', true).each(function (calcPt) {\n        removeBADNUM(calcPt, this);\n      });\n    }\n\n    if (subTypes.hasText(trace)) {\n      s.selectAll('g').data(Lib.identity).enter().append('g').append('text').each(function (calcPt) {\n        removeBADNUM(calcPt, this);\n      });\n    } // call style here within topojson request callback\n\n\n    style(gd, calcTrace);\n  });\n};\n\nfunction calcGeoJSON(calcTrace, topojson) {\n  var trace = calcTrace[0].trace;\n  if (!Array.isArray(trace.locations)) return;\n  var features = getTopojsonFeatures(trace, topojson);\n  var locationmode = trace.locationmode;\n\n  for (var i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    var feature = locationToFeature(locationmode, calcPt.loc, features);\n    calcPt.lonlat = feature ? feature.properties.ct : [BADNUM, BADNUM];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}