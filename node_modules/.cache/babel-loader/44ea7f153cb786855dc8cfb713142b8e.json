{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\n\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\n\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\n\nvar PlotSchema = require('./plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar Polar = require('../plots/polar/legacy');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar Drawing = require('../components/drawing');\n\nvar Color = require('../components/color');\n\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\n\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\n\nvar svgTextUtils = require('../lib/svg_text_utils');\n\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar manageArrays = require('./manage_arrays');\n\nvar helpers = require('./helpers');\n\nvar subroutines = require('./subroutines');\n\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\n\nfunction plot(gd, data, layout, config) {\n  var frames;\n  gd = Lib.getGraphDiv(gd); // Events.init is idempotent and bails early if gd has already been init'd\n\n  Events.init(gd);\n\n  if (Lib.isPlainObject(data)) {\n    var obj = data;\n    data = obj.data;\n    layout = obj.layout;\n    config = obj.config;\n    frames = obj.frames;\n  }\n\n  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n  if (okToPlot === false) return Promise.reject(); // if there's no data or layout, and this isn't yet a plotly plot\n  // container, log a warning to help plotly.js users debug\n\n  if (!data && !layout && !Lib.isPlotDiv(gd)) {\n    Lib.warn('Calling Plotly.plot as if redrawing ' + 'but this container doesn\\'t yet have a plot.', gd);\n  }\n\n  function addFrames() {\n    if (frames) {\n      return exports.addFrames(gd, frames);\n    }\n  } // transfer configuration options to gd until we move over to\n  // a more OO like model\n\n\n  setPlotContext(gd, config);\n  if (!layout) layout = {}; // hook class for plots main container (in case of plotly.js\n  // this won't be #embedded-graph or .js-tab-contents)\n\n  d3.select(gd).classed('js-plotly-plot', true); // off-screen getBoundingClientRect testing space,\n  // in #js-plotly-tester (and stored as Drawing.tester)\n  // so we can share cached text across tabs\n\n  Drawing.makeTester(); // collect promises for any async actions during plotting\n  // any part of the plotting code can push to gd._promises, then\n  // before we move to the next step, we check that they're all\n  // complete, and empty out the promise list again.\n\n  if (!Array.isArray(gd._promises)) gd._promises = [];\n  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data); // if there is already data on the graph, append the new data\n  // if you only want to redraw, pass a non-array for data\n\n  if (Array.isArray(data)) {\n    helpers.cleanData(data);\n    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data); // for routines outside graph_obj that want a clean tab\n    // (rather than appending to an existing one) gd.empty\n    // is used to determine whether to make a new tab\n\n    gd.empty = false;\n  }\n\n  if (!gd.layout || graphWasEmpty) {\n    gd.layout = helpers.cleanLayout(layout);\n  }\n\n  Plots.supplyDefaults(gd);\n  var fullLayout = gd._fullLayout;\n\n  var hasCartesian = fullLayout._has('cartesian'); // Legacy polar plots\n\n\n  if (!fullLayout._has('polar') && data && data[0] && data[0].r) {\n    Lib.log('Legacy polar charts are deprecated!');\n    return plotLegacyPolar(gd, data, layout);\n  } // so we don't try to re-call Plotly.plot from inside\n  // legend and colorbar, if margins changed\n\n\n  fullLayout._replotting = true; // make or remake the framework if we need to\n\n  if (graphWasEmpty) makePlotFramework(gd); // polar need a different framework\n\n  if (gd.framework !== makePlotFramework) {\n    gd.framework = makePlotFramework;\n    makePlotFramework(gd);\n  } // clear gradient defs on each .plot call, because we know we'll loop through all traces\n\n\n  Drawing.initGradients(gd); // save initial show spikes once per graph\n\n  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd); // prepare the data and find the autorange\n  // generate calcdata, if we need to\n  // to force redoing calcdata, just delete it before calling Plotly.plot\n\n  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n  if (recalc) Plots.doCalcdata(gd); // in case it has changed, attach fullData traces to calcdata\n\n  for (var i = 0; i < gd.calcdata.length; i++) {\n    gd.calcdata[i][0].trace = gd._fullData[i];\n  } // make the figure responsive\n\n\n  if (gd._context.responsive) {\n    if (!gd._responsiveChartHandler) {\n      // Keep a reference to the resize handler to purge it down the road\n      gd._responsiveChartHandler = function () {\n        if (!Lib.isHidden(gd)) Plots.resize(gd);\n      }; // Listen to window resize\n\n\n      window.addEventListener('resize', gd._responsiveChartHandler);\n    }\n  } else {\n    Lib.clearResponsive(gd);\n  }\n  /*\n   * start async-friendly code - now we're actually drawing things\n   */\n\n\n  var oldMargins = Lib.extendFlat({}, fullLayout._size); // draw framework first so that margin-pushing\n  // components can position themselves correctly\n\n  var drawFrameworkCalls = 0;\n\n  function drawFramework() {\n    var basePlotModules = fullLayout._basePlotModules;\n\n    for (var i = 0; i < basePlotModules.length; i++) {\n      if (basePlotModules[i].drawFramework) {\n        basePlotModules[i].drawFramework(gd);\n      }\n    }\n\n    if (!fullLayout._glcanvas && fullLayout._has('gl')) {\n      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n        key: 'contextLayer',\n        context: true,\n        pick: false\n      }, {\n        key: 'focusLayer',\n        context: false,\n        pick: false\n      }, {\n        key: 'pickLayer',\n        context: false,\n        pick: true\n      }], function (d) {\n        return d.key;\n      });\n\n      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {\n        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n      }).style({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'visible',\n        'pointer-events': 'none'\n      });\n    }\n\n    if (fullLayout._glcanvas) {\n      fullLayout._glcanvas.attr('width', fullLayout.width).attr('height', fullLayout.height);\n\n      var regl = fullLayout._glcanvas.data()[0].regl;\n\n      if (regl) {\n        // Unfortunately, this can happen when relayouting to large\n        // width/height on some browsers.\n        if (Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight) {\n          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n\n          if (drawFrameworkCalls) {\n            Lib.error(msg);\n          } else {\n            Lib.log(msg + ' Clearing graph and plotting again.');\n            Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n            Plots.supplyDefaults(gd);\n            fullLayout = gd._fullLayout;\n            Plots.doCalcdata(gd);\n            drawFrameworkCalls++;\n            return drawFramework();\n          }\n        }\n      }\n    }\n\n    if (fullLayout.modebar.orientation === 'h') {\n      fullLayout._modebardiv.style('height', null).style('width', '100%');\n    } else {\n      fullLayout._modebardiv.style('width', null).style('height', fullLayout.height + 'px');\n    }\n\n    return Plots.previousPromises(gd);\n  } // draw anything that can affect margins.\n\n\n  function marginPushers() {\n    // First reset the list of things that are allowed to change the margins\n    // So any deleted traces or components will be wiped out of the\n    // automargin calculation.\n    // This means *every* margin pusher must be listed here, even if it\n    // doesn't actually try to push the margins until later.\n    Plots.clearAutoMarginIds(gd);\n    subroutines.drawMarginPushers(gd);\n    Axes.allowAutoMargin(gd); // TODO can this be moved elsewhere?\n\n    if (fullLayout._has('pie')) {\n      var fullData = gd._fullData;\n\n      for (var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if (trace.type === 'pie' && trace.automargin) {\n          Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n        }\n      }\n    }\n\n    Plots.doAutoMargin(gd);\n    return Plots.previousPromises(gd);\n  } // in case the margins changed, draw margin pushers again\n\n\n  function marginPushersAgain() {\n    if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);\n  }\n\n  function positionAndAutorange() {\n    if (!recalc) {\n      doAutoRangeAndConstraints();\n      return;\n    } // TODO: autosize extra for text markers and images\n    // see https://github.com/plotly/plotly.js/issues/1111\n\n\n    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);\n  }\n\n  function doAutoRangeAndConstraints() {\n    if (gd._transitioning) return;\n    subroutines.doAutoRangeAndConstraints(gd); // store initial ranges *after* enforcing constraints, otherwise\n    // we will never look like we're at the initial ranges\n\n    if (graphWasEmpty) Axes.saveRangeInitial(gd); // this one is different from shapes/annotations calcAutorange\n    // the others incorporate those components into ax._extremes,\n    // this one actually sets the ranges in rangesliders.\n\n    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n  } // draw ticks, titles, and calculate axis scaling (._b, ._m)\n\n\n  function drawAxes() {\n    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n  }\n\n  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];\n  if (hasCartesian) seq.push(positionAndAutorange);\n  seq.push(subroutines.layoutStyles);\n  if (hasCartesian) seq.push(drawAxes);\n  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover, Plots.redrag, // TODO: doAutoMargin is only needed here for axis automargin, which\n  // happens outside of marginPushers where all the other automargins are\n  // calculated. Would be much better to separate margin calculations from\n  // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n  Plots.doAutoMargin, Plots.previousPromises); // even if everything we did was synchronous, return a promise\n  // so that the caller doesn't care which route we took\n\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    emitAfterPlot(gd);\n    return gd;\n  });\n}\n\nfunction emitAfterPlot(gd) {\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._redrawFromAutoMarginCount) {\n    fullLayout._redrawFromAutoMarginCount--;\n  } else {\n    gd.emit('plotly_afterplot');\n  }\n}\n\nfunction setPlotConfig(obj) {\n  return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n  try {\n    gd._fullLayout._paper.style('background', bgColor);\n  } catch (e) {\n    Lib.error(e);\n  }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n  var blend = Color.combine(bgColor, 'white');\n  setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n  if (!gd._context) {\n    gd._context = Lib.extendDeep({}, dfltConfig); // stash <base> href, used to make robust clipPath URLs\n\n    var base = d3.select('base');\n    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';\n  }\n\n  var context = gd._context;\n  var i, keys, key;\n\n  if (config) {\n    keys = Object.keys(config);\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      if (key === 'editable' || key === 'edits') continue;\n\n      if (key in context) {\n        if (key === 'setBackground' && config[key] === 'opaque') {\n          context[key] = opaqueSetBackground;\n        } else {\n          context[key] = config[key];\n        }\n      }\n    } // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n\n\n    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n      context.plotGlPixelRatio = context.plot3dPixelRatio;\n    } // now deal with editable and edits - first editable overrides\n    // everything, then edits refines\n\n\n    var editable = config.editable;\n\n    if (editable !== undefined) {\n      // we're not going to *use* context.editable, we're only going to\n      // use context.edits... but keep it for the record\n      context.editable = editable;\n      keys = Object.keys(context.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        context.edits[keys[i]] = editable;\n      }\n    }\n\n    if (config.edits) {\n      keys = Object.keys(config.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n\n        if (key in context.edits) {\n          context.edits[key] = config.edits[key];\n        }\n      }\n    } // not part of the user-facing config options\n\n\n    context._exportedPlot = config._exportedPlot;\n  } // staticPlot forces a bunch of others:\n\n\n  if (context.staticPlot) {\n    context.editable = false;\n    context.edits = {};\n    context.autosizable = false;\n    context.scrollZoom = false;\n    context.doubleClick = false;\n    context.showTips = false;\n    context.showLink = false;\n    context.displayModeBar = false;\n  } // make sure hover-only devices have mode bar visible\n\n\n  if (context.displayModeBar === 'hover' && !hasHover) {\n    context.displayModeBar = true;\n  } // default and fallback for setBackground\n\n\n  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n    context.setBackground = setBackground;\n  } // Check if gd has a specified widht/height to begin with\n\n\n  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0; // fill context._scrollZoom helper to help manage scrollZoom flaglist\n\n  var szIn = context.scrollZoom;\n  var szOut = context._scrollZoom = {};\n\n  if (szIn === true) {\n    szOut.cartesian = 1;\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  } else if (typeof szIn === 'string') {\n    var parts = szIn.split('+');\n\n    for (i = 0; i < parts.length; i++) {\n      szOut[parts[i]] = 1;\n    }\n  } else if (szIn !== false) {\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  }\n}\n\nfunction plotLegacyPolar(gd, data, layout) {\n  // build or reuse the container skeleton\n  var plotContainer = d3.select(gd).selectAll('.plot-container').data([0]);\n  plotContainer.enter().insert('div', ':first-child').classed('plot-container plotly', true);\n  var paperDiv = plotContainer.selectAll('.svg-container').data([0]);\n  paperDiv.enter().append('div').classed('svg-container', true).style('position', 'relative'); // empty it everytime for now\n\n  paperDiv.html(''); // fulfill gd requirements\n\n  if (data) gd.data = data;\n  if (layout) gd.layout = layout;\n  Polar.manager.fillLayout(gd); // resize canvas\n\n  paperDiv.style({\n    width: gd._fullLayout.width + 'px',\n    height: gd._fullLayout.height + 'px'\n  }); // instantiate framework\n\n  gd.framework = Polar.manager.framework(gd); // plot\n\n  gd.framework({\n    data: gd.data,\n    layout: gd.layout\n  }, paperDiv.node()); // set undo point\n\n  gd.framework.setUndoPoint(); // get the resulting svg for extending it\n\n  var polarPlotSVG = gd.framework.svg(); // editable title\n\n  var opacity = 1;\n  var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n  if (txt === '' || !txt) opacity = 0;\n\n  var titleLayout = function () {\n    this.call(svgTextUtils.convertToTspans, gd); // TODO: html/mathjax\n    // TODO: center title\n  };\n\n  var title = polarPlotSVG.select('.title-group text').call(titleLayout);\n\n  if (gd._context.edits.titleText) {\n    var placeholderText = Lib._(gd, 'Click to enter Plot title');\n\n    if (!txt || txt === placeholderText) {\n      opacity = 0.2; // placeholder is not going through convertToTspans\n      // so needs explicit data-unformatted\n\n      title.attr({\n        'data-unformatted': placeholderText\n      }).text(placeholderText).style({\n        opacity: opacity\n      }).on('mouseover.opacity', function () {\n        d3.select(this).transition().duration(100).style('opacity', 1);\n      }).on('mouseout.opacity', function () {\n        d3.select(this).transition().duration(1000).style('opacity', 0);\n      });\n    }\n\n    var setContenteditable = function () {\n      this.call(svgTextUtils.makeEditable, {\n        gd: gd\n      }).on('edit', function (text) {\n        gd.framework({\n          layout: {\n            title: {\n              text: text\n            }\n          }\n        });\n        this.text(text).call(titleLayout);\n        this.call(setContenteditable);\n      }).on('cancel', function () {\n        var txt = this.attr('data-unformatted');\n        this.text(txt).call(titleLayout);\n      });\n    };\n\n    title.call(setContenteditable);\n  }\n\n  gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n\n  Plots.addLinks(gd);\n  return Promise.resolve();\n} // convenience function to force a full redraw, mostly for use by plotly.js\n\n\nfunction redraw(gd) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  helpers.cleanData(gd.data);\n  helpers.cleanLayout(gd.layout);\n  gd.calcdata = undefined;\n  return exports.plot(gd).then(function () {\n    gd.emit('plotly_redraw');\n    return gd;\n  });\n}\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\n\n\nfunction newPlot(gd, data, layout, config) {\n  gd = Lib.getGraphDiv(gd); // remove gl contexts\n\n  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n  Plots.purge(gd);\n  return exports.plot(gd, data, layout, config);\n}\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\n\n\nfunction positivifyIndices(indices, maxIndex) {\n  var parentLength = maxIndex + 1;\n  var positiveIndices = [];\n  var i;\n  var index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n\n    if (index < 0) {\n      positiveIndices.push(parentLength + index);\n    } else {\n      positiveIndices.push(index);\n    }\n  }\n\n  return positiveIndices;\n}\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\n\n\nfunction assertIndexArray(gd, indices, arrayName) {\n  var i, index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i]; // validate that indices are indeed integers\n\n    if (index !== parseInt(index, 10)) {\n      throw new Error('all values in ' + arrayName + ' must be integers');\n    } // check that all indices are in bounds for given gd.data array length\n\n\n    if (index >= gd.data.length || index < -gd.data.length) {\n      throw new Error(arrayName + ' must be valid indices for gd.data.');\n    } // check that indices aren't repeated\n\n\n    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n      throw new Error('each index in ' + arrayName + ' must be unique.');\n    }\n  }\n}\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\n\n\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // validate currentIndices array\n\n\n  if (typeof currentIndices === 'undefined') {\n    throw new Error('currentIndices is a required argument.');\n  } else if (!Array.isArray(currentIndices)) {\n    currentIndices = [currentIndices];\n  }\n\n  assertIndexArray(gd, currentIndices, 'currentIndices'); // validate newIndices array if it exists\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined') {\n    assertIndexArray(gd, newIndices, 'newIndices');\n  } // check currentIndices and newIndices are the same length if newIdices exists\n\n\n  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n    throw new Error('current and new indices must be of equal length.');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\n\n\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n  var i, value; // check that gd has attribute 'data' and 'data' is array\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // make sure traces exists\n\n\n  if (typeof traces === 'undefined') {\n    throw new Error('traces must be defined.');\n  } // make sure traces is an array\n\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure each value in traces is an object\n\n\n  for (i = 0; i < traces.length; i++) {\n    value = traces[i];\n\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n      throw new Error('all values in traces array must be non-array objects');\n    }\n  } // make sure we have an index for each trace\n\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n    throw new Error('if indices is specified, traces.length must equal indices.length');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\n\n\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array');\n  }\n\n  if (!Lib.isPlainObject(update)) {\n    throw new Error('update must be a key:value object');\n  }\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers');\n  }\n\n  assertIndexArray(gd, indices, 'indices');\n\n  for (var key in update) {\n    /*\n     * Verify that the attribute to be updated contains as many trace updates\n     * as indices. Failure must result in throw and no-op\n     */\n    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {\n      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n    }\n    /*\n     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n     */\n\n\n    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {\n      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');\n    }\n  }\n}\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\n\n\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  var updateProps = [];\n  var trace, target, prop, insert, maxp; // allow scalar index to represent a single trace position\n\n  if (!Array.isArray(indices)) indices = [indices]; // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // loop through all update keys and traces and harvest validated data.\n\n  for (var key in update) {\n    for (var j = 0; j < indices.length; j++) {\n      /*\n       * Choose the trace indexed by the indices map argument and get the prop setter-getter\n       * instance that references the key and value for this particular trace.\n       */\n      trace = gd.data[indices[j]];\n      prop = nestedProperty(trace, key);\n      /*\n       * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n       * Target must exist as an Array to allow the extend operation to be performed.\n       */\n\n      target = prop.get();\n      insert = update[key][j];\n\n      if (!Lib.isArrayOrTypedArray(insert)) {\n        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n      }\n\n      if (!Lib.isArrayOrTypedArray(target)) {\n        throw new Error('cannot extend missing or non-array attribute: ' + key);\n      }\n\n      if (target.constructor !== insert.constructor) {\n        throw new Error('cannot extend array with an array of a different type: ' + key);\n      }\n      /*\n       * maxPoints may be an object map or a scalar. If object select the key:value, else\n       * Use the scalar maxPoints for all key and trace combinations.\n       */\n\n\n      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints; // could have chosen null here, -1 just tells us to not take a window\n\n      if (!isNumeric(maxp)) maxp = -1;\n      /*\n       * Wrap the nestedProperty in an object containing required data\n       * for lengthening and windowing this particular trace - key combination.\n       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n       */\n\n      updateProps.push({\n        prop: prop,\n        target: target,\n        insert: insert,\n        maxp: Math.floor(maxp)\n      });\n    }\n  } // all target and insertion data now validated\n\n\n  return updateProps;\n}\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\n\n\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n  assertExtendTracesArgs(gd, update, indices, maxPoints);\n  var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n  var undoUpdate = {};\n  var undoPoints = {};\n\n  for (var i = 0; i < updateProps.length; i++) {\n    var prop = updateProps[i].prop;\n    var maxp = updateProps[i].maxp; // return new array and remainder\n\n    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n    prop.set(out[0]); // build the inverse update object for the undo operation\n\n    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n    undoUpdate[prop.astr].push(out[1]); // build the matching maxPoints undo object containing original trace lengths\n\n    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n    undoPoints[prop.astr].push(updateProps[i].target.length);\n  }\n\n  return {\n    update: undoUpdate,\n    maxPoints: undoPoints\n  };\n}\n\nfunction concatTypedArray(arr0, arr1) {\n  var arr2 = new arr0.constructor(arr0.length + arr1.length);\n  arr2.set(arr0);\n  arr2.set(arr1, arr0.length);\n  return arr2;\n}\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\n\n\nfunction extendTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp < 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(target, insert);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target);\n          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          var targetBegin = target.length - numberOfItemsFromTarget;\n          newArray.set(target.subarray(targetBegin));\n          newArray.set(insert, numberOfItemsFromTarget);\n          remainder.set(target.subarray(0, targetBegin));\n        }\n      }\n    } else {\n      newArray = target.concat(insert);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n  return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp <= 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(insert, target);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n          remainder.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target, numberOfItemsFromInsert);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          newArray.set(insert);\n          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n          remainder.set(target.subarray(numberOfItemsFromTarget));\n        }\n      }\n    } else {\n      newArray = insert.concat(target);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n  return promise;\n}\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\n\n\nfunction addTraces(gd, traces, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var currentIndices = [];\n  var undoFunc = exports.deleteTraces;\n  var redoFunc = addTraces;\n  var undoArgs = [gd, currentIndices];\n  var redoArgs = [gd, traces]; // no newIndices here\n\n  var i;\n  var promise; // all validation is done elsewhere to remove clutter here\n\n  checkAddTracesArgs(gd, traces, newIndices); // make sure traces is an array\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure traces do not repeat existing ones\n\n\n  traces = traces.map(function (trace) {\n    return Lib.extendFlat({}, trace);\n  });\n  helpers.cleanData(traces); // add the traces to gd.data (no redrawing yet!)\n\n  for (i = 0; i < traces.length; i++) {\n    gd.data.push(traces[i]);\n  } // to continue, we need to call moveTraces which requires currentIndices\n\n\n  for (i = 0; i < traces.length; i++) {\n    currentIndices.push(-traces.length + i);\n  } // if the user didn't define newIndices, they just want the traces appended\n  // i.e., we can simply redraw and be done\n\n\n  if (typeof newIndices === 'undefined') {\n    promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    return promise;\n  } // make sure indices is property defined\n\n\n  if (!Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  try {\n    // this is redundant, but necessary to not catch later possible errors!\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n  } catch (error) {\n    // something went wrong, reset gd to be safe and rethrow error\n    gd.data.splice(gd.data.length - traces.length, traces.length);\n    throw error;\n  } // if we're here, the user has defined specific places to place the new traces\n  // this requires some extra work that moveTraces will do\n\n\n  Queue.startSequence(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  promise = exports.moveTraces(gd, currentIndices, newIndices);\n  Queue.stopSequence(gd);\n  return promise;\n}\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\n\n\nfunction deleteTraces(gd, indices) {\n  gd = Lib.getGraphDiv(gd);\n  var traces = [];\n  var undoFunc = exports.addTraces;\n  var redoFunc = deleteTraces;\n  var undoArgs = [gd, traces, indices];\n  var redoArgs = [gd, indices];\n  var i;\n  var deletedTrace; // make sure indices are defined\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers.');\n  } else if (!Array.isArray(indices)) {\n    indices = [indices];\n  }\n\n  assertIndexArray(gd, indices, 'indices'); // convert negative indices to positive indices\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // we want descending here so that splicing later doesn't affect indexing\n\n  indices.sort(Lib.sorterDes);\n\n  for (i = 0; i < indices.length; i += 1) {\n    deletedTrace = gd.data.splice(indices[i], 1)[0];\n    traces.push(deletedTrace);\n  }\n\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\n\n\nfunction moveTraces(gd, currentIndices, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var newData = [];\n  var movingTraceMap = [];\n  var undoFunc = moveTraces;\n  var redoFunc = moveTraces;\n  var undoArgs = [gd, newIndices, currentIndices];\n  var redoArgs = [gd, currentIndices, newIndices];\n  var i; // to reduce complexity here, check args elsewhere\n  // this throws errors where appropriate\n\n  checkMoveTracesArgs(gd, currentIndices, newIndices); // make sure currentIndices is an array\n\n  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices]; // if undefined, define newIndices to point to the end of gd.data array\n\n  if (typeof newIndices === 'undefined') {\n    newIndices = [];\n\n    for (i = 0; i < currentIndices.length; i++) {\n      newIndices.push(-currentIndices.length + i);\n    }\n  } // make sure newIndices is an array if it's user-defined\n\n\n  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices]; // convert negative indices to positive indices (they're the same length)\n\n  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n  newIndices = positivifyIndices(newIndices, gd.data.length - 1); // at this point, we've coerced the index arrays into predictable forms\n  // get the traces that aren't being moved around\n\n  for (i = 0; i < gd.data.length; i++) {\n    // if index isn't in currentIndices, include it in ignored!\n    if (currentIndices.indexOf(i) === -1) {\n      newData.push(gd.data[i]);\n    }\n  } // get a mapping of indices to moving traces\n\n\n  for (i = 0; i < currentIndices.length; i++) {\n    movingTraceMap.push({\n      newIndex: newIndices[i],\n      trace: gd.data[currentIndices[i]]\n    });\n  } // reorder this mapping by newIndex, ascending\n\n\n  movingTraceMap.sort(function (a, b) {\n    return a.newIndex - b.newIndex;\n  }); // now, add the moving traces back in, in order!\n\n  for (i = 0; i < movingTraceMap.length; i += 1) {\n    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n  }\n\n  gd.data = newData;\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\n\n\nfunction restyle(gd, astr, val, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = Lib.extendFlat({}, astr);\n    if (_traces === undefined) _traces = val;\n  } else {\n    Lib.warn('Restyle fail.', astr, val, _traces);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var specs = _restyle(gd, aobj, traces);\n\n  var flags = specs.flags; // clear calcdata and/or axis types if required so they get regenerated\n\n  if (flags.calc) gd.calcdata = undefined;\n  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {}); // fill in redraw sequence\n\n  var seq = [];\n\n  if (flags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises); // maybe only call Plots.supplyDataDefaults in the splom case,\n    // to skip over long and slow axes defaults\n\n    Plots.supplyDefaults(gd);\n\n    if (flags.markerSize) {\n      Plots.doCalcdata(gd);\n      addAxRangeSequence(seq); // TODO\n      // if all axes have autorange:false, then\n      // proceed to subroutines.doTraceStyle(),\n      // otherwise we must go through addAxRangeSequence,\n      // which in general must redraws 'all' axes\n    }\n\n    if (flags.style) seq.push(subroutines.doTraceStyle);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    gd.emit('plotly_restyle', specs.eventData);\n    return gd;\n  });\n} // for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\n\n\nfunction undefinedToNull(val) {\n  if (val === undefined) return null;\n  return val;\n}\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\n\n\nfunction makeNP(preGUI, guiEditFlag) {\n  if (!guiEditFlag) return nestedProperty;\n  return function (container, attr, prefix) {\n    var np = nestedProperty(container, attr);\n    var npSet = np.set;\n\n    np.set = function (val) {\n      var fullAttr = (prefix || '') + attr;\n      storeCurrent(fullAttr, np.get(), val, preGUI);\n      npSet(val);\n    };\n\n    return np;\n  };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n  if (Array.isArray(val) || Array.isArray(newVal)) {\n    var arrayVal = Array.isArray(val) ? val : [];\n    var arrayNew = Array.isArray(newVal) ? newVal : [];\n    var maxLen = Math.max(arrayVal.length, arrayNew.length);\n\n    for (var i = 0; i < maxLen; i++) {\n      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n    }\n  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n    var objVal = Lib.isPlainObject(val) ? val : {};\n    var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n    var objBoth = Lib.extendFlat({}, objVal, objNew);\n\n    for (var key in objBoth) {\n      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n    }\n  } else if (preGUI[attr] === undefined) {\n    preGUI[attr] = undefinedToNull(val);\n  }\n}\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\n\n\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n  for (var attr in edits) {\n    var np = nestedProperty(container, attr);\n    storeCurrent(attr, np.get(), edits[attr], preGUI);\n  }\n}\n\nfunction _restyle(gd, aobj, traces) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var data = gd.data;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var i;\n  cleanDeprecatedAttributeKeys(aobj); // initialize flags\n\n  var flags = editTypes.traceFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {};\n  var axlist; // make a new empty vals array for undoit\n\n  function a0() {\n    return traces.map(function () {\n      return undefined;\n    });\n  } // for autoranging multiple axes\n\n\n  function addToAxlist(axid) {\n    var axName = Axes.id2name(axid);\n    if (axlist.indexOf(axName) === -1) axlist.push(axName);\n  }\n\n  function autorangeAttr(axName) {\n    return 'LAYOUT' + axName + '.autorange';\n  }\n\n  function rangeAttr(axName) {\n    return 'LAYOUT' + axName + '.range';\n  }\n\n  function getFullTrace(traceIndex) {\n    // usually fullData maps 1:1 onto data, but with groupby transforms\n    // the fullData index can be greater. Take the *first* matching trace.\n    for (var j = traceIndex; j < fullData.length; j++) {\n      if (fullData[j]._input === data[traceIndex]) return fullData[j];\n    } // should never get here - and if we *do* it should cause an error\n    // later on undefined fullTrace is passed to nestedProperty.\n\n  } // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // val=null will delete the attribute\n  // attr can be an array to set several at once (all to the same val)\n\n\n  function doextra(attr, val, i) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val, i);\n      });\n      return;\n    } // quit if explicitly setting this elsewhere\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var extraparam;\n\n    if (attr.substr(0, 6) === 'LAYOUT') {\n      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n    } else {\n      var tracei = traces[i];\n\n      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n\n      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n    }\n\n    if (!(attr in undoit)) {\n      undoit[attr] = a0();\n    }\n\n    if (undoit[attr][i] === undefined) {\n      undoit[attr][i] = undefinedToNull(extraparam.get());\n    }\n\n    if (val !== undefined) {\n      extraparam.set(val);\n    }\n  }\n\n  function allBins(binAttr) {\n    return function (j) {\n      return fullData[j][binAttr];\n    };\n  }\n\n  function arrayBins(binAttr) {\n    return function (vij, j) {\n      return vij === false ? fullData[traces[j]][binAttr] : null;\n    };\n  } // now make the changes to gd.data (and occasionally gd.layout)\n  // and figure out what kind of graphics update we need to do\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var vi = aobj[ai];\n    var cont;\n    var contFull;\n    var param;\n    var oldVal;\n    var newVal;\n    var valObject; // Backward compatibility shim for turning histogram autobin on,\n    // or freezing previous autobinned values.\n    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n\n    if (ai === 'autobinx' || ai === 'autobiny') {\n      ai = ai.charAt(ai.length - 1) + 'bins';\n      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;\n    }\n\n    redoit[ai] = vi;\n\n    if (ai.substr(0, 6) === 'LAYOUT') {\n      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n      undoit[ai] = [undefinedToNull(param.get())]; // since we're allowing val to be an array, allow it here too,\n      // even though that's meaningless\n\n      param.set(Array.isArray(vi) ? vi[0] : vi); // ironically, the layout attrs in restyle only require replot,\n      // not relayout\n\n      flags.calc = true;\n      continue;\n    } // set attribute in gd.data\n\n\n    undoit[ai] = a0();\n\n    for (i = 0; i < traces.length; i++) {\n      cont = data[traces[i]];\n      contFull = getFullTrace(traces[i]);\n      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n      param = makeNP(preGUI, guiEditFlag)(cont, ai);\n      oldVal = param.get();\n      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n      if (newVal === undefined) continue;\n      var finalPart = param.parts[param.parts.length - 1];\n      var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n      var prefixDot = prefix ? prefix + '.' : '';\n      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;\n      valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n      if (valObject && valObject.impliedEdits && newVal !== null) {\n        for (var impliedKey in valObject.impliedEdits) {\n          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n        }\n      } else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {\n        // changing colorbar size modes,\n        // make the resulting size not change\n        // note that colorbar fractional sizing is based on the\n        // original plot size, before anything (like a colorbar)\n        // increases the margins\n        var gs = fullLayout._size;\n        var orient = innerContFull.orient;\n        var topOrBottom = orient === 'top' || orient === 'bottom';\n\n        if (finalPart === 'thicknessmode') {\n          var thicknorm = topOrBottom ? gs.h : gs.w;\n          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n        } else {\n          var lennorm = topOrBottom ? gs.w : gs.h;\n          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n        }\n      } else if (ai === 'type' && (newVal === 'pie' !== (oldVal === 'pie') || newVal === 'funnelarea' !== (oldVal === 'funnelarea'))) {\n        var labelsTo = 'x';\n        var valuesTo = 'y';\n\n        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n          labelsTo = 'y';\n          valuesTo = 'x';\n        }\n\n        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n        if (oldVal === 'pie' || oldVal === 'funnelarea') {\n          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get()); // super kludgy - but if all pies are gone we won't remove them otherwise\n\n          fullLayout._pielayer.selectAll('g.trace').remove();\n        } else if (Registry.traceIs(cont, 'cartesian')) {\n          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());\n        }\n      }\n\n      undoit[ai][i] = undefinedToNull(oldVal); // set the new value - if val is an array, it's one el per trace\n      // first check for attributes that get more complex alterations\n\n      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];\n\n      if (swapAttrs.indexOf(ai) !== -1) {\n        // setting an orientation: make sure it's changing\n        // before we swap everything else\n        if (ai === 'orientation') {\n          param.set(newVal); // obnoxious that we need this level of coupling... but in order to\n          // properly handle setting orientation to `null` we need to mimic\n          // the logic inside Bars.supplyDefaults for default orientation\n\n          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';\n\n          if ((param.get() || defaultOrientation) === contFull.orientation) {\n            continue;\n          }\n        } else if (ai === 'orientationaxes') {\n          // orientationaxes has no value,\n          // it flips everything and the axes\n          cont.orientation = {\n            v: 'h',\n            h: 'v'\n          }[contFull.orientation];\n        }\n\n        helpers.swapXYData(cont);\n        flags.calc = flags.clearAxisTypes = true;\n      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n        // TODO: use manageArrays.applyContainerArrayChanges here too\n        helpers.manageArrayContainers(param, newVal, undoit);\n        flags.calc = true;\n      } else {\n        if (valObject) {\n          // must redo calcdata when restyling array values of arrayOk attributes\n          // ... but no need to this for regl-based traces\n          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {\n            flags.calc = true;\n          } else editTypes.update(flags, valObject);\n        } else {\n          /*\n           * if we couldn't find valObject,  assume a full recalc.\n           * This can happen if you're changing type and making\n           * some other edits too, so the modules we're\n           * looking at don't have these attributes in them.\n           */\n          flags.calc = true;\n        } // all the other ones, just modify that one attribute\n\n\n        param.set(newVal);\n      }\n    } // swap the data attributes of the relevant x and y axes?\n\n\n    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n      Axes.swap(gd, traces);\n    } // swap hovermode if set to \"compare x/y data\"\n\n\n    if (ai === 'orientationaxes') {\n      var hovermode = nestedProperty(gd.layout, 'hovermode');\n\n      if (hovermode.get() === 'x') {\n        hovermode.set('y');\n      } else if (hovermode.get() === 'y') {\n        hovermode.set('x');\n      }\n    } // Major enough changes deserve autoscale and\n    // non-reversed axes so people don't get confused\n    //\n    // Note: autobin (or its new analog bin clearing) is not included here\n    // since we're not pushing bins back to gd.data, so if we have bin\n    // info it was explicitly provided by the user.\n\n\n    if (['orientation', 'type'].indexOf(ai) !== -1) {\n      axlist = [];\n\n      for (i = 0; i < traces.length; i++) {\n        var trace = data[traces[i]];\n\n        if (Registry.traceIs(trace, 'cartesian')) {\n          addToAxlist(trace.xaxis || 'x');\n          addToAxlist(trace.yaxis || 'y');\n        }\n      }\n\n      doextra(axlist.map(autorangeAttr), true, 0);\n      doextra(axlist.map(rangeAttr), [0, 1], 0);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  return {\n    flags: flags,\n    undoit: undoit,\n    redoit: redoit,\n    traces: traces,\n    eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n  };\n}\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\n\n\nfunction cleanDeprecatedAttributeKeys(aobj) {\n  var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n  var colorbarRegex = /colorbar\\.title$/;\n  var keys = Object.keys(aobj);\n  var i, key, value;\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    value = aobj[key];\n\n    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {\n      replace(key, key.replace('title', 'title.text'));\n    } else if (key.indexOf('titlefont') > -1) {\n      replace(key, key.replace('titlefont', 'title.font'));\n    } else if (key.indexOf('titleposition') > -1) {\n      replace(key, key.replace('titleposition', 'title.position'));\n    } else if (key.indexOf('titleside') > -1) {\n      replace(key, key.replace('titleside', 'title.side'));\n    } else if (key.indexOf('titleoffset') > -1) {\n      replace(key, key.replace('titleoffset', 'title.offset'));\n    }\n  }\n\n  function replace(oldAttrStr, newAttrStr) {\n    aobj[newAttrStr] = aobj[oldAttrStr];\n    delete aobj[oldAttrStr];\n  }\n}\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\n\n\nfunction relayout(gd, astr, val) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = Lib.extendFlat({}, astr);\n  } else {\n    Lib.warn('Relayout fail.', astr, val);\n    return Promise.reject();\n  }\n\n  if (Object.keys(aobj).length) gd.changed = true;\n\n  var specs = _relayout(gd, aobj);\n\n  var flags = specs.flags; // clear calcdata if required\n\n  if (flags.calc) gd.calcdata = undefined; // fill in redraw sequence\n  // even if we don't have anything left in aobj,\n  // something may have happened within relayout that we\n  // need to wait for\n\n  var seq = [Plots.previousPromises];\n\n  if (flags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else if (Object.keys(aobj).length) {\n    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n    if (flags.legend) seq.push(subroutines.doLegend);\n    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n    if (flags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (flags.modebar) seq.push(subroutines.doModeBar);\n    if (flags.camera) seq.push(subroutines.doCamera);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_relayout', specs.eventData);\n    return gd;\n  });\n} // Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\n\n\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n  var fullLayout = gd._fullLayout;\n  if (!flags.axrange) return false;\n\n  for (var k in flags) {\n    if (k !== 'axrange' && flags[k]) return false;\n  }\n\n  for (var axId in specs.rangesAltered) {\n    var axName = Axes.id2name(axId);\n    var axIn = gd.layout[axName];\n    var axOut = fullLayout[axName];\n    axOut.autorange = axIn.autorange;\n    axOut.range = axIn.range.slice();\n    axOut.cleanRange();\n\n    if (axOut._matchGroup) {\n      for (var axId2 in axOut._matchGroup) {\n        if (axId2 !== axId) {\n          var ax2 = fullLayout[Axes.id2name(axId2)];\n          ax2.autorange = axOut.autorange;\n          ax2.range = axOut.range.slice();\n          ax2._input.range = axOut.range.slice();\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n  // N.B. leave as sequence of subroutines (for now) instead of\n  // subroutine of its own so that finalDraw always gets\n  // executed after drawData\n  var drawAxes = rangesAltered ? function (gd) {\n    var axIds = [];\n    var skipTitle = true;\n\n    for (var id in rangesAltered) {\n      var ax = Axes.getFromId(gd, id);\n      axIds.push(id);\n\n      if (ax._matchGroup) {\n        for (var id2 in ax._matchGroup) {\n          if (!rangesAltered[id2]) {\n            axIds.push(id2);\n          }\n        }\n      }\n\n      if (ax.automargin) skipTitle = false;\n    }\n\n    return Axes.draw(gd, axIds, {\n      skipTitle: skipTitle\n    });\n  } : function (gd) {\n    return Axes.draw(gd, 'redraw');\n  };\n  seq.push(clearSelect, subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var keys = Object.keys(aobj);\n  var axes = Axes.list(gd);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var arrayEdits = {};\n  var arrayStr, i, j;\n  cleanDeprecatedAttributeKeys(aobj);\n  keys = Object.keys(aobj); // look for 'allaxes', split out into all axes\n  // in case of 3D the axis are nested within a scene which is held in _id\n\n  for (i = 0; i < keys.length; i++) {\n    if (keys[i].indexOf('allaxes') === 0) {\n      for (j = 0; j < axes.length; j++) {\n        var scene = axes[j]._id.substr(1);\n\n        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';\n        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n      }\n\n      delete aobj[keys[i]];\n    }\n  } // initialize flags\n\n\n  var flags = editTypes.layoutFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {}; // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // attr can be an array to set several at once (all to the same val)\n\n  function doextra(attr, val) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val);\n      });\n      return;\n    } // if we have another value for this attribute (explicitly or\n    // via a parent) do not override with this auto-generated extra\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var p = layoutNP(layout, attr);\n\n    if (!(attr in undoit)) {\n      undoit[attr] = undefinedToNull(p.get());\n    }\n\n    if (val !== undefined) p.set(val);\n  } // for constraint enforcement: keep track of all axes (as {id: name})\n  // we're editing the (auto)range of, so we can tell the others constrained\n  // to scale with them that it's OK for them to shrink\n\n\n  var rangesAltered = {};\n  var axId;\n\n  function recordAlteredAxis(pleafPlus) {\n    var axId = Axes.name2id(pleafPlus.split('.')[0]);\n    rangesAltered[axId] = 1;\n    return axId;\n  } // alter gd.layout\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var p = layoutNP(layout, ai);\n    var vi = aobj[ai];\n    var plen = p.parts.length; // p.parts may end with an index integer if the property is an array\n\n    var pend = plen - 1;\n\n    while (pend > 0 && typeof p.parts[pend] !== 'string') pend--; // last property in chain (leaf node)\n\n\n    var pleaf = p.parts[pend]; // leaf plus immediate parent\n\n    var pleafPlus = p.parts[pend - 1] + '.' + pleaf; // trunk nodes (everything except the leaf)\n\n    var ptrunk = p.parts.slice(0, pend).join('.');\n    var parentIn = nestedProperty(gd.layout, ptrunk).get();\n    var parentFull = nestedProperty(fullLayout, ptrunk).get();\n    var vOld = p.get();\n    if (vi === undefined) continue;\n    redoit[ai] = vi; // axis reverse is special - it is its own inverse\n    // op and has no flag.\n\n    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);\n    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n    if (valObject && valObject.impliedEdits && vi !== null) {\n      for (var impliedKey in valObject.impliedEdits) {\n        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n      }\n    } // Setting width or height to null must reset the graph's width / height\n    // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    //\n    // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // can't use impliedEdits for this because behavior depends on vi\n\n\n    if (['width', 'height'].indexOf(ai) !== -1) {\n      if (vi) {\n        doextra('autosize', null); // currently we don't support autosize one dim only - so\n        // explicitly set the other one. Note that doextra will\n        // ignore this if the same relayout call also provides oppositeAttr\n\n        var oppositeAttr = ai === 'height' ? 'width' : 'height';\n        doextra(oppositeAttr, fullLayout[oppositeAttr]);\n      } else {\n        fullLayout[ai] = gd._initialAutoSize[ai];\n      }\n    } else if (ai === 'autosize') {\n      // depends on vi here too, so again can't use impliedEdits\n      doextra('width', vi ? null : fullLayout.width);\n      doextra('height', vi ? null : fullLayout.height);\n    } else if (pleafPlus.match(AX_RANGE_RE)) {\n      // check autorange vs range\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n      var axFull = nestedProperty(fullLayout, ptrunk).get();\n\n      if (axFull._inputDomain) {\n        // if we're autoranging and this axis has a constrained domain,\n        // reset it so we don't get locked into a shrunken size\n        axFull._input.domain = axFull._inputDomain.slice();\n      }\n    } else if (pleafPlus.match(AX_DOMAIN_RE)) {\n      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n    } // toggling axis type between log and linear: we need to convert\n    // positions for components that are still using linearized values,\n    // not data values like newer components.\n    // previously we did this for log <-> not-log, but now only do it\n    // for log <-> linear\n\n\n    if (pleaf === 'type') {\n      var ax = parentIn;\n      var toLog = parentFull.type === 'linear' && vi === 'log';\n      var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n      if (toLog || fromLog) {\n        if (!ax || !ax.range) {\n          // 2D never gets here, but 3D does\n          // I don't think this is needed, but left here in case there\n          // are edge cases I'm not thinking of.\n          doextra(ptrunk + '.autorange', true);\n        } else if (!parentFull.autorange) {\n          // toggling log without autorange: need to also recalculate ranges\n          // because log axes use linearized values for range endpoints\n          var r0 = ax.range[0];\n          var r1 = ax.range[1];\n\n          if (toLog) {\n            // if both limits are negative, autorange\n            if (r0 <= 0 && r1 <= 0) {\n              doextra(ptrunk + '.autorange', true);\n            } // if one is negative, set it 6 orders below the other.\n\n\n            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6; // now set the range values as appropriate\n\n            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n          } else {\n            doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n            doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n          }\n        } else if (toLog) {\n          // just make sure the range is positive and in the right\n          // order, it'll get recalculated later\n          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];\n        } // clear polar view initial stash for radial range so that\n        // value get recomputed in correct units\n\n\n        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {\n          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n        } // Annotations and images also need to convert to/from linearized coords\n        // Shapes do not need this :)\n\n\n        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n      } else {\n        // any other type changes: the range from the previous type\n        // will not make sense, so autorange it.\n        doextra(ptrunk + '.autorange', true);\n        doextra(ptrunk + '.range', null);\n      }\n\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleaf.match(AX_NAME_PATTERN)) {\n      var fullProp = nestedProperty(fullLayout, ai).get();\n      var newType = (vi || {}).type; // This can potentially cause strange behavior if the autotype is not\n      // numeric (linear, because we don't auto-log) but the previous type\n      // was log. That's a very strange edge case though\n\n      if (!newType || newType === '-') newType = 'linear';\n      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n    } // alter gd.layout\n    // collect array component edits for execution all together\n    // so we can ensure consistent behavior adding/removing items\n    // and order-independence for add/remove/edit all together in\n    // one relayout call\n\n\n    var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n\n    if (containerArrayMatch) {\n      arrayStr = containerArrayMatch.array;\n      i = containerArrayMatch.index;\n      var propStr = containerArrayMatch.property;\n      var updateValObject = valObject || {\n        editType: 'calc'\n      };\n\n      if (i !== '' && propStr === '') {\n        // special handling of undoit if we're adding or removing an element\n        // ie 'annotations[2]' which can be {...} (add) or null,\n        // does not work when replacing the entire array\n        if (manageArrays.isAddVal(vi)) {\n          undoit[ai] = null;\n        } else if (manageArrays.isRemoveVal(vi)) {\n          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n        } else {\n          Lib.warn('unrecognized full object value', aobj);\n        }\n      }\n\n      editTypes.update(flags, updateValObject); // prepare the edits object we'll send to applyContainerArrayChanges\n\n      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n      var objEdits = arrayEdits[arrayStr][i];\n      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n      objEdits[propStr] = vi;\n      delete aobj[ai];\n    } else if (pleaf === 'reverse') {\n      // handle axis reversal explicitly, as there's no 'reverse' attribute\n      if (parentIn.range) parentIn.range.reverse();else {\n        doextra(ptrunk + '.autorange', true);\n        parentIn.range = [1, 0];\n      }\n      if (parentFull.autorange) flags.calc = true;else flags.plot = true;\n    } else {\n      if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {\n        flags.plot = true;\n      } else if (fullLayout._has('gl2d')) {\n        flags.plot = true;\n      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;\n\n      p.set(vi);\n    }\n  } // now we've collected component edits - execute them all together\n\n\n  for (arrayStr in arrayEdits) {\n    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n    if (!finished) flags.plot = true;\n  } // figure out if we need to recalculate axis constraints\n\n\n  var constraints = fullLayout._axisConstraintGroups || [];\n\n  for (axId in rangesAltered) {\n    for (i = 0; i < constraints.length; i++) {\n      var group = constraints[i];\n\n      if (group[axId]) {\n        // Always recalc if we're changing constrained ranges.\n        // Otherwise it's possible to violate the constraints by\n        // specifying arbitrary ranges for all axes in the group.\n        // this way some ranges may expand beyond what's specified,\n        // as they do at first draw, to satisfy the constraints.\n        flags.calc = true;\n\n        for (var groupAxId in group) {\n          if (!rangesAltered[groupAxId]) {\n            Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n          }\n        }\n      }\n    }\n  } // If the autosize changed or height or width was explicitly specified,\n  // this triggers a redraw\n  // TODO: do we really need special aobj.height/width handling here?\n  // couldn't editType do this?\n\n\n  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  } // now all attribute mods are done, as are\n  // redo and undo so we can save them\n\n\n  return {\n    flags: flags,\n    rangesAltered: rangesAltered,\n    undoit: undoit,\n    redoit: redoit,\n    eventData: eventData\n  };\n}\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\n\n\nfunction updateAutosize(gd) {\n  var fullLayout = gd._fullLayout;\n  var oldWidth = fullLayout.width;\n  var oldHeight = fullLayout.height; // calculate autosizing\n\n  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;\n}\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\n\n\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n\n  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n  if (Object.keys(traceUpdate).length) gd.changed = true;\n  if (Object.keys(layoutUpdate).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n\n  var restyleFlags = restyleSpecs.flags;\n\n  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n\n  var relayoutFlags = relayoutSpecs.flags; // clear calcdata and/or axis types if required\n\n  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate); // fill in redraw sequence\n\n  var seq = [];\n\n  if (relayoutFlags.layoutReplot) {\n    // N.B. works fine when both\n    // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n    seq.push(subroutines.layoutReplot);\n  } else if (restyleFlags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises);\n    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n    if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n    if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n    if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_update', {\n      data: restyleSpecs.eventData,\n      layout: relayoutSpecs.eventData\n    });\n    return gd;\n  });\n}\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\n\n\nfunction guiEdit(func) {\n  return function wrappedEdit(gd) {\n    gd._fullLayout._guiEditing = true;\n    var p = func.apply(null, arguments);\n    gd._fullLayout._guiEditing = false;\n    return p;\n  };\n} // For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\n\n\nvar layoutUIControlPatterns = [{\n  pattern: /^hiddenlabels/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/\n}, // showspikes and modes include those nested inside scenes\n{\n  pattern: /axis\\d*\\.showspikes$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /(hover|drag)mode$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /^(scene\\d*)\\.camera/\n}, {\n  pattern: /^(geo\\d*)\\.(projection|center)/\n}, {\n  pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/\n}, {\n  pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/\n}, {\n  pattern: /^(polar\\d*\\.angularaxis)\\.rotation/\n}, {\n  pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^legend\\.(x|y)$/,\n  attr: 'editrevision'\n}, {\n  pattern: /^(shapes|annotations)/,\n  attr: 'editrevision'\n}, {\n  pattern: /^title\\.text$/,\n  attr: 'editrevision'\n}]; // same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\n\nvar traceUIControlPatterns = [{\n  pattern: /^selectedpoints$/,\n  attr: 'selectionrevision'\n}, // \"visible\" includes trace.transforms[i].styles[j].value.visible\n{\n  pattern: /(^|value\\.)visible$/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^dimensions\\[\\d+\\]\\.constraintrange/\n}, {\n  pattern: /^node\\.(x|y|groups)/\n}, // for Sankey nodes\n{\n  pattern: /^level$/\n}, // for Sunburst & Treemap traces\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n// \"name\" also includes transform.styles\n{\n  pattern: /(^|value\\.)name$/\n}, // including nested colorbar attributes (ie marker.colorbar)\n{\n  pattern: /colorbar\\.title\\.text$/\n}, {\n  pattern: /colorbar\\.(x|y)$/,\n  attr: 'editrevision'\n}];\n\nfunction findUIPattern(key, patternSpecs) {\n  for (var i = 0; i < patternSpecs.length; i++) {\n    var spec = patternSpecs[i];\n    var match = key.match(spec.pattern);\n\n    if (match) {\n      return {\n        head: match[1],\n        attr: spec.attr\n      };\n    }\n  }\n} // We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\n\n\nfunction getNewRev(revAttr, container) {\n  var newRev = nestedProperty(container, revAttr).get();\n  if (newRev !== undefined) return newRev;\n  var parts = revAttr.split('.');\n  parts.pop();\n\n  while (parts.length > 1) {\n    parts.pop();\n    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n    if (newRev !== undefined) return newRev;\n  }\n\n  return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (fullData[i]._fullInput.uid === uid) return i;\n  }\n\n  return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].uid === uid) return i;\n  } // fall back on trace order, but only if user didn't provide a uid for that trace\n\n\n  return !data[tracei] || data[tracei].uid ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n  var v1IsObj = Lib.isPlainObject(v1);\n  var v1IsArray = Array.isArray(v1);\n\n  if (v1IsObj || v1IsArray) {\n    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);\n  }\n\n  return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n  var layoutPreGUI = oldFullLayout._preGUI;\n  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n  var bothInheritAutorange = [];\n  var newRangeAccepted = {};\n\n  for (key in layoutPreGUI) {\n    match = findUIPattern(key, layoutUIControlPatterns);\n\n    if (match) {\n      revAttr = match.attr || match.head + '.uirevision';\n      oldRev = nestedProperty(oldFullLayout, revAttr).get();\n      newRev = oldRev && getNewRev(revAttr, layout);\n\n      if (newRev && newRev === oldRev) {\n        preGUIVal = layoutPreGUI[key];\n        if (preGUIVal === null) preGUIVal = undefined;\n        newNP = nestedProperty(layout, key);\n        newVal = newNP.get();\n\n        if (valsMatch(newVal, preGUIVal)) {\n          if (newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n            bothInheritAutorange.push(key.substr(0, key.length - 10));\n          }\n\n          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n          continue;\n        }\n      }\n    } else {\n      Lib.warn('unrecognized GUI edit: ' + key);\n    } // if we got this far, the new value was accepted as the new starting\n    // point (either because it changed or revision changed)\n    // so remove it from _preGUI for next time.\n\n\n    delete layoutPreGUI[key];\n\n    if (key.substr(key.length - 8, 6) === 'range[') {\n      newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n    }\n  } // Special logic for `autorange`, since it interacts with `range`:\n  // If the new figure's matching `range` was kept, and `autorange`\n  // wasn't supplied explicitly in either the original or the new figure,\n  // we shouldn't alter that - but we may just have done that, so fix it.\n\n\n  for (var i = 0; i < bothInheritAutorange.length; i++) {\n    var axAttr = bothInheritAutorange[i];\n\n    if (newRangeAccepted[axAttr]) {\n      var newAx = nestedProperty(layout, axAttr).get();\n      if (newAx) delete newAx.autorange;\n    }\n  } // Now traces - try to match them up by uid (in case we added/deleted in\n  // the middle), then fall back on index.\n\n\n  var allTracePreGUI = oldFullLayout._tracePreGUI;\n\n  for (var uid in allTracePreGUI) {\n    var tracePreGUI = allTracePreGUI[uid];\n    var newTrace = null;\n    var fullInput;\n\n    for (key in tracePreGUI) {\n      // wait until we know we have preGUI values to look for traces\n      // but if we don't find both, stop looking at this uid\n      if (!newTrace) {\n        var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n\n        if (fulli < 0) {\n          // Somehow we didn't even have this trace in oldFullData...\n          // I guess this could happen with `deleteTraces` or something\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        var fullTrace = oldFullData[fulli];\n        fullInput = fullTrace._fullInput;\n        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n\n        if (newTracei < 0) {\n          // No match in new data\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        newTrace = data[newTracei];\n      }\n\n      match = findUIPattern(key, traceUIControlPatterns);\n\n      if (match) {\n        if (match.attr) {\n          oldRev = nestedProperty(oldFullLayout, match.attr).get();\n          newRev = oldRev && getNewRev(match.attr, layout);\n        } else {\n          oldRev = fullInput.uirevision; // inheritance for trace.uirevision is simple, just layout.uirevision\n\n          newRev = newTrace.uirevision;\n          if (newRev === undefined) newRev = layout.uirevision;\n        }\n\n        if (newRev && newRev === oldRev) {\n          preGUIVal = tracePreGUI[key];\n          if (preGUIVal === null) preGUIVal = undefined;\n          newNP = nestedProperty(newTrace, key);\n          newVal = newNP.get();\n\n          if (valsMatch(newVal, preGUIVal)) {\n            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n            continue;\n          }\n        }\n      } else {\n        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n      }\n\n      delete tracePreGUI[key];\n    }\n  }\n}\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\n\n\nfunction react(gd, data, layout, config) {\n  var frames, plotDone;\n\n  function addFrames() {\n    return exports.addFrames(gd, frames);\n  }\n\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var oldFullData = gd._fullData;\n  var oldFullLayout = gd._fullLayout; // you can use this as the initial draw as well as to update\n\n  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n    plotDone = exports.newPlot(gd, data, layout, config);\n  } else {\n    if (Lib.isPlainObject(data)) {\n      var obj = data;\n      data = obj.data;\n      layout = obj.layout;\n      config = obj.config;\n      frames = obj.frames;\n    }\n\n    var configChanged = false; // assume that if there's a config at all, we're reacting to it too,\n    // and completely replace the previous config\n\n    if (config) {\n      var oldConfig = Lib.extendDeep({}, gd._context);\n      gd._context = undefined;\n      setPlotContext(gd, config);\n      configChanged = diffConfig(oldConfig, gd._context);\n    }\n\n    gd.data = data || [];\n    helpers.cleanData(gd.data);\n    gd.layout = layout || {};\n    helpers.cleanLayout(gd.layout);\n    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout); // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n    // which supplyDefaults usually does at the end, but we may need to NOT do\n    // if the diff (which we haven't determined yet) says we'll recalc\n\n    Plots.supplyDefaults(gd, {\n      skipUpdateCalc: true\n    });\n    var newFullData = gd._fullData;\n    var newFullLayout = gd._fullLayout;\n    var immutable = newFullLayout.datarevision === undefined;\n    var transition = newFullLayout.transition;\n    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n    var newDataRevision = relayoutFlags.newDataRevision;\n    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision); // TODO: how to translate this part of relayout to Plotly.react?\n    // // Setting width or height to null must reset the graph's width / height\n    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    // //\n    // // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n    //     fullLayout[ai] = gd._initialAutoSize[ai];\n    // }\n\n    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true; // clear calcdata if required\n\n    if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined; // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n    else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData); // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n    // must be handled by the user when using Plotly.react.\n    // fill in redraw sequence\n\n    var seq = [];\n\n    if (frames) {\n      gd._transitionData = {};\n      Plots.createTransitionData(gd);\n      seq.push(addFrames);\n    } // Transition pathway,\n    // only used when 'transition' is set by user and\n    // when at least one animatable attribute has changed,\n    // N.B. config changed aren't animatable\n\n\n    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n      Plots.doCalcdata(gd);\n      subroutines.doAutoRangeAndConstraints(gd);\n      seq.push(function () {\n        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n      });\n    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n      gd._fullLayout._skipDefaults = true;\n      seq.push(exports.plot);\n    } else {\n      for (var componentType in relayoutFlags.arrays) {\n        var indices = relayoutFlags.arrays[componentType];\n\n        if (indices.length) {\n          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n\n          if (drawOne !== Lib.noop) {\n            for (var i = 0; i < indices.length; i++) {\n              drawOne(gd, indices[i]);\n            }\n          } else {\n            var draw = Registry.getComponentMethod(componentType, 'draw');\n\n            if (draw === Lib.noop) {\n              throw new Error('cannot draw components: ' + componentType);\n            }\n\n            draw(gd);\n          }\n        }\n      }\n\n      seq.push(Plots.previousPromises);\n      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n      if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n      if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n      if (relayoutFlags.axrange) addAxRangeSequence(seq);\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n      if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n      seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n    plotDone = Lib.syncOrAsync(seq, gd);\n    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  }\n\n  return plotDone.then(function () {\n    gd.emit('plotly_react', {\n      data: data,\n      layout: layout\n    });\n    return gd;\n  });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n  var sameTraceLength = oldFullData.length === newFullData.length;\n\n  if (!transition && !sameTraceLength) {\n    return {\n      fullReplot: true,\n      calc: true\n    };\n  }\n\n  var flags = editTypes.traceFlags();\n  flags.arrays = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  var i, trace;\n\n  function getTraceValObject(parts) {\n    var out = PlotSchema.getTraceValObject(trace, parts);\n\n    if (!trace._module.animatable && out.anim) {\n      out.anim = false;\n    }\n\n    return out;\n  }\n\n  var diffOpts = {\n    getValObject: getTraceValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    newDataRevision: newDataRevision,\n    gd: gd\n  };\n  var seenUIDs = {};\n\n  for (i = 0; i < oldFullData.length; i++) {\n    if (newFullData[i]) {\n      trace = newFullData[i]._fullInput;\n      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n      if (seenUIDs[trace.uid]) continue;\n      seenUIDs[trace.uid] = 1;\n      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n  var flags = editTypes.layoutFlags();\n  flags.arrays = {};\n  flags.rangesAltered = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n\n  function getLayoutValObject(parts) {\n    return PlotSchema.getLayoutValObject(newFullLayout, parts);\n  }\n\n  var diffOpts = {\n    getValObject: getLayoutValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    gd: gd\n  };\n  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n  var valObject, key, astr;\n  var getValObject = opts.getValObject;\n  var flags = opts.flags;\n  var immutable = opts.immutable;\n  var inArray = opts.inArray;\n  var arrayIndex = opts.arrayIndex;\n\n  function changed() {\n    var editType = valObject.editType;\n\n    if (inArray && editType.indexOf('arraydraw') !== -1) {\n      Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n      return;\n    }\n\n    editTypes.update(flags, valObject);\n\n    if (editType !== 'none') {\n      flags.nChanges++;\n    } // track animatable changes\n\n\n    if (opts.transition && valObject.anim) {\n      flags.nChangesAnim++;\n    } // track cartesian axes with altered ranges\n\n\n    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n      flags.rangesAltered[outerparts[0]] = 1;\n    } // clear _inputDomain on cartesian axes with altered domains\n\n\n    if (AX_DOMAIN_RE.test(astr)) {\n      nestedProperty(newContainer, '_inputDomain').set(null);\n    } // track datarevision changes\n\n\n    if (key === 'datarevision') {\n      flags.newDataRevision = 1;\n    }\n  }\n\n  function valObjectCanBeDataArray(valObject) {\n    return valObject.valType === 'data_array' || valObject.arrayOk;\n  }\n\n  for (key in oldContainer) {\n    // short-circuit based on previous calls or previous keys that already maximized the pathway\n    if (flags.calc && !opts.transition) return;\n    var oldVal = oldContainer[key];\n    var newVal = newContainer[key];\n    var parts = outerparts.concat(key);\n    astr = parts.join('.');\n    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue; // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n    // and unlike other auto values they don't make it back into the input,\n    // so newContainer won't have them.\n\n    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n      var tickMode = newContainer.tickmode;\n      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n    } // FIXME: Similarly for axis ranges for 3D\n    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n\n\n    if (key === 'range' && newContainer.autorange) continue;\n    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n    valObject = getValObject(parts); // in case type changed, we may not even *have* a valObject.\n\n    if (!valObject) continue;\n    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n    var valType = valObject.valType;\n    var i;\n    var canBeDataArray = valObjectCanBeDataArray(valObject);\n    var wasArray = Array.isArray(oldVal);\n    var nowArray = Array.isArray(newVal); // hack for traces that modify the data in supplyDefaults, like\n    // converting 1D to 2D arrays, which will always create new objects\n\n    if (wasArray && nowArray) {\n      var inputKey = '_input_' + key;\n      var oldValIn = oldContainer[inputKey];\n      var newValIn = newContainer[inputKey];\n      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n    }\n\n    if (newVal === undefined) {\n      if (canBeDataArray && wasArray) flags.calc = true;else changed();\n    } else if (valObject._isLinkedToArray) {\n      var arrayEditIndices = [];\n      var extraIndices = false;\n      if (!inArray) flags.arrays[key] = arrayEditIndices;\n      var minLen = Math.min(oldVal.length, newVal.length);\n      var maxLen = Math.max(oldVal.length, newVal.length);\n\n      if (minLen !== maxLen) {\n        if (valObject.editType === 'arraydraw') {\n          extraIndices = true;\n        } else {\n          changed();\n          continue;\n        }\n      }\n\n      for (i = 0; i < minLen; i++) {\n        getDiffFlags(oldVal[i], newVal[i], parts.concat(i), // add array indices, but not if we're already in an array\n        Lib.extendFlat({\n          inArray: key,\n          arrayIndex: i\n        }, opts));\n      } // put this at the end so that we know our collected array indices are sorted\n      // but the check for length changes happens up front so we can short-circuit\n      // diffing if appropriate\n\n\n      if (extraIndices) {\n        for (i = minLen; i < maxLen; i++) {\n          arrayEditIndices.push(i);\n        }\n      }\n    } else if (!valType && Lib.isPlainObject(oldVal)) {\n      getDiffFlags(oldVal, newVal, parts, opts);\n    } else if (canBeDataArray) {\n      if (wasArray && nowArray) {\n        // don't try to diff two data arrays. If immutable we know the data changed,\n        // if not, assume it didn't and let `layout.datarevision` tell us if it did\n        if (immutable) {\n          flags.calc = true;\n        } // look for animatable attributes when the data changed\n\n\n        if (immutable || opts.newDataRevision) {\n          changed();\n        }\n      } else if (wasArray !== nowArray) {\n        flags.calc = true;\n      } else changed();\n    } else if (wasArray && nowArray) {\n      // info array, colorscale, 'any' - these are short, just stringify.\n      // I don't *think* that covers up any real differences post-validation, does it?\n      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n      // all elements.\n      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n        changed();\n      }\n    } else {\n      changed();\n    }\n  }\n\n  for (key in newContainer) {\n    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n      valObject = getValObject(outerparts.concat(key));\n\n      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n        flags.calc = true;\n        return;\n      } else changed();\n    }\n  }\n}\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\n\n\nfunction diffConfig(oldConfig, newConfig) {\n  var key;\n\n  for (key in oldConfig) {\n    if (key.charAt(0) === '_') continue;\n    var oldVal = oldConfig[key];\n    var newVal = newConfig[key];\n\n    if (oldVal !== newVal) {\n      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n        if (diffConfig(oldVal, newVal)) {\n          return true;\n        }\n      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {\n        if (oldVal.length !== newVal.length) {\n          return true;\n        }\n\n        for (var i = 0; i < oldVal.length; i++) {\n          if (oldVal[i] !== newVal[i]) {\n            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n              if (diffConfig(oldVal[i], newVal[i])) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n}\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\n\n\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plot.ly/javascript/animations/');\n  }\n\n  var trans = gd._transitionData; // This is the queue of frames that will be animated as soon as possible. They\n  // are popped immediately upon the *start* of a transition:\n\n  if (!trans._frameQueue) {\n    trans._frameQueue = [];\n  }\n\n  animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n  var transitionOpts = animationOpts.transition;\n  var frameOpts = animationOpts.frame; // Since frames are popped immediately, an empty queue only means all frames have\n  // *started* to transition, not that the animation is complete. To solve that,\n  // track a separate counter that increments at the same time as frames are added\n  // to the queue, but decrements only when the transition is complete.\n\n  if (trans._frameWaitingCnt === undefined) {\n    trans._frameWaitingCnt = 0;\n  }\n\n  function getTransitionOpts(i) {\n    if (Array.isArray(transitionOpts)) {\n      if (i >= transitionOpts.length) {\n        return transitionOpts[0];\n      } else {\n        return transitionOpts[i];\n      }\n    } else {\n      return transitionOpts;\n    }\n  }\n\n  function getFrameOpts(i) {\n    if (Array.isArray(frameOpts)) {\n      if (i >= frameOpts.length) {\n        return frameOpts[0];\n      } else {\n        return frameOpts[i];\n      }\n    } else {\n      return frameOpts;\n    }\n  } // Execute a callback after the wrapper function has been called n times.\n  // This is used to defer the resolution until a transition has resovled *and*\n  // the frame has completed. If it's not done this way, then we get a race\n  // condition in which the animation might resolve before a transition is complete\n  // or vice versa.\n\n\n  function callbackOnNthTime(cb, n) {\n    var cnt = 0;\n    return function () {\n      if (cb && ++cnt === n) {\n        return cb();\n      }\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    function discardExistingFrames() {\n      if (trans._frameQueue.length === 0) {\n        return;\n      }\n\n      while (trans._frameQueue.length) {\n        var next = trans._frameQueue.pop();\n\n        if (next.onInterrupt) {\n          next.onInterrupt();\n        }\n      }\n\n      gd.emit('plotly_animationinterrupted', []);\n    }\n\n    function queueFrames(frameList) {\n      if (frameList.length === 0) return;\n\n      for (var i = 0; i < frameList.length; i++) {\n        var computedFrame;\n\n        if (frameList[i].type === 'byname') {\n          // If it's a named frame, compute it:\n          computedFrame = Plots.computeFrame(gd, frameList[i].name);\n        } else {\n          // Otherwise we must have been given a simple object, so treat\n          // the input itself as the computed frame.\n          computedFrame = frameList[i].data;\n        }\n\n        var frameOpts = getFrameOpts(i);\n        var transitionOpts = getTransitionOpts(i); // It doesn't make much sense for the transition duration to be greater than\n        // the frame duration, so limit it:\n\n        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n        var nextFrame = {\n          frame: computedFrame,\n          name: frameList[i].name,\n          frameOpts: frameOpts,\n          transitionOpts: transitionOpts\n        };\n\n        if (i === frameList.length - 1) {\n          // The last frame in this .animate call stores the promise resolve\n          // and reject callbacks. This is how we ensure that the animation\n          // loop (which may exist as a result of a *different* .animate call)\n          // still resolves or rejecdts this .animate call's promise. once it's\n          // complete.\n          nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n          nextFrame.onInterrupt = reject;\n        }\n\n        trans._frameQueue.push(nextFrame);\n      } // Set it as never having transitioned to a frame. This will cause the animation\n      // loop to immediately transition to the next frame (which, for immediate mode,\n      // is the first frame in the list since all others would have been discarded\n      // below)\n\n\n      if (animationOpts.mode === 'immediate') {\n        trans._lastFrameAt = -Infinity;\n      } // Only it's not already running, start a RAF loop. This could be avoided in the\n      // case that there's only one frame, but it significantly complicated the logic\n      // and only sped things up by about 5% or so for a lorenz attractor simulation.\n      // It would be a fine thing to implement, but the benefit of that optimization\n      // doesn't seem worth the extra complexity.\n\n\n      if (!trans._animationRaf) {\n        beginAnimationLoop();\n      }\n    }\n\n    function stopAnimationLoop() {\n      gd.emit('plotly_animated'); // Be sure to unset also since it's how we know whether a loop is already running:\n\n      window.cancelAnimationFrame(trans._animationRaf);\n      trans._animationRaf = null;\n    }\n\n    function nextFrame() {\n      if (trans._currentFrame && trans._currentFrame.onComplete) {\n        // Execute the callback and unset it to ensure it doesn't\n        // accidentally get called twice\n        trans._currentFrame.onComplete();\n      }\n\n      var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n      if (newFrame) {\n        // Since it's sometimes necessary to do deep digging into frame data,\n        // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n        // so check when casting the name, just to be absolutely certain:\n        var stringName = newFrame.name ? newFrame.name.toString() : null;\n        gd._fullLayout._currentFrame = stringName;\n        trans._lastFrameAt = Date.now();\n        trans._timeToNext = newFrame.frameOpts.duration; // This is simply called and it's left to .transition to decide how to manage\n        // interrupting current transitions. That means we don't need to worry about\n        // how it resolves or what happens after this:\n\n        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {\n          if (newFrame.onComplete) {\n            newFrame.onComplete();\n          }\n        });\n        gd.emit('plotly_animatingframe', {\n          name: stringName,\n          frame: newFrame.frame,\n          animation: {\n            frame: newFrame.frameOpts,\n            transition: newFrame.transitionOpts\n          }\n        });\n      } else {\n        // If there are no more frames, then stop the RAF loop:\n        stopAnimationLoop();\n      }\n    }\n\n    function beginAnimationLoop() {\n      gd.emit('plotly_animating'); // If no timer is running, then set last frame = long ago so that the next\n      // frame is immediately transitioned:\n\n      trans._lastFrameAt = -Infinity;\n      trans._timeToNext = 0;\n      trans._runningTransitions = 0;\n      trans._currentFrame = null;\n\n      var doFrame = function () {\n        // This *must* be requested before nextFrame since nextFrame may decide\n        // to cancel it if there's nothing more to animated:\n        trans._animationRaf = window.requestAnimationFrame(doFrame); // Check if we're ready for a new frame:\n\n        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {\n          nextFrame();\n        }\n      };\n\n      doFrame();\n    } // This is an animate-local counter that helps match up option input list\n    // items with the particular frame.\n\n\n    var configCounter = 0;\n\n    function setTransitionConfig(frame) {\n      if (Array.isArray(transitionOpts)) {\n        if (configCounter >= transitionOpts.length) {\n          frame.transitionOpts = transitionOpts[configCounter];\n        } else {\n          frame.transitionOpts = transitionOpts[0];\n        }\n      } else {\n        frame.transitionOpts = transitionOpts;\n      }\n\n      configCounter++;\n      return frame;\n    } // Disambiguate what's sort of frames have been received\n\n\n    var i, frame;\n    var frameList = [];\n    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n    if (isSingleFrame) {\n      // In this case, a simple object has been passed to animate.\n      frameList.push({\n        type: 'object',\n        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n      });\n    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n      // In this case, null or undefined has been passed so that we want to\n      // animate *all* currently defined frames\n      for (i = 0; i < trans._frames.length; i++) {\n        frame = trans._frames[i];\n        if (!frame) continue;\n\n        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n          frameList.push({\n            type: 'byname',\n            name: String(frame.name),\n            data: setTransitionConfig({\n              name: frame.name\n            })\n          });\n        }\n      }\n    } else if (isFrameArray) {\n      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n        var frameOrName = frameOrGroupNameOrFrameList[i];\n\n        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n          frameOrName = String(frameOrName); // In this case, there's an array and this frame is a string name:\n\n          frameList.push({\n            type: 'byname',\n            name: frameOrName,\n            data: setTransitionConfig({\n              name: frameOrName\n            })\n          });\n        } else if (Lib.isPlainObject(frameOrName)) {\n          frameList.push({\n            type: 'object',\n            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n          });\n        }\n      }\n    } // Verify that all of these frames actually exist; return and reject if not:\n\n\n    for (i = 0; i < frameList.length; i++) {\n      frame = frameList[i];\n\n      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n        Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n        reject();\n        return;\n      }\n    } // If the mode is either next or immediate, then all currently queued frames must\n    // be dumped and the corresponding .animate promises rejected.\n\n\n    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n      discardExistingFrames();\n    }\n\n    if (animationOpts.direction === 'reverse') {\n      frameList.reverse();\n    }\n\n    var currentFrame = gd._fullLayout._currentFrame;\n\n    if (currentFrame && animationOpts.fromcurrent) {\n      var idx = -1;\n\n      for (i = 0; i < frameList.length; i++) {\n        frame = frameList[i];\n\n        if (frame.type === 'byname' && frame.name === currentFrame) {\n          idx = i;\n          break;\n        }\n      }\n\n      if (idx > 0 && idx < frameList.length - 1) {\n        var filteredFrameList = [];\n\n        for (i = 0; i < frameList.length; i++) {\n          frame = frameList[i];\n\n          if (frameList[i].type !== 'byname' || i > idx) {\n            filteredFrameList.push(frame);\n          }\n        }\n\n        frameList = filteredFrameList;\n      }\n    }\n\n    if (frameList.length > 0) {\n      queueFrames(frameList);\n    } else {\n      // This is the case where there were simply no frames. It's a little strange\n      // since there's not much to do:\n      gd.emit('plotly_animated');\n      resolve();\n    }\n  });\n}\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\n\n\nfunction addFrames(gd, frameList, indices) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (frameList === null || frameList === undefined) {\n    return Promise.resolve();\n  }\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plot.ly/javascript/animations/');\n  }\n\n  var i, frame, j, idx;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n\n  if (!Array.isArray(frameList)) {\n    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n  } // Create a sorted list of insertions since we run into lots of problems if these\n  // aren't in ascending order of index:\n  //\n  // Strictly for sorting. Make sure this is guaranteed to never collide with any\n  // already-exisisting indices:\n\n\n  var bigIndex = _frames.length + frameList.length * 2;\n  var insertions = [];\n  var _frameHashLocal = {};\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    if (!Lib.isPlainObject(frameList[i])) continue; // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n    // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n\n    var lookupName = frameList[i].name;\n    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n    var newName = frameList[i].name;\n    var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n      numericNameWarningCount++;\n      Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name + '\" with a frame whose name of type \"number\" also equates to \"' + name + '\". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');\n\n      if (numericNameWarningCount === numericNameWarningCountLimit) {\n        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');\n      }\n    }\n\n    _frameHashLocal[lookupName] = {\n      name: lookupName\n    };\n    insertions.push({\n      frame: Plots.supplyFrameDefaults(frameList[i]),\n      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i\n    });\n  } // Sort this, taking note that undefined insertions end up at the end:\n\n\n  insertions.sort(function (a, b) {\n    if (a.index > b.index) return -1;\n    if (a.index < b.index) return 1;\n    return 0;\n  });\n  var ops = [];\n  var revops = [];\n  var frameCount = _frames.length;\n\n  for (i = insertions.length - 1; i >= 0; i--) {\n    frame = insertions[i].frame;\n\n    if (typeof frame.name === 'number') {\n      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');\n    }\n\n    if (!frame.name) {\n      // Repeatedly assign a default name, incrementing the counter each time until\n      // we get a name that's not in the hashed lookup table:\n      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]);\n    }\n\n    if (_frameHash[frame.name]) {\n      // If frame is present, overwrite its definition:\n      for (j = 0; j < _frames.length; j++) {\n        if ((_frames[j] || {}).name === frame.name) break;\n      }\n\n      ops.push({\n        type: 'replace',\n        index: j,\n        value: frame\n      });\n      revops.unshift({\n        type: 'replace',\n        index: j,\n        value: _frames[j]\n      });\n    } else {\n      // Otherwise insert it at the end of the list:\n      idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n      ops.push({\n        type: 'insert',\n        index: idx,\n        value: frame\n      });\n      revops.unshift({\n        type: 'delete',\n        index: idx\n      });\n      frameCount++;\n    }\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\n\n\nfunction deleteFrames(gd, frameList) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  var i, idx;\n  var _frames = gd._transitionData._frames;\n  var ops = [];\n  var revops = [];\n\n  if (!frameList) {\n    frameList = [];\n\n    for (i = 0; i < _frames.length; i++) {\n      frameList.push(i);\n    }\n  }\n\n  frameList = frameList.slice();\n  frameList.sort();\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    idx = frameList[i];\n    ops.push({\n      type: 'delete',\n      index: idx\n    });\n    revops.unshift({\n      type: 'insert',\n      index: idx,\n      value: _frames[idx]\n    });\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\n\n\nfunction purge(gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n  var fullData = gd._fullData || []; // remove gl contexts\n\n  Plots.cleanPlot([], {}, fullData, fullLayout); // purge properties\n\n  Plots.purge(gd); // purge event emitter methods\n\n  Events.purge(gd); // remove plot container\n\n  if (fullLayout._container) fullLayout._container.remove(); // in contrast to Plotly.Plots.purge which does NOT clear _context!\n\n  delete gd._context;\n  return gd;\n} // -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\n\n\nfunction makePlotFramework(gd) {\n  var gd3 = d3.select(gd);\n  var fullLayout = gd._fullLayout; // Plot container\n\n  fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n\n  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true); // Make the svg container\n\n\n  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n\n  fullLayout._paperdiv.enter().append('div').classed('svg-container', true).style('position', 'relative'); // Make the graph containers\n  // start fresh each time we get here, so we know the order comes out\n  // right, rather than enter/exit which can muck up the order\n  // TODO: sort out all the ordering so we don't have to\n  // explicitly delete anything\n  // FIXME: parcoords reuses this object, not the best pattern\n\n\n  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);\n\n  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);\n\n  fullLayout._paperdiv.selectAll('.main-svg').remove();\n\n  fullLayout._paperdiv.select('.modebar-container').remove();\n\n  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);\n  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n  fullLayout._hoverpaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n\n  if (!fullLayout._uid) {\n    var otherUids = {};\n    d3.selectAll('defs').each(function () {\n      if (this.id) otherUids[this.id.split('-')[1]] = 1;\n    });\n    fullLayout._uid = Lib.randstr(otherUids);\n  }\n\n  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);\n\n  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);\n  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);\n  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);\n  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);\n  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);\n  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true); // lower shape/image layer - note that this is behind\n  // all subplots data/grids but above the backgrounds\n  // except inset subplots, whose backgrounds are drawn\n  // inside their own group so that they appear above\n  // the data for the main subplot\n  // lower shapes and images which are fully referenced to\n  // a subplot still get drawn within the subplot's group\n  // so they will work correctly on insets\n\n  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);\n\n  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);\n  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true); // single cartesian layer for the whole plot\n\n  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true); // single polar layer for the whole plot\n\n  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true); // single ternary layer for the whole plot\n\n  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true); // single geo layer for the whole plot\n\n  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true); // single funnelarea layer for the whole plot\n\n  fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true); // single pie layer for the whole plot\n\n  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true); // single treemap layer for the whole plot\n\n  fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true); // single sunburst layer for the whole plot\n\n  fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true); // single indicator layer for the whole plot\n\n  fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true); // fill in image server scrape-svg\n\n  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true); // lastly upper shapes, info (legend, annotations) and hover layers go on top\n  // these are in a different svg element normally, but get collapsed into a single\n  // svg when exporting (after inserting 3D)\n  // upper shapes/images are only those drawn above the whole plot, including subplots\n\n  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);\n\n  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);\n  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);\n  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n  fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true); // Make the modebar container\n\n  fullLayout._modebardiv.classed('modebar-container', true).style('position', 'absolute').style('top', '0px').style('right', '0px');\n\n  gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\nexports.newPlot = newPlot;\nexports.plot = plot;\nexports.purge = purge;\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\nexports.setPlotConfig = setPlotConfig;\nexports.update = update;\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;","map":null,"metadata":{},"sourceType":"script"}