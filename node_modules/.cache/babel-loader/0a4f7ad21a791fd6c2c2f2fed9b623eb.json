{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar INTERPTHRESHOLD = 1e-2;\nvar NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nfunction correctionOvershoot(maxFractionalChange) {\n  // start with less overshoot, until we know it's converging,\n  // then ramp up the overshoot for faster convergence\n  return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n/*\n * interp2d: Fill in missing data from a 2D array using an iterative\n *   poisson equation solver with zero-derivative BC at edges.\n *   Amazingly, this just amounts to repeatedly averaging all the existing\n *   nearest neighbors, at least if we don't take x/y scaling into account,\n *   which is the right approach here where x and y may not even have the\n *   same units.\n *\n * @param {array of arrays} z\n *      The 2D array to fill in. Will be mutated here. Assumed to already be\n *      cleaned, so all entries are numbers except gaps, which are `undefined`.\n * @param {array of arrays} emptyPoints\n *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number\n *      of neighbors that are *not* missing. Assumed to be sorted from most to\n *      least neighbors, as produced by heatmap/find_empties.\n */\n\n\nmodule.exports = function interp2d(z, emptyPoints) {\n  var maxFractionalChange = 1;\n  var i; // one pass to fill in a starting value for all the empties\n\n  iterateInterp2d(z, emptyPoints); // we're don't need to iterate lone empties - remove them\n\n  for (i = 0; i < emptyPoints.length; i++) {\n    if (emptyPoints[i][2] < 4) break;\n  } // but don't remove these points from the original array,\n  // we'll use them for masking, so make a copy.\n\n\n  emptyPoints = emptyPoints.slice(i);\n\n  for (i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n    maxFractionalChange = iterateInterp2d(z, emptyPoints, correctionOvershoot(maxFractionalChange));\n  }\n\n  if (maxFractionalChange > INTERPTHRESHOLD) {\n    Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n  }\n\n  return z;\n};\n\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n  var maxFractionalChange = 0;\n  var thisPt;\n  var i;\n  var j;\n  var p;\n  var q;\n  var neighborShift;\n  var neighborRow;\n  var neighborVal;\n  var neighborCount;\n  var neighborSum;\n  var initialVal;\n  var minNeighbor;\n  var maxNeighbor;\n\n  for (p = 0; p < emptyPoints.length; p++) {\n    thisPt = emptyPoints[p];\n    i = thisPt[0];\n    j = thisPt[1];\n    initialVal = z[i][j];\n    neighborSum = 0;\n    neighborCount = 0;\n\n    for (q = 0; q < 4; q++) {\n      neighborShift = NEIGHBORSHIFTS[q];\n      neighborRow = z[i + neighborShift[0]];\n      if (!neighborRow) continue;\n      neighborVal = neighborRow[j + neighborShift[1]];\n\n      if (neighborVal !== undefined) {\n        if (neighborSum === 0) {\n          minNeighbor = maxNeighbor = neighborVal;\n        } else {\n          minNeighbor = Math.min(minNeighbor, neighborVal);\n          maxNeighbor = Math.max(maxNeighbor, neighborVal);\n        }\n\n        neighborCount++;\n        neighborSum += neighborVal;\n      }\n    }\n\n    if (neighborCount === 0) {\n      throw 'iterateInterp2d order is wrong: no defined neighbors';\n    } // this is the laplace equation interpolation:\n    // each point is just the average of its neighbors\n    // note that this ignores differential x/y scaling\n    // which I think is the right approach, since we\n    // don't know what that scaling means\n\n\n    z[i][j] = neighborSum / neighborCount;\n\n    if (initialVal === undefined) {\n      if (neighborCount < 4) maxFractionalChange = 1;\n    } else {\n      // we can make large empty regions converge faster\n      // if we overshoot the change vs the previous value\n      z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n\n      if (maxNeighbor > minNeighbor) {\n        maxFractionalChange = Math.max(maxFractionalChange, Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n      }\n    }\n  }\n\n  return maxFractionalChange;\n}","map":null,"metadata":{},"sourceType":"script"}