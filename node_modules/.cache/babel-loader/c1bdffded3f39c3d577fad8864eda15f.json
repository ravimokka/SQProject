{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\n\nvar Events = require('../../lib/events');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar overrideCursor = require('../../lib/override_cursor');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar dragElement = require('../dragelement');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants'); // hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\n\n\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180; // expansion of projected height\n\nvar YFACTOR = 1 / Math.sin(YA_RADIANS); // to make the appropriate post-rotation x offset,\n// you need both x and y offsets\n\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS); // size and display constants for hover text\n\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD; // fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\n\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n  gd = Lib.getGraphDiv(gd);\n  Lib.throttle(gd._fullLayout._uid + constants.HOVERID, constants.HOVERMINTIME, function () {\n    _hover(gd, evt, subplot, noHoverEvent);\n  });\n};\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\n\n\nexports.loneHover = function loneHover(hoverItems, opts) {\n  var multiHover = true;\n\n  if (!Array.isArray(hoverItems)) {\n    multiHover = false;\n    hoverItems = [hoverItems];\n  }\n\n  var pointsData = hoverItems.map(function (hoverItem) {\n    return {\n      color: hoverItem.color || Color.defaultLine,\n      x0: hoverItem.x0 || hoverItem.x || 0,\n      x1: hoverItem.x1 || hoverItem.x || 0,\n      y0: hoverItem.y0 || hoverItem.y || 0,\n      y1: hoverItem.y1 || hoverItem.y || 0,\n      xLabel: hoverItem.xLabel,\n      yLabel: hoverItem.yLabel,\n      zLabel: hoverItem.zLabel,\n      text: hoverItem.text,\n      name: hoverItem.name,\n      idealAlign: hoverItem.idealAlign,\n      // optional extra bits of styling\n      borderColor: hoverItem.borderColor,\n      fontFamily: hoverItem.fontFamily,\n      fontSize: hoverItem.fontSize,\n      fontColor: hoverItem.fontColor,\n      nameLength: hoverItem.nameLength,\n      textAlign: hoverItem.textAlign,\n      // filler to make createHoverText happy\n      trace: hoverItem.trace || {\n        index: 0,\n        hoverinfo: ''\n      },\n      xa: {\n        _offset: 0\n      },\n      ya: {\n        _offset: 0\n      },\n      index: 0,\n      hovertemplate: hoverItem.hovertemplate || false,\n      eventData: hoverItem.eventData || false,\n      hovertemplateLabels: hoverItem.hovertemplateLabels || false\n    };\n  });\n  var container3 = d3.select(opts.container);\n  var outerContainer3 = opts.outerContainer ? d3.select(opts.outerContainer) : container3;\n  var fullOpts = {\n    hovermode: 'closest',\n    rotateLabels: false,\n    bgColor: opts.bgColor || Color.background,\n    container: container3,\n    outerContainer: outerContainer3\n  };\n  var hoverLabel = createHoverText(pointsData, fullOpts, opts.gd); // Fix vertical overlap\n\n  var tooltipSpacing = 5;\n  var lastBottomY = 0;\n  var anchor = 0;\n  hoverLabel.sort(function (a, b) {\n    return a.y0 - b.y0;\n  }).each(function (d, i) {\n    var topY = d.y0 - d.by / 2;\n\n    if (topY - tooltipSpacing < lastBottomY) {\n      d.offset = lastBottomY - topY + tooltipSpacing;\n    } else {\n      d.offset = 0;\n    }\n\n    lastBottomY = topY + d.by + d.offset;\n    if (i === opts.anchorIndex || 0) anchor = d.offset;\n  }).each(function (d) {\n    d.offset -= anchor;\n  });\n  alignHoverText(hoverLabel, fullOpts.rotateLabels);\n  return multiHover ? hoverLabel : hoverLabel.node();\n}; // The actual implementation is here:\n\n\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n  if (!subplot) subplot = 'xy'; // if the user passed in an array of subplots,\n  // use those instead of finding overlayed plots\n\n  var subplots = Array.isArray(subplot) ? subplot : [subplot];\n  var fullLayout = gd._fullLayout;\n  var plots = fullLayout._plots || [];\n  var plotinfo = plots[subplot];\n\n  var hasCartesian = fullLayout._has('cartesian'); // list of all overlaid subplots to look at\n\n\n  if (plotinfo) {\n    var overlayedSubplots = plotinfo.overlays.map(function (pi) {\n      return pi.id;\n    });\n    subplots = subplots.concat(overlayedSubplots);\n  }\n\n  var len = subplots.length;\n  var xaArray = new Array(len);\n  var yaArray = new Array(len);\n  var supportsCompare = false;\n\n  for (var i = 0; i < len; i++) {\n    var spId = subplots[i];\n\n    if (plots[spId]) {\n      // 'cartesian' case\n      supportsCompare = true;\n      xaArray[i] = plots[spId].xaxis;\n      yaArray[i] = plots[spId].yaxis;\n    } else if (fullLayout[spId] && fullLayout[spId]._subplot) {\n      // other subplot types\n      var _subplot = fullLayout[spId]._subplot;\n      xaArray[i] = _subplot.xaxis;\n      yaArray[i] = _subplot.yaxis;\n    } else {\n      Lib.warn('Unrecognized subplot: ' + spId);\n      return;\n    }\n  }\n\n  var hovermode = evt.hovermode || fullLayout.hovermode;\n  if (hovermode && !supportsCompare) hovermode = 'closest';\n\n  if (['x', 'y', 'closest'].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector('.zoombox') || gd._dragging) {\n    return dragElement.unhoverRaw(gd, evt);\n  }\n\n  var hoverdistance = fullLayout.hoverdistance === -1 ? Infinity : fullLayout.hoverdistance;\n  var spikedistance = fullLayout.spikedistance === -1 ? Infinity : fullLayout.spikedistance; // hoverData: the set of candidate points we've found to highlight\n\n  var hoverData = []; // searchData: the data to search in. Mostly this is just a copy of\n  // gd.calcdata, filtered to the subplot and overlays we're on\n  // but if a point array is supplied it will be a mapping\n  // of indicated curves\n\n  var searchData = []; // [x|y]valArray: the axis values of the hover event\n  // mapped onto each of the currently selected overlaid subplots\n\n  var xvalArray, yvalArray;\n  var itemnum, curvenum, cd, trace, subplotId, subploti, mode, xval, yval, pointData, closedataPreviousLength; // spikePoints: the set of candidate points we've found to draw spikes to\n\n  var spikePoints = {\n    hLinePoint: null,\n    vLinePoint: null\n  }; // does subplot have one (or more) horizontal traces?\n  // This is used to determine whether we rotate the labels or not\n\n  var hasOneHorizontalTrace = false; // Figure out what we're hovering on:\n  // mouse location or user-supplied data\n\n  if (Array.isArray(evt)) {\n    // user specified an array of points to highlight\n    hovermode = 'array';\n\n    for (itemnum = 0; itemnum < evt.length; itemnum++) {\n      cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n\n      if (cd) {\n        trace = cd[0].trace;\n\n        if (cd[0].trace.hoverinfo !== 'skip') {\n          searchData.push(cd);\n\n          if (trace.orientation === 'h') {\n            hasOneHorizontalTrace = true;\n          }\n        }\n      }\n    }\n  } else {\n    for (curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n      cd = gd.calcdata[curvenum];\n      trace = cd[0].trace;\n\n      if (trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n        searchData.push(cd);\n\n        if (trace.orientation === 'h') {\n          hasOneHorizontalTrace = true;\n        }\n      }\n    } // [x|y]px: the pixels (from top left) of the mouse location\n    // on the currently selected plot area\n    // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n\n\n    var hasUserCalledHover = !evt.target;\n    var xpx, ypx;\n\n    if (hasUserCalledHover) {\n      if ('xpx' in evt) xpx = evt.xpx;else xpx = xaArray[0]._length / 2;\n      if ('ypx' in evt) ypx = evt.ypx;else ypx = yaArray[0]._length / 2;\n    } else {\n      // fire the beforehover event and quit if it returns false\n      // note that we're only calling this on real mouse events, so\n      // manual calls to fx.hover will always run.\n      if (Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n        return;\n      }\n\n      var dbb = evt.target.getBoundingClientRect();\n      xpx = evt.clientX - dbb.left;\n      ypx = evt.clientY - dbb.top; // in case hover was called from mouseout into hovertext,\n      // it's possible you're not actually over the plot anymore\n\n      if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n        return dragElement.unhoverRaw(gd, evt);\n      }\n    }\n\n    evt.pointerX = xpx + xaArray[0]._offset;\n    evt.pointerY = ypx + yaArray[0]._offset;\n    if ('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);else xvalArray = helpers.p2c(xaArray, xpx);\n    if ('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);else yvalArray = helpers.p2c(yaArray, ypx);\n\n    if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n      Lib.warn('Fx.hover failed', evt, gd);\n      return dragElement.unhoverRaw(gd, evt);\n    }\n  } // the pixel distance to beat as a matching point\n  // in 'x' or 'y' mode this resets for each trace\n\n\n  var distance = Infinity; // find the closest point in each trace\n  // this is minimum dx and/or dy, depending on mode\n  // and the pixel position for the label (labelXpx, labelYpx)\n\n  for (curvenum = 0; curvenum < searchData.length; curvenum++) {\n    cd = searchData[curvenum]; // filter out invisible or broken data\n\n    if (!cd || !cd[0] || !cd[0].trace) continue;\n    trace = cd[0].trace;\n    if (trace.visible !== true || trace._length === 0) continue; // Explicitly bail out for these two. I don't know how to otherwise prevent\n    // the rest of this function from running and failing\n\n    if (['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n    if (trace.type === 'splom') {\n      // splom traces do not generate overlay subplots,\n      // it is safe to assume here splom traces correspond to the 0th subplot\n      subploti = 0;\n      subplotId = subplots[subploti];\n    } else {\n      subplotId = helpers.getSubplot(trace);\n      subploti = subplots.indexOf(subplotId);\n    } // within one trace mode can sometimes be overridden\n\n\n    mode = hovermode; // container for new point, also used to pass info into module.hoverPoints\n\n    pointData = {\n      // trace properties\n      cd: cd,\n      trace: trace,\n      xa: xaArray[subploti],\n      ya: yaArray[subploti],\n      // max distances for hover and spikes - for points that want to show but do not\n      // want to override other points, set distance/spikeDistance equal to max*Distance\n      // and it will not get filtered out but it will be guaranteed to have a greater\n      // distance than any point that calculated a real distance.\n      maxHoverDistance: hoverdistance,\n      maxSpikeDistance: spikedistance,\n      // point properties - override all of these\n      index: false,\n      // point index in trace - only used by plotly.js hoverdata consumers\n      distance: Math.min(distance, hoverdistance),\n      // pixel distance or pseudo-distance\n      // distance/pseudo-distance for spikes. This distance should always be calculated\n      // as if in \"closest\" mode, and should only be set if this point should\n      // generate a spike.\n      spikeDistance: Infinity,\n      // in some cases the spikes have different positioning from the hover label\n      // they don't need x0/x1, just one position\n      xSpike: undefined,\n      ySpike: undefined,\n      // where and how to display the hover label\n      color: Color.defaultLine,\n      // trace color\n      name: trace.name,\n      x0: undefined,\n      x1: undefined,\n      y0: undefined,\n      y1: undefined,\n      xLabelVal: undefined,\n      yLabelVal: undefined,\n      zLabelVal: undefined,\n      text: undefined\n    }; // add ref to subplot object (non-cartesian case)\n\n    if (fullLayout[subplotId]) {\n      pointData.subplot = fullLayout[subplotId]._subplot;\n    } // add ref to splom scene\n\n\n    if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n      pointData.scene = fullLayout._splomScenes[trace.uid];\n    }\n\n    closedataPreviousLength = hoverData.length; // for a highlighting array, figure out what\n    // we're searching for with this element\n\n    if (mode === 'array') {\n      var selection = evt[curvenum];\n\n      if ('pointNumber' in selection) {\n        pointData.index = selection.pointNumber;\n        mode = 'closest';\n      } else {\n        mode = '';\n\n        if ('xval' in selection) {\n          xval = selection.xval;\n          mode = 'x';\n        }\n\n        if ('yval' in selection) {\n          yval = selection.yval;\n          mode = mode ? 'closest' : 'y';\n        }\n      }\n    } else {\n      xval = xvalArray[subploti];\n      yval = yvalArray[subploti];\n    } // Now if there is range to look in, find the points to hover.\n\n\n    if (hoverdistance !== 0) {\n      if (trace._module && trace._module.hoverPoints) {\n        var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode, fullLayout._hoverlayer);\n\n        if (newPoints) {\n          var newPoint;\n\n          for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n            newPoint = newPoints[newPointNum];\n\n            if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n              hoverData.push(cleanPoint(newPoint, hovermode));\n            }\n          }\n        }\n      } else {\n        Lib.log('Unrecognized trace type in hover:', trace);\n      }\n    } // in closest mode, remove any existing (farther) points\n    // and don't look any farther than this latest point (or points, some\n    // traces like box & violin make multiple hover labels at once)\n\n\n    if (hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n      hoverData.splice(0, closedataPreviousLength);\n      distance = hoverData[0].distance;\n    } // Now if there is range to look in, find the points to draw the spikelines\n    // Do it only if there is no hoverData\n\n\n    if (hasCartesian && spikedistance !== 0) {\n      if (hoverData.length === 0) {\n        pointData.distance = spikedistance;\n        pointData.index = false;\n\n        var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', fullLayout._hoverlayer);\n\n        if (closestPoints) {\n          closestPoints = closestPoints.filter(function (point) {\n            // some hover points, like scatter fills, do not allow spikes,\n            // so will generate a hover point but without a valid spikeDistance\n            return point.spikeDistance <= spikedistance;\n          });\n        }\n\n        if (closestPoints && closestPoints.length) {\n          var tmpPoint;\n          var closestVPoints = closestPoints.filter(function (point) {\n            return point.xa.showspikes;\n          });\n\n          if (closestVPoints.length) {\n            var closestVPt = closestVPoints[0];\n\n            if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n              tmpPoint = fillSpikePoint(closestVPt);\n\n              if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                spikePoints.vLinePoint = tmpPoint;\n              }\n            }\n          }\n\n          var closestHPoints = closestPoints.filter(function (point) {\n            return point.ya.showspikes;\n          });\n\n          if (closestHPoints.length) {\n            var closestHPt = closestHPoints[0];\n\n            if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n              tmpPoint = fillSpikePoint(closestHPt);\n\n              if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                spikePoints.hLinePoint = tmpPoint;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function selectClosestPoint(pointsData, spikedistance) {\n    var resultPoint = null;\n    var minDistance = Infinity;\n    var thisSpikeDistance;\n\n    for (var i = 0; i < pointsData.length; i++) {\n      thisSpikeDistance = pointsData[i].spikeDistance;\n\n      if (thisSpikeDistance < minDistance && thisSpikeDistance <= spikedistance) {\n        resultPoint = pointsData[i];\n        minDistance = thisSpikeDistance;\n      }\n    }\n\n    return resultPoint;\n  }\n\n  function fillSpikePoint(point) {\n    if (!point) return null;\n    return {\n      xa: point.xa,\n      ya: point.ya,\n      x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n      y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n      distance: point.distance,\n      spikeDistance: point.spikeDistance,\n      curveNumber: point.trace.index,\n      color: point.color,\n      pointNumber: point.index\n    };\n  }\n\n  var spikelineOpts = {\n    fullLayout: fullLayout,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paperdiv,\n    event: evt\n  };\n  var oldspikepoints = gd._spikepoints;\n  var newspikepoints = {\n    vLinePoint: spikePoints.vLinePoint,\n    hLinePoint: spikePoints.hLinePoint\n  };\n  gd._spikepoints = newspikepoints; // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n\n  if (hasCartesian && spikedistance !== 0) {\n    if (hoverData.length !== 0) {\n      var tmpHPointData = hoverData.filter(function (point) {\n        return point.ya.showspikes;\n      });\n      var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance);\n      spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n      var tmpVPointData = hoverData.filter(function (point) {\n        return point.xa.showspikes;\n      });\n      var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance);\n      spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n    }\n  } // if hoverData is empty check for the spikes to draw and quit if there are none\n\n\n  if (hoverData.length === 0) {\n    var result = dragElement.unhoverRaw(gd, evt);\n\n    if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {\n      if (spikesChanged(oldspikepoints)) {\n        createSpikelines(gd, spikePoints, spikelineOpts);\n      }\n    }\n\n    return result;\n  }\n\n  if (hasCartesian) {\n    if (spikesChanged(oldspikepoints)) {\n      createSpikelines(gd, spikePoints, spikelineOpts);\n    }\n  }\n\n  hoverData.sort(function (d1, d2) {\n    return d1.distance - d2.distance;\n  }); // lastly, emit custom hover/unhover events\n\n  var oldhoverdata = gd._hoverdata;\n  var newhoverdata = []; // pull out just the data that's useful to\n  // other people and send it to the event\n\n  for (itemnum = 0; itemnum < hoverData.length; itemnum++) {\n    var pt = hoverData[itemnum];\n    var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n    if (pt.hovertemplate !== false) {\n      var ht = false;\n\n      if (pt.cd[pt.index] && pt.cd[pt.index].ht) {\n        ht = pt.cd[pt.index].ht;\n      }\n\n      pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n    }\n\n    pt.eventData = [eventData];\n    newhoverdata.push(eventData);\n  }\n\n  gd._hoverdata = newhoverdata;\n  var rotateLabels = hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1) || hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1;\n  var bgColor = Color.combine(fullLayout.plot_bgcolor || Color.background, fullLayout.paper_bgcolor);\n  var labelOpts = {\n    hovermode: hovermode,\n    rotateLabels: rotateLabels,\n    bgColor: bgColor,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paperdiv,\n    commonLabelOpts: fullLayout.hoverlabel,\n    hoverdistance: fullLayout.hoverdistance\n  };\n  var hoverLabels = createHoverText(hoverData, labelOpts, gd);\n  hoverAvoidOverlaps(hoverLabels, rotateLabels ? 'xa' : 'ya', fullLayout);\n  alignHoverText(hoverLabels, rotateLabels); // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n  // we should improve the \"fx\" API so other plots can use it without these hack.\n\n  if (evt.target && evt.target.tagName) {\n    var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n    overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n  } // don't emit events if called manually\n\n\n  if (!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n  if (oldhoverdata) {\n    gd.emit('plotly_unhover', {\n      event: evt,\n      points: oldhoverdata\n    });\n  }\n\n  gd.emit('plotly_hover', {\n    event: evt,\n    points: gd._hoverdata,\n    xaxes: xaArray,\n    yaxes: yaArray,\n    xvals: xvalArray,\n    yvals: yvalArray\n  });\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts, gd) {\n  var fullLayout = gd._fullLayout;\n  var hovermode = opts.hovermode;\n  var rotateLabels = opts.rotateLabels;\n  var bgColor = opts.bgColor;\n  var container = opts.container;\n  var outerContainer = opts.outerContainer;\n  var commonLabelOpts = opts.commonLabelOpts || {}; // opts.fontFamily/Size are used for the common label\n  // and as defaults for each hover label, though the individual labels\n  // can override this.\n\n  var fontFamily = opts.fontFamily || constants.HOVERFONT;\n  var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n  var c0 = hoverData[0];\n  var xa = c0.xa;\n  var ya = c0.ya;\n  var commonAttr = hovermode === 'y' ? 'yLabel' : 'xLabel';\n  var t0 = c0[commonAttr];\n  var t00 = (String(t0) || '').split(' ')[0];\n  var outerContainerBB = outerContainer.node().getBoundingClientRect();\n  var outerTop = outerContainerBB.top;\n  var outerWidth = outerContainerBB.width;\n  var outerHeight = outerContainerBB.height; // show the common label, if any, on the axis\n  // never show a common label in array mode,\n  // even if sometimes there could be one\n\n  var showCommonLabel = t0 !== undefined && c0.distance <= opts.hoverdistance && (hovermode === 'x' || hovermode === 'y'); // all hover traces hoverinfo must contain the hovermode\n  // to have common labels\n\n  if (showCommonLabel) {\n    var allHaveZ = true;\n    var i, traceHoverinfo;\n\n    for (i = 0; i < hoverData.length; i++) {\n      if (allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n      traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n\n      if (traceHoverinfo) {\n        var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n\n        if (parts.indexOf('all') === -1 && parts.indexOf(hovermode) === -1) {\n          showCommonLabel = false;\n          break;\n        }\n      }\n    } // xyz labels put all info in their main label, so have no need of a common label\n\n\n    if (allHaveZ) showCommonLabel = false;\n  }\n\n  var commonLabel = container.selectAll('g.axistext').data(showCommonLabel ? [0] : []);\n  commonLabel.enter().append('g').classed('axistext', true);\n  commonLabel.exit().remove();\n  commonLabel.each(function () {\n    var label = d3.select(this);\n    var lpath = Lib.ensureSingle(label, 'path', '', function (s) {\n      s.style({\n        'stroke-width': '1px'\n      });\n    });\n    var ltext = Lib.ensureSingle(label, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n    var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n    var contrastColor = Color.contrast(commonBgColor);\n    var commonLabelFont = {\n      family: commonLabelOpts.font.family || fontFamily,\n      size: commonLabelOpts.font.size || fontSize,\n      color: commonLabelOpts.font.color || contrastColor\n    };\n    lpath.style({\n      fill: commonBgColor,\n      stroke: commonStroke\n    });\n    ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    label.attr('transform', '');\n    var tbb = ltext.node().getBoundingClientRect();\n    var lx, ly;\n\n    if (hovermode === 'x') {\n      var topsign = xa.side === 'top' ? '-' : '';\n      ltext.attr('text-anchor', 'middle').call(svgTextUtils.positionText, 0, xa.side === 'top' ? outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD);\n      lx = xa._offset + (c0.x0 + c0.x1) / 2;\n      ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n      var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n\n      if (lx < halfWidth) {\n        lx = halfWidth;\n        lpath.attr('d', 'M-' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L-' + (halfWidth - HOVERARROWSIZE * 2) + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'Z');\n      } else if (lx > fullLayout.width - halfWidth) {\n        lx = fullLayout.width - halfWidth;\n        lpath.attr('d', 'M' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L' + halfWidth + ',' + topsign + HOVERARROWSIZE + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'H' + (halfWidth - HOVERARROWSIZE * 2) + 'Z');\n      } else {\n        lpath.attr('d', 'M0,0' + 'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + (HOVERTEXTPAD + tbb.width / 2) + 'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');\n      }\n    } else {\n      var anchor;\n      var sgn;\n      var leftsign;\n\n      if (ya.side === 'right') {\n        anchor = 'start';\n        sgn = 1;\n        leftsign = '';\n        lx = xa._offset + xa._length;\n      } else {\n        anchor = 'end';\n        sgn = -1;\n        leftsign = '-';\n        lx = xa._offset;\n      }\n\n      ly = ya._offset + (c0.y0 + c0.y1) / 2;\n      ltext.attr('text-anchor', anchor);\n      lpath.attr('d', 'M0,0' + 'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE + 'V' + (HOVERTEXTPAD + tbb.height / 2) + 'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) + 'V-' + (HOVERTEXTPAD + tbb.height / 2) + 'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n      var halfHeight = tbb.height / 2;\n      var lty = outerTop - tbb.top - halfHeight;\n      var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n      var clipPath;\n\n      if (lx < tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {\n        clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight + 'h-' + (tbb.width - HOVERTEXTPAD) + 'V' + halfHeight + 'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n        var ltx = tbb.width - lx + HOVERTEXTPAD;\n        svgTextUtils.positionText(ltext, ltx, lty); // shift each line (except the longest) so that start-of-line\n        // is always visible\n\n        if (anchor === 'end') {\n          ltext.selectAll('tspan').each(function () {\n            var s = d3.select(this);\n            var dummy = Drawing.tester.append('text').text(s.text()).call(Drawing.font, commonLabelFont);\n            var dummyBB = dummy.node().getBoundingClientRect();\n\n            if (dummyBB.width < tbb.width) {\n              s.attr('x', ltx - dummyBB.width);\n            }\n\n            dummy.remove();\n          });\n        }\n      } else {\n        svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n        clipPath = null;\n      }\n\n      var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n\n      textClip.enter().append('clipPath').attr('id', clipId).append('path');\n      textClip.exit().remove();\n      textClip.select('path').attr('d', clipPath);\n      Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n    }\n\n    label.attr('transform', 'translate(' + lx + ',' + ly + ')'); // remove the \"close but not quite\" points\n    // because of error bars, only take up to a space\n\n    hoverData = hoverData.filter(function (d) {\n      return d.zLabelVal !== undefined || (d[commonAttr] || '').split(' ')[0] === t00;\n    });\n  }); // show all the individual labels\n  // first create the objects\n\n  var hoverLabels = container.selectAll('g.hovertext').data(hoverData, function (d) {\n    // N.B. when multiple items have the same result key-function value,\n    // only the first of those items in hoverData gets rendered\n    return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa, d.ya || ''].join(',');\n  });\n  hoverLabels.enter().append('g').classed('hovertext', true).each(function () {\n    var g = d3.select(this); // trace name label (rect and text.name)\n\n    g.append('rect').call(Color.fill, Color.addOpacity(bgColor, 0.8));\n    g.append('text').classed('name', true); // trace data label (path and text.nums)\n\n    g.append('path').style('stroke-width', '1px');\n    g.append('text').classed('nums', true).call(Drawing.font, fontFamily, fontSize);\n  });\n  hoverLabels.exit().remove(); // then put the text in, position the pointer to the data,\n  // and figure out sizes\n\n  hoverLabels.each(function (d) {\n    var g = d3.select(this).attr('transform', '');\n    var name = '';\n    var text = ''; // combine possible non-opaque trace color with bgColor\n\n    var color0 = d.bgcolor || d.color; // color for 'nums' part of the label\n\n    var numsColor = Color.combine(Color.opacity(color0) ? color0 : Color.defaultLine, bgColor); // color for 'name' part of the label\n\n    var nameColor = Color.combine(Color.opacity(d.color) ? d.color : Color.defaultLine, bgColor); // find a contrasting color for border and text\n\n    var contrastColor = d.borderColor || Color.contrast(numsColor); // to get custom 'name' labels pass cleanPoint\n\n    if (d.nameOverride !== undefined) d.name = d.nameOverride;\n\n    if (d.name) {\n      if (d.trace._meta) {\n        d.name = Lib.templateString(d.name, d.trace._meta);\n      }\n\n      name = plainText(d.name, d.nameLength);\n    }\n\n    if (d.zLabel !== undefined) {\n      if (d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n      if (d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n\n      if (d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox') {\n        text += (text ? 'z: ' : '') + d.zLabel;\n      }\n    } else if (showCommonLabel && d[hovermode + 'Label'] === t0) {\n      text = d[(hovermode === 'x' ? 'y' : 'x') + 'Label'] || '';\n    } else if (d.xLabel === undefined) {\n      if (d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n        text = d.yLabel;\n      }\n    } else if (d.yLabel === undefined) text = d.xLabel;else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n    if ((d.text || d.text === 0) && !Array.isArray(d.text)) {\n      text += (text ? '<br>' : '') + d.text;\n    } // used by other modules (initially just ternary) that\n    // manage their own hoverinfo independent of cleanPoint\n    // the rest of this will still apply, so such modules\n    // can still put things in (x|y|z)Label, text, and name\n    // and hoverinfo will still determine their visibility\n\n\n    if (d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText; // if 'text' is empty at this point,\n    // and hovertemplate is not defined,\n    // put 'name' in main label and don't show secondary label\n\n    if (text === '' && !d.hovertemplate) {\n      // if 'name' is also empty, remove entire label\n      if (name === '') g.remove();\n      text = name;\n    } // hovertemplate\n\n\n    var d3locale = fullLayout._d3locale;\n    var hovertemplate = d.hovertemplate || false;\n    var hovertemplateLabels = d.hovertemplateLabels || d;\n    var eventData = d.eventData[0] || {};\n\n    if (hovertemplate) {\n      text = Lib.hovertemplateString(hovertemplate, hovertemplateLabels, d3locale, eventData, d.trace._meta);\n      text = text.replace(EXTRA_STRING_REGEX, function (match, extra) {\n        // assign name for secondary text label\n        name = plainText(extra, d.nameLength); // remove from main text label\n\n        return '';\n      });\n    } // main label\n\n\n    var tx = g.select('text.nums').call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, d.fontColor || contrastColor).text(text).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    var tx2 = g.select('text.name');\n    var tx2width = 0;\n    var tx2height = 0; // secondary label for non-empty 'name'\n\n    if (name && name !== text) {\n      tx2.call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, nameColor).text(name).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n      var t2bb = tx2.node().getBoundingClientRect();\n      tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n      tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n    } else {\n      tx2.remove();\n      g.select('rect').remove();\n    }\n\n    g.select('path').style({\n      fill: numsColor,\n      stroke: contrastColor\n    });\n    var tbb = tx.node().getBoundingClientRect();\n    var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n    var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n    var dx = Math.abs(d.x1 - d.x0);\n    var dy = Math.abs(d.y1 - d.y0);\n    var txTotalWidth = tbb.width + HOVERARROWSIZE + HOVERTEXTPAD + tx2width;\n    var anchorStartOK, anchorEndOK;\n    d.ty0 = outerTop - tbb.top;\n    d.bx = tbb.width + 2 * HOVERTEXTPAD;\n    d.by = Math.max(tbb.height + 2 * HOVERTEXTPAD, tx2height);\n    d.anchor = 'start';\n    d.txwidth = tbb.width;\n    d.tx2width = tx2width;\n    d.offset = 0;\n\n    if (rotateLabels) {\n      d.pos = htx;\n      anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n      anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n\n      if ((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n        hty -= dy / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        hty += dy / 2;\n        d.anchor = 'start';\n      } else d.anchor = 'middle';\n    } else {\n      d.pos = hty;\n      anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n      anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n\n      if ((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n        htx -= dx / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        htx += dx / 2;\n        d.anchor = 'start';\n      } else {\n        d.anchor = 'middle';\n        var txHalfWidth = txTotalWidth / 2;\n        var overflowR = htx + txHalfWidth - outerWidth;\n        var overflowL = htx - txHalfWidth;\n        if (overflowR > 0) htx -= overflowR;\n        if (overflowL < 0) htx += -overflowL;\n      }\n    }\n\n    tx.attr('text-anchor', d.anchor);\n    if (tx2width) tx2.attr('text-anchor', d.anchor);\n    g.attr('transform', 'translate(' + htx + ',' + hty + ')' + (rotateLabels ? 'rotate(' + YANGLE + ')' : ''));\n  });\n  return hoverLabels;\n} // Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\n\n\nfunction hoverAvoidOverlaps(hoverLabels, axKey, fullLayout) {\n  var nummoves = 0;\n  var axSign = 1;\n  var nLabels = hoverLabels.size(); // make groups of touching points\n\n  var pointgroups = new Array(nLabels);\n  var k = 0;\n  hoverLabels.each(function (d) {\n    var ax = d[axKey];\n    var axIsX = ax._id.charAt(0) === 'x';\n    var rng = ax.range;\n\n    if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {\n      axSign = -1;\n    }\n\n    pointgroups[k++] = [{\n      datum: d,\n      traceIndex: d.trace.index,\n      dp: 0,\n      pos: d.pos,\n      posref: d.posref,\n      size: d.by * (axIsX ? YFACTOR : 1) / 2,\n      pmin: 0,\n      pmax: axIsX ? fullLayout.width : fullLayout.height\n    }];\n  });\n  pointgroups.sort(function (a, b) {\n    return a[0].posref - b[0].posref || // for equal positions, sort trace indices increasing or decreasing\n    // depending on whether the axis is reversed or not... so stacked\n    // traces will generally keep their order even if one trace adds\n    // nothing to the stack.\n    axSign * (b[0].traceIndex - a[0].traceIndex);\n  });\n  var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n  function constrainGroup(grp) {\n    var minPt = grp[0];\n    var maxPt = grp[grp.length - 1]; // overlap with the top - positive vals are overlaps\n\n    topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size; // overlap with the bottom - positive vals are overlaps\n\n    bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax; // check for min overlap first, so that we always\n    // see the largest labels\n    // allow for .01px overlap, so we don't get an\n    // infinite loop from rounding errors\n\n    if (topOverlap > 0.01) {\n      for (j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n\n      donepositioning = false;\n    }\n\n    if (bottomOverlap < 0.01) return;\n\n    if (topOverlap < -0.01) {\n      // make sure we're not pushing back and forth\n      for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n\n      donepositioning = false;\n    }\n\n    if (!donepositioning) return; // no room to fix positioning, delete off-screen points\n    // first see how many points we need to delete\n\n    var deleteCount = 0;\n\n    for (i = 0; i < grp.length; i++) {\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n    } // start by deleting points whose data is off screen\n\n\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i]; // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n\n      if (pti.pos > minPt.pmax - 1) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n\n    for (i = 0; i < grp.length; i++) {\n      if (deleteCount <= 0) break;\n      pti = grp[i]; // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n\n      if (pti.pos < minPt.pmin + 1) {\n        pti.del = true;\n        deleteCount--; // shift the whole group minus into this new space\n\n        bottomOverlap = pti.size * 2;\n\n        for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n      }\n    } // then delete points that go off the bottom\n\n\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n  } // loop through groups, combining them if they overlap,\n  // until nothing moves\n\n\n  while (!donepositioning && nummoves <= nLabels) {\n    // to avoid infinite loops, don't move more times\n    // than there are traces\n    nummoves++; // assume nothing will move in this iteration,\n    // reverse this if it does\n\n    donepositioning = true;\n    i = 0;\n\n    while (i < pointgroups.length - 1) {\n      // the higher (g0) and lower (g1) point group\n      var g0 = pointgroups[i];\n      var g1 = pointgroups[i + 1]; // the lowest point in the higher group (p0)\n      // the highest point in the lower group (p1)\n\n      var p0 = g0[g0.length - 1];\n      var p1 = g1[0];\n      topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size; // Only group points that lie on the same axes\n\n      if (topOverlap > 0.01 && p0.pmin === p1.pmin && p0.pmax === p1.pmax) {\n        // push the new point(s) added to this group out of the way\n        for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap; // add them to the group\n\n\n        g0.push.apply(g0, g1);\n        pointgroups.splice(i + 1, 1); // adjust for minimum average movement\n\n        sumdp = 0;\n\n        for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n\n        bottomOverlap = sumdp / g0.length;\n\n        for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n\n        donepositioning = false;\n      } else i++;\n    } // check if we're going off the plot on either side and fix\n\n\n    pointgroups.forEach(constrainGroup);\n  } // now put these offsets into hoverData\n\n\n  for (i = pointgroups.length - 1; i >= 0; i--) {\n    var grp = pointgroups[i];\n\n    for (j = grp.length - 1; j >= 0; j--) {\n      var pt = grp[j];\n      var hoverPt = pt.datum;\n      hoverPt.offset = pt.dp;\n      hoverPt.del = pt.del;\n    }\n  }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels) {\n  // finally set the text positioning relative to the data and draw the\n  // box around it\n  hoverLabels.each(function (d) {\n    var g = d3.select(this);\n    if (d.del) return g.remove();\n    var tx = g.select('text.nums');\n    var anchor = d.anchor;\n    var horzSign = anchor === 'end' ? -1 : 1;\n    var alignShift = {\n      start: 1,\n      end: -1,\n      middle: 0\n    }[anchor];\n    var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n    var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n    var offsetX = 0;\n    var offsetY = d.offset;\n\n    if (anchor === 'middle') {\n      txx -= d.tx2width / 2;\n      tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n    }\n\n    if (rotateLabels) {\n      offsetY *= -YSHIFTY;\n      offsetX = d.offset * YSHIFTX;\n    }\n\n    g.select('path').attr('d', anchor === 'middle' ? // middle aligned: rect centered on data\n    'M-' + (d.bx / 2 + d.tx2width / 2) + ',' + (offsetY - d.by / 2) + 'h' + d.bx + 'v' + d.by + 'h-' + d.bx + 'Z' : // left or right aligned: side rect with arrow to data\n    'M0,0L' + (horzSign * HOVERARROWSIZE + offsetX) + ',' + (HOVERARROWSIZE + offsetY) + 'v' + (d.by / 2 - HOVERARROWSIZE) + 'h' + horzSign * d.bx + 'v-' + d.by + 'H' + (horzSign * HOVERARROWSIZE + offsetX) + 'V' + (offsetY - HOVERARROWSIZE) + 'Z');\n    var posX = txx + offsetX;\n    var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n    var textAlign = d.textAlign || 'auto';\n\n    if (textAlign !== 'auto') {\n      if (textAlign === 'left' && anchor !== 'start') {\n        tx.attr('text-anchor', 'start');\n        posX = anchor === 'middle' ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;\n      } else if (textAlign === 'right' && anchor !== 'end') {\n        tx.attr('text-anchor', 'end');\n        posX = anchor === 'middle' ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;\n      }\n    }\n\n    tx.call(svgTextUtils.positionText, posX, posY);\n\n    if (d.tx2width) {\n      g.select('text.name').call(svgTextUtils.positionText, tx2x + alignShift * HOVERTEXTPAD + offsetX, offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n      g.select('rect').call(Drawing.setRect, tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX, offsetY - d.by / 2 - 1, d.tx2width, d.by + 2);\n    }\n  });\n}\n\nfunction cleanPoint(d, hovermode) {\n  var index = d.index;\n  var trace = d.trace || {};\n  var cd0 = d.cd[0];\n  var cd = d.cd[index] || {};\n\n  function pass(v) {\n    return v || isNumeric(v) && v === 0;\n  }\n\n  var getVal = Array.isArray(index) ? function (calcKey, traceKey) {\n    var v = Lib.castOption(cd0, index, calcKey);\n    return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n  } : function (calcKey, traceKey) {\n    return Lib.extractOption(cd, trace, calcKey, traceKey);\n  };\n\n  function fill(key, calcKey, traceKey) {\n    var val = getVal(calcKey, traceKey);\n    if (pass(val)) d[key] = val;\n  }\n\n  fill('hoverinfo', 'hi', 'hoverinfo');\n  fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n  fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n  fill('fontFamily', 'htf', 'hoverlabel.font.family');\n  fill('fontSize', 'hts', 'hoverlabel.font.size');\n  fill('fontColor', 'htc', 'hoverlabel.font.color');\n  fill('nameLength', 'hnl', 'hoverlabel.namelength');\n  fill('textAlign', 'hta', 'hoverlabel.align');\n  d.posref = hovermode === 'y' || hovermode === 'closest' && trace.orientation === 'h' ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2; // then constrain all the positions to be on the plot\n\n  d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n  d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n  d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n  d.y1 = Lib.constrain(d.y1, 0, d.ya._length); // and convert the x and y label values into formatted text\n\n  if (d.xLabelVal !== undefined) {\n    d.xLabel = 'xLabel' in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal);\n    d.xVal = d.xa.c2d(d.xLabelVal);\n  }\n\n  if (d.yLabelVal !== undefined) {\n    d.yLabel = 'yLabel' in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal);\n    d.yVal = d.ya.c2d(d.yLabelVal);\n  } // Traces like heatmaps generate the zLabel in their hoverPoints function\n\n\n  if (d.zLabelVal !== undefined && d.zLabel === undefined) {\n    d.zLabel = String(d.zLabelVal);\n  } // for box means and error bars, add the range to the label\n\n\n  if (!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n    var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n\n    if (d.xerrneg !== undefined) {\n      d.xLabel += ' +' + xeText + ' / -' + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n    } else d.xLabel += ' ± ' + xeText; // small distance penalty for error bars, so that if there are\n    // traces with errors and some without, the error bar label will\n    // hoist up to the point\n\n\n    if (hovermode === 'x') d.distance += 1;\n  }\n\n  if (!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n    var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n\n    if (d.yerrneg !== undefined) {\n      d.yLabel += ' +' + yeText + ' / -' + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n    } else d.yLabel += ' ± ' + yeText;\n\n    if (hovermode === 'y') d.distance += 1;\n  }\n\n  var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n  if (infomode && infomode !== 'all') {\n    infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n    if (infomode.indexOf('x') === -1) d.xLabel = undefined;\n    if (infomode.indexOf('y') === -1) d.yLabel = undefined;\n    if (infomode.indexOf('z') === -1) d.zLabel = undefined;\n    if (infomode.indexOf('text') === -1) d.text = undefined;\n    if (infomode.indexOf('name') === -1) d.name = undefined;\n  }\n\n  return d;\n}\n\nfunction createSpikelines(gd, closestPoints, opts) {\n  var container = opts.container;\n  var fullLayout = opts.fullLayout;\n  var gs = fullLayout._size;\n  var evt = opts.event;\n  var showY = !!closestPoints.hLinePoint;\n  var showX = !!closestPoints.vLinePoint;\n  var xa, ya; // Remove old spikeline items\n\n  container.selectAll('.spikeline').remove();\n  if (!(showX || showY)) return;\n  var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor); // Horizontal line (to y-axis)\n\n  if (showY) {\n    var hLinePoint = closestPoints.hLinePoint;\n    var hLinePointX, hLinePointY;\n    xa = hLinePoint && hLinePoint.xa;\n    ya = hLinePoint && hLinePoint.ya;\n    var ySnap = ya.spikesnap;\n\n    if (ySnap === 'cursor') {\n      hLinePointX = evt.pointerX;\n      hLinePointY = evt.pointerY;\n    } else {\n      hLinePointX = xa._offset + hLinePoint.x;\n      hLinePointY = ya._offset + hLinePoint.y;\n    }\n\n    var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;\n    var yMode = ya.spikemode;\n    var yThickness = ya.spikethickness;\n    var yColor = ya.spikecolor || dfltHLineColor;\n    var xEdge = Axes.getPxPosition(gd, ya);\n    var xBase, xEndSpike;\n\n    if (yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n      if (yMode.indexOf('toaxis') !== -1) {\n        xBase = xEdge;\n        xEndSpike = hLinePointX;\n      }\n\n      if (yMode.indexOf('across') !== -1) {\n        var xAcross0 = ya._counterDomainMin;\n        var xAcross1 = ya._counterDomainMax;\n\n        if (ya.anchor === 'free') {\n          xAcross0 = Math.min(xAcross0, ya.position);\n          xAcross1 = Math.max(xAcross1, ya.position);\n        }\n\n        xBase = gs.l + xAcross0 * gs.w;\n        xEndSpike = gs.l + xAcross1 * gs.w;\n      } // Foreground horizontal line (to y-axis)\n\n\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness,\n        stroke: yColor,\n        'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n      }).classed('spikeline', true).classed('crisp', true); // Background horizontal Line (to y-axis)\n\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    } // Y axis marker\n\n\n    if (yMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n        cy: hLinePointY,\n        r: yThickness,\n        fill: yColor\n      }).classed('spikeline', true);\n    }\n  }\n\n  if (showX) {\n    var vLinePoint = closestPoints.vLinePoint;\n    var vLinePointX, vLinePointY;\n    xa = vLinePoint && vLinePoint.xa;\n    ya = vLinePoint && vLinePoint.ya;\n    var xSnap = xa.spikesnap;\n\n    if (xSnap === 'cursor') {\n      vLinePointX = evt.pointerX;\n      vLinePointY = evt.pointerY;\n    } else {\n      vLinePointX = xa._offset + vLinePoint.x;\n      vLinePointY = ya._offset + vLinePoint.y;\n    }\n\n    var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;\n    var xMode = xa.spikemode;\n    var xThickness = xa.spikethickness;\n    var xColor = xa.spikecolor || dfltVLineColor;\n    var yEdge = Axes.getPxPosition(gd, xa);\n    var yBase, yEndSpike;\n\n    if (xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n      if (xMode.indexOf('toaxis') !== -1) {\n        yBase = yEdge;\n        yEndSpike = vLinePointY;\n      }\n\n      if (xMode.indexOf('across') !== -1) {\n        var yAcross0 = xa._counterDomainMin;\n        var yAcross1 = xa._counterDomainMax;\n\n        if (xa.anchor === 'free') {\n          yAcross0 = Math.min(yAcross0, xa.position);\n          yAcross1 = Math.max(yAcross1, xa.position);\n        }\n\n        yBase = gs.t + (1 - yAcross1) * gs.h;\n        yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n      } // Foreground vertical line (to x-axis)\n\n\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness,\n        stroke: xColor,\n        'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n      }).classed('spikeline', true).classed('crisp', true); // Background vertical line (to x-axis)\n\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    } // X axis marker\n\n\n    if (xMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: vLinePointX,\n        cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n        r: xThickness,\n        fill: xColor\n      }).classed('spikeline', true);\n    }\n  }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n  // don't emit any events if nothing changed\n  if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n  for (var i = oldhoverdata.length - 1; i >= 0; i--) {\n    var oldPt = oldhoverdata[i];\n    var newPt = gd._hoverdata[i];\n\n    if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n  // don't relayout the plot because of new spikelines if spikelines points didn't change\n  if (!oldspikepoints) return true;\n  if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;\n  return false;\n}\n\nfunction plainText(s, len) {\n  return svgTextUtils.plainText(s || '', {\n    len: len,\n    allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n  });\n}","map":null,"metadata":{},"sourceType":"script"}