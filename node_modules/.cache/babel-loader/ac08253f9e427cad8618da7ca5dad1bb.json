{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar id2name = require('./axis_ids').id2name;\n\nvar scaleZoom = require('./scale_zoom');\n\nvar makePadFn = require('./autorange').makePadFn;\n\nvar concatExtremes = require('./autorange').concatExtremes;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleConstraintDefaults = function (containerIn, containerOut, coerce, allAxisIds, layoutOut) {\n  var constraintGroups = layoutOut._axisConstraintGroups;\n  var matchGroups = layoutOut._axisMatchGroups;\n  var axId = containerOut._id;\n  var axLetter = axId.charAt(0);\n  var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n  var thisID = containerOut._id;\n  var letter = thisID.charAt(0); // coerce the constraint mechanics even if this axis has no scaleanchor\n  // because it may be the anchor of another axis.\n\n  var constrain = coerce('constrain');\n  Lib.coerce(containerIn, containerOut, {\n    constraintoward: {\n      valType: 'enumerated',\n      values: letter === 'x' ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n      dflt: letter === 'x' ? 'center' : 'middle'\n    }\n  }, 'constraintoward');\n  var matches, matchOpts;\n\n  if ((containerIn.matches || splomStash.matches) && !containerOut.fixedrange) {\n    matchOpts = getConstraintOpts(matchGroups, thisID, allAxisIds, layoutOut);\n    matches = Lib.coerce(containerIn, containerOut, {\n      matches: {\n        valType: 'enumerated',\n        values: matchOpts.linkableAxes || [],\n        dflt: splomStash.matches\n      }\n    }, 'matches');\n  } // 'matches' wins over 'scaleanchor' (for now)\n\n\n  var scaleanchor, scaleOpts;\n\n  if (!matches && containerIn.scaleanchor && !(containerOut.fixedrange && constrain !== 'domain')) {\n    scaleOpts = getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut, constrain);\n    scaleanchor = Lib.coerce(containerIn, containerOut, {\n      scaleanchor: {\n        valType: 'enumerated',\n        values: scaleOpts.linkableAxes || []\n      }\n    }, 'scaleanchor');\n  }\n\n  if (matches) {\n    delete containerOut.constrain;\n    updateConstraintGroups(matchGroups, matchOpts.thisGroup, thisID, matches, 1);\n  } else if (allAxisIds.indexOf(containerIn.matches) !== -1) {\n    Lib.warn('ignored ' + containerOut._name + '.matches: \"' + containerIn.matches + '\" to avoid either an infinite loop ' + 'or because the target axis has fixed range.');\n  }\n\n  if (scaleanchor) {\n    var scaleratio = coerce('scaleratio'); // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n    // but that seems hacky. Better way to say \"must be a positive number\"?\n    // Of course if you use several super-tiny values you could eventually\n    // force a product of these to zero and all hell would break loose...\n    // Likewise with super-huge values.\n\n    if (!scaleratio) scaleratio = containerOut.scaleratio = 1;\n    updateConstraintGroups(constraintGroups, scaleOpts.thisGroup, thisID, scaleanchor, scaleratio);\n  } else if (allAxisIds.indexOf(containerIn.scaleanchor) !== -1) {\n    Lib.warn('ignored ' + containerOut._name + '.scaleanchor: \"' + containerIn.scaleanchor + '\" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because the target ' + 'axis has fixed range or this axis declares a *matches* constraint.');\n  }\n}; // If this axis is already part of a constraint group, we can't\n// scaleanchor any other axis in that group, or we'd make a loop.\n// Filter allAxisIds to enforce this, also matching axis types.\n\n\nfunction getConstraintOpts(groups, thisID, allAxisIds, layoutOut, constrain) {\n  var doesNotConstrainRange = constrain !== 'range';\n  var thisType = layoutOut[id2name(thisID)].type;\n  var i, j, idj, axj;\n  var linkableAxes = [];\n\n  for (j = 0; j < allAxisIds.length; j++) {\n    idj = allAxisIds[j];\n    if (idj === thisID) continue;\n    axj = layoutOut[id2name(idj)];\n\n    if (axj.type === thisType) {\n      if (!axj.fixedrange) {\n        linkableAxes.push(idj);\n      } else if (doesNotConstrainRange && axj.anchor) {\n        // allow domain constraints on subplots where\n        // BOTH axes have fixedrange:true and constrain:domain\n        var counterAxj = layoutOut[id2name(axj.anchor)];\n\n        if (counterAxj.fixedrange) {\n          linkableAxes.push(idj);\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < groups.length; i++) {\n    if (groups[i][thisID]) {\n      var thisGroup = groups[i];\n      var linkableAxesNoLoops = [];\n\n      for (j = 0; j < linkableAxes.length; j++) {\n        idj = linkableAxes[j];\n        if (!thisGroup[idj]) linkableAxesNoLoops.push(idj);\n      }\n\n      return {\n        linkableAxes: linkableAxesNoLoops,\n        thisGroup: thisGroup\n      };\n    }\n  }\n\n  return {\n    linkableAxes: linkableAxes,\n    thisGroup: null\n  };\n}\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */\n\n\nfunction updateConstraintGroups(constraintGroups, thisGroup, thisID, scaleanchor, scaleratio) {\n  var i, j, groupi, keyj, thisGroupIndex;\n\n  if (thisGroup === null) {\n    thisGroup = {};\n    thisGroup[thisID] = 1;\n    thisGroupIndex = constraintGroups.length;\n    constraintGroups.push(thisGroup);\n  } else {\n    thisGroupIndex = constraintGroups.indexOf(thisGroup);\n  }\n\n  var thisGroupKeys = Object.keys(thisGroup); // we know that this axis isn't in any other groups, but we don't know\n  // about the scaleanchor axis. If it is, we need to merge the groups.\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    groupi = constraintGroups[i];\n\n    if (i !== thisGroupIndex && groupi[scaleanchor]) {\n      var baseScale = groupi[scaleanchor];\n\n      for (j = 0; j < thisGroupKeys.length; j++) {\n        keyj = thisGroupKeys[j];\n        groupi[keyj] = baseScale * scaleratio * thisGroup[keyj];\n      }\n\n      constraintGroups.splice(thisGroupIndex, 1);\n      return;\n    }\n  } // otherwise, we insert the new scaleanchor axis as the base scale (1)\n  // in its group, and scale the rest of the group to it\n\n\n  if (scaleratio !== 1) {\n    for (j = 0; j < thisGroupKeys.length; j++) {\n      thisGroup[thisGroupKeys[j]] *= scaleratio;\n    }\n  }\n\n  thisGroup[scaleanchor] = 1;\n}\n\nexports.enforce = function enforce(gd) {\n  var fullLayout = gd._fullLayout;\n  var constraintGroups = fullLayout._axisConstraintGroups || [];\n  var i, j, axisID, ax, normScale, mode, factor;\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    var group = constraintGroups[i];\n    var axisIDs = Object.keys(group);\n    var minScale = Infinity;\n    var maxScale = 0; // mostly matchScale will be the same as minScale\n    // ie we expand axis ranges to encompass *everything*\n    // that's currently in any of their ranges, but during\n    // autorange of a subset of axes we will ignore other\n    // axes for this purpose.\n\n    var matchScale = Infinity;\n    var normScales = {};\n    var axes = {};\n    var hasAnyDomainConstraint = false; // find the (normalized) scale of each axis in the group\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      axes[axisID] = ax = fullLayout[id2name(axisID)];\n      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();\n      if (!ax._inputRange) ax._inputRange = ax.range.slice(); // set axis scale here so we can use _m rather than\n      // having to calculate it from length and range\n\n      ax.setScale(); // abs: inverted scales still satisfy the constraint\n\n      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n      minScale = Math.min(minScale, normScale);\n\n      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {\n        matchScale = Math.min(matchScale, normScale);\n      } // this has served its purpose, so remove it\n\n\n      delete ax._constraintShrinkable;\n      maxScale = Math.max(maxScale, normScale);\n      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;\n    } // Do we have a constraint mismatch? Give a small buffer for rounding errors\n\n\n    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue; // now increase any ranges we need to until all normalized scales are equal\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      normScale = normScales[axisID];\n      ax = axes[axisID];\n      mode = ax.constrain; // even if the scale didn't change, if we're shrinking domain\n      // we need to recalculate in case `constraintoward` changed\n\n      if (normScale !== matchScale || mode === 'domain') {\n        factor = normScale / matchScale;\n\n        if (mode === 'range') {\n          scaleZoom(ax, factor);\n        } else {\n          // mode === 'domain'\n          var inputDomain = ax._inputDomain;\n          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);\n          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n          factor /= domainShrunk;\n\n          if (factor * rangeShrunk < 1) {\n            // we've asked to magnify the axis more than we can just by\n            // enlarging the domain - so we need to constrict range\n            ax.domain = ax._input.domain = inputDomain.slice();\n            scaleZoom(ax, factor);\n            continue;\n          }\n\n          if (rangeShrunk < 1) {\n            // the range has previously been constricted by ^^, but we've\n            // switched to the domain-constricted regime, so reset range\n            ax.range = ax._input.range = ax._inputRange.slice();\n            factor *= rangeShrunk;\n          }\n\n          if (ax.autorange) {\n            /*\n             * range & factor may need to change because range was\n             * calculated for the larger scaling, so some pixel\n             * paddings may get cut off when we reduce the domain.\n             *\n             * This is easier than the regular autorange calculation\n             * because we already know the scaling `m`, but we still\n             * need to cut out impossible constraints (like\n             * annotations with super-long arrows). That's what\n             * outerMin/Max are for - if the expansion was going to\n             * go beyond the original domain, it must be impossible\n             */\n            var rl0 = ax.r2l(ax.range[0]);\n            var rl1 = ax.r2l(ax.range[1]);\n            var rangeCenter = (rl0 + rl1) / 2;\n            var rangeMin = rangeCenter;\n            var rangeMax = rangeCenter;\n            var halfRange = Math.abs(rl1 - rangeCenter); // extra tiny bit for rounding errors, in case we actually\n            // *are* expanding to the full domain\n\n            var outerMin = rangeCenter - halfRange * factor * 1.0001;\n            var outerMax = rangeCenter + halfRange * factor * 1.0001;\n            var getPad = makePadFn(ax);\n            updateDomain(ax, factor);\n            var m = Math.abs(ax._m);\n            var extremes = concatExtremes(gd, ax);\n            var minArray = extremes.min;\n            var maxArray = extremes.max;\n            var newVal;\n            var k;\n\n            for (k = 0; k < minArray.length; k++) {\n              newVal = minArray[k].val - getPad(minArray[k]) / m;\n\n              if (newVal > outerMin && newVal < rangeMin) {\n                rangeMin = newVal;\n              }\n            }\n\n            for (k = 0; k < maxArray.length; k++) {\n              newVal = maxArray[k].val + getPad(maxArray[k]) / m;\n\n              if (newVal < outerMax && newVal > rangeMax) {\n                rangeMax = newVal;\n              }\n            }\n\n            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n            factor /= domainExpand;\n            rangeMin = ax.l2r(rangeMin);\n            rangeMax = ax.l2r(rangeMax);\n            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];\n          }\n\n          updateDomain(ax, factor);\n        }\n      }\n    }\n  }\n}; // For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\n\n\nexports.clean = function clean(gd, ax) {\n  if (ax._inputDomain) {\n    var isConstrained = false;\n    var axId = ax._id;\n    var constraintGroups = gd._fullLayout._axisConstraintGroups;\n\n    for (var j = 0; j < constraintGroups.length; j++) {\n      if (constraintGroups[j][axId]) {\n        isConstrained = true;\n        break;\n      }\n    }\n\n    if (!isConstrained || ax.constrain !== 'domain') {\n      ax._input.domain = ax.domain = ax._inputDomain;\n      delete ax._inputDomain;\n    }\n  }\n};\n\nfunction updateDomain(ax, factor) {\n  var inputDomain = ax._inputDomain;\n  var centerFraction = FROM_BL[ax.constraintoward];\n  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];\n  ax.setScale();\n}","map":null,"metadata":{},"sourceType":"script"}