{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\n\nmodule.exports = function makeComputeError(opts) {\n  var type = opts.type;\n  var symmetric = opts.symmetric;\n\n  if (type === 'data') {\n    var array = opts.array || [];\n\n    if (symmetric) {\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        return [val, val];\n      };\n    } else {\n      var arrayminus = opts.arrayminus || [];\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        var valMinus = +arrayminus[index]; // in case one is present and the other is missing, fill in 0\n        // so we still see the present one. Mostly useful during manual\n        // data entry.\n\n        if (!isNaN(val) || !isNaN(valMinus)) {\n          return [valMinus || 0, val || 0];\n        }\n\n        return [NaN, NaN];\n      };\n    }\n  } else {\n    var computeErrorValue = makeComputeErrorValue(type, opts.value);\n    var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n    if (symmetric || opts.valueminus === undefined) {\n      return function computeError(dataPt) {\n        var val = computeErrorValue(dataPt);\n        return [val, val];\n      };\n    } else {\n      return function computeError(dataPt) {\n        return [computeErrorValueMinus(dataPt), computeErrorValue(dataPt)];\n      };\n    }\n  }\n};\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\n\n\nfunction makeComputeErrorValue(type, value) {\n  if (type === 'percent') {\n    return function (dataPt) {\n      return Math.abs(dataPt * value / 100);\n    };\n  }\n\n  if (type === 'constant') {\n    return function () {\n      return Math.abs(value);\n    };\n  }\n\n  if (type === 'sqrt') {\n    return function (dataPt) {\n      return Math.sqrt(Math.abs(dataPt));\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"script"}