{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Fx = require('../../components/fx');\n\nvar Registry = require('../../registry');\n\nvar getTraceColor = require('./get_trace_color');\n\nvar Color = require('../../components/color');\n\nvar fillText = Lib.fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var pt = [xpx, ypx];\n  var hoveron = trace.hoveron || '';\n  var minRad = trace.mode.indexOf('markers') !== -1 ? 3 : 0.5; // look for points to hover on first, then take fills only if we\n  // didn't find a point\n\n  if (hoveron.indexOf('points') !== -1) {\n    var dx = function (di) {\n      // dx and dy are used in compare modes - here we want to always\n      // prioritize the closest data point, at least as long as markers are\n      // the same size or nonexistent, but still try to prioritize small markers too.\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\n      var d = dxRaw < rad ? kink * dxRaw / rad : dxRaw - rad + kink;\n      return d;\n    };\n\n    var dy = function (di) {\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\n      return dyRaw < rad ? kink * dyRaw / rad : dyRaw - rad + kink;\n    };\n\n    var dxy = function (di) {\n      // scatter points: d.mrc is the calculated marker radius\n      // adjust the distance so if you're inside the marker it\n      // always will show up regardless of point size, but\n      // prioritize smaller points\n      var rad = Math.max(minRad, di.mrc || 0);\n      var dx = xa.c2p(di.x) - xpx;\n      var dy = ya.c2p(di.y) - ypx;\n      return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\n    };\n\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n    if (pointData.index !== false) {\n      // the closest data point\n      var di = cd[pointData.index];\n      var xc = xa.c2p(di.x, true);\n      var yc = ya.c2p(di.y, true);\n      var rad = di.mrc || 1; // now we're done using the whole `calcdata` array, replace the\n      // index with the original index (in case of inserted point from\n      // stacked area)\n\n      pointData.index = di.i;\n      var orientation = cd[0].t.orientation; // TODO: for scatter and bar, option to show (sub)totals and\n      // raw data? Currently stacked and/or normalized bars just show\n      // the normalized individual sizes, so that's what I'm doing here\n      // for now.\n\n      var sizeVal = orientation && (di.sNorm || di.s);\n      var xLabelVal = orientation === 'h' ? sizeVal : di.x;\n      var yLabelVal = orientation === 'v' ? sizeVal : di.y;\n      Lib.extendFlat(pointData, {\n        color: getTraceColor(trace, di),\n        x0: xc - rad,\n        x1: xc + rad,\n        xLabelVal: xLabelVal,\n        y0: yc - rad,\n        y1: yc + rad,\n        yLabelVal: yLabelVal,\n        spikeDistance: dxy(di),\n        hovertemplate: trace.hovertemplate\n      });\n      fillText(di, trace, pointData);\n      Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n      return [pointData];\n    }\n  } // even if hoveron is 'fills', only use it if we have polygons too\n\n\n  if (hoveron.indexOf('fills') !== -1 && trace._polygons) {\n    var polygons = trace._polygons;\n    var polygonsIn = [];\n    var inside = false;\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    var ymin = Infinity;\n    var ymax = -Infinity;\n    var i, j, polygon, pts, xCross, x0, x1, y0, y1;\n\n    for (i = 0; i < polygons.length; i++) {\n      polygon = polygons[i]; // TODO: this is not going to work right for curved edges, it will\n      // act as though they're straight. That's probably going to need\n      // the elements themselves to capture the events. Worth it?\n\n      if (polygon.contains(pt)) {\n        inside = !inside; // TODO: need better than just the overall bounding box\n\n        polygonsIn.push(polygon);\n        ymin = Math.min(ymin, polygon.ymin);\n        ymax = Math.max(ymax, polygon.ymax);\n      }\n    }\n\n    if (inside) {\n      // constrain ymin/max to the visible plot, so the label goes\n      // at the middle of the piece you can see\n      ymin = Math.max(ymin, 0);\n      ymax = Math.min(ymax, ya._length); // find the overall left-most and right-most points of the\n      // polygon(s) we're inside at their combined vertical midpoint.\n      // This is where we will draw the hover label.\n      // Note that this might not be the vertical midpoint of the\n      // whole trace, if it's disjoint.\n\n      var yAvg = (ymin + ymax) / 2;\n\n      for (i = 0; i < polygonsIn.length; i++) {\n        pts = polygonsIn[i].pts;\n\n        for (j = 1; j < pts.length; j++) {\n          y0 = pts[j - 1][1];\n          y1 = pts[j][1];\n\n          if (y0 > yAvg !== y1 >= yAvg) {\n            x0 = pts[j - 1][0];\n            x1 = pts[j][0];\n\n            if (y1 - y0) {\n              xCross = x0 + (x1 - x0) * (yAvg - y0) / (y1 - y0);\n              xmin = Math.min(xmin, xCross);\n              xmax = Math.max(xmax, xCross);\n            }\n          }\n        }\n      } // constrain xmin/max to the visible plot now too\n\n\n      xmin = Math.max(xmin, 0);\n      xmax = Math.min(xmax, xa._length); // get only fill or line color for the hover color\n\n      var color = Color.defaultLine;\n      if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;else if (Color.opacity((trace.line || {}).color)) {\n        color = trace.line.color;\n      }\n      Lib.extendFlat(pointData, {\n        // never let a 2D override 1D type as closest point\n        // also: no spikeDistance, it's not allowed for fills\n        distance: pointData.maxHoverDistance,\n        x0: xmin,\n        x1: xmax,\n        y0: yAvg,\n        y1: yAvg,\n        color: color,\n        hovertemplate: false\n      });\n      delete pointData.index;\n\n      if (trace.text && !Array.isArray(trace.text)) {\n        pointData.text = String(trace.text);\n      } else pointData.text = trace.name;\n\n      return [pointData];\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}