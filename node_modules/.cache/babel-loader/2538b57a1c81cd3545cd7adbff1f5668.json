{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar subTypes = require('./subtypes');\n\nvar calcColorscale = require('./colorscale_calc');\n\nvar arraysToCalcdata = require('./arrays_to_calcdata');\n\nvar calcSelection = require('./calc_selection');\n\nfunction calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n  var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n  var x = xa.makeCalcdata(trace, 'x');\n  var y = ya.makeCalcdata(trace, 'y');\n  var serieslen = trace._length;\n  var cd = new Array(serieslen);\n  var ids = trace.ids;\n  var stackGroupOpts = getStackOpts(trace, fullLayout, xa, ya);\n  var interpolateGaps = false;\n  var isV, i, j, k, interpolate, vali;\n  setFirstScatter(fullLayout, trace);\n  var xAttr = 'x';\n  var yAttr = 'y';\n  var posAttr;\n\n  if (stackGroupOpts) {\n    Lib.pushUnique(stackGroupOpts.traceIndices, trace._expandedIndex);\n    isV = stackGroupOpts.orientation === 'v'; // size, like we use for bar\n\n    if (isV) {\n      yAttr = 's';\n      posAttr = 'x';\n    } else {\n      xAttr = 's';\n      posAttr = 'y';\n    }\n\n    interpolate = stackGroupOpts.stackgaps === 'interpolate';\n  } else {\n    var ppad = calcMarkerSize(trace, serieslen);\n    calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n  }\n\n  for (i = 0; i < serieslen; i++) {\n    var cdi = cd[i] = {};\n    var xValid = isNumeric(x[i]);\n    var yValid = isNumeric(y[i]);\n\n    if (xValid && yValid) {\n      cdi[xAttr] = x[i];\n      cdi[yAttr] = y[i];\n    } else if (stackGroupOpts && (isV ? xValid : yValid)) {\n      // if we're stacking we need to hold on to all valid positions\n      // even with invalid sizes\n      cdi[posAttr] = isV ? x[i] : y[i];\n      cdi.gap = true;\n\n      if (interpolate) {\n        cdi.s = BADNUM;\n        interpolateGaps = true;\n      } else {\n        cdi.s = 0;\n      }\n    } else {\n      cdi[xAttr] = cdi[yAttr] = BADNUM;\n    }\n\n    if (ids) {\n      cdi.id = String(ids[i]);\n    }\n  }\n\n  arraysToCalcdata(cd, trace);\n  calcColorscale(gd, trace);\n  calcSelection(cd, trace);\n\n  if (stackGroupOpts) {\n    // remove bad positions and sort\n    // note that original indices get added to cd in arraysToCalcdata\n    i = 0;\n\n    while (i < cd.length) {\n      if (cd[i][posAttr] === BADNUM) {\n        cd.splice(i, 1);\n      } else i++;\n    }\n\n    Lib.sort(cd, function (a, b) {\n      return a[posAttr] - b[posAttr] || a.i - b.i;\n    });\n\n    if (interpolateGaps) {\n      // first fill the beginning with constant from the first point\n      i = 0;\n\n      while (i < cd.length - 1 && cd[i].gap) {\n        i++;\n      }\n\n      vali = cd[i].s;\n      if (!vali) vali = cd[i].s = 0; // in case of no data AT ALL in this trace - use 0\n\n      for (j = 0; j < i; j++) {\n        cd[j].s = vali;\n      } // then fill the end with constant from the last point\n\n\n      k = cd.length - 1;\n\n      while (k > i && cd[k].gap) {\n        k--;\n      }\n\n      vali = cd[k].s;\n\n      for (j = cd.length - 1; j > k; j--) {\n        cd[j].s = vali;\n      } // now interpolate internal gaps linearly\n\n\n      while (i < k) {\n        i++;\n\n        if (cd[i].gap) {\n          j = i + 1;\n\n          while (cd[j].gap) {\n            j++;\n          }\n\n          var pos0 = cd[i - 1][posAttr];\n          var size0 = cd[i - 1].s;\n          var m = (cd[j].s - size0) / (cd[j][posAttr] - pos0);\n\n          while (i < j) {\n            cd[i].s = size0 + (cd[i][posAttr] - pos0) * m;\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  return cd;\n}\n\nfunction calcAxisExpansion(gd, trace, xa, ya, x, y, ppad) {\n  var serieslen = trace._length;\n  var fullLayout = gd._fullLayout;\n  var xId = xa._id;\n  var yId = ya._id;\n  var firstScatter = fullLayout._firstScatter[firstScatterGroup(trace)] === trace.uid;\n  var stackOrientation = (getStackOpts(trace, fullLayout, xa, ya) || {}).orientation;\n  var fill = trace.fill; // cancel minimum tick spacings (only applies to bars and boxes)\n\n  xa._minDtick = 0;\n  ya._minDtick = 0; // check whether bounds should be tight, padded, extended to zero...\n  // most cases both should be padded on both ends, so start with that.\n\n  var xOptions = {\n    padded: true\n  };\n  var yOptions = {\n    padded: true\n  };\n\n  if (ppad) {\n    xOptions.ppad = yOptions.ppad = ppad;\n  } // TODO: text size\n\n\n  var openEnded = serieslen < 2 || x[0] !== x[serieslen - 1] || y[0] !== y[serieslen - 1];\n\n  if (openEnded && (fill === 'tozerox' || fill === 'tonextx' && (firstScatter || stackOrientation === 'h'))) {\n    // include zero (tight) and extremes (padded) if fill to zero\n    // (unless the shape is closed, then it's just filling the shape regardless)\n    xOptions.tozero = true;\n  } else if (!(trace.error_y || {}).visible && ( // if no error bars, markers or text, or fill to y=0 remove x padding\n  fill === 'tonexty' || fill === 'tozeroy' || !subTypes.hasMarkers(trace) && !subTypes.hasText(trace))) {\n    xOptions.padded = false;\n    xOptions.ppad = 0;\n  }\n\n  if (openEnded && (fill === 'tozeroy' || fill === 'tonexty' && (firstScatter || stackOrientation === 'v'))) {\n    // now check for y - rather different logic, though still mostly padded both ends\n    // include zero (tight) and extremes (padded) if fill to zero\n    // (unless the shape is closed, then it's just filling the shape regardless)\n    yOptions.tozero = true;\n  } else if (fill === 'tonextx' || fill === 'tozerox') {\n    // tight y: any x fill\n    yOptions.padded = false;\n  } // N.B. asymmetric splom traces call this with blank {} xa or ya\n\n\n  if (xId) trace._extremes[xId] = Axes.findExtremes(xa, x, xOptions);\n  if (yId) trace._extremes[yId] = Axes.findExtremes(ya, y, yOptions);\n}\n\nfunction calcMarkerSize(trace, serieslen) {\n  if (!subTypes.hasMarkers(trace)) return; // Treat size like x or y arrays --- Run d2c\n  // this needs to go before ppad computation\n\n  var marker = trace.marker;\n  var sizeref = 1.6 * (trace.marker.sizeref || 1);\n  var markerTrans;\n\n  if (trace.marker.sizemode === 'area') {\n    markerTrans = function (v) {\n      return Math.max(Math.sqrt((v || 0) / sizeref), 3);\n    };\n  } else {\n    markerTrans = function (v) {\n      return Math.max((v || 0) / sizeref, 3);\n    };\n  }\n\n  if (Lib.isArrayOrTypedArray(marker.size)) {\n    // I tried auto-type but category and dates dont make much sense.\n    var ax = {\n      type: 'linear'\n    };\n    Axes.setConvert(ax);\n    var s = ax.makeCalcdata(trace.marker, 'size');\n    var sizeOut = new Array(serieslen);\n\n    for (var i = 0; i < serieslen; i++) {\n      sizeOut[i] = markerTrans(s[i]);\n    }\n\n    return sizeOut;\n  } else {\n    return markerTrans(marker.size);\n  }\n}\n/**\n * mark the first scatter trace for each subplot\n * note that scatter and scattergl each get their own first trace\n * note also that I'm doing this during calc rather than supplyDefaults\n * so I don't need to worry about transforms, but if we ever do\n * per-trace calc this will get confused.\n */\n\n\nfunction setFirstScatter(fullLayout, trace) {\n  var group = firstScatterGroup(trace);\n  var firstScatter = fullLayout._firstScatter;\n  if (!firstScatter[group]) firstScatter[group] = trace.uid;\n}\n\nfunction firstScatterGroup(trace) {\n  var stackGroup = trace.stackgroup;\n  return trace.xaxis + trace.yaxis + trace.type + (stackGroup ? '-' + stackGroup : '');\n}\n\nfunction getStackOpts(trace, fullLayout, xa, ya) {\n  var stackGroup = trace.stackgroup;\n  if (!stackGroup) return;\n  var stackOpts = fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup];\n  var stackAx = stackOpts.orientation === 'v' ? ya : xa; // Allow stacking only on numeric axes\n  // calc is a little late to be figuring this out, but during supplyDefaults\n  // we don't know the axis type yet\n\n  if (stackAx.type === 'linear' || stackAx.type === 'log') return stackOpts;\n}\n\nmodule.exports = {\n  calc: calc,\n  calcMarkerSize: calcMarkerSize,\n  calcAxisExpansion: calcAxisExpansion,\n  setFirstScatter: setFirstScatter,\n  getStackOpts: getStackOpts\n};","map":null,"metadata":{},"sourceType":"script"}