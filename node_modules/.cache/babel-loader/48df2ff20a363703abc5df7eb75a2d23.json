{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar loggers = require('./loggers');\n\nvar identity = require('./identity'); // don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\n\n\nvar roundingError = 1e-9;\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\n\nexports.findBin = function (val, bins, linelow) {\n  if (isNumeric(bins.start)) {\n    return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);\n  } else {\n    var n1 = 0;\n    var n2 = bins.length;\n    var c = 0;\n    var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n    var n, test;\n\n    if (binSize >= 0) {\n      test = linelow ? lessThan : lessOrEqual;\n    } else {\n      test = linelow ? greaterOrEqual : greaterThan;\n    }\n\n    val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1); // c is just to avoid infinite loops if there's an error\n\n    while (n1 < n2 && c++ < 100) {\n      n = Math.floor((n1 + n2) / 2);\n      if (test(bins[n], val)) n1 = n + 1;else n2 = n;\n    }\n\n    if (c > 90) loggers.log('Long binary search...');\n    return n1 - 1;\n  }\n};\n\nfunction lessThan(a, b) {\n  return a < b;\n}\n\nfunction lessOrEqual(a, b) {\n  return a <= b;\n}\n\nfunction greaterThan(a, b) {\n  return a > b;\n}\n\nfunction greaterOrEqual(a, b) {\n  return a >= b;\n}\n\nexports.sorterAsc = function (a, b) {\n  return a - b;\n};\n\nexports.sorterDes = function (a, b) {\n  return b - a;\n};\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\n\n\nexports.distinctVals = function (valsIn) {\n  var vals = valsIn.slice(); // otherwise we sort the original array...\n\n  vals.sort(exports.sorterAsc);\n  var l = vals.length - 1;\n  var minDiff = vals[l] - vals[0] || 1;\n  var errDiff = minDiff / (l || 1) / 10000;\n  var v2 = [vals[0]];\n\n  for (var i = 0; i < l; i++) {\n    // make sure values aren't just off by a rounding error\n    if (vals[i + 1] > vals[i] + errDiff) {\n      minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);\n      v2.push(vals[i + 1]);\n    }\n  }\n\n  return {\n    vals: v2,\n    minDiff: minDiff\n  };\n};\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\n\n\nexports.roundUp = function (val, arrayIn, reverse) {\n  var low = 0;\n  var high = arrayIn.length - 1;\n  var mid;\n  var c = 0;\n  var dlow = reverse ? 0 : 1;\n  var dhigh = reverse ? 1 : 0;\n  var rounded = reverse ? Math.ceil : Math.floor; // c is just to avoid infinite loops if there's an error\n\n  while (low < high && c++ < 100) {\n    mid = rounded((low + high) / 2);\n    if (arrayIn[mid] <= val) low = mid + dlow;else high = mid - dhigh;\n  }\n\n  return arrayIn[low];\n};\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\n\n\nexports.sort = function (array, sortFn) {\n  var notOrdered = 0;\n  var notReversed = 0;\n\n  for (var i = 1; i < array.length; i++) {\n    var pairOrder = sortFn(array[i], array[i - 1]);\n    if (pairOrder < 0) notOrdered = 1;else if (pairOrder > 0) notReversed = 1;\n    if (notOrdered && notReversed) return array.sort(sortFn);\n  }\n\n  return notReversed ? array : array.reverse();\n};\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\n\n\nexports.findIndexOfMin = function (arr, fn) {\n  fn = fn || identity;\n  var min = Infinity;\n  var ind;\n\n  for (var i = 0; i < arr.length; i++) {\n    var v = fn(arr[i]);\n\n    if (v < min) {\n      min = v;\n      ind = i;\n    }\n  }\n\n  return ind;\n};","map":null,"metadata":{},"sourceType":"script"}