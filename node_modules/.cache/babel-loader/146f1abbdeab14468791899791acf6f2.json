{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp, _initialiseProps;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\r\n * Created by RaphaÃ«l Morineau on 28 Oct 2016.\r\n */\n\n\nimport React, { Component } from 'react';\nimport { object } from 'prop-types';\nimport InfiniteScroller from 'react-infinite';\nimport ListItem from 'material-ui/List/ListItem';\nimport Popover from 'material-ui/Popover/Popover';\nimport TextField from 'material-ui/TextField/TextField';\nimport SelectionsPresenter from './SelectionsPresenter';\nimport { getChildrenLength, areEqual } from './utils';\nimport { selectFieldTypes } from './types';\nimport { selectFieldDefaultProps } from './defaultProps';\nvar SelectField = (_temp = _class = function (_Component) {\n  _inherits(SelectField, _Component);\n\n  function SelectField(props, context) {\n    _classCallCheck(this, SelectField);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\n    _initialiseProps.call(_this);\n\n    var children = props.children,\n        value = props.value,\n        multiple = props.multiple,\n        showAutocompleteThreshold = props.showAutocompleteThreshold;\n    var itemsLength = getChildrenLength(children);\n    _this.state = {\n      isOpen: false,\n      isFocused: false,\n      initialValue: value || (multiple ? [] : null),\n      itemsLength: itemsLength,\n      isAutocompleteShown: _this.showAutocomplete(showAutocompleteThreshold, itemsLength),\n      selectedItems: value || (multiple ? [] : null),\n      searchText: ''\n    };\n    _this.menuItems = [];\n    return _this;\n  } // eslint-disable-next-line camelcase\n\n\n  SelectField.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n    if (!areEqual(nextProps.value, this.state.selectedItems)) {\n      this.setState({\n        selectedItems: nextProps.value\n      });\n    }\n\n    if (!areEqual(nextProps.children, this.props.children)) {\n      var itemsLength = getChildrenLength(nextProps.children);\n      this.setState({\n        itemsLength: itemsLength,\n        isAutocompleteShown: this.showAutocomplete(this.props.showAutocompleteThreshold, itemsLength)\n      });\n    }\n  };\n\n  SelectField.prototype.showAutocomplete = function showAutocomplete() {\n    var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var itemsLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (typeof threshold === 'number') return itemsLength >= threshold;\n\n    switch (threshold) {\n      case 'always':\n        return true;\n\n      case 'never':\n      default:\n        return false;\n    }\n  };\n\n  SelectField.prototype.componentDidMount = function componentDidMount() {\n    // Potential problem with Popover ?\n    // https://github.com/callemall/material-ui/blob/master/src/DropDownMenu/DropDownMenu.js#L237\n    if (this.props.openImmediately) this.openMenu();\n  };\n\n  SelectField.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {};\n\n  SelectField.prototype.openMenu = function openMenu() {\n    var _this2 = this;\n\n    if (!this.state.isOpen) this.props.onMenuOpen();\n\n    if (this.state.itemsLength || this.props.showAutocompleteThreshold === 'always') {\n      this.setState({\n        isOpen: true\n      }, function () {\n        return _this2.focusTextField();\n      });\n    }\n  }; // FIXME: both focusTextField and focusMenuItem don't really focus the targeted element, user must hit another key to trigger the actual focus... need to find a solution for a true direct focus\n\n\n  SelectField.prototype.focusMenuItem = function focusMenuItem(index) {\n    var targetMenuItem = this.menuItems.find(function (item) {\n      return !!item && (index ? item.props.tabIndex === index : true);\n    });\n    if (targetMenuItem) targetMenuItem.applyFocusState('keyboard-focused');\n  };\n\n  SelectField.prototype.focusTextField = function focusTextField() {\n    this.state.isAutocompleteShown && this.searchTextField ? this.searchTextField.focus() : this.focusMenuItem();\n  };\n\n  SelectField.prototype.clearTextField = function clearTextField(callback) {\n    this.props.keepSearchOnSelect ? typeof callback === 'function' && callback() // don't reset the autocomplete\n    : this.setState({\n      searchText: ''\n    }, callback);\n  };\n  /**\r\n   * Main Component Wrapper methods\r\n   */\n  // toggle instead of close ? (in case user changes targetOrigin/anchorOrigin)\n\n  /**\r\n   * TextField autocomplete methods\r\n   */\n\n  /**\r\n   * Menu Header methods\r\n   */\n\n  /**\r\n   * Menu methods\r\n   */\n  // group must be of type 'optgroup'\n  // TODO: add Shift+Tab\n\n  /**\r\n   * this.menuItems can contain uncontinuous React elements, because of filtering\r\n   */\n\n\n  SelectField.prototype.render = function render() {\n    var _this3 = this;\n\n    var _props = this.props,\n        anchorOrigin = _props.anchorOrigin,\n        autocompleteFilter = _props.autocompleteFilter,\n        autocompleteStyle = _props.autocompleteStyle,\n        autocompleteUnderlineFocusStyle = _props.autocompleteUnderlineFocusStyle,\n        autocompleteUnderlineStyle = _props.autocompleteUnderlineStyle,\n        canAutoPosition = _props.canAutoPosition,\n        checkPosition = _props.checkPosition,\n        checkedIcon = _props.checkedIcon,\n        children = _props.children,\n        disabled = _props.disabled,\n        dropDownIcon = _props.dropDownIcon,\n        elementHeight = _props.elementHeight,\n        errorStyle = _props.errorStyle,\n        errorText = _props.errorText,\n        floatingLabel = _props.floatingLabel,\n        floatingLabelFocusStyle = _props.floatingLabelFocusStyle,\n        floatingLabelStyle = _props.floatingLabelStyle,\n        hintText = _props.hintText,\n        hintTextAutocomplete = _props.hintTextAutocomplete,\n        hoverColor = _props.hoverColor,\n        infiniteLoadBeginEdgeOffset = _props.infiniteLoadBeginEdgeOffset,\n        innerDivStyle = _props.innerDivStyle,\n        menuCloseButton = _props.menuCloseButton,\n        menuFooterStyle = _props.menuFooterStyle,\n        menuGroupStyle = _props.menuGroupStyle,\n        menuStyle = _props.menuStyle,\n        multiple = _props.multiple,\n        nb2show = _props.nb2show,\n        noMatchFound = _props.noMatchFound,\n        noMatchFoundStyle = _props.noMatchFoundStyle,\n        popoverClassName = _props.popoverClassName,\n        popoverWidth = _props.popoverWidth,\n        onInfiniteLoad = _props.onInfiniteLoad,\n        resetButton = _props.resetButton,\n        selectAllButton = _props.selectAllButton,\n        selectedMenuItemStyle = _props.selectedMenuItemStyle,\n        selectionsRenderer = _props.selectionsRenderer,\n        style = _props.style,\n        unCheckedIcon = _props.unCheckedIcon,\n        underlineErrorStyle = _props.underlineErrorStyle,\n        underlineFocusStyle = _props.underlineFocusStyle,\n        underlineStyle = _props.underlineStyle,\n        withResetSelectAllButtons = _props.withResetSelectAllButtons; // Default style depending on Material-UI context (muiTheme)\n\n    var _context$muiTheme = this.context.muiTheme,\n        palette = _context$muiTheme.baseTheme.palette,\n        menuItem = _context$muiTheme.menuItem;\n\n    var mergedSelectedMenuItemStyle = _extends({\n      color: menuItem.selectedTextColor\n    }, selectedMenuItemStyle);\n\n    if (checkedIcon) {\n      checkedIcon.props.style.fill = mergedSelectedMenuItemStyle.color;\n    }\n\n    var mergedHoverColor = hoverColor || menuItem.hoverColor;\n    /**\r\n     * MenuItems building, based on user's children\r\n     * 1st function is the base process for producing a MenuItem,\r\n     * including filtering from the Autocomplete.\r\n     * 2nd function is the main loop over children array,\r\n     * accounting for optgroups.\r\n     */\n\n    var menuItemBuilder = function menuItemBuilder(nodes, child, index) {\n      var selectedItems = _this3.state.selectedItems;\n      var _child$props = child.props,\n          childValue = _child$props.value,\n          label = _child$props.label;\n\n      if (!autocompleteFilter(_this3.state.searchText, label || childValue)) {\n        return nodes;\n      }\n\n      var isSelected = Array.isArray(selectedItems) ? selectedItems.some(function (obj) {\n        return areEqual(obj.value, childValue);\n      }) : selectedItems ? selectedItems.value === childValue : false;\n      var leftCheckbox = multiple && checkPosition === 'left' && (isSelected ? checkedIcon : unCheckedIcon) || null;\n      var rightCheckbox = multiple && checkPosition === 'right' && (isSelected ? checkedIcon : unCheckedIcon) || null;\n\n      if (multiple && checkPosition !== '') {\n        if (checkedIcon) checkedIcon.props.style.marginTop = 0;\n        if (unCheckedIcon) unCheckedIcon.props.style.marginTop = 0;\n      }\n\n      return [].concat(nodes, [React.createElement(ListItem, {\n        key: ++index,\n        tabIndex: index,\n        ref: function ref(_ref) {\n          return _this3.menuItems[++index] = _ref;\n        },\n        disableFocusRipple: true,\n        hoverColor: mergedHoverColor,\n        innerDivStyle: _extends({\n          paddingTop: 10,\n          paddingBottom: 10,\n          paddingLeft: multiple && checkPosition === 'left' ? 56 : 16,\n          paddingRight: multiple && checkPosition === 'right' ? 56 : 16\n        }, innerDivStyle),\n        leftIcon: leftCheckbox,\n        onClick: _this3.handleMenuSelection({\n          value: childValue,\n          label: label\n        }),\n        primaryText: child,\n        rightIcon: rightCheckbox,\n        style: isSelected ? mergedSelectedMenuItemStyle : {}\n      })]);\n    };\n\n    var fixedChildren = Array.isArray(children) ? children : [children];\n    var menuItems = !disabled && fixedChildren.length && this.state.isOpen && fixedChildren.reduce(function (nodes, child, index) {\n      if (child.type !== 'optgroup') {\n        return menuItemBuilder(nodes, child, index);\n      }\n\n      var nextIndex = nodes.length ? +nodes[nodes.length - 1].key + 1 : 0;\n      var menuGroup = React.createElement(ListItem, {\n        disabled: true,\n        key: nextIndex,\n        primaryText: child.props.label,\n        style: _extends({\n          cursor: 'default',\n          paddingTop: 10,\n          paddingBottom: 10\n        }, menuGroupStyle)\n      });\n      var groupedItems = [];\n      var cpc = child.props.children;\n\n      if (cpc) {\n        if (Array.isArray(cpc) && cpc.length) {\n          groupedItems = cpc.reduce(function (nodes, child, idx) {\n            return menuItemBuilder(nodes, child, nextIndex + idx);\n          }, []);\n        } else if ((typeof cpc === 'undefined' ? 'undefined' : _typeof(cpc)) === 'object') {\n          groupedItems = menuItemBuilder(nodes, cpc, nextIndex);\n        }\n      }\n\n      return groupedItems.length ? [].concat(nodes, [menuGroup], groupedItems) : nodes;\n    }, []);\n    var autoCompleteHeight = this.state.isAutocompleteShown ? 53 : 0;\n    var headerHeight = multiple && withResetSelectAllButtons ? 36 : 0;\n    var footerHeight = multiple && menuCloseButton ? 36 : 0;\n    var noMatchFoundHeight = 36;\n    var optionsContainerHeight = (Array.isArray(elementHeight) ? elementHeight.reduce(function (totalHeight, height) {\n      return totalHeight + height;\n    }, 0) : elementHeight * (nb2show < menuItems.length ? nb2show : menuItems.length)) || 0;\n    var popoverHeight = autoCompleteHeight + headerHeight + (optionsContainerHeight || noMatchFoundHeight) + footerHeight + 6;\n    var scrollableStyle = {\n      overflowY: nb2show >= menuItems.length ? 'hidden' : 'scroll'\n    };\n    var baseWidth = this.root ? this.root.clientWidth : null;\n    var menuWidth = Math.max(baseWidth, popoverWidth);\n    return React.createElement('div', {\n      ref: function ref(_ref4) {\n        return _this3.root = _ref4;\n      },\n      tabIndex: disabled ? '-1' : '0',\n      onBlur: this.onBlur,\n      onClick: this.handleClick,\n      onFocus: this.onFocus,\n      onKeyDown: this.handleKeyDown,\n      style: _extends({\n        cursor: disabled ? 'not-allowed' : 'pointer',\n        color: disabled ? palette.disabledColor : palette.textColor,\n        outline: 'none'\n      }, style),\n      title: !this.state.itemsLength ? 'Nothing to show' : ''\n    }, React.createElement(SelectionsPresenter, {\n      disabled: disabled,\n      dropDownIcon: dropDownIcon,\n      errorStyle: errorStyle,\n      errorText: errorText,\n      floatingLabel: floatingLabel,\n      floatingLabelFocusStyle: floatingLabelFocusStyle,\n      floatingLabelStyle: floatingLabelStyle,\n      hintText: hintText,\n      isFocused: this.state.isFocused,\n      isOpen: this.state.isOpen,\n      muiTheme: this.context.muiTheme,\n      selectedValues: this.state.selectedItems,\n      selectionsRenderer: selectionsRenderer,\n      underlineErrorStyle: underlineErrorStyle,\n      underlineFocusStyle: underlineFocusStyle,\n      underlineStyle: underlineStyle\n    }), React.createElement(Popover, {\n      anchorEl: this.root,\n      anchorOrigin: anchorOrigin,\n      canAutoPosition: canAutoPosition,\n      className: popoverClassName,\n      onRequestClose: this.closeMenu,\n      open: this.state.isOpen,\n      style: {\n        height: popoverHeight,\n        width: menuWidth\n      },\n      useLayerForClickAway: false\n    }, this.state.isAutocompleteShown && React.createElement(TextField, {\n      ref: function ref(_ref2) {\n        return _this3.searchTextField = _ref2;\n      },\n      autoFocus: true,\n      hintText: hintTextAutocomplete,\n      inputStyle: autocompleteStyle,\n      onChange: this.handleTextFieldAutocompletionFiltering,\n      onKeyDown: this.handleTextFieldKeyDown,\n      style: {\n        margin: '0 16px 5px',\n        width: 'calc(100% - 32px)'\n      },\n      underlineFocusStyle: autocompleteUnderlineFocusStyle,\n      underlineStyle: autocompleteUnderlineStyle,\n      value: this.state.searchText\n    }), multiple && withResetSelectAllButtons && React.createElement('header', {\n      style: {\n        display: 'flex',\n        alignItems: 'center'\n      }\n    }, React.createElement('div', {\n      onClick: this.selectAll,\n      style: {\n        flex: '50%'\n      }\n    }, selectAllButton), React.createElement('div', {\n      onClick: this.reset,\n      style: {\n        flex: '50%'\n      }\n    }, resetButton)), React.createElement('div', {\n      ref: function ref(_ref3) {\n        return _this3.menu = _ref3;\n      },\n      onKeyDown: this.handleMenuKeyDown,\n      style: menuStyle\n    }, menuItems.length ? React.createElement(InfiniteScroller, {\n      containerHeight: optionsContainerHeight,\n      elementHeight: elementHeight,\n      styles: {\n        scrollableStyle: scrollableStyle\n      },\n      onInfiniteLoad: onInfiniteLoad,\n      infiniteLoadBeginEdgeOffset: infiniteLoadBeginEdgeOffset\n    }, menuItems) : React.createElement(ListItem, {\n      disabled: true,\n      primaryText: noMatchFound,\n      style: _extends({\n        cursor: 'default',\n        padding: '10px 16px'\n      }, noMatchFoundStyle)\n    })), multiple && React.createElement('footer', {\n      style: {\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'flex-end'\n      }\n    }, React.createElement('div', {\n      onClick: this.closeMenu,\n      style: menuFooterStyle\n    }, menuCloseButton))));\n  };\n\n  return SelectField;\n}(Component), _class.contextTypes = {\n  muiTheme: object.isRequired\n}, _class.defaultProps = selectFieldDefaultProps, _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this.onFocus = function () {\n    return _this4.setState({\n      isFocused: true\n    });\n  };\n\n  this.onBlur = function () {\n    return !_this4.state.isOpen && _this4.setState({\n      isFocused: false\n    });\n  };\n\n  this.closeMenu = function (reason) {\n    var _props2 = _this4.props,\n        onChange = _props2.onChange,\n        name = _props2.name;\n    if (reason) _this4.setState({\n      isFocused: false\n    }); // if reason === 'clickaway' or 'offscreen'\n\n    _this4.setState({\n      isOpen: false,\n      searchText: ''\n    }, function () {\n      if (!reason) _this4.root.focus();\n      onChange(_this4.state.selectedItems, name);\n    });\n  };\n\n  this.handleClick = function () {\n    return !_this4.props.disabled && _this4.openMenu();\n  };\n\n  this.handleKeyDown = function (event) {\n    return !_this4.props.disabled && /ArrowDown|Enter/.test(event.key) && _this4.openMenu();\n  };\n\n  this.handleTextFieldAutocompletionFiltering = function (event, searchText) {\n    _this4.props.onAutoCompleteTyping(searchText);\n\n    _this4.setState({\n      searchText: searchText\n    }, function () {\n      return _this4.focusTextField();\n    });\n  };\n\n  this.handleTextFieldKeyDown = function (_ref5) {\n    var key = _ref5.key;\n\n    switch (key) {\n      case 'ArrowDown':\n        _this4.focusMenuItem();\n\n        break;\n\n      case 'Escape':\n        _this4.clearTextField();\n\n        _this4.closeMenu();\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  this.selectAll = function () {\n    var _props3 = _this4.props,\n        children = _props3.children,\n        autocompleteFilter = _props3.autocompleteFilter;\n    var fixedChildren = Array.isArray(children) ? children : [children];\n    var selectedItems = fixedChildren.reduce(function (nodes, child) {\n      var type = child.type,\n          _child$props2 = child.props,\n          value = _child$props2.value,\n          label = _child$props2.label;\n\n      var passesFilter = function passesFilter(label, value) {\n        return autocompleteFilter(_this4.state.searchText, label || value);\n      };\n\n      if (type !== 'optgroup' && passesFilter(label, value)) {\n        return nodes.concat({\n          value: value,\n          label: label\n        });\n      } else if (type === 'optgroup') {\n        var groupedItems = _this4.selectAllInGroup(child);\n\n        return groupedItems.length ? nodes.concat(groupedItems) : nodes;\n      } else return nodes;\n    }, []);\n\n    _this4.setState({\n      selectedItems: selectedItems\n    }, function () {\n      return _this4.getSelected();\n    });\n  };\n\n  this.reset = function () {\n    return _this4.setState(function (prevState) {\n      return {\n        selectedItems: prevState.initialValue\n      };\n    }, function () {\n      return _this4.getSelected();\n    });\n  };\n\n  this.handleMenuSelection = function (selectedItem) {\n    return function (event) {\n      event.preventDefault();\n      var selectedItems = _this4.state.selectedItems;\n\n      if (_this4.props.multiple) {\n        var selectedItemExists = selectedItems.some(function (obj) {\n          return areEqual(obj.value, selectedItem.value);\n        });\n        var updatedValues = selectedItemExists ? selectedItems.filter(function (obj) {\n          return !areEqual(obj.value, selectedItem.value);\n        }) : selectedItems.concat(selectedItem);\n\n        _this4.setState({\n          selectedItems: updatedValues\n        }, function () {\n          return _this4.getSelected();\n        });\n\n        _this4.clearTextField(function () {\n          return _this4.focusTextField();\n        });\n      } else {\n        var updatedValue = areEqual(selectedItems, selectedItem) ? null : selectedItem;\n\n        _this4.setState({\n          selectedItems: updatedValue\n        }, function () {\n          return _this4.closeMenu();\n        });\n      }\n    };\n  };\n\n  this.getSelected = function () {\n    return _this4.props.onSelect && _this4.props.onSelect(_this4.state.selectedItems, _this4.props.name);\n  };\n\n  this.selectAllInGroup = function (group) {\n    var children = group.props.children;\n\n    var passesFilter = function passesFilter(label, value) {\n      return _this4.props.autocompleteFilter(_this4.state.searchText, label || value);\n    };\n\n    var fixedChildren = Array.isArray(children) ? children : [children];\n    return fixedChildren.reduce(function (nodes, _ref6) {\n      var _ref6$props = _ref6.props,\n          value = _ref6$props.value,\n          label = _ref6$props.label;\n      return passesFilter(label, value) ? nodes.concat({\n        value: value,\n        label: label\n      }) : nodes;\n    }, []);\n  };\n\n  this.handleMenuKeyDown = function (_ref7) {\n    var key = _ref7.key,\n        tabIndex = _ref7.target.tabIndex;\n\n    var cleanMenuItems = _this4.menuItems.filter(function (item) {\n      return !!item;\n    });\n\n    var firstTabIndex = cleanMenuItems[0].props.tabIndex;\n    var lastTabIndex = cleanMenuItems[cleanMenuItems.length - 1].props.tabIndex;\n    var currentElementIndex = cleanMenuItems.findIndex(function (item) {\n      return item.props.tabIndex === tabIndex;\n    });\n\n    switch (key) {\n      case 'ArrowUp':\n        if (+tabIndex === firstTabIndex) {\n          _this4.state.isAutocompleteShown ? _this4.focusTextField() : _this4.focusMenuItem(lastTabIndex);\n        } else {\n          var previousTabIndex = cleanMenuItems.slice(0, currentElementIndex).slice(-1)[0].props.tabIndex;\n\n          _this4.focusMenuItem(previousTabIndex);\n        }\n\n        break;\n\n      case 'ArrowDown':\n        if (+tabIndex === lastTabIndex) {\n          _this4.state.isAutocompleteShown ? _this4.focusTextField() : _this4.focusMenuItem();\n        } else {\n          var nextTabIndex = cleanMenuItems.slice(currentElementIndex + 1)[0].props.tabIndex;\n\n          _this4.focusMenuItem(nextTabIndex);\n        }\n\n        break;\n\n      case 'PageUp':\n        _this4.focusMenuItem();\n\n        break;\n\n      case 'PageDown':\n        _this4.focusMenuItem(lastTabIndex);\n\n        break;\n\n      case 'Escape':\n        _this4.closeMenu();\n\n        break;\n\n      default:\n        break;\n    }\n  };\n}, _temp);\nexport { SelectField as default };\nSelectField.propTypes = process.env.NODE_ENV !== \"production\" ? selectFieldTypes : {};","map":null,"metadata":{},"sourceType":"module"}