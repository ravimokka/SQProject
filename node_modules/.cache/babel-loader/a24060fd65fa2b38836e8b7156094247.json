{"ast":null,"code":"// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\nvar GeoJSON = {\n  // convert a GeoJSON object to a PolyBool polygon\n  toPolygon: function (PolyBool, geojson) {\n    // converts list of LineString's to segments\n    function GeoPoly(coords) {\n      // check for empty coords\n      if (coords.length <= 0) return PolyBool.segments({\n        inverted: false,\n        regions: []\n      }); // convert LineString to segments\n\n      function LineString(ls) {\n        // remove tail which should be the same as head\n        var reg = ls.slice(0, ls.length - 1);\n        return PolyBool.segments({\n          inverted: false,\n          regions: [reg]\n        });\n      } // the first LineString is considered the outside\n\n\n      var out = LineString(coords[0]); // the rest of the LineStrings are considered interior holes, so subtract them from the\n      // current result\n\n      for (var i = 1; i < coords.length; i++) out = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n      return out;\n    }\n\n    if (geojson.type === 'Polygon') {\n      // single polygon, so just convert it and we're done\n      return PolyBool.polygon(GeoPoly(geojson.coordinates));\n    } else if (geojson.type === 'MultiPolygon') {\n      // multiple polygons, so union all the polygons together\n      var out = PolyBool.segments({\n        inverted: false,\n        regions: []\n      });\n\n      for (var i = 0; i < geojson.coordinates.length; i++) out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\n      return PolyBool.polygon(out);\n    }\n\n    throw new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n  },\n  // convert a PolyBool polygon to a GeoJSON object\n  fromPolygon: function (PolyBool, eps, poly) {\n    // make sure out polygon is clean\n    poly = PolyBool.polygon(PolyBool.segments(poly)); // test if r1 is inside r2\n\n    function regionInsideRegion(r1, r2) {\n      // we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n      // could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n      // edge of the first line, which cannot be on an edge\n      return eps.pointInsideRegion([(r1[0][0] + r1[1][0]) * 0.5, (r1[0][1] + r1[1][1]) * 0.5], r2);\n    } // calculate inside heirarchy\n    //\n    //  _____________________   _______    roots -> A       -> F\n    // |          A          | |   F   |            |          |\n    // |  _______   _______  | |  ___  |            +-- B      +-- G\n    // | |   B   | |   C   | | | |   | |            |   |\n    // | |  ___  | |  ___  | | | |   | |            |   +-- D\n    // | | | D | | | | E | | | | | G | |            |\n    // | | |___| | | |___| | | | |   | |            +-- C\n    // | |_______| |_______| | | |___| |                |\n    // |_____________________| |_______|                +-- E\n\n\n    function newNode(region) {\n      return {\n        region: region,\n        children: []\n      };\n    }\n\n    var roots = newNode(null);\n\n    function addChild(root, region) {\n      // first check if we're inside any children\n      for (var i = 0; i < root.children.length; i++) {\n        var child = root.children[i];\n\n        if (regionInsideRegion(region, child.region)) {\n          // we are, so insert inside them instead\n          addChild(child, region);\n          return;\n        }\n      } // not inside any children, so check to see if any children are inside us\n\n\n      var node = newNode(region);\n\n      for (var i = 0; i < root.children.length; i++) {\n        var child = root.children[i];\n\n        if (regionInsideRegion(child.region, region)) {\n          // oops... move the child beneath us, and remove them from root\n          node.children.push(child);\n          root.children.splice(i, 1);\n          i--;\n        }\n      } // now we can add ourselves\n\n\n      root.children.push(node);\n    } // add all regions to the root\n\n\n    for (var i = 0; i < poly.regions.length; i++) {\n      var region = poly.regions[i];\n      if (region.length < 3) // regions must have at least 3 points (sanity check)\n        continue;\n      addChild(roots, region);\n    } // with our heirarchy, we can distinguish between exterior borders, and interior holes\n    // the root nodes are exterior, children are interior, children's children are exterior,\n    // children's children's children are interior, etc\n    // while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\n    function forceWinding(region, clockwise) {\n      // first, see if we're clockwise or counter-clockwise\n      // https://en.wikipedia.org/wiki/Shoelace_formula\n      var winding = 0;\n      var last_x = region[region.length - 1][0];\n      var last_y = region[region.length - 1][1];\n      var copy = [];\n\n      for (var i = 0; i < region.length; i++) {\n        var curr_x = region[i][0];\n        var curr_y = region[i][1];\n        copy.push([curr_x, curr_y]); // create a copy while we're at it\n\n        winding += curr_y * last_x - curr_x * last_y;\n        last_x = curr_x;\n        last_y = curr_y;\n      } // this assumes Cartesian coordinates (Y is positive going up)\n\n\n      var isclockwise = winding < 0;\n      if (isclockwise !== clockwise) copy.reverse(); // while we're here, the last point must be the first point...\n\n      copy.push([copy[0][0], copy[0][1]]);\n      return copy;\n    }\n\n    var geopolys = [];\n\n    function addExterior(node) {\n      var poly = [forceWinding(node.region, false)];\n      geopolys.push(poly); // children of exteriors are interior\n\n      for (var i = 0; i < node.children.length; i++) poly.push(getInterior(node.children[i]));\n    }\n\n    function getInterior(node) {\n      // children of interiors are exterior\n      for (var i = 0; i < node.children.length; i++) addExterior(node.children[i]); // return the clockwise interior\n\n\n      return forceWinding(node.region, true);\n    } // root nodes are exterior\n\n\n    for (var i = 0; i < roots.children.length; i++) addExterior(roots.children[i]); // lastly, construct the approrpriate GeoJSON object\n\n\n    if (geopolys.length <= 0) // empty GeoJSON Polygon\n      return {\n        type: 'Polygon',\n        coordinates: []\n      };\n    if (geopolys.length == 1) // use a GeoJSON Polygon\n      return {\n        type: 'Polygon',\n        coordinates: geopolys[0]\n      };\n    return {\n      // otherwise, use a GeoJSON MultiPolygon\n      type: 'MultiPolygon',\n      coordinates: geopolys\n    };\n  }\n};\nmodule.exports = GeoJSON;","map":null,"metadata":{},"sourceType":"script"}