{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Fx = require('../fx');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar dragElement = require('../dragelement');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head'); // Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  drawRaw: drawRaw\n};\n/*\n * draw: draw all annotations without any new modifications\n */\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  fullLayout._infolayer.selectAll('.annotation').remove();\n\n  for (var i = 0; i < fullLayout.annotations.length; i++) {\n    if (fullLayout.annotations[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n\n  return Plots.previousPromises(gd);\n}\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\n\n\nfunction drawOne(gd, index) {\n  var fullLayout = gd._fullLayout;\n  var options = fullLayout.annotations[index] || {};\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  if (xa) xa.setScale();\n  if (ya) ya.setScale();\n  drawRaw(gd, options, index, false, xa, ya);\n}\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\n\n\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n  var fullLayout = gd._fullLayout;\n  var gs = gd._fullLayout._size;\n  var edits = gd._context.edits;\n  var className, containerStr;\n\n  if (subplotId) {\n    className = 'annotation-' + subplotId;\n    containerStr = subplotId + '.annotations';\n  } else {\n    className = 'annotation';\n    containerStr = 'annotations';\n  }\n\n  var editHelpers = arrayEditor(gd.layout, containerStr, options);\n  var modifyBase = editHelpers.modifyBase;\n  var modifyItem = editHelpers.modifyItem;\n  var getUpdateObj = editHelpers.getUpdateObj; // remove the existing annotation if there is one\n\n  fullLayout._infolayer.selectAll('.' + className + '[data-index=\"' + index + '\"]').remove();\n\n  var annClipID = 'clip' + fullLayout._uid + '_ann' + index; // this annotation is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n\n  if (!options._input || options.visible === false) {\n    d3.selectAll('#' + annClipID).remove();\n    return;\n  } // calculated pixel positions\n  // x & y each will get text, head, and tail as appropriate\n\n\n  var annPosPx = {\n    x: {},\n    y: {}\n  };\n  var textangle = +options.textangle || 0; // create the components\n  // made a single group to contain all, so opacity can work right\n  // with border/arrow together this could handle a whole bunch of\n  // cleanup at this point, but works for now\n\n  var annGroup = fullLayout._infolayer.append('g').classed(className, true).attr('data-index', String(index)).style('opacity', options.opacity); // another group for text+background so that they can rotate together\n\n\n  var annTextGroup = annGroup.append('g').classed('annotation-text-g', true);\n  var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n  var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n  function makeEventData(initialEvent) {\n    var eventData = {\n      index: index,\n      annotation: options._input,\n      fullAnnotation: options,\n      event: initialEvent\n    };\n\n    if (subplotId) {\n      eventData.subplotId = subplotId;\n    }\n\n    return eventData;\n  }\n\n  var annTextGroupInner = annTextGroup.append('g').style('pointer-events', textEvents ? 'all' : null).call(setCursor, 'pointer').on('click', function () {\n    gd._dragging = false;\n    gd.emit('plotly_clickannotation', makeEventData(d3.event));\n  });\n\n  if (options.hovertext) {\n    annTextGroupInner.on('mouseover', function () {\n      var hoverOptions = options.hoverlabel;\n      var hoverFont = hoverOptions.font;\n      var bBox = this.getBoundingClientRect();\n      var bBoxRef = gd.getBoundingClientRect();\n      Fx.loneHover({\n        x0: bBox.left - bBoxRef.left,\n        x1: bBox.right - bBoxRef.left,\n        y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n        text: options.hovertext,\n        color: hoverOptions.bgcolor,\n        borderColor: hoverOptions.bordercolor,\n        fontFamily: hoverFont.family,\n        fontSize: hoverFont.size,\n        fontColor: hoverFont.color\n      }, {\n        container: fullLayout._hoverlayer.node(),\n        outerContainer: fullLayout._paper.node(),\n        gd: gd\n      });\n    }).on('mouseout', function () {\n      Fx.loneUnhover(fullLayout._hoverlayer.node());\n    });\n  }\n\n  var borderwidth = options.borderwidth;\n  var borderpad = options.borderpad;\n  var borderfull = borderwidth + borderpad;\n  var annTextBG = annTextGroupInner.append('rect').attr('class', 'bg').style('stroke-width', borderwidth + 'px').call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);\n  var isSizeConstrained = options.width || options.height;\n\n  var annTextClip = fullLayout._topclips.selectAll('#' + annClipID).data(isSizeConstrained ? [0] : []);\n\n  annTextClip.enter().append('clipPath').classed('annclip', true).attr('id', annClipID).append('rect');\n  annTextClip.exit().remove();\n  var font = options.font;\n  var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;\n  var annText = annTextGroupInner.append('text').classed('annotation-text', true).text(text);\n\n  function textLayout(s) {\n    s.call(Drawing.font, font).attr({\n      'text-anchor': {\n        left: 'start',\n        right: 'end'\n      }[options.align] || 'middle'\n    });\n    svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n    return s;\n  }\n\n  function drawGraphicalElements() {\n    // if the text has *only* a link, make the whole box into a link\n    var anchor3 = annText.selectAll('a');\n\n    if (anchor3.size() === 1 && anchor3.text() === annText.text()) {\n      var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n        'xlink:xlink:href': anchor3.attr('xlink:href'),\n        'xlink:xlink:show': anchor3.attr('xlink:show')\n      }).style({\n        cursor: 'pointer'\n      });\n      wholeLink.node().appendChild(annTextBG.node());\n    }\n\n    var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n    var hasMathjax = !mathjaxGroup.empty();\n    var anntextBB = Drawing.bBox((hasMathjax ? mathjaxGroup : annText).node());\n    var textWidth = anntextBB.width;\n    var textHeight = anntextBB.height;\n    var annWidth = options.width || textWidth;\n    var annHeight = options.height || textHeight;\n    var outerWidth = Math.round(annWidth + 2 * borderfull);\n    var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n    function shiftFraction(v, anchor) {\n      if (anchor === 'auto') {\n        if (v < 1 / 3) anchor = 'left';else if (v > 2 / 3) anchor = 'right';else anchor = 'center';\n      }\n\n      return {\n        center: 0,\n        middle: 0,\n        left: 0.5,\n        bottom: -0.5,\n        right: -0.5,\n        top: 0.5\n      }[anchor];\n    }\n\n    var annotationIsOffscreen = false;\n    var letters = ['x', 'y'];\n\n    for (var i = 0; i < letters.length; i++) {\n      var axLetter = letters[i];\n      var axRef = options[axLetter + 'ref'] || axLetter;\n      var tailRef = options['a' + axLetter + 'ref'];\n      var ax = {\n        x: xa,\n        y: ya\n      }[axLetter];\n      var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180; // note that these two can be either positive or negative\n\n      var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n      var annSizeFromHeight = outerHeight * Math.sin(dimAngle); // but this one is the positive total size\n\n      var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n      var anchor = options[axLetter + 'anchor'];\n      var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n      var posPx = annPosPx[axLetter];\n      var basePx;\n      var textPadShift;\n      var alignPosition;\n      var autoAlignFraction;\n      var textShift;\n      /*\n       * calculate the *primary* pixel position\n       * which is the arrowhead if there is one,\n       * otherwise the text anchor point\n       */\n\n      if (ax) {\n        // check if annotation is off screen, to bypass DOM manipulations\n        var posFraction = ax.r2fraction(options[axLetter]);\n\n        if (posFraction < 0 || posFraction > 1) {\n          if (tailRef === axRef) {\n            posFraction = ax.r2fraction(options['a' + axLetter]);\n\n            if (posFraction < 0 || posFraction > 1) {\n              annotationIsOffscreen = true;\n            }\n          } else {\n            annotationIsOffscreen = true;\n          }\n        }\n\n        basePx = ax._offset + ax.r2p(options[axLetter]);\n        autoAlignFraction = 0.5;\n      } else {\n        if (axLetter === 'x') {\n          alignPosition = options[axLetter];\n          basePx = gs.l + gs.w * alignPosition;\n        } else {\n          alignPosition = 1 - options[axLetter];\n          basePx = gs.t + gs.h * alignPosition;\n        }\n\n        autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n      } // now translate this into pixel positions of head, tail, and text\n      // as well as paddings for autorange\n\n\n      if (options.showarrow) {\n        posPx.head = basePx;\n        var arrowLength = options['a' + axLetter]; // with an arrow, the text rotates around the anchor point\n\n        textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n        if (tailRef === axRef) {\n          posPx.tail = ax._offset + ax.r2p(arrowLength); // tail is data-referenced: autorange pads the text in px from the tail\n\n          textPadShift = textShift;\n        } else {\n          posPx.tail = basePx + arrowLength; // tail is specified in px from head, so autorange also pads vs head\n\n          textPadShift = textShift + arrowLength;\n        }\n\n        posPx.text = posPx.tail + textShift; // constrain pixel/paper referenced so the draggers are at least\n        // partially visible\n\n        var maxPx = fullLayout[axLetter === 'x' ? 'width' : 'height'];\n\n        if (axRef === 'paper') {\n          posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n        }\n\n        if (tailRef === 'pixel') {\n          var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n          var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n\n          if (shiftPlus > 0) {\n            posPx.tail += shiftPlus;\n            posPx.text += shiftPlus;\n          } else if (shiftMinus > 0) {\n            posPx.tail -= shiftMinus;\n            posPx.text -= shiftMinus;\n          }\n        }\n\n        posPx.tail += overallShift;\n        posPx.head += overallShift;\n      } else {\n        // with no arrow, the text rotates and *then* we put the anchor\n        // relative to the new bounding box\n        textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n        textPadShift = textShift;\n        posPx.text = basePx + textShift;\n      }\n\n      posPx.text += overallShift;\n      textShift += overallShift;\n      textPadShift += overallShift; // padplus/minus are used by autorange\n\n      options['_' + axLetter + 'padplus'] = annSize / 2 + textPadShift;\n      options['_' + axLetter + 'padminus'] = annSize / 2 - textPadShift; // size/shift are used during dragging\n\n      options['_' + axLetter + 'size'] = annSize;\n      options['_' + axLetter + 'shift'] = textShift;\n    }\n\n    if (annotationIsOffscreen) {\n      annTextGroupInner.remove();\n      return;\n    }\n\n    var xShift = 0;\n    var yShift = 0;\n\n    if (options.align !== 'left') {\n      xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n    }\n\n    if (options.valign !== 'top') {\n      yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n    }\n\n    if (hasMathjax) {\n      mathjaxGroup.select('svg').attr({\n        x: borderfull + xShift - 1,\n        y: borderfull + yShift\n      }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    } else {\n      var texty = borderfull + yShift - anntextBB.top;\n      var textx = borderfull + xShift - anntextBB.left;\n      annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    }\n\n    annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull, annWidth, annHeight);\n    annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2, outerWidth - borderwidth, outerHeight - borderwidth);\n    annTextGroupInner.call(Drawing.setTranslate, Math.round(annPosPx.x.text - outerWidth / 2), Math.round(annPosPx.y.text - outerHeight / 2));\n    /*\n     * rotate text and background\n     * we already calculated the text center position *as rotated*\n     * because we needed that for autoranging anyway, so now whether\n     * we have an arrow or not, we rotate about the text center.\n     */\n\n    annTextGroup.attr({\n      transform: 'rotate(' + textangle + ',' + annPosPx.x.text + ',' + annPosPx.y.text + ')'\n    });\n    /*\n     * add the arrow\n     * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n     * dx and dy are normally zero, but when you are dragging the textbox\n     * while the head stays put, dx and dy are the pixel offsets\n     */\n\n    var drawArrow = function (dx, dy) {\n      annGroup.selectAll('.annotation-arrow-g').remove();\n      var headX = annPosPx.x.head;\n      var headY = annPosPx.y.head;\n      var tailX = annPosPx.x.tail + dx;\n      var tailY = annPosPx.y.tail + dy;\n      var textX = annPosPx.x.text + dx;\n      var textY = annPosPx.y.text + dy; // find the edge of the text box, where we'll start the arrow:\n      // create transform matrix to rotate the text box corners\n\n      var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n      var applyTransform = Lib.apply2DTransform(transform);\n      var applyTransform2 = Lib.apply2DTransform2(transform); // calculate and transform bounding box\n\n      var width = +annTextBG.attr('width');\n      var height = +annTextBG.attr('height');\n      var xLeft = textX - 0.5 * width;\n      var xRight = xLeft + width;\n      var yTop = textY - 0.5 * height;\n      var yBottom = yTop + height;\n      var edges = [[xLeft, yTop, xLeft, yBottom], [xLeft, yBottom, xRight, yBottom], [xRight, yBottom, xRight, yTop], [xRight, yTop, xLeft, yTop]].map(applyTransform2); // Remove the line if it ends inside the box.  Use ray\n      // casting for rotated boxes: see which edges intersect a\n      // line from the arrowhead to far away and reduce with xor\n      // to get the parity of the number of intersections.\n\n      if (edges.reduce(function (a, x) {\n        return a ^ !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6, x[0], x[1], x[2], x[3]);\n      }, false)) {\n        // no line or arrow - so quit drawArrow now\n        return;\n      }\n\n      edges.forEach(function (x) {\n        var p = Lib.segmentsIntersect(tailX, tailY, headX, headY, x[0], x[1], x[2], x[3]);\n\n        if (p) {\n          tailX = p.x;\n          tailY = p.y;\n        }\n      });\n      var strokewidth = options.arrowwidth;\n      var arrowColor = options.arrowcolor;\n      var arrowSide = options.arrowside;\n      var arrowGroup = annGroup.append('g').style({\n        opacity: Color.opacity(arrowColor)\n      }).classed('annotation-arrow-g', true);\n      var arrow = arrowGroup.append('path').attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY).style('stroke-width', strokewidth + 'px').call(Color.stroke, Color.rgb(arrowColor));\n      drawArrowHead(arrow, arrowSide, options); // the arrow dragger is a small square right at the head, then a line to the tail,\n      // all expanded by a stroke width of 6px plus the arrow line width\n\n      if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n        var arrowDragHeadX = headX;\n        var arrowDragHeadY = headY;\n\n        if (options.standoff) {\n          var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n          arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n          arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n        }\n\n        var arrowDrag = arrowGroup.append('path').classed('annotation-arrow', true).classed('anndrag', true).classed('cursor-move', true).attr({\n          d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n          transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'\n        }).style('stroke-width', strokewidth + 6 + 'px').call(Color.stroke, 'rgba(0,0,0,0)').call(Color.fill, 'rgba(0,0,0,0)');\n        var annx0, anny0; // dragger for the arrow & head: translates the whole thing\n        // (head/tail/text) all together\n\n        dragElement.init({\n          element: arrowDrag.node(),\n          gd: gd,\n          prepFn: function () {\n            var pos = Drawing.getTranslate(annTextGroupInner);\n            annx0 = pos.x;\n            anny0 = pos.y;\n\n            if (xa && xa.autorange) {\n              modifyBase(xa._name + '.autorange', true);\n            }\n\n            if (ya && ya.autorange) {\n              modifyBase(ya._name + '.autorange', true);\n            }\n          },\n          moveFn: function (dx, dy) {\n            var annxy0 = applyTransform(annx0, anny0);\n            var xcenter = annxy0[0] + dx;\n            var ycenter = annxy0[1] + dy;\n            annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n            modifyItem('x', xa ? xa.p2r(xa.r2p(options.x) + dx) : options.x + dx / gs.w);\n            modifyItem('y', ya ? ya.p2r(ya.r2p(options.y) + dy) : options.y - dy / gs.h);\n\n            if (options.axref === options.xref) {\n              modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n            }\n\n            if (options.ayref === options.yref) {\n              modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n            }\n\n            arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n            annTextGroup.attr({\n              transform: 'rotate(' + textangle + ',' + xcenter + ',' + ycenter + ')'\n            });\n          },\n          doneFn: function () {\n            Registry.call('_guiRelayout', gd, getUpdateObj());\n            var notesBox = document.querySelector('.js-notes-box-panel');\n            if (notesBox) notesBox.redraw(notesBox.selectedObj);\n          }\n        });\n      }\n    };\n\n    if (options.showarrow) drawArrow(0, 0); // user dragging the annotation (text, not arrow)\n\n    if (editTextPosition) {\n      var baseTextTransform; // dragger for the textbox: if there's an arrow, just drag the\n      // textbox and tail, leave the head untouched\n\n      dragElement.init({\n        element: annTextGroupInner.node(),\n        gd: gd,\n        prepFn: function () {\n          baseTextTransform = annTextGroup.attr('transform');\n        },\n        moveFn: function (dx, dy) {\n          var csr = 'pointer';\n\n          if (options.showarrow) {\n            if (options.axref === options.xref) {\n              modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n            } else {\n              modifyItem('ax', options.ax + dx);\n            }\n\n            if (options.ayref === options.yref) {\n              modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n            } else {\n              modifyItem('ay', options.ay + dy);\n            }\n\n            drawArrow(dx, dy);\n          } else if (!subplotId) {\n            var xUpdate, yUpdate;\n\n            if (xa) {\n              xUpdate = xa.p2r(xa.r2p(options.x) + dx);\n            } else {\n              var widthFraction = options._xsize / gs.w;\n              var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n              xUpdate = dragElement.align(xLeft + dx / gs.w, widthFraction, 0, 1, options.xanchor);\n            }\n\n            if (ya) {\n              yUpdate = ya.p2r(ya.r2p(options.y) + dy);\n            } else {\n              var heightFraction = options._ysize / gs.h;\n              var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n              yUpdate = dragElement.align(yBottom - dy / gs.h, heightFraction, 0, 1, options.yanchor);\n            }\n\n            modifyItem('x', xUpdate);\n            modifyItem('y', yUpdate);\n\n            if (!xa || !ya) {\n              csr = dragElement.getCursor(xa ? 0.5 : xUpdate, ya ? 0.5 : yUpdate, options.xanchor, options.yanchor);\n            }\n          } else return;\n\n          annTextGroup.attr({\n            transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform\n          });\n          setCursor(annTextGroupInner, csr);\n        },\n        clickFn: function (_, initialEvent) {\n          if (options.captureevents) {\n            gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n          }\n        },\n        doneFn: function () {\n          setCursor(annTextGroupInner);\n          Registry.call('_guiRelayout', gd, getUpdateObj());\n          var notesBox = document.querySelector('.js-notes-box-panel');\n          if (notesBox) notesBox.redraw(notesBox.selectedObj);\n        }\n      });\n    }\n  }\n\n  if (edits.annotationText) {\n    annText.call(svgTextUtils.makeEditable, {\n      delegate: annTextGroupInner,\n      gd: gd\n    }).call(textLayout).on('edit', function (_text) {\n      options.text = _text;\n      this.call(textLayout);\n      modifyItem('text', _text);\n\n      if (xa && xa.autorange) {\n        modifyBase(xa._name + '.autorange', true);\n      }\n\n      if (ya && ya.autorange) {\n        modifyBase(ya._name + '.autorange', true);\n      }\n\n      Registry.call('_guiRelayout', gd, getUpdateObj());\n    });\n  } else annText.call(textLayout);\n}","map":null,"metadata":{},"sourceType":"script"}