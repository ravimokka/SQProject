{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar makeComputeError = require('./compute_error');\n\nmodule.exports = function calc(gd) {\n  var calcdata = gd.calcdata;\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var calcTrace = calcdata[i];\n    var trace = calcTrace[0].trace;\n\n    if (trace.visible === true && Registry.traceIs(trace, 'errorBarsOK')) {\n      var xa = Axes.getFromId(gd, trace.xaxis);\n      var ya = Axes.getFromId(gd, trace.yaxis);\n      calcOneAxis(calcTrace, trace, xa, 'x');\n      calcOneAxis(calcTrace, trace, ya, 'y');\n    }\n  }\n};\n\nfunction calcOneAxis(calcTrace, trace, axis, coord) {\n  var opts = trace['error_' + coord] || {};\n  var isVisible = opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1;\n  var vals = [];\n  if (!isVisible) return;\n  var computeError = makeComputeError(opts);\n\n  for (var i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    var iIn = calcPt.i; // for types that don't include `i` in each calcdata point\n\n    if (iIn === undefined) iIn = i; // for stacked area inserted points\n    // TODO: errorbars have been tested cursorily with stacked area,\n    // but not thoroughly. It's not even really clear what you want to do:\n    // Should it just be calculated based on that trace's size data?\n    // Should you add errors from below in quadrature?\n    // And what about normalization, where in principle the errors shrink\n    // again when you get up to the top end?\n    // One option would be to forbid errorbars with stacking until we\n    // decide how to handle these questions.\n    else if (iIn === null) continue;\n    var calcCoord = calcPt[coord];\n    if (!isNumeric(axis.c2l(calcCoord))) continue;\n    var errors = computeError(calcCoord, iIn);\n\n    if (isNumeric(errors[0]) && isNumeric(errors[1])) {\n      var shoe = calcPt[coord + 's'] = calcCoord - errors[0];\n      var hat = calcPt[coord + 'h'] = calcCoord + errors[1];\n      vals.push(shoe, hat);\n    }\n  }\n\n  var axId = axis._id;\n  var baseExtremes = trace._extremes[axId];\n  var extremes = Axes.findExtremes(axis, vals, Lib.extendFlat({\n    tozero: baseExtremes.opts.tozero\n  }, {\n    padded: true\n  }));\n  baseExtremes.min = baseExtremes.min.concat(extremes.min);\n  baseExtremes.max = baseExtremes.max.concat(extremes.max);\n}","map":null,"metadata":{},"sourceType":"script"}