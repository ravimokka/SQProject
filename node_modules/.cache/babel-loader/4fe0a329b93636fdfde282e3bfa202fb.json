{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plots = require('../../plots/plots');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar constants = require('./constants');\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nmodule.exports = function draw(gd) {\n  var fullLayout = gd._fullLayout;\n  var sliderData = makeSliderData(fullLayout, gd); // draw a container for *all* sliders:\n\n  var sliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);\n\n  sliders.enter().append('g').classed(constants.containerClassName, true).style('cursor', 'ew-resize');\n\n  function clearSlider(sliderOpts) {\n    if (sliderOpts._commandObserver) {\n      sliderOpts._commandObserver.remove();\n\n      delete sliderOpts._commandObserver;\n    } // Most components don't need to explicitly remove autoMargin, because\n    // marginPushers does this - but slider updates don't go through\n    // a full replot so we need to explicitly remove it.\n\n\n    Plots.autoMargin(gd, autoMarginId(sliderOpts));\n  }\n\n  sliders.exit().each(function () {\n    d3.select(this).selectAll('g.' + constants.groupClassName).each(clearSlider);\n  }).remove(); // Return early if no menus visible:\n\n  if (sliderData.length === 0) return;\n  var sliderGroups = sliders.selectAll('g.' + constants.groupClassName).data(sliderData, keyFunction);\n  sliderGroups.enter().append('g').classed(constants.groupClassName, true);\n  sliderGroups.exit().each(clearSlider).remove(); // Find the dimensions of the sliders:\n\n  for (var i = 0; i < sliderData.length; i++) {\n    var sliderOpts = sliderData[i];\n    findDimensions(gd, sliderOpts);\n  }\n\n  sliderGroups.each(function (sliderOpts) {\n    var gSlider = d3.select(this);\n    computeLabelSteps(sliderOpts);\n    Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function (data) {\n      // NB: Same as below. This is *not* always the same as sliderOpts since\n      // if a new set of steps comes in, the reference in this callback would\n      // be invalid. We need to refetch it from the slider group, which is\n      // the join data that creates this slider. So if this slider still exists,\n      // the group should be valid, *to the best of my knowledge.* If not,\n      // we'd have to look it up by d3 data join index/key.\n      var opts = gSlider.data()[0];\n      if (opts.active === data.index) return;\n      if (opts._dragging) return;\n      setActive(gd, gSlider, opts, data.index, false, true);\n    });\n    drawSlider(gd, d3.select(this), sliderOpts);\n  });\n};\n\nfunction autoMarginId(sliderOpts) {\n  return constants.autoMarginIdRoot + sliderOpts._index;\n} // This really only just filters by visibility:\n\n\nfunction makeSliderData(fullLayout, gd) {\n  var contOpts = fullLayout[constants.name];\n  var sliderData = [];\n\n  for (var i = 0; i < contOpts.length; i++) {\n    var item = contOpts[i];\n    if (!item.visible) continue;\n    item._gd = gd;\n    sliderData.push(item);\n  }\n\n  return sliderData;\n} // This is set in the defaults step:\n\n\nfunction keyFunction(opts) {\n  return opts._index;\n} // Compute the dimensions (mutates sliderOpts):\n\n\nfunction findDimensions(gd, sliderOpts) {\n  var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass).data(sliderOpts._visibleSteps);\n  sliderLabels.enter().append('g').classed(constants.labelGroupClass, true); // loop over fake buttons to find width / height\n\n  var maxLabelWidth = 0;\n  var labelHeight = 0;\n  sliderLabels.each(function (stepOpts) {\n    var labelGroup = d3.select(this);\n    var text = drawLabel(labelGroup, {\n      step: stepOpts\n    }, sliderOpts);\n    var textNode = text.node();\n\n    if (textNode) {\n      var bBox = Drawing.bBox(textNode);\n      labelHeight = Math.max(labelHeight, bBox.height);\n      maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n    }\n  });\n  sliderLabels.remove();\n  var dims = sliderOpts._dims = {};\n  dims.inputAreaWidth = Math.max(constants.railWidth, constants.gripHeight); // calculate some overall dimensions - some of these are needed for\n  // calculating the currentValue dimensions\n\n  var graphSize = gd._fullLayout._size;\n  dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n  dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n\n  if (sliderOpts.lenmode === 'fraction') {\n    // fraction:\n    dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n  } else {\n    // pixels:\n    dims.outerLength = sliderOpts.len;\n  } // The length of the rail, *excluding* padding on either end:\n\n\n  dims.inputAreaStart = 0;\n  dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n  var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n  var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n  var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n  dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n  dims.labelHeight = labelHeight; // loop over all possible values for currentValue to find the\n  // area we need for it\n\n  dims.currentValueMaxWidth = 0;\n  dims.currentValueHeight = 0;\n  dims.currentValueTotalHeight = 0;\n  dims.currentValueMaxLines = 1;\n\n  if (sliderOpts.currentvalue.visible) {\n    // Get the dimensions of the current value label:\n    var dummyGroup = Drawing.tester.append('g');\n    sliderLabels.each(function (stepOpts) {\n      var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n      var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || {\n        width: 0,\n        height: 0\n      };\n      var lines = svgTextUtils.lineCount(curValPrefix);\n      dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n      dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n      dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n    });\n    dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n    dummyGroup.remove();\n  }\n\n  dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n  var xanchor = 'left';\n\n  if (Lib.isRightAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength;\n    xanchor = 'right';\n  }\n\n  if (Lib.isCenterAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength / 2;\n    xanchor = 'center';\n  }\n\n  var yanchor = 'top';\n\n  if (Lib.isBottomAnchor(sliderOpts)) {\n    dims.ly -= dims.height;\n    yanchor = 'bottom';\n  }\n\n  if (Lib.isMiddleAnchor(sliderOpts)) {\n    dims.ly -= dims.height / 2;\n    yanchor = 'middle';\n  }\n\n  dims.outerLength = Math.ceil(dims.outerLength);\n  dims.height = Math.ceil(dims.height);\n  dims.lx = Math.round(dims.lx);\n  dims.ly = Math.round(dims.ly);\n  var marginOpts = {\n    y: sliderOpts.y,\n    b: dims.height * FROM_BR[yanchor],\n    t: dims.height * FROM_TL[yanchor]\n  };\n\n  if (sliderOpts.lenmode === 'fraction') {\n    marginOpts.l = 0;\n    marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n    marginOpts.r = 0;\n    marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n  } else {\n    marginOpts.x = sliderOpts.x;\n    marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n    marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n  }\n\n  Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\n\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n  // This is related to the other long notes in this file regarding what happens\n  // when slider steps disappear. This particular fix handles what happens when\n  // the *current* slider step is removed. The drawing functions will error out\n  // when they fail to find it, so the fix for now is that it will just draw the\n  // slider in the first position but will not execute the command.\n  if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {\n    sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n  } // These are carefully ordered for proper z-ordering:\n\n\n  sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);\n  var dims = sliderOpts._dims; // Position the rectangle:\n\n  Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n  sliderGroup.call(setGripPosition, sliderOpts, false);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n}\n\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n  if (!sliderOpts.currentvalue.visible) return;\n  var dims = sliderOpts._dims;\n  var x0, textAnchor;\n\n  switch (sliderOpts.currentvalue.xanchor) {\n    case 'right':\n      // This is anchored left and adjusted by the width of the longest label\n      // so that the prefix doesn't move. The goal of this is to emphasize\n      // what's actually changing and make the update less distracting.\n      x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n      textAnchor = 'left';\n      break;\n\n    case 'center':\n      x0 = dims.inputAreaLength * 0.5;\n      textAnchor = 'middle';\n      break;\n\n    default:\n      x0 = constants.currentValueInset;\n      textAnchor = 'left';\n  }\n\n  var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function (s) {\n    s.classed('user-select-none', true).attr({\n      'text-anchor': textAnchor,\n      'data-notex': 1\n    });\n  });\n  var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n\n  if (typeof valueOverride === 'string') {\n    str += valueOverride;\n  } else {\n    var curVal = sliderOpts.steps[sliderOpts.active].label;\n    var _meta = sliderOpts._gd._fullLayout._meta;\n    if (_meta) curVal = Lib.templateString(curVal, _meta);\n    str += curVal;\n  }\n\n  if (sliderOpts.currentvalue.suffix) {\n    str += sliderOpts.currentvalue.suffix;\n  }\n\n  text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  var lines = svgTextUtils.lineCount(text);\n  var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;\n  svgTextUtils.positionText(text, x0, y0);\n  return text;\n}\n\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n  var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  grip.attr({\n    width: constants.gripWidth,\n    height: constants.gripHeight,\n    rx: constants.gripRadius,\n    ry: constants.gripRadius\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n}\n\nfunction drawLabel(item, data, sliderOpts) {\n  var text = Lib.ensureSingle(item, 'text', constants.labelClass, function (s) {\n    s.classed('user-select-none', true).attr({\n      'text-anchor': 'middle',\n      'data-notex': 1\n    });\n  });\n  var tx = data.step.label;\n  var _meta = sliderOpts._gd._fullLayout._meta;\n  if (_meta) tx = Lib.templateString(tx, _meta);\n  text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  return text;\n}\n\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n  var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n  var dims = sliderOpts._dims;\n  var labelItems = labels.selectAll('g.' + constants.labelGroupClass).data(dims.labelSteps);\n  labelItems.enter().append('g').classed(constants.labelGroupClass, true);\n  labelItems.exit().remove();\n  labelItems.each(function (d) {\n    var item = d3.select(this);\n    item.call(drawLabel, d, sliderOpts);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, d.fraction), constants.tickOffset + sliderOpts.ticklen + // position is the baseline of the top line of text only, even\n    // if the label spans multiple lines\n    sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight);\n  });\n}\n\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n  var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n  var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n\n  if (quantizedIndex !== sliderOpts.active) {\n    setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n  }\n}\n\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n  var previousActive = sliderOpts.active;\n  sliderOpts.active = index; // due to templating, it's possible this slider doesn't even exist yet\n\n  arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate('active', index);\n  var step = sliderOpts.steps[sliderOpts.active];\n  sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n  gd.emit('plotly_sliderchange', {\n    slider: sliderOpts,\n    step: sliderOpts.steps[sliderOpts.active],\n    interaction: doCallback,\n    previousActive: previousActive\n  });\n\n  if (step && step.method && doCallback) {\n    if (sliderGroup._nextMethod) {\n      // If we've already queued up an update, just overwrite it with the most recent:\n      sliderGroup._nextMethod.step = step;\n      sliderGroup._nextMethod.doCallback = doCallback;\n      sliderGroup._nextMethod.doTransition = doTransition;\n    } else {\n      sliderGroup._nextMethod = {\n        step: step,\n        doCallback: doCallback,\n        doTransition: doTransition\n      };\n      sliderGroup._nextMethodRaf = window.requestAnimationFrame(function () {\n        var _step = sliderGroup._nextMethod.step;\n        if (!_step.method) return;\n\n        if (_step.execute) {\n          Plots.executeAPICommand(gd, _step.method, _step.args);\n        }\n\n        sliderGroup._nextMethod = null;\n        sliderGroup._nextMethodRaf = null;\n      });\n    }\n  }\n}\n\nfunction attachGripEvents(item, gd, sliderGroup) {\n  var node = sliderGroup.node();\n  var $gd = d3.select(gd); // NB: This is *not* the same as sliderOpts itself! These callbacks\n  // are in a closure so this array won't actually be correct if the\n  // steps have changed since this was initialized. The sliderGroup,\n  // however, has not changed since that *is* the slider, so it must\n  // be present to receive mouse events.\n\n  function getSliderOpts() {\n    return sliderGroup.data()[0];\n  }\n\n  item.on('mousedown', function () {\n    var sliderOpts = getSliderOpts();\n    gd.emit('plotly_sliderstart', {\n      slider: sliderOpts\n    });\n    var grip = sliderGroup.select('.' + constants.gripRectClass);\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n    grip.call(Color.fill, sliderOpts.activebgcolor);\n    var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n    handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n    sliderOpts._dragging = true;\n    $gd.on('mousemove', function () {\n      var sliderOpts = getSliderOpts();\n      var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n      handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n    });\n    $gd.on('mouseup', function () {\n      var sliderOpts = getSliderOpts();\n      sliderOpts._dragging = false;\n      grip.call(Color.fill, sliderOpts.bgcolor);\n      $gd.on('mouseup', null);\n      $gd.on('mousemove', null);\n      gd.emit('plotly_sliderend', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active]\n      });\n    });\n  });\n}\n\nfunction drawTicks(sliderGroup, sliderOpts) {\n  var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass).data(sliderOpts._visibleSteps);\n  var dims = sliderOpts._dims;\n  tick.enter().append('rect').classed(constants.tickRectClass, true);\n  tick.exit().remove();\n  tick.attr({\n    width: sliderOpts.tickwidth + 'px',\n    'shape-rendering': 'crispEdges'\n  });\n  tick.each(function (d, i) {\n    var isMajor = i % dims.labelStride === 0;\n    var item = d3.select(this);\n    item.attr({\n      height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen\n    }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth, (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight);\n  });\n}\n\nfunction computeLabelSteps(sliderOpts) {\n  var dims = sliderOpts._dims;\n  dims.labelSteps = [];\n  var nsteps = sliderOpts._stepCount;\n\n  for (var i = 0; i < nsteps; i += dims.labelStride) {\n    dims.labelSteps.push({\n      fraction: i / (nsteps - 1),\n      step: sliderOpts._visibleSteps[i]\n    });\n  }\n}\n\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n  var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n  var quantizedIndex = 0;\n\n  for (var i = 0; i < sliderOpts._stepCount; i++) {\n    if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n      quantizedIndex = i;\n      break;\n    }\n  }\n\n  var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1)); // If this is true, then *this component* is already invoking its own command\n  // and has triggered its own animation.\n\n  if (sliderOpts._invokingCommand) return;\n  var el = grip;\n\n  if (doTransition && sliderOpts.transition.duration > 0) {\n    el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);\n  } // Drawing.setTranslate doesn't work here becasue of the transition duck-typing.\n  // It's also not necessary because there are no other transitions to preserve.\n\n\n  el.attr('transform', 'translate(' + (x - constants.gripWidth * 0.5) + ',' + sliderOpts._dims.currentValueTotalHeight + ')');\n} // Convert a number from [0-1] to a pixel position relative to the slider group container:\n\n\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n  var dims = sliderOpts._dims;\n  return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n} // Convert a position relative to the slider group to a nubmer in [0, 1]\n\n\nfunction positionToNormalizedValue(sliderOpts, position) {\n  var dims = sliderOpts._dims;\n  return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\n\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  rect.attr({\n    width: dims.inputAreaLength,\n    height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n  }).call(Color.fill, sliderOpts.bgcolor).attr('opacity', 0);\n  Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\n\nfunction drawRail(sliderGroup, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var computedLength = dims.inputAreaLength - constants.railInset * 2;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n  rect.attr({\n    width: computedLength,\n    height: constants.railWidth,\n    rx: constants.railRadius,\n    ry: constants.railRadius,\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n  Drawing.setTranslate(rect, constants.railInset, (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight);\n}","map":null,"metadata":{},"sourceType":"script"}