{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar id2name = require('./axis_ids').id2name;\n\nvar scaleZoom = require('./scale_zoom');\n\nvar makePadFn = require('./autorange').makePadFn;\n\nvar concatExtremes = require('./autorange').concatExtremes;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleConstraintDefaults = function (containerIn, containerOut, coerce, opts) {\n  var allAxisIds = opts.allAxisIds;\n  var layoutOut = opts.layoutOut;\n  var scaleanchorDflt = opts.scaleanchorDflt;\n  var constrainDflt = opts.constrainDflt;\n  var constraintGroups = layoutOut._axisConstraintGroups;\n  var matchGroups = layoutOut._axisMatchGroups;\n  var axId = containerOut._id;\n  var axLetter = axId.charAt(0);\n  var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n  var thisID = containerOut._id;\n  var letter = thisID.charAt(0); // coerce the constraint mechanics even if this axis has no scaleanchor\n  // because it may be the anchor of another axis.\n\n  var constrain = coerce('constrain', constrainDflt);\n  Lib.coerce(containerIn, containerOut, {\n    constraintoward: {\n      valType: 'enumerated',\n      values: letter === 'x' ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n      dflt: letter === 'x' ? 'center' : 'middle'\n    }\n  }, 'constraintoward');\n  var matches, matchOpts;\n\n  if ((containerIn.matches || splomStash.matches) && !containerOut.fixedrange) {\n    matchOpts = getConstraintOpts(matchGroups, thisID, allAxisIds, layoutOut);\n    matches = Lib.coerce(containerIn, containerOut, {\n      matches: {\n        valType: 'enumerated',\n        values: matchOpts.linkableAxes || [],\n        dflt: splomStash.matches\n      }\n    }, 'matches');\n  } // 'matches' wins over 'scaleanchor' (for now)\n\n\n  var scaleanchor, scaleOpts;\n\n  if (!matches && !(containerOut.fixedrange && constrain !== 'domain') && (containerIn.scaleanchor || scaleanchorDflt)) {\n    scaleOpts = getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut, constrain);\n    scaleanchor = Lib.coerce(containerIn, containerOut, {\n      scaleanchor: {\n        valType: 'enumerated',\n        values: scaleOpts.linkableAxes || []\n      }\n    }, 'scaleanchor', scaleanchorDflt);\n  }\n\n  if (matches) {\n    delete containerOut.constrain;\n    updateConstraintGroups(matchGroups, matchOpts.thisGroup, thisID, matches, 1);\n  } else if (allAxisIds.indexOf(containerIn.matches) !== -1) {\n    Lib.warn('ignored ' + containerOut._name + '.matches: \"' + containerIn.matches + '\" to avoid either an infinite loop ' + 'or because the target axis has fixed range.');\n  }\n\n  if (scaleanchor) {\n    var scaleratio = coerce('scaleratio'); // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n    // but that seems hacky. Better way to say \"must be a positive number\"?\n    // Of course if you use several super-tiny values you could eventually\n    // force a product of these to zero and all hell would break loose...\n    // Likewise with super-huge values.\n\n    if (!scaleratio) scaleratio = containerOut.scaleratio = 1;\n    updateConstraintGroups(constraintGroups, scaleOpts.thisGroup, thisID, scaleanchor, scaleratio);\n  } else if (allAxisIds.indexOf(containerIn.scaleanchor) !== -1) {\n    Lib.warn('ignored ' + containerOut._name + '.scaleanchor: \"' + containerIn.scaleanchor + '\" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because the target ' + 'axis has fixed range or this axis declares a *matches* constraint.');\n  }\n}; // If this axis is already part of a constraint group, we can't\n// scaleanchor any other axis in that group, or we'd make a loop.\n// Filter allAxisIds to enforce this, also matching axis types.\n\n\nfunction getConstraintOpts(groups, thisID, allAxisIds, layoutOut, constrain) {\n  var doesNotConstrainRange = constrain !== 'range';\n  var thisType = layoutOut[id2name(thisID)].type;\n  var i, j, idj, axj;\n  var linkableAxes = [];\n\n  for (j = 0; j < allAxisIds.length; j++) {\n    idj = allAxisIds[j];\n    if (idj === thisID) continue;\n    axj = layoutOut[id2name(idj)];\n\n    if (axj.type === thisType) {\n      if (!axj.fixedrange) {\n        linkableAxes.push(idj);\n      } else if (doesNotConstrainRange && axj.anchor) {\n        // allow domain constraints on subplots where\n        // BOTH axes have fixedrange:true and constrain:domain\n        var counterAxj = layoutOut[id2name(axj.anchor)];\n\n        if (counterAxj.fixedrange) {\n          linkableAxes.push(idj);\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < groups.length; i++) {\n    if (groups[i][thisID]) {\n      var thisGroup = groups[i];\n      var linkableAxesNoLoops = [];\n\n      for (j = 0; j < linkableAxes.length; j++) {\n        idj = linkableAxes[j];\n        if (!thisGroup[idj]) linkableAxesNoLoops.push(idj);\n      }\n\n      return {\n        linkableAxes: linkableAxesNoLoops,\n        thisGroup: thisGroup\n      };\n    }\n  }\n\n  return {\n    linkableAxes: linkableAxes,\n    thisGroup: null\n  };\n}\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */\n\n\nfunction updateConstraintGroups(constraintGroups, thisGroup, thisID, scaleanchor, scaleratio) {\n  var i, j, groupi, keyj, thisGroupIndex;\n\n  if (thisGroup === null) {\n    thisGroup = {};\n    thisGroup[thisID] = 1;\n    thisGroupIndex = constraintGroups.length;\n    constraintGroups.push(thisGroup);\n  } else {\n    thisGroupIndex = constraintGroups.indexOf(thisGroup);\n  }\n\n  var thisGroupKeys = Object.keys(thisGroup); // we know that this axis isn't in any other groups, but we don't know\n  // about the scaleanchor axis. If it is, we need to merge the groups.\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    groupi = constraintGroups[i];\n\n    if (i !== thisGroupIndex && groupi[scaleanchor]) {\n      var baseScale = groupi[scaleanchor];\n\n      for (j = 0; j < thisGroupKeys.length; j++) {\n        keyj = thisGroupKeys[j];\n        groupi[keyj] = baseScale * scaleratio * thisGroup[keyj];\n      }\n\n      constraintGroups.splice(thisGroupIndex, 1);\n      return;\n    }\n  } // otherwise, we insert the new scaleanchor axis as the base scale (1)\n  // in its group, and scale the rest of the group to it\n\n\n  if (scaleratio !== 1) {\n    for (j = 0; j < thisGroupKeys.length; j++) {\n      thisGroup[thisGroupKeys[j]] *= scaleratio;\n    }\n  }\n\n  thisGroup[scaleanchor] = 1;\n}\n\nexports.enforce = function enforce(gd) {\n  var fullLayout = gd._fullLayout;\n  var constraintGroups = fullLayout._axisConstraintGroups || [];\n  var i, j, axisID, ax, normScale, mode, factor;\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    var group = constraintGroups[i];\n    var axisIDs = Object.keys(group);\n    var minScale = Infinity;\n    var maxScale = 0; // mostly matchScale will be the same as minScale\n    // ie we expand axis ranges to encompass *everything*\n    // that's currently in any of their ranges, but during\n    // autorange of a subset of axes we will ignore other\n    // axes for this purpose.\n\n    var matchScale = Infinity;\n    var normScales = {};\n    var axes = {};\n    var hasAnyDomainConstraint = false; // find the (normalized) scale of each axis in the group\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      axes[axisID] = ax = fullLayout[id2name(axisID)];\n      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();\n      if (!ax._inputRange) ax._inputRange = ax.range.slice(); // set axis scale here so we can use _m rather than\n      // having to calculate it from length and range\n\n      ax.setScale(); // abs: inverted scales still satisfy the constraint\n\n      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n      minScale = Math.min(minScale, normScale);\n\n      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {\n        matchScale = Math.min(matchScale, normScale);\n      } // this has served its purpose, so remove it\n\n\n      delete ax._constraintShrinkable;\n      maxScale = Math.max(maxScale, normScale);\n      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;\n    } // Do we have a constraint mismatch? Give a small buffer for rounding errors\n\n\n    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue; // now increase any ranges we need to until all normalized scales are equal\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      normScale = normScales[axisID];\n      ax = axes[axisID];\n      mode = ax.constrain; // even if the scale didn't change, if we're shrinking domain\n      // we need to recalculate in case `constraintoward` changed\n\n      if (normScale !== matchScale || mode === 'domain') {\n        factor = normScale / matchScale;\n\n        if (mode === 'range') {\n          scaleZoom(ax, factor);\n        } else {\n          // mode === 'domain'\n          var inputDomain = ax._inputDomain;\n          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);\n          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n          factor /= domainShrunk;\n\n          if (factor * rangeShrunk < 1) {\n            // we've asked to magnify the axis more than we can just by\n            // enlarging the domain - so we need to constrict range\n            ax.domain = ax._input.domain = inputDomain.slice();\n            scaleZoom(ax, factor);\n            continue;\n          }\n\n          if (rangeShrunk < 1) {\n            // the range has previously been constricted by ^^, but we've\n            // switched to the domain-constricted regime, so reset range\n            ax.range = ax._input.range = ax._inputRange.slice();\n            factor *= rangeShrunk;\n          }\n\n          if (ax.autorange) {\n            /*\n             * range & factor may need to change because range was\n             * calculated for the larger scaling, so some pixel\n             * paddings may get cut off when we reduce the domain.\n             *\n             * This is easier than the regular autorange calculation\n             * because we already know the scaling `m`, but we still\n             * need to cut out impossible constraints (like\n             * annotations with super-long arrows). That's what\n             * outerMin/Max are for - if the expansion was going to\n             * go beyond the original domain, it must be impossible\n             */\n            var rl0 = ax.r2l(ax.range[0]);\n            var rl1 = ax.r2l(ax.range[1]);\n            var rangeCenter = (rl0 + rl1) / 2;\n            var rangeMin = rangeCenter;\n            var rangeMax = rangeCenter;\n            var halfRange = Math.abs(rl1 - rangeCenter); // extra tiny bit for rounding errors, in case we actually\n            // *are* expanding to the full domain\n\n            var outerMin = rangeCenter - halfRange * factor * 1.0001;\n            var outerMax = rangeCenter + halfRange * factor * 1.0001;\n            var getPad = makePadFn(ax);\n            updateDomain(ax, factor);\n            var m = Math.abs(ax._m);\n            var extremes = concatExtremes(gd, ax);\n            var minArray = extremes.min;\n            var maxArray = extremes.max;\n            var newVal;\n            var k;\n\n            for (k = 0; k < minArray.length; k++) {\n              newVal = minArray[k].val - getPad(minArray[k]) / m;\n\n              if (newVal > outerMin && newVal < rangeMin) {\n                rangeMin = newVal;\n              }\n            }\n\n            for (k = 0; k < maxArray.length; k++) {\n              newVal = maxArray[k].val + getPad(maxArray[k]) / m;\n\n              if (newVal < outerMax && newVal > rangeMax) {\n                rangeMax = newVal;\n              }\n            }\n\n            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n            factor /= domainExpand;\n            rangeMin = ax.l2r(rangeMin);\n            rangeMax = ax.l2r(rangeMax);\n            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];\n          }\n\n          updateDomain(ax, factor);\n        }\n      }\n    }\n  }\n}; // For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\n\n\nexports.clean = function clean(gd, ax) {\n  if (ax._inputDomain) {\n    var isConstrained = false;\n    var axId = ax._id;\n    var constraintGroups = gd._fullLayout._axisConstraintGroups;\n\n    for (var j = 0; j < constraintGroups.length; j++) {\n      if (constraintGroups[j][axId]) {\n        isConstrained = true;\n        break;\n      }\n    }\n\n    if (!isConstrained || ax.constrain !== 'domain') {\n      ax._input.domain = ax.domain = ax._inputDomain;\n      delete ax._inputDomain;\n    }\n  }\n};\n\nfunction updateDomain(ax, factor) {\n  var inputDomain = ax._inputDomain;\n  var centerFraction = FROM_BL[ax.constraintoward];\n  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];\n  ax.setScale();\n}","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/plots/cartesian/constraints.js"],"names":["Lib","require","id2name","scaleZoom","makePadFn","concatExtremes","ALMOST_EQUAL","FROM_BL","exports","handleConstraintDefaults","containerIn","containerOut","coerce","opts","allAxisIds","layoutOut","scaleanchorDflt","constrainDflt","constraintGroups","_axisConstraintGroups","matchGroups","_axisMatchGroups","axId","_id","axLetter","charAt","splomStash","_splomAxes","thisID","letter","constrain","constraintoward","valType","values","dflt","matches","matchOpts","fixedrange","getConstraintOpts","linkableAxes","scaleanchor","scaleOpts","updateConstraintGroups","thisGroup","indexOf","warn","_name","scaleratio","groups","doesNotConstrainRange","thisType","type","i","j","idj","axj","length","push","anchor","counterAxj","linkableAxesNoLoops","groupi","keyj","thisGroupIndex","thisGroupKeys","Object","keys","baseScale","splice","enforce","gd","fullLayout","_fullLayout","axisID","ax","normScale","mode","factor","group","axisIDs","minScale","Infinity","maxScale","matchScale","normScales","axes","hasAnyDomainConstraint","_inputDomain","domain","slice","_inputRange","range","setScale","Math","abs","_m","min","_constraintShrinkable","max","inputDomain","domainShrunk","rangeShrunk","r2l","_input","autorange","rl0","rl1","rangeCenter","rangeMin","rangeMax","halfRange","outerMin","outerMax","getPad","updateDomain","m","extremes","minArray","maxArray","newVal","k","val","domainExpand","l2r","clean","isConstrained","centerFraction","center"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar id2name = require('./axis_ids').id2name;\nvar scaleZoom = require('./scale_zoom');\nvar makePadFn = require('./autorange').makePadFn;\nvar concatExtremes = require('./autorange').concatExtremes;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleConstraintDefaults = function(containerIn, containerOut, coerce, opts) {\n    var allAxisIds = opts.allAxisIds;\n    var layoutOut = opts.layoutOut;\n    var scaleanchorDflt = opts.scaleanchorDflt;\n    var constrainDflt = opts.constrainDflt;\n    var constraintGroups = layoutOut._axisConstraintGroups;\n    var matchGroups = layoutOut._axisMatchGroups;\n    var axId = containerOut._id;\n    var axLetter = axId.charAt(0);\n    var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n    var thisID = containerOut._id;\n    var letter = thisID.charAt(0);\n\n    // coerce the constraint mechanics even if this axis has no scaleanchor\n    // because it may be the anchor of another axis.\n    var constrain = coerce('constrain', constrainDflt);\n    Lib.coerce(containerIn, containerOut, {\n        constraintoward: {\n            valType: 'enumerated',\n            values: letter === 'x' ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n            dflt: letter === 'x' ? 'center' : 'middle'\n        }\n    }, 'constraintoward');\n\n    var matches, matchOpts;\n\n    if((containerIn.matches || splomStash.matches) && !containerOut.fixedrange) {\n        matchOpts = getConstraintOpts(matchGroups, thisID, allAxisIds, layoutOut);\n        matches = Lib.coerce(containerIn, containerOut, {\n            matches: {\n                valType: 'enumerated',\n                values: matchOpts.linkableAxes || [],\n                dflt: splomStash.matches\n            }\n        }, 'matches');\n    }\n\n    // 'matches' wins over 'scaleanchor' (for now)\n    var scaleanchor, scaleOpts;\n\n    if(!matches &&\n       !(containerOut.fixedrange && constrain !== 'domain') &&\n       (containerIn.scaleanchor || scaleanchorDflt)\n     ) {\n        scaleOpts = getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut, constrain);\n        scaleanchor = Lib.coerce(containerIn, containerOut, {\n            scaleanchor: {\n                valType: 'enumerated',\n                values: scaleOpts.linkableAxes || []\n            }\n        }, 'scaleanchor', scaleanchorDflt);\n    }\n\n    if(matches) {\n        delete containerOut.constrain;\n        updateConstraintGroups(matchGroups, matchOpts.thisGroup, thisID, matches, 1);\n    } else if(allAxisIds.indexOf(containerIn.matches) !== -1) {\n        Lib.warn('ignored ' + containerOut._name + '.matches: \"' +\n            containerIn.matches + '\" to avoid either an infinite loop ' +\n            'or because the target axis has fixed range.');\n    }\n\n    if(scaleanchor) {\n        var scaleratio = coerce('scaleratio');\n\n        // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n        // but that seems hacky. Better way to say \"must be a positive number\"?\n        // Of course if you use several super-tiny values you could eventually\n        // force a product of these to zero and all hell would break loose...\n        // Likewise with super-huge values.\n        if(!scaleratio) scaleratio = containerOut.scaleratio = 1;\n\n        updateConstraintGroups(constraintGroups, scaleOpts.thisGroup, thisID, scaleanchor, scaleratio);\n    } else if(allAxisIds.indexOf(containerIn.scaleanchor) !== -1) {\n        Lib.warn('ignored ' + containerOut._name + '.scaleanchor: \"' +\n            containerIn.scaleanchor + '\" to avoid either an infinite loop ' +\n            'and possibly inconsistent scaleratios, or because the target ' +\n            'axis has fixed range or this axis declares a *matches* constraint.');\n    }\n};\n\n// If this axis is already part of a constraint group, we can't\n// scaleanchor any other axis in that group, or we'd make a loop.\n// Filter allAxisIds to enforce this, also matching axis types.\nfunction getConstraintOpts(groups, thisID, allAxisIds, layoutOut, constrain) {\n    var doesNotConstrainRange = constrain !== 'range';\n    var thisType = layoutOut[id2name(thisID)].type;\n    var i, j, idj, axj;\n\n    var linkableAxes = [];\n    for(j = 0; j < allAxisIds.length; j++) {\n        idj = allAxisIds[j];\n        if(idj === thisID) continue;\n\n        axj = layoutOut[id2name(idj)];\n        if(axj.type === thisType) {\n            if(!axj.fixedrange) {\n                linkableAxes.push(idj);\n            } else if(doesNotConstrainRange && axj.anchor) {\n                // allow domain constraints on subplots where\n                // BOTH axes have fixedrange:true and constrain:domain\n                var counterAxj = layoutOut[id2name(axj.anchor)];\n                if(counterAxj.fixedrange) {\n                    linkableAxes.push(idj);\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < groups.length; i++) {\n        if(groups[i][thisID]) {\n            var thisGroup = groups[i];\n\n            var linkableAxesNoLoops = [];\n            for(j = 0; j < linkableAxes.length; j++) {\n                idj = linkableAxes[j];\n                if(!thisGroup[idj]) linkableAxesNoLoops.push(idj);\n            }\n            return {linkableAxes: linkableAxesNoLoops, thisGroup: thisGroup};\n        }\n    }\n\n    return {linkableAxes: linkableAxes, thisGroup: null};\n}\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */\nfunction updateConstraintGroups(constraintGroups, thisGroup, thisID, scaleanchor, scaleratio) {\n    var i, j, groupi, keyj, thisGroupIndex;\n\n    if(thisGroup === null) {\n        thisGroup = {};\n        thisGroup[thisID] = 1;\n        thisGroupIndex = constraintGroups.length;\n        constraintGroups.push(thisGroup);\n    } else {\n        thisGroupIndex = constraintGroups.indexOf(thisGroup);\n    }\n\n    var thisGroupKeys = Object.keys(thisGroup);\n\n    // we know that this axis isn't in any other groups, but we don't know\n    // about the scaleanchor axis. If it is, we need to merge the groups.\n    for(i = 0; i < constraintGroups.length; i++) {\n        groupi = constraintGroups[i];\n        if(i !== thisGroupIndex && groupi[scaleanchor]) {\n            var baseScale = groupi[scaleanchor];\n            for(j = 0; j < thisGroupKeys.length; j++) {\n                keyj = thisGroupKeys[j];\n                groupi[keyj] = baseScale * scaleratio * thisGroup[keyj];\n            }\n            constraintGroups.splice(thisGroupIndex, 1);\n            return;\n        }\n    }\n\n    // otherwise, we insert the new scaleanchor axis as the base scale (1)\n    // in its group, and scale the rest of the group to it\n    if(scaleratio !== 1) {\n        for(j = 0; j < thisGroupKeys.length; j++) {\n            thisGroup[thisGroupKeys[j]] *= scaleratio;\n        }\n    }\n    thisGroup[scaleanchor] = 1;\n}\n\nexports.enforce = function enforce(gd) {\n    var fullLayout = gd._fullLayout;\n    var constraintGroups = fullLayout._axisConstraintGroups || [];\n\n    var i, j, axisID, ax, normScale, mode, factor;\n\n    for(i = 0; i < constraintGroups.length; i++) {\n        var group = constraintGroups[i];\n        var axisIDs = Object.keys(group);\n\n        var minScale = Infinity;\n        var maxScale = 0;\n        // mostly matchScale will be the same as minScale\n        // ie we expand axis ranges to encompass *everything*\n        // that's currently in any of their ranges, but during\n        // autorange of a subset of axes we will ignore other\n        // axes for this purpose.\n        var matchScale = Infinity;\n        var normScales = {};\n        var axes = {};\n        var hasAnyDomainConstraint = false;\n\n        // find the (normalized) scale of each axis in the group\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            axes[axisID] = ax = fullLayout[id2name(axisID)];\n\n            if(ax._inputDomain) ax.domain = ax._inputDomain.slice();\n            else ax._inputDomain = ax.domain.slice();\n\n            if(!ax._inputRange) ax._inputRange = ax.range.slice();\n\n            // set axis scale here so we can use _m rather than\n            // having to calculate it from length and range\n            ax.setScale();\n\n            // abs: inverted scales still satisfy the constraint\n            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n            minScale = Math.min(minScale, normScale);\n            if(ax.constrain === 'domain' || !ax._constraintShrinkable) {\n                matchScale = Math.min(matchScale, normScale);\n            }\n\n            // this has served its purpose, so remove it\n            delete ax._constraintShrinkable;\n            maxScale = Math.max(maxScale, normScale);\n\n            if(ax.constrain === 'domain') hasAnyDomainConstraint = true;\n        }\n\n        // Do we have a constraint mismatch? Give a small buffer for rounding errors\n        if(minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;\n\n        // now increase any ranges we need to until all normalized scales are equal\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            normScale = normScales[axisID];\n            ax = axes[axisID];\n            mode = ax.constrain;\n\n            // even if the scale didn't change, if we're shrinking domain\n            // we need to recalculate in case `constraintoward` changed\n            if(normScale !== matchScale || mode === 'domain') {\n                factor = normScale / matchScale;\n\n                if(mode === 'range') {\n                    scaleZoom(ax, factor);\n                } else {\n                    // mode === 'domain'\n\n                    var inputDomain = ax._inputDomain;\n                    var domainShrunk = (ax.domain[1] - ax.domain[0]) /\n                        (inputDomain[1] - inputDomain[0]);\n                    var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) /\n                        (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n\n                    factor /= domainShrunk;\n\n                    if(factor * rangeShrunk < 1) {\n                        // we've asked to magnify the axis more than we can just by\n                        // enlarging the domain - so we need to constrict range\n                        ax.domain = ax._input.domain = inputDomain.slice();\n                        scaleZoom(ax, factor);\n                        continue;\n                    }\n\n                    if(rangeShrunk < 1) {\n                        // the range has previously been constricted by ^^, but we've\n                        // switched to the domain-constricted regime, so reset range\n                        ax.range = ax._input.range = ax._inputRange.slice();\n                        factor *= rangeShrunk;\n                    }\n\n                    if(ax.autorange) {\n                        /*\n                         * range & factor may need to change because range was\n                         * calculated for the larger scaling, so some pixel\n                         * paddings may get cut off when we reduce the domain.\n                         *\n                         * This is easier than the regular autorange calculation\n                         * because we already know the scaling `m`, but we still\n                         * need to cut out impossible constraints (like\n                         * annotations with super-long arrows). That's what\n                         * outerMin/Max are for - if the expansion was going to\n                         * go beyond the original domain, it must be impossible\n                         */\n                        var rl0 = ax.r2l(ax.range[0]);\n                        var rl1 = ax.r2l(ax.range[1]);\n                        var rangeCenter = (rl0 + rl1) / 2;\n                        var rangeMin = rangeCenter;\n                        var rangeMax = rangeCenter;\n                        var halfRange = Math.abs(rl1 - rangeCenter);\n                        // extra tiny bit for rounding errors, in case we actually\n                        // *are* expanding to the full domain\n                        var outerMin = rangeCenter - halfRange * factor * 1.0001;\n                        var outerMax = rangeCenter + halfRange * factor * 1.0001;\n                        var getPad = makePadFn(ax);\n\n                        updateDomain(ax, factor);\n                        var m = Math.abs(ax._m);\n                        var extremes = concatExtremes(gd, ax);\n                        var minArray = extremes.min;\n                        var maxArray = extremes.max;\n                        var newVal;\n                        var k;\n\n                        for(k = 0; k < minArray.length; k++) {\n                            newVal = minArray[k].val - getPad(minArray[k]) / m;\n                            if(newVal > outerMin && newVal < rangeMin) {\n                                rangeMin = newVal;\n                            }\n                        }\n\n                        for(k = 0; k < maxArray.length; k++) {\n                            newVal = maxArray[k].val + getPad(maxArray[k]) / m;\n                            if(newVal < outerMax && newVal > rangeMax) {\n                                rangeMax = newVal;\n                            }\n                        }\n\n                        var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n                        factor /= domainExpand;\n\n                        rangeMin = ax.l2r(rangeMin);\n                        rangeMax = ax.l2r(rangeMax);\n                        ax.range = ax._input.range = (rl0 < rl1) ?\n                            [rangeMin, rangeMax] : [rangeMax, rangeMin];\n                    }\n\n                    updateDomain(ax, factor);\n                }\n            }\n        }\n    }\n};\n\n// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean = function clean(gd, ax) {\n    if(ax._inputDomain) {\n        var isConstrained = false;\n        var axId = ax._id;\n        var constraintGroups = gd._fullLayout._axisConstraintGroups;\n        for(var j = 0; j < constraintGroups.length; j++) {\n            if(constraintGroups[j][axId]) {\n                isConstrained = true;\n                break;\n            }\n        }\n        if(!isConstrained || ax.constrain !== 'domain') {\n            ax._input.domain = ax.domain = ax._inputDomain;\n            delete ax._inputDomain;\n        }\n    }\n};\n\nfunction updateDomain(ax, factor) {\n    var inputDomain = ax._inputDomain;\n    var centerFraction = FROM_BL[ax.constraintoward];\n    var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n\n    ax.domain = ax._input.domain = [\n        center + (inputDomain[0] - center) / factor,\n        center + (inputDomain[1] - center) / factor\n    ];\n    ax.setScale();\n}\n"]},"metadata":{},"sourceType":"script"}