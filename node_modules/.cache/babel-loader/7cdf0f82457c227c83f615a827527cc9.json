{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Color = require('../color');\n\nvar isValidScale = require('./scales').isValid;\n\nfunction hasColorscale(trace, containerStr, colorKey) {\n  var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() || {} : trace;\n  var color = container[colorKey || 'color'];\n  var isArrayWithOneNumber = false;\n\n  if (Lib.isArrayOrTypedArray(color)) {\n    for (var i = 0; i < color.length; i++) {\n      if (isNumeric(color[i])) {\n        isArrayWithOneNumber = true;\n        break;\n      }\n    }\n  }\n\n  return Lib.isPlainObject(container) && (isArrayWithOneNumber || container.showscale === true || isNumeric(container.cmin) && isNumeric(container.cmax) || isValidScale(container.colorscale) || Lib.isPlainObject(container.colorbar));\n}\n\nvar constantAttrs = ['showscale', 'autocolorscale', 'colorscale', 'reversescale', 'colorbar'];\nvar letterAttrs = ['min', 'max', 'mid', 'auto'];\n/**\n * Extract 'c' / 'z', trace / color axis colorscale options\n *\n * Note that it would be nice to replace all z* with c* equivalents in v2\n *\n * @param {object} cont : attribute container\n * @return {object}:\n *  - min: cmin or zmin\n *  - max: cmax or zmax\n *  - mid: cmid or zmid\n *  - auto: cauto or zauto\n *  - *scale: *scale attrs\n *  - colorbar: colorbar\n *  - _sync: function syncing attr and underscore dual (useful when calc'ing min/max)\n */\n\nfunction extractOpts(cont) {\n  var colorAx = cont._colorAx;\n  var cont2 = colorAx ? colorAx : cont;\n  var out = {};\n  var cLetter;\n  var i, k;\n\n  for (i = 0; i < constantAttrs.length; i++) {\n    k = constantAttrs[i];\n    out[k] = cont2[k];\n  }\n\n  if (colorAx) {\n    cLetter = 'c';\n\n    for (i = 0; i < letterAttrs.length; i++) {\n      k = letterAttrs[i];\n      out[k] = cont2['c' + k];\n    }\n  } else {\n    var k2;\n\n    for (i = 0; i < letterAttrs.length; i++) {\n      k = letterAttrs[i];\n      k2 = 'c' + k;\n\n      if (k2 in cont2) {\n        out[k] = cont2[k2];\n        continue;\n      }\n\n      k2 = 'z' + k;\n\n      if (k2 in cont2) {\n        out[k] = cont2[k2];\n      }\n    }\n\n    cLetter = k2.charAt(0);\n  }\n\n  out._sync = function (k, v) {\n    var k2 = letterAttrs.indexOf(k) !== -1 ? cLetter + k : k;\n    cont2[k2] = cont2['_' + k2] = v;\n  };\n\n  return out;\n}\n/**\n * Extract colorscale into numeric domain and color range.\n *\n * @param {object} cont colorscale container (e.g. trace, marker)\n *  - colorscale {array of arrays}\n *  - cmin/zmin {number}\n *  - cmax/zmax {number}\n *  - reversescale {boolean}\n *\n * @return {object}\n *  - domain {array}\n *  - range {array}\n */\n\n\nfunction extractScale(cont) {\n  var cOpts = extractOpts(cont);\n  var cmin = cOpts.min;\n  var cmax = cOpts.max;\n  var scl = cOpts.reversescale ? flipScale(cOpts.colorscale) : cOpts.colorscale;\n  var N = scl.length;\n  var domain = new Array(N);\n  var range = new Array(N);\n\n  for (var i = 0; i < N; i++) {\n    var si = scl[i];\n    domain[i] = cmin + si[0] * (cmax - cmin);\n    range[i] = si[1];\n  }\n\n  return {\n    domain: domain,\n    range: range\n  };\n}\n\nfunction flipScale(scl) {\n  var N = scl.length;\n  var sclNew = new Array(N);\n\n  for (var i = N - 1, j = 0; i >= 0; i--, j++) {\n    var si = scl[i];\n    sclNew[j] = [1 - si[0], si[1]];\n  }\n\n  return sclNew;\n}\n/**\n * General colorscale function generator.\n *\n * @param {object} specs output of Colorscale.extractScale or precomputed domain, range.\n *  - domain {array}\n *  - range {array}\n *\n * @param {object} opts\n *  - noNumericCheck {boolean} if true, scale func bypasses numeric checks\n *  - returnArray {boolean} if true, scale func return 4-item array instead of color strings\n *\n * @return {function}\n */\n\n\nfunction makeColorScaleFunc(specs, opts) {\n  opts = opts || {};\n  var domain = specs.domain;\n  var range = specs.range;\n  var N = range.length;\n\n  var _range = new Array(N);\n\n  for (var i = 0; i < N; i++) {\n    var rgba = tinycolor(range[i]).toRgb();\n    _range[i] = [rgba.r, rgba.g, rgba.b, rgba.a];\n  }\n\n  var _sclFunc = d3.scale.linear().domain(domain).range(_range).clamp(true);\n\n  var noNumericCheck = opts.noNumericCheck;\n  var returnArray = opts.returnArray;\n  var sclFunc;\n\n  if (noNumericCheck && returnArray) {\n    sclFunc = _sclFunc;\n  } else if (noNumericCheck) {\n    sclFunc = function (v) {\n      return colorArray2rbga(_sclFunc(v));\n    };\n  } else if (returnArray) {\n    sclFunc = function (v) {\n      if (isNumeric(v)) return _sclFunc(v);else if (tinycolor(v).isValid()) return v;else return Color.defaultLine;\n    };\n  } else {\n    sclFunc = function (v) {\n      if (isNumeric(v)) return colorArray2rbga(_sclFunc(v));else if (tinycolor(v).isValid()) return v;else return Color.defaultLine;\n    };\n  } // colorbar draw looks into the d3 scale closure for domain and range\n\n\n  sclFunc.domain = _sclFunc.domain;\n\n  sclFunc.range = function () {\n    return range;\n  };\n\n  return sclFunc;\n}\n\nfunction makeColorScaleFuncFromTrace(trace, opts) {\n  return makeColorScaleFunc(extractScale(trace), opts);\n}\n\nfunction colorArray2rbga(colorArray) {\n  var colorObj = {\n    r: colorArray[0],\n    g: colorArray[1],\n    b: colorArray[2],\n    a: colorArray[3]\n  };\n  return tinycolor(colorObj).toRgbString();\n}\n\nmodule.exports = {\n  hasColorscale: hasColorscale,\n  extractOpts: extractOpts,\n  extractScale: extractScale,\n  flipScale: flipScale,\n  makeColorScaleFunc: makeColorScaleFunc,\n  makeColorScaleFuncFromTrace: makeColorScaleFuncFromTrace\n};","map":null,"metadata":{},"sourceType":"script"}