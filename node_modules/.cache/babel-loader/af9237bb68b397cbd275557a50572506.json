{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar extendFlat = Lib.extendFlat;\nvar isPlainObject = Lib.isPlainObject;\nvar traceOpts = {\n  valType: 'flaglist',\n  extras: ['none'],\n  flags: ['calc', 'clearAxisTypes', 'plot', 'style', 'markerSize', 'colorbars'],\n  description: ['trace attributes should include an `editType` string matching this flaglist.', '*calc* is the most extensive: a full `Plotly.plot` starting by clearing `gd.calcdata`', 'to force it to be regenerated', '*clearAxisTypes* resets the types of the axes this trace is on, because new data could', 'cause the automatic axis type detection to change. Log type will not be cleared, as that', 'is never automatically chosen so must have been user-specified.', '*plot* calls `Plotly.plot` but without first clearing `gd.calcdata`.', '*style* only calls `module.style` (or module.editStyle) for all trace modules and redraws the legend.', '*markerSize* is like *style*, but propagate axis-range changes due to scatter `marker.size`', '*colorbars* only redraws colorbars.'].join(' ')\n};\nvar layoutOpts = {\n  valType: 'flaglist',\n  extras: ['none'],\n  flags: ['calc', 'plot', 'legend', 'ticks', 'axrange', 'layoutstyle', 'modebar', 'camera', 'arraydraw', 'colorbars'],\n  description: ['layout attributes should include an `editType` string matching this flaglist.', '*calc* is the most extensive: a full `Plotly.plot` starting by clearing `gd.calcdata`', 'to force it to be regenerated', '*plot* calls `Plotly.plot` but without first clearing `gd.calcdata`.', '*legend* only redraws the legend.', '*ticks* only redraws axis ticks, labels, and gridlines.', '*axrange* minimal sequence when updating axis ranges.', '*layoutstyle* reapplies global and SVG cartesian axis styles.', '*modebar* just updates the modebar.', '*camera* just updates the camera settings for gl3d scenes.', '*arraydraw* allows component arrays to invoke the redraw routines just for the', 'component(s) that changed.', '*colorbars* only redraws colorbars.'].join(' ')\n}; // flags for inside restyle/relayout include a few extras\n// that shouldn't be used in attributes, to deal with certain\n// combinations and conditionals efficiently\n\nvar traceEditTypeFlags = traceOpts.flags.slice().concat(['fullReplot']);\nvar layoutEditTypeFlags = layoutOpts.flags.slice().concat('layoutReplot');\nmodule.exports = {\n  traces: traceOpts,\n  layout: layoutOpts,\n\n  /*\n   * default (all false) edit flags for restyle (traces)\n   * creates a new object each call, so the caller can mutate freely\n   */\n  traceFlags: function () {\n    return falseObj(traceEditTypeFlags);\n  },\n\n  /*\n   * default (all false) edit flags for relayout\n   * creates a new object each call, so the caller can mutate freely\n   */\n  layoutFlags: function () {\n    return falseObj(layoutEditTypeFlags);\n  },\n\n  /*\n   * update `flags` with the `editType` values found in `attr`\n   */\n  update: function (flags, attr) {\n    var editType = attr.editType;\n\n    if (editType && editType !== 'none') {\n      var editTypeParts = editType.split('+');\n\n      for (var i = 0; i < editTypeParts.length; i++) {\n        flags[editTypeParts[i]] = true;\n      }\n    }\n  },\n  overrideAll: overrideAll\n};\n\nfunction falseObj(keys) {\n  var out = {};\n\n  for (var i = 0; i < keys.length; i++) out[keys[i]] = false;\n\n  return out;\n}\n/**\n * For attributes that are largely copied from elsewhere into a plot type that doesn't\n * support partial redraws - overrides the editType field of all attributes in the object\n *\n * @param {object} attrs: the attributes to override. Will not be mutated.\n * @param {string} editTypeOverride: the new editType to use\n * @param {'nested'|'from-root'} overrideContainers:\n *   - 'nested' will override editType for nested containers but not the root.\n *   - 'from-root' will also override editType of the root container.\n *   Containers below the absolute top level (trace or layout root) DO need an\n *   editType even if they are not `valObject`s themselves (eg `scatter.marker`)\n *   to handle the case where you edit the whole container.\n *\n * @return {object} a new attributes object with `editType` modified as directed\n */\n\n\nfunction overrideAll(attrs, editTypeOverride, overrideContainers) {\n  var out = extendFlat({}, attrs);\n\n  for (var key in out) {\n    var attr = out[key];\n\n    if (isPlainObject(attr)) {\n      out[key] = overrideOne(attr, editTypeOverride, overrideContainers, key);\n    }\n  }\n\n  if (overrideContainers === 'from-root') out.editType = editTypeOverride;\n  return out;\n}\n\nfunction overrideOne(attr, editTypeOverride, overrideContainers, key) {\n  if (attr.valType) {\n    var out = extendFlat({}, attr);\n    out.editType = editTypeOverride;\n\n    if (Array.isArray(attr.items)) {\n      out.items = new Array(attr.items.length);\n\n      for (var i = 0; i < attr.items.length; i++) {\n        out.items[i] = overrideOne(attr.items[i], editTypeOverride, 'from-root');\n      }\n    }\n\n    return out;\n  } else {\n    // don't provide an editType for the _deprecated container\n    return overrideAll(attr, editTypeOverride, key.charAt(0) === '_' ? 'nested' : 'from-root');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}