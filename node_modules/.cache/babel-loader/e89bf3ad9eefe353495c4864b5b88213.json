{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar traceIs = require('../../registry').traceIs;\n\nvar autoType = require('./axis_autotype');\n/*\n *  data: the plot data to use in choosing auto type\n *  name: axis object name (ie 'xaxis') if one should be stored\n */\n\n\nmodule.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {\n  var axType = coerce('type', (options.splomStash || {}).type);\n\n  if (axType === '-') {\n    setAutoType(containerOut, options.data);\n\n    if (containerOut.type === '-') {\n      containerOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      containerIn.type = containerOut.type;\n    }\n  }\n};\n\nfunction setAutoType(ax, data) {\n  // new logic: let people specify any type they want,\n  // only autotype if type is '-'\n  if (ax.type !== '-') return;\n  var id = ax._id;\n  var axLetter = id.charAt(0); // support 3d\n\n  if (id.indexOf('scene') !== -1) id = axLetter;\n  var d0 = getFirstNonEmptyTrace(data, id, axLetter);\n  if (!d0) return; // first check for histograms, as the count direction\n  // should always default to a linear axis\n\n  if (d0.type === 'histogram' && axLetter === {\n    v: 'y',\n    h: 'x'\n  }[d0.orientation || 'v']) {\n    ax.type = 'linear';\n    return;\n  }\n\n  var calAttr = axLetter + 'calendar';\n  var calendar = d0[calAttr];\n  var opts = {\n    noMultiCategory: !traceIs(d0, 'cartesian') || traceIs(d0, 'noMultiCategory')\n  };\n  var i; // check all boxes on this x axis to see\n  // if they're dates, numbers, or categories\n\n  if (isBoxWithoutPositionCoords(d0, axLetter)) {\n    var posLetter = getBoxPosLetter(d0);\n    var boxPositions = [];\n\n    for (i = 0; i < data.length; i++) {\n      var trace = data[i];\n      if (!traceIs(trace, 'box-violin') || (trace[axLetter + 'axis'] || axLetter) !== id) continue;\n      if (trace[posLetter] !== undefined) boxPositions.push(trace[posLetter][0]);else if (trace.name !== undefined) boxPositions.push(trace.name);else boxPositions.push('text');\n      if (trace[calAttr] !== calendar) calendar = undefined;\n    }\n\n    ax.type = autoType(boxPositions, calendar, opts);\n  } else if (d0.type === 'splom') {\n    var dimensions = d0.dimensions;\n    var dim = dimensions[d0._axesDim[id]];\n    if (dim.visible) ax.type = autoType(dim.values, calendar, opts);\n  } else {\n    ax.type = autoType(d0[axLetter] || [d0[axLetter + '0']], calendar, opts);\n  }\n}\n\nfunction getFirstNonEmptyTrace(data, id, axLetter) {\n  for (var i = 0; i < data.length; i++) {\n    var trace = data[i];\n\n    if (trace.type === 'splom' && trace._length > 0 && (trace['_' + axLetter + 'axes'] || {})[id]) {\n      return trace;\n    }\n\n    if ((trace[axLetter + 'axis'] || axLetter) === id) {\n      if (isBoxWithoutPositionCoords(trace, axLetter)) {\n        return trace;\n      } else if ((trace[axLetter] || []).length || trace[axLetter + '0']) {\n        return trace;\n      }\n    }\n  }\n}\n\nfunction getBoxPosLetter(trace) {\n  return {\n    v: 'x',\n    h: 'y'\n  }[trace.orientation || 'v'];\n}\n\nfunction isBoxWithoutPositionCoords(trace, axLetter) {\n  var posLetter = getBoxPosLetter(trace);\n  var isBox = traceIs(trace, 'box-violin');\n  var isCandlestick = traceIs(trace._fullInput || {}, 'candlestick');\n  return isBox && !isCandlestick && axLetter === posLetter && trace[posLetter] === undefined && trace[posLetter + '0'] === undefined;\n}","map":null,"metadata":{},"sourceType":"script"}