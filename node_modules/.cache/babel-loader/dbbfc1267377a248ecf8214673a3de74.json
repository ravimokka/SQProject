{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar polybool = require('polybooljs');\n\nvar Registry = require('../../registry');\n\nvar Color = require('../../components/color');\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar polygon = require('../../lib/polygon');\n\nvar throttle = require('../../lib/throttle');\n\nvar makeEventData = require('../../components/fx/helpers').makeEventData;\n\nvar getFromId = require('./axis_ids').getFromId;\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\n\nvar MINSELECT = constants.MINSELECT;\nvar filteredPolygon = polygon.filter;\nvar polygonTester = polygon.tester;\n\nfunction getAxId(ax) {\n  return ax._id;\n}\n\nfunction prepSelect(e, startX, startY, dragOptions, mode) {\n  var gd = dragOptions.gd;\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragBBox = dragOptions.element.getBoundingClientRect();\n  var plotinfo = dragOptions.plotinfo;\n  var xs = plotinfo.xaxis._offset;\n  var ys = plotinfo.yaxis._offset;\n  var x0 = startX - dragBBox.left;\n  var y0 = startY - dragBBox.top;\n  var x1 = x0;\n  var y1 = y0;\n  var path0 = 'M' + x0 + ',' + y0;\n  var pw = dragOptions.xaxes[0]._length;\n  var ph = dragOptions.yaxes[0]._length;\n  var allAxes = dragOptions.xaxes.concat(dragOptions.yaxes);\n  var subtract = e.altKey;\n  var filterPoly, selectionTester, mergedPolygons, currentPolygon;\n  var i, searchInfo, eventData;\n  coerceSelectionsCache(e, gd, dragOptions);\n\n  if (mode === 'lasso') {\n    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n  }\n\n  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1, 2]);\n  outlines.enter().append('path').attr('class', function (d) {\n    return 'select-outline select-outline-' + d + ' select-outline-' + plotinfo.id;\n  }).attr('transform', 'translate(' + xs + ', ' + ys + ')').attr('d', path0 + 'Z');\n  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1\n  }).attr('transform', 'translate(' + xs + ', ' + ys + ')').attr('d', 'M0,0Z');\n  var throttleID = fullLayout._uid + constants.SELECTID;\n  var selection = []; // find the traces to search for selection points\n\n  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot); // in v2 (once log ranges are fixed),\n  // we'll be able to p2r here for all axis types\n\n  function p2r(ax, v) {\n    return ax.type === 'log' ? ax.p2d(v) : ax.p2r(v);\n  }\n\n  function axValue(ax) {\n    var index = ax._id.charAt(0) === 'y' ? 1 : 0;\n    return function (v) {\n      return p2r(ax, v[index]);\n    };\n  }\n\n  function ascending(a, b) {\n    return a - b;\n  } // allow subplots to override fillRangeItems routine\n\n\n  var fillRangeItems;\n\n  if (plotinfo.fillRangeItems) {\n    fillRangeItems = plotinfo.fillRangeItems;\n  } else {\n    if (mode === 'select') {\n      fillRangeItems = function (eventData, poly) {\n        var ranges = eventData.range = {};\n\n        for (i = 0; i < allAxes.length; i++) {\n          var ax = allAxes[i];\n\n          var axLetter = ax._id.charAt(0);\n\n          ranges[ax._id] = [p2r(ax, poly[axLetter + 'min']), p2r(ax, poly[axLetter + 'max'])].sort(ascending);\n        }\n      };\n    } else {\n      fillRangeItems = function (eventData, poly, filterPoly) {\n        var dataPts = eventData.lassoPoints = {};\n\n        for (i = 0; i < allAxes.length; i++) {\n          var ax = allAxes[i];\n          dataPts[ax._id] = filterPoly.filtered.map(axValue(ax));\n        }\n      };\n    }\n  }\n\n  dragOptions.moveFn = function (dx0, dy0) {\n    x1 = Math.max(0, Math.min(pw, dx0 + x0));\n    y1 = Math.max(0, Math.min(ph, dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n\n    if (mode === 'select') {\n      var direction = fullLayout.selectdirection;\n\n      if (fullLayout.selectdirection === 'any') {\n        if (dy < Math.min(dx * 0.6, MINSELECT)) direction = 'h';else if (dx < Math.min(dy * 0.6, MINSELECT)) direction = 'v';else direction = 'd';\n      } else {\n        direction = fullLayout.selectdirection;\n      }\n\n      if (direction === 'h') {\n        // horizontal motion: make a vertical box\n        currentPolygon = [[x0, 0], [x0, ph], [x1, ph], [x1, 0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(0, ph);\n        currentPolygon.ymax = Math.max(0, ph); // extras to guide users in keeping a straight selection\n\n        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');\n      } else if (direction === 'v') {\n        // vertical motion: make a horizontal box\n        currentPolygon = [[0, y0], [0, y1], [pw, y1], [pw, y0]];\n        currentPolygon.xmin = Math.min(0, pw);\n        currentPolygon.xmax = Math.max(0, pw);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');\n      } else if (direction === 'd') {\n        // diagonal motion\n        currentPolygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M0,0Z');\n      }\n    } else if (mode === 'lasso') {\n      filterPoly.addPt([x1, y1]);\n      currentPolygon = filterPoly.filtered;\n    } // create outline & tester\n\n\n    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n      currentPolygon.subtract = subtract;\n      selectionTester = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTester = polygonTester(currentPolygon);\n    } // draw selection\n\n\n    drawSelection(mergedPolygons, outlines);\n    throttle.throttle(throttleID, constants.SELECTDELAY, function () {\n      selection = [];\n      var thisSelection;\n      var traceSelections = [];\n      var traceSelection;\n\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTester);\n        traceSelections.push(traceSelection);\n        thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n        if (selection.length) {\n          for (var j = 0; j < thisSelection.length; j++) {\n            selection.push(thisSelection[j]);\n          }\n        } else selection = thisSelection;\n      }\n\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n      fillRangeItems(eventData, currentPolygon, filterPoly);\n      dragOptions.gd.emit('plotly_selecting', eventData);\n    });\n  };\n\n  dragOptions.clickFn = function (numClicks, evt) {\n    var clickmode = fullLayout.clickmode;\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n\n      if (numClicks === 2) {\n        // clear selection on doubleclick\n        outlines.remove();\n\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n\n          searchInfo._module.selectPoints(searchInfo, false);\n        }\n\n        updateSelectedState(gd, searchTraces);\n        clearSelectionsCache(dragOptions);\n        gd.emit('plotly_deselect', null);\n      } else {\n        if (clickmode.indexOf('select') > -1) {\n          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);\n        }\n\n        if (clickmode === 'event') {\n          // TODO: remove in v2 - this was probably never intended to work as it does,\n          // but in case anyone depends on it we don't want to break it now.\n          // Note that click-to-select introduced pre v2 also emitts proper\n          // event data when clickmode is having 'select' in its flag list.\n          gd.emit('plotly_selected', undefined);\n        }\n      }\n\n      Fx.click(gd, evt);\n    }).catch(Lib.error);\n  };\n\n  dragOptions.doneFn = function () {\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      dragOptions.gd.emit('plotly_selected', eventData);\n\n      if (currentPolygon && dragOptions.selectionDefs) {\n        // save last polygons\n        currentPolygon.subtract = subtract;\n        dragOptions.selectionDefs.push(currentPolygon); // we have to keep reference to arrays container\n\n        dragOptions.mergedPolygons.length = 0;\n        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n      }\n\n      if (dragOptions.doneFnCompleted) {\n        dragOptions.doneFnCompleted(selection);\n      }\n    }).catch(Lib.error);\n  };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n  var hoverData = gd._hoverdata;\n  var clickmode = gd._fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1;\n  var selection = [];\n  var searchTraces, searchInfo, currentSelectionDef, selectionTester, traceSelection;\n  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n  if (isHoverDataSet(hoverData)) {\n    coerceSelectionsCache(evt, gd, dragOptions);\n    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0; // Note: potentially costly operation isPointOrBinSelected is\n    // called as late as possible through the use of an assignment\n    // in an if condition.\n\n    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n      if (polygonOutlines) polygonOutlines.remove();\n\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n\n        searchInfo._module.selectPoints(searchInfo, false);\n      }\n\n      updateSelectedState(gd, searchTraces);\n      clearSelectionsCache(dragOptions);\n\n      if (sendEvents) {\n        gd.emit('plotly_deselect', null);\n      }\n    } else {\n      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));\n      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n      selectionTester = multiTester(allSelectionDefs);\n\n      for (i = 0; i < searchTraces.length; i++) {\n        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTester);\n        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n        if (selection.length) {\n          for (var j = 0; j < thisTracesSelection.length; j++) {\n            selection.push(thisTracesSelection[j]);\n          }\n        } else selection = thisTracesSelection;\n      }\n\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n\n      if (currentSelectionDef && dragOptions) {\n        dragOptions.selectionDefs.push(currentSelectionDef);\n      }\n\n      if (polygonOutlines) drawSelection(dragOptions.mergedPolygons, polygonOutlines);\n\n      if (sendEvents) {\n        gd.emit('plotly_selected', eventData);\n      }\n    }\n  }\n}\n/**\n * Constructs a new point selection definition object.\n */\n\n\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n  return {\n    pointNumber: pointNumber,\n    searchInfo: searchInfo,\n    subtract: subtract\n  };\n}\n\nfunction isPointSelectionDef(o) {\n  return 'pointNumber' in o && 'searchInfo' in o;\n}\n/*\n * Constructs a new point number tester.\n */\n\n\nfunction newPointNumTester(pointSelectionDef) {\n  return {\n    xmin: 0,\n    xmax: 0,\n    ymin: 0,\n    ymax: 0,\n    pts: [],\n    contains: function (pt, omitFirstEdge, pointNumber, searchInfo) {\n      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;\n    },\n    isRect: false,\n    degenerate: false,\n    subtract: pointSelectionDef.subtract\n  };\n}\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\n\n\nfunction multiTester(list) {\n  var testers = [];\n  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n  var xmax = xmin;\n  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n  var ymax = ymin;\n\n  for (var i = 0; i < list.length; i++) {\n    if (isPointSelectionDef(list[i])) {\n      testers.push(newPointNumTester(list[i]));\n    } else {\n      var tester = polygon.tester(list[i]);\n      tester.subtract = list[i].subtract;\n      testers.push(tester);\n      xmin = Math.min(xmin, tester.xmin);\n      xmax = Math.max(xmax, tester.xmax);\n      ymin = Math.min(ymin, tester.ymin);\n      ymax = Math.max(ymax, tester.ymax);\n    }\n  }\n  /**\n   * Tests if the given point is within this tester.\n   *\n   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n   * @param {*} arg - An optional parameter to pass down to wrapped testers.\n   * @param {number} pointNumber - The point number of the point within the underlying data array.\n   * @param {number} searchInfo - An object identifying the trace the point is contained in.\n   *\n   * @return {boolean} true if point is considered to be selected, false otherwise.\n   */\n\n\n  function contains(pt, arg, pointNumber, searchInfo) {\n    var contained = false;\n\n    for (var i = 0; i < testers.length; i++) {\n      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n        // if contained by subtract tester - exclude the point\n        contained = testers[i].subtract === false;\n      }\n    }\n\n    return contained;\n  }\n\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: [],\n    contains: contains,\n    isRect: false,\n    degenerate: false\n  };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n  var fullLayout = gd._fullLayout;\n  var plotinfo = dragOptions.plotinfo;\n  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;\n  var hasModifierKey = evt.shiftKey || evt.altKey;\n\n  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {\n    // take over selection definitions from prev mode, if any\n    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n  } else if (!hasModifierKey || !plotinfo.selection) {\n    clearSelectionsCache(dragOptions);\n  } // clear selection outline when selecting a different subplot\n\n\n  if (!selectingOnSameSubplot) {\n    clearSelect(gd);\n    fullLayout._lastSelectedSubplot = plotinfo.id;\n  }\n}\n\nfunction clearSelectionsCache(dragOptions) {\n  var plotinfo = dragOptions.plotinfo;\n  plotinfo.selection = {};\n  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n  var searchTraces = [];\n  var xAxisIds = xAxes.map(getAxId);\n  var yAxisIds = yAxes.map(getAxId);\n  var cd, trace, i;\n\n  for (i = 0; i < gd.calcdata.length; i++) {\n    cd = gd.calcdata[i];\n    trace = cd[0].trace;\n    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n    if (subplot && (trace.subplot === subplot || trace.geo === subplot)) {\n      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n    } else if (trace.type === 'splom' && // FIXME: make sure we don't have more than single axis for splom\n    trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n      var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      info.scene = gd._fullLayout._splomScenes[trace.uid];\n      searchTraces.push(info);\n    } else if (trace.type === 'sankey') {\n      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      searchTraces.push(sankeyInfo);\n    } else {\n      if (xAxisIds.indexOf(trace.xaxis) === -1) continue;\n      if (yAxisIds.indexOf(trace.yaxis) === -1) continue;\n      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n    }\n  }\n\n  return searchTraces;\n\n  function createSearchInfo(module, calcData, xaxis, yaxis) {\n    return {\n      _module: module,\n      cd: calcData,\n      xaxis: xaxis,\n      yaxis: yaxis\n    };\n  }\n}\n\nfunction drawSelection(polygons, outlines) {\n  var paths = [];\n  var i, d;\n\n  for (i = 0; i < polygons.length; i++) {\n    var ppts = polygons[i];\n    paths.push(ppts.join('L') + 'L' + ppts[0]);\n  }\n\n  d = polygons.length > 0 ? 'M' + paths.join('M') + 'Z' : 'M0,0Z';\n  outlines.attr('d', d);\n}\n\nfunction isHoverDataSet(hoverData) {\n  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n  var hoverDatum = hoverData[0];\n  var pointNumber = -1;\n  var pointNumbers = [];\n  var searchInfo, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n      // Special case for box (and violin)\n      if (hoverDatum.hoverOnBox === true) {\n        break;\n      } // Hint: in some traces like histogram, one graphical element\n      // doesn't correspond to one particular data point, but to\n      // bins of data points. Thus, hoverDatum can have a binNumber\n      // property instead of pointNumber.\n\n\n      if (hoverDatum.pointNumber !== undefined) {\n        pointNumber = hoverDatum.pointNumber;\n      } else if (hoverDatum.binNumber !== undefined) {\n        pointNumber = hoverDatum.binNumber;\n        pointNumbers = hoverDatum.pointNumbers;\n      }\n\n      break;\n    }\n  }\n\n  return {\n    pointNumber: pointNumber,\n    pointNumbers: pointNumbers,\n    searchInfo: searchInfo\n  };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n  var trace = clickedPtInfo.searchInfo.cd[0].trace;\n  var ptNum = clickedPtInfo.pointNumber;\n  var ptNums = clickedPtInfo.pointNumbers;\n  var ptNumsSet = ptNums.length > 0; // When pointsNumbers is set (e.g. histogram's binning),\n  // it is assumed that when the first point of\n  // a bin is selected, all others are as well\n\n  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum; // TODO potential performance improvement\n  // Primarily we need this function to determine if a click adds\n  // or subtracts from a selection.\n  // In cases `trace.selectedpoints` is a huge array, indexOf\n  // might be slow. One remedy would be to introduce a hash somewhere.\n\n  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n  var tracesWithSelectedPts = [];\n  var searchInfo, trace, isSameTrace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n      tracesWithSelectedPts.push(searchInfo);\n    }\n  }\n\n  if (tracesWithSelectedPts.length === 1) {\n    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n\n    if (isSameTrace) {\n      trace = clickedPtInfo.searchInfo.cd[0].trace;\n\n      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n  var len = 0;\n  var searchInfo, trace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    trace = searchInfo.cd[0].trace;\n\n    if (trace.selectedpoints) {\n      if (trace.selectedpoints.length > 1) return false;\n      len += trace.selectedpoints.length;\n      if (len > 1) return false;\n    }\n  }\n\n  return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n  var i, searchInfo, cd, trace; // before anything else, update preGUI if necessary\n\n  for (i = 0; i < searchTraces.length; i++) {\n    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n\n    if (tracePreGUI.selectedpoints === undefined) {\n      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n    }\n  }\n\n  if (eventData) {\n    var pts = eventData.points || [];\n\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n      if (trace._fullInput !== trace) trace.selectedpoints = [];\n    }\n\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var data = pt.data;\n      var fullData = pt.fullData;\n\n      if (pt.pointIndices) {\n        [].push.apply(data.selectedpoints, pt.pointIndices);\n\n        if (trace._fullInput !== trace) {\n          [].push.apply(fullData.selectedpoints, pt.pointIndices);\n        }\n      } else {\n        data.selectedpoints.push(pt.pointIndex);\n\n        if (trace._fullInput !== trace) {\n          fullData.selectedpoints.push(pt.pointIndex);\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      delete trace.selectedpoints;\n      delete trace._input.selectedpoints;\n\n      if (trace._fullInput !== trace) {\n        delete trace._fullInput.selectedpoints;\n      }\n    }\n  }\n\n  var hasRegl = false;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    cd = searchInfo.cd;\n    trace = cd[0].trace;\n\n    if (Registry.traceIs(trace, 'regl')) {\n      hasRegl = true;\n    }\n\n    var _module = searchInfo._module;\n    var fn = _module.styleOnSelect || _module.style;\n\n    if (fn) {\n      fn(gd, cd, cd[0].node3);\n      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n    }\n  }\n\n  if (hasRegl) {\n    clearGlCanvases(gd);\n    redrawReglTraces(gd);\n  }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n  var res;\n\n  if (subtract) {\n    res = polybool.difference({\n      regions: list,\n      inverted: false\n    }, {\n      regions: [poly],\n      inverted: false\n    });\n    return res.regions;\n  }\n\n  res = polybool.union({\n    regions: list,\n    inverted: false\n  }, {\n    regions: [poly],\n    inverted: false\n  });\n  return res.regions;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n  if (Array.isArray(selection)) {\n    var cd = searchInfo.cd;\n    var trace = searchInfo.cd[0].trace;\n\n    for (var i = 0; i < selection.length; i++) {\n      selection[i] = makeEventData(selection[i], trace, cd);\n    }\n  }\n\n  return selection;\n} // until we get around to persistent selections, remove the outline\n// here. The selection itself will be removed when the plot redraws\n// at the end.\n\n\nfunction clearSelect(gd) {\n  var fullLayout = gd._fullLayout || {};\n  var zoomlayer = fullLayout._zoomlayer;\n\n  if (zoomlayer) {\n    zoomlayer.selectAll('.select-outline').remove();\n  }\n}\n\nmodule.exports = {\n  prepSelect: prepSelect,\n  clearSelect: clearSelect,\n  selectOnClick: selectOnClick\n};","map":null,"metadata":{},"sourceType":"script"}