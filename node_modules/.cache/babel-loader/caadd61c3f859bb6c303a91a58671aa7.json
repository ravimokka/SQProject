{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\n\nvar binFunctions = require('./bin_functions');\n\nvar normFunctions = require('./norm_functions');\n\nvar doAvg = require('./average');\n\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nfunction calc(gd, trace) {\n  var pos = [];\n  var size = [];\n  var pa = Axes.getFromId(gd, trace.orientation === 'h' ? trace.yaxis : trace.xaxis);\n  var mainData = trace.orientation === 'h' ? 'y' : 'x';\n  var counterData = {\n    x: 'y',\n    y: 'x'\n  }[mainData];\n  var calendar = trace[mainData + 'calendar'];\n  var cumulativeSpec = trace.cumulative;\n  var i;\n  var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n  var binSpec = binsAndPos[0];\n  var pos0 = binsAndPos[1];\n  var nonuniformBins = typeof binSpec.size === 'string';\n  var binEdges = [];\n  var bins = nonuniformBins ? binEdges : binSpec; // make the empty bin array\n\n  var inc = [];\n  var counts = [];\n  var inputPoints = [];\n  var total = 0;\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densityNorm = norm.indexOf('density') !== -1;\n  var i2, binEnd, n;\n\n  if (cumulativeSpec.enabled && densityNorm) {\n    // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n    // which in the end means it's the same as without \"density\"\n    norm = norm.replace(/ ?density$/, '');\n    densityNorm = false;\n  }\n\n  var extremeFunc = func === 'max' || func === 'min';\n  var sizeInit = extremeFunc ? null : 0;\n  var binFunc = binFunctions.count;\n  var normFunc = normFunctions[norm];\n  var isAvg = false;\n\n  var pr2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n\n  var rawCounterData;\n\n  if (Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n    rawCounterData = trace[counterData];\n    isAvg = func === 'avg';\n    binFunc = binFunctions[func];\n  } // create the bins (and any extra arrays needed)\n  // assume more than 1e6 bins is an error, so we don't crash the browser\n\n\n  i = pr2c(binSpec.start); // decrease end a little in case of rounding errors\n\n  binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n  while (i < binEnd && pos.length < 1e6) {\n    i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n    pos.push((i + i2) / 2);\n    size.push(sizeInit);\n    inputPoints.push([]); // nonuniform bins (like months) we need to search,\n    // rather than straight calculate the bin we're in\n\n    binEdges.push(i); // nonuniform bins also need nonuniform normalization factors\n\n    if (densityNorm) inc.push(1 / (i2 - i));\n    if (isAvg) counts.push(0); // break to avoid infinite loops\n\n    if (i2 <= i) break;\n    i = i2;\n  }\n\n  binEdges.push(i); // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n\n  if (!nonuniformBins && pa.type === 'date') {\n    bins = {\n      start: pr2c(bins.start),\n      end: pr2c(bins.end),\n      size: bins.size\n    };\n  } // bin the data\n  // and make histogram-specific pt-number-to-cd-index map object\n\n\n  var nMax = size.length;\n  var uniqueValsPerBin = true;\n  var leftGap = Infinity;\n  var rightGap = Infinity;\n  var ptNumber2cdIndex = {};\n\n  for (i = 0; i < pos0.length; i++) {\n    var posi = pos0[i];\n    n = Lib.findBin(posi, bins);\n\n    if (n >= 0 && n < nMax) {\n      total += binFunc(n, i, size, rawCounterData, counts);\n\n      if (uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n        uniqueValsPerBin = false;\n      }\n\n      inputPoints[n].push(i);\n      ptNumber2cdIndex[i] = n;\n      leftGap = Math.min(leftGap, posi - binEdges[n]);\n      rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n    }\n  }\n\n  var roundFn;\n\n  if (!uniqueValsPerBin) {\n    roundFn = getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar);\n  } // average and/or normalize the data, if needed\n\n\n  if (isAvg) total = doAvg(size, counts);\n  if (normFunc) normFunc(size, total, inc); // after all normalization etc, now we can accumulate if desired\n\n  if (cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n  var seriesLen = Math.min(pos.length, size.length);\n  var cd = [];\n  var firstNonzero = 0;\n  var lastNonzero = seriesLen - 1; // look for empty bins at the ends to remove, so autoscale omits them\n\n  for (i = 0; i < seriesLen; i++) {\n    if (size[i]) {\n      firstNonzero = i;\n      break;\n    }\n  }\n\n  for (i = seriesLen - 1; i >= firstNonzero; i--) {\n    if (size[i]) {\n      lastNonzero = i;\n      break;\n    }\n  } // create the \"calculated data\" to plot\n\n\n  for (i = firstNonzero; i <= lastNonzero; i++) {\n    if (isNumeric(pos[i]) && isNumeric(size[i])) {\n      var cdi = {\n        p: pos[i],\n        s: size[i],\n        b: 0\n      }; // setup hover and event data fields,\n      // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n      // for cumulative distributions\n\n      if (!cumulativeSpec.enabled) {\n        cdi.pts = inputPoints[i];\n\n        if (uniqueValsPerBin) {\n          cdi.ph0 = cdi.ph1 = inputPoints[i].length ? pos0[inputPoints[i][0]] : pos[i];\n        } else {\n          cdi.ph0 = roundFn(binEdges[i]);\n          cdi.ph1 = roundFn(binEdges[i + 1], true);\n        }\n      }\n\n      cd.push(cdi);\n    }\n  }\n\n  if (cd.length === 1) {\n    // when we collapse to a single bin, calcdata no longer describes bin size\n    // so we need to explicitly specify it\n    cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n  }\n\n  arraysToCalcdata(cd, trace);\n\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n  }\n\n  return cd;\n}\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\n\n\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n  var binAttr = mainData + 'bins';\n  var fullLayout = gd._fullLayout;\n  var groupName = trace['_' + mainData + 'bingroup'];\n  var binOpts = fullLayout._histogramBinOpts[groupName];\n  var isOverlay = fullLayout.barmode === 'overlay';\n  var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n  var r2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n\n  var c2r = function (v) {\n    return pa.c2r(v, 0, calendar);\n  };\n\n  var cleanBound = pa.type === 'date' ? function (v) {\n    return v || v === 0 ? Lib.cleanDate(v, null, calendar) : null;\n  } : function (v) {\n    return isNumeric(v) ? Number(v) : null;\n  };\n\n  function setBound(attr, bins, newBins) {\n    if (bins[attr + 'Found']) {\n      bins[attr] = cleanBound(bins[attr]);\n      if (bins[attr] === null) bins[attr] = newBins[attr];\n    } else {\n      autoVals[attr] = bins[attr] = newBins[attr];\n      Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n    }\n  } // all but the first trace in this group has already been marked finished\n  // clear this flag, so next time we run calc we will run autobin again\n\n\n  if (trace['_' + mainData + 'autoBinFinished']) {\n    delete trace['_' + mainData + 'autoBinFinished'];\n  } else {\n    traces = binOpts.traces;\n    var allPos = []; // Note: we're including `legendonly` traces here for autobin purposes,\n    // so that showing & hiding from the legend won't affect bins.\n    // But this complicates things a bit since those traces don't `calc`,\n    // hence `isFirstVisible`.\n\n    var isFirstVisible = true;\n    var has2dMap = false;\n    var hasHist2dContour = false;\n\n    for (i = 0; i < traces.length; i++) {\n      tracei = traces[i];\n\n      if (tracei.visible) {\n        var mainDatai = binOpts.dirs[i];\n        pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n        allPos = Lib.concat(allPos, pos0);\n        delete tracei['_' + mainData + 'autoBinFinished'];\n\n        if (trace.visible === true) {\n          if (isFirstVisible) {\n            isFirstVisible = false;\n          } else {\n            delete tracei._autoBin;\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n          }\n\n          if (Registry.traceIs(tracei, '2dMap')) {\n            has2dMap = true;\n          }\n\n          if (tracei.type === 'histogram2dcontour') {\n            hasHist2dContour = true;\n          }\n        }\n      }\n    }\n\n    calendar = traces[0][mainData + 'calendar'];\n    var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n    var autoBin = traces[0]._autoBin = {};\n    autoVals = autoBin[binOpts.dirs[0]] = {};\n\n    if (hasHist2dContour) {\n      // the \"true\" 2nd argument reverses the tick direction (which we can't\n      // just do with a minus sign because of month bins)\n      if (!binOpts.size) {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      }\n\n      if (binOpts.end === undefined) {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    } // Edge case: single-valued histogram overlaying others\n    // Use them all together to calculate the bin size for the single-valued one\n\n\n    if (isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 && pa.type !== 'category' && pa.type !== 'multicategory') {\n      // Several single-valued histograms! Stop infinite recursion,\n      // just return an extra flag that tells handleSingleValueOverlays\n      // to sort out this trace too\n      if (_overlayEdgeCase) return [newBinSpec, pos0, true];\n      newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n    } // adjust for CDF edge cases\n\n\n    cumulativeSpec = tracei.cumulative || {};\n\n    if (cumulativeSpec.enabled && cumulativeSpec.currentbin !== 'include') {\n      if (cumulativeSpec.direction === 'decreasing') {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      } else {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    }\n\n    binOpts.size = newBinSpec.size;\n\n    if (!binOpts.sizeFound) {\n      autoVals.size = newBinSpec.size;\n      Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n    }\n\n    setBound('start', binOpts, newBinSpec);\n    setBound('end', binOpts, newBinSpec);\n  }\n\n  pos0 = trace['_' + mainData + 'pos0'];\n  delete trace['_' + mainData + 'pos0']; // Each trace can specify its own start/end, or if omitted\n  // we ensure they're beyond the bounds of this trace's data,\n  // and we need to make sure start is aligned with the main start\n\n  var traceInputBins = trace._input[binAttr] || {};\n  var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n  var mainStart = binOpts.start;\n  var startIn = pa.r2l(traceInputBins.start);\n  var hasStart = startIn !== undefined;\n\n  if ((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n    // We have an explicit start to reconcile across traces\n    // if this trace has an explicit start, shift it down to a bin edge\n    // if another trace had an explicit start, shift it down to a\n    // bin edge past our data\n    var traceStart = hasStart ? startIn : Lib.aggNums(Math.min, null, pos0);\n    var dummyAx = {\n      type: pa.type === 'category' || pa.type === 'multicategory' ? 'linear' : pa.type,\n      r2l: pa.r2l,\n      dtick: binOpts.size,\n      tick0: mainStart,\n      calendar: calendar,\n      range: [traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)].map(pa.l2r)\n    };\n    var newStart = Axes.tickFirst(dummyAx);\n\n    if (newStart > pa.r2l(traceStart)) {\n      newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n    }\n\n    traceBinOptsCalc.start = pa.l2r(newStart);\n    if (!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n  }\n\n  var mainEnd = binOpts.end;\n  var endIn = pa.r2l(traceInputBins.end);\n  var hasEnd = endIn !== undefined;\n\n  if ((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n    // Reconciling an explicit end is easier, as it doesn't need to\n    // match bin edges\n    var traceEnd = hasEnd ? endIn : Lib.aggNums(Math.max, null, pos0);\n    traceBinOptsCalc.end = pa.l2r(traceEnd);\n    if (!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n  } // Backward compatibility for one-time autobinning.\n  // autobin: true is handled in cleanData, but autobin: false\n  // needs to be here where we have determined the values.\n\n\n  var autoBinAttr = 'autobin' + mainData;\n\n  if (trace._input[autoBinAttr] === false) {\n    trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n    delete trace._input[autoBinAttr];\n    delete trace[autoBinAttr];\n  }\n\n  return [traceBinOptsCalc, pos0];\n}\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\n\n\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n  var fullLayout = gd._fullLayout;\n  var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n  var pastThisTrace = false;\n  var minSize = Infinity;\n  var singleValuedTraces = [trace];\n  var i, tracei, binOpts; // first collect all the:\n  // - min bin size from all multi-valued traces\n  // - single-valued traces\n\n  for (i = 0; i < overlaidTraceGroup.length; i++) {\n    tracei = overlaidTraceGroup[i];\n\n    if (tracei === trace) {\n      pastThisTrace = true;\n    } else if (!pastThisTrace) {\n      // This trace has already had its autobins calculated, so either:\n      // - it is part of a bingroup\n      // - it is NOT a single-valued trace\n      binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n      minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n    } else {\n      var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n      var binSpeci = resulti[0];\n      var isSingleValued = resulti[2]; // so we can use this result when we get to tracei in the normal\n      // course of events, mark it as done and put _pos0 back\n\n      tracei['_' + mainData + 'autoBinFinished'] = 1;\n      tracei['_' + mainData + 'pos0'] = resulti[1];\n\n      if (isSingleValued) {\n        singleValuedTraces.push(tracei);\n      } else {\n        minSize = Math.min(minSize, binSpeci.size);\n      }\n    }\n  } // find the real data values for each single-valued trace\n  // hunt through pos0 for the first valid value\n\n\n  var dataVals = new Array(singleValuedTraces.length);\n\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n\n    for (var j = 0; j < pos0.length; j++) {\n      if (pos0[j] !== undefined) {\n        dataVals[i] = pos0[j];\n        break;\n      }\n    }\n  } // are ALL traces are single-valued? use the min difference between\n  // all of their values (which defaults to 1 if there's still only one)\n\n\n  if (!isFinite(minSize)) {\n    minSize = Lib.distinctVals(dataVals).minDiff;\n  } // now apply the min size we found to all single-valued traces\n\n\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    tracei = singleValuedTraces[i];\n    var calendar = tracei[mainData + 'calendar'];\n    var newBins = {\n      start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n      end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n      size: minSize\n    };\n    tracei._input[binAttr] = tracei[binAttr] = newBins;\n    binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n    if (binOpts) Lib.extendFlat(binOpts, newBins);\n  }\n\n  return trace[binAttr];\n}\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\n\n\nfunction getConnectedHistograms(gd, trace) {\n  var xid = trace.xaxis;\n  var yid = trace.yaxis;\n  var orientation = trace.orientation;\n  var out = [];\n  var fullData = gd._fullData;\n\n  for (var i = 0; i < fullData.length; i++) {\n    var tracei = fullData[i];\n\n    if (tracei.type === 'histogram' && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {\n      out.push(tracei);\n    }\n  }\n\n  return out;\n}\n\nfunction cdf(size, direction, currentBin) {\n  var i, vi, prevSum;\n\n  function firstHalfPoint(i) {\n    prevSum = size[i];\n    size[i] /= 2;\n  }\n\n  function nextHalfPoint(i) {\n    vi = size[i];\n    size[i] = prevSum + vi / 2;\n    prevSum += vi;\n  }\n\n  if (currentBin === 'half') {\n    if (direction === 'increasing') {\n      firstHalfPoint(0);\n\n      for (i = 1; i < size.length; i++) {\n        nextHalfPoint(i);\n      }\n    } else {\n      firstHalfPoint(size.length - 1);\n\n      for (i = size.length - 2; i >= 0; i--) {\n        nextHalfPoint(i);\n      }\n    }\n  } else if (direction === 'increasing') {\n    for (i = 1; i < size.length; i++) {\n      size[i] += size[i - 1];\n    } // 'exclude' is identical to 'include' just shifted one bin over\n\n\n    if (currentBin === 'exclude') {\n      size.unshift(0);\n      size.pop();\n    }\n  } else {\n    for (i = size.length - 2; i >= 0; i--) {\n      size[i] += size[i + 1];\n    }\n\n    if (currentBin === 'exclude') {\n      size.push(0);\n      size.shift();\n    }\n  }\n}\n\nmodule.exports = {\n  calc: calc,\n  calcAllAutoBins: calcAllAutoBins\n};","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/traces/histogram/calc.js"],"names":["isNumeric","require","Lib","Registry","Axes","arraysToCalcdata","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","calc","gd","trace","pos","size","pa","getFromId","orientation","yaxis","xaxis","mainData","counterData","x","y","calendar","cumulativeSpec","cumulative","i","binsAndPos","calcAllAutoBins","binSpec","pos0","nonuniformBins","binEdges","bins","inc","counts","inputPoints","total","norm","histnorm","func","histfunc","densityNorm","indexOf","i2","binEnd","n","enabled","replace","extremeFunc","sizeInit","binFunc","count","normFunc","isAvg","pr2c","v","r2c","rawCounterData","isArrayOrTypedArray","start","end","tickIncrement","length","push","type","nMax","uniqueValsPerBin","leftGap","Infinity","rightGap","ptNumber2cdIndex","posi","findBin","Math","min","roundFn","cdf","direction","currentbin","seriesLen","cd","firstNonzero","lastNonzero","cdi","p","s","b","pts","ph0","ph1","width1","selectedpoints","tagSelected","_overlayEdgeCase","binAttr","fullLayout","_fullLayout","groupName","binOpts","_histogramBinOpts","isOverlay","barmode","traces","tracei","autoVals","c2r","cleanBound","cleanDate","Number","setBound","attr","newBins","nestedProperty","set","allPos","isFirstVisible","has2dMap","hasHist2dContour","visible","mainDatai","dirs","makeCalcdata","concat","_autoBin","traceIs","newBinSpec","autoBin","nbins","sizeFound","undefined","_dataSpan","handleSingleValueOverlays","traceInputBins","_input","traceBinOptsCalc","extendFlat","mainStart","startIn","r2l","hasStart","startFound","traceStart","aggNums","dummyAx","dtick","tick0","range","map","l2r","newStart","tickFirst","mainEnd","endIn","hasEnd","endFound","traceEnd","max","autoBinAttr","overlaidTraceGroup","getConnectedHistograms","pastThisTrace","minSize","singleValuedTraces","resulti","binSpeci","isSingleValued","dataVals","Array","j","isFinite","distinctVals","minDiff","xid","yid","out","fullData","_fullData","currentBin","vi","prevSum","firstHalfPoint","nextHalfPoint","unshift","pop","shift","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar binFunctions = require('./bin_functions');\nvar normFunctions = require('./norm_functions');\nvar doAvg = require('./average');\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nfunction calc(gd, trace) {\n    var pos = [];\n    var size = [];\n    var pa = Axes.getFromId(gd, trace.orientation === 'h' ? trace.yaxis : trace.xaxis);\n    var mainData = trace.orientation === 'h' ? 'y' : 'x';\n    var counterData = {x: 'y', y: 'x'}[mainData];\n    var calendar = trace[mainData + 'calendar'];\n    var cumulativeSpec = trace.cumulative;\n    var i;\n\n    var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n    var binSpec = binsAndPos[0];\n    var pos0 = binsAndPos[1];\n\n    var nonuniformBins = typeof binSpec.size === 'string';\n    var binEdges = [];\n    var bins = nonuniformBins ? binEdges : binSpec;\n    // make the empty bin array\n    var inc = [];\n    var counts = [];\n    var inputPoints = [];\n    var total = 0;\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densityNorm = norm.indexOf('density') !== -1;\n    var i2, binEnd, n;\n\n    if(cumulativeSpec.enabled && densityNorm) {\n        // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n        // which in the end means it's the same as without \"density\"\n        norm = norm.replace(/ ?density$/, '');\n        densityNorm = false;\n    }\n\n    var extremeFunc = func === 'max' || func === 'min';\n    var sizeInit = extremeFunc ? null : 0;\n    var binFunc = binFunctions.count;\n    var normFunc = normFunctions[norm];\n    var isAvg = false;\n    var pr2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var rawCounterData;\n\n    if(Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n        rawCounterData = trace[counterData];\n        isAvg = func === 'avg';\n        binFunc = binFunctions[func];\n    }\n\n    // create the bins (and any extra arrays needed)\n    // assume more than 1e6 bins is an error, so we don't crash the browser\n    i = pr2c(binSpec.start);\n\n    // decrease end a little in case of rounding errors\n    binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n    while(i < binEnd && pos.length < 1e6) {\n        i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n        pos.push((i + i2) / 2);\n        size.push(sizeInit);\n        inputPoints.push([]);\n        // nonuniform bins (like months) we need to search,\n        // rather than straight calculate the bin we're in\n        binEdges.push(i);\n        // nonuniform bins also need nonuniform normalization factors\n        if(densityNorm) inc.push(1 / (i2 - i));\n        if(isAvg) counts.push(0);\n        // break to avoid infinite loops\n        if(i2 <= i) break;\n        i = i2;\n    }\n    binEdges.push(i);\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBins && pa.type === 'date') {\n        bins = {\n            start: pr2c(bins.start),\n            end: pr2c(bins.end),\n            size: bins.size\n        };\n    }\n\n    // bin the data\n    // and make histogram-specific pt-number-to-cd-index map object\n    var nMax = size.length;\n    var uniqueValsPerBin = true;\n    var leftGap = Infinity;\n    var rightGap = Infinity;\n    var ptNumber2cdIndex = {};\n    for(i = 0; i < pos0.length; i++) {\n        var posi = pos0[i];\n        n = Lib.findBin(posi, bins);\n        if(n >= 0 && n < nMax) {\n            total += binFunc(n, i, size, rawCounterData, counts);\n            if(uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n                uniqueValsPerBin = false;\n            }\n            inputPoints[n].push(i);\n            ptNumber2cdIndex[i] = n;\n\n            leftGap = Math.min(leftGap, posi - binEdges[n]);\n            rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n        }\n    }\n\n    var roundFn;\n    if(!uniqueValsPerBin) {\n        roundFn = getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar);\n    }\n\n    // average and/or normalize the data, if needed\n    if(isAvg) total = doAvg(size, counts);\n    if(normFunc) normFunc(size, total, inc);\n\n    // after all normalization etc, now we can accumulate if desired\n    if(cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n\n    var seriesLen = Math.min(pos.length, size.length);\n    var cd = [];\n    var firstNonzero = 0;\n    var lastNonzero = seriesLen - 1;\n\n    // look for empty bins at the ends to remove, so autoscale omits them\n    for(i = 0; i < seriesLen; i++) {\n        if(size[i]) {\n            firstNonzero = i;\n            break;\n        }\n    }\n    for(i = seriesLen - 1; i >= firstNonzero; i--) {\n        if(size[i]) {\n            lastNonzero = i;\n            break;\n        }\n    }\n\n    // create the \"calculated data\" to plot\n    for(i = firstNonzero; i <= lastNonzero; i++) {\n        if((isNumeric(pos[i]) && isNumeric(size[i]))) {\n            var cdi = {\n                p: pos[i],\n                s: size[i],\n                b: 0\n            };\n\n            // setup hover and event data fields,\n            // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n            // for cumulative distributions\n            if(!cumulativeSpec.enabled) {\n                cdi.pts = inputPoints[i];\n                if(uniqueValsPerBin) {\n                    cdi.ph0 = cdi.ph1 = (inputPoints[i].length) ? pos0[inputPoints[i][0]] : pos[i];\n                } else {\n                    cdi.ph0 = roundFn(binEdges[i]);\n                    cdi.ph1 = roundFn(binEdges[i + 1], true);\n                }\n            }\n            cd.push(cdi);\n        }\n    }\n\n    if(cd.length === 1) {\n        // when we collapse to a single bin, calcdata no longer describes bin size\n        // so we need to explicitly specify it\n        cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n    }\n\n    arraysToCalcdata(cd, trace);\n\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n    }\n\n    return cd;\n}\n\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n    var binAttr = mainData + 'bins';\n    var fullLayout = gd._fullLayout;\n    var groupName = trace['_' + mainData + 'bingroup'];\n    var binOpts = fullLayout._histogramBinOpts[groupName];\n    var isOverlay = fullLayout.barmode === 'overlay';\n    var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n    var r2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var c2r = function(v) { return pa.c2r(v, 0, calendar); };\n\n    var cleanBound = pa.type === 'date' ?\n        function(v) { return (v || v === 0) ? Lib.cleanDate(v, null, calendar) : null; } :\n        function(v) { return isNumeric(v) ? Number(v) : null; };\n\n    function setBound(attr, bins, newBins) {\n        if(bins[attr + 'Found']) {\n            bins[attr] = cleanBound(bins[attr]);\n            if(bins[attr] === null) bins[attr] = newBins[attr];\n        } else {\n            autoVals[attr] = bins[attr] = newBins[attr];\n            Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n        }\n    }\n\n    // all but the first trace in this group has already been marked finished\n    // clear this flag, so next time we run calc we will run autobin again\n    if(trace['_' + mainData + 'autoBinFinished']) {\n        delete trace['_' + mainData + 'autoBinFinished'];\n    } else {\n        traces = binOpts.traces;\n        var allPos = [];\n\n        // Note: we're including `legendonly` traces here for autobin purposes,\n        // so that showing & hiding from the legend won't affect bins.\n        // But this complicates things a bit since those traces don't `calc`,\n        // hence `isFirstVisible`.\n        var isFirstVisible = true;\n        var has2dMap = false;\n        var hasHist2dContour = false;\n        for(i = 0; i < traces.length; i++) {\n            tracei = traces[i];\n\n            if(tracei.visible) {\n                var mainDatai = binOpts.dirs[i];\n                pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n\n                allPos = Lib.concat(allPos, pos0);\n                delete tracei['_' + mainData + 'autoBinFinished'];\n\n                if(trace.visible === true) {\n                    if(isFirstVisible) {\n                        isFirstVisible = false;\n                    } else {\n                        delete tracei._autoBin;\n                        tracei['_' + mainData + 'autoBinFinished'] = 1;\n                    }\n                    if(Registry.traceIs(tracei, '2dMap')) {\n                        has2dMap = true;\n                    }\n                    if(tracei.type === 'histogram2dcontour') {\n                        hasHist2dContour = true;\n                    }\n                }\n            }\n        }\n\n        calendar = traces[0][mainData + 'calendar'];\n        var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n\n        var autoBin = traces[0]._autoBin = {};\n        autoVals = autoBin[binOpts.dirs[0]] = {};\n\n        if(hasHist2dContour) {\n            // the \"true\" 2nd argument reverses the tick direction (which we can't\n            // just do with a minus sign because of month bins)\n            if(!binOpts.size) {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            }\n            if(binOpts.end === undefined) {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n\n        // Edge case: single-valued histogram overlaying others\n        // Use them all together to calculate the bin size for the single-valued one\n        if(isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 &&\n            pa.type !== 'category' && pa.type !== 'multicategory') {\n            // Several single-valued histograms! Stop infinite recursion,\n            // just return an extra flag that tells handleSingleValueOverlays\n            // to sort out this trace too\n            if(_overlayEdgeCase) return [newBinSpec, pos0, true];\n\n            newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n        }\n\n        // adjust for CDF edge cases\n        cumulativeSpec = tracei.cumulative || {};\n        if(cumulativeSpec.enabled && (cumulativeSpec.currentbin !== 'include')) {\n            if(cumulativeSpec.direction === 'decreasing') {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            } else {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n\n        binOpts.size = newBinSpec.size;\n        if(!binOpts.sizeFound) {\n            autoVals.size = newBinSpec.size;\n            Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n        }\n\n        setBound('start', binOpts, newBinSpec);\n        setBound('end', binOpts, newBinSpec);\n    }\n\n    pos0 = trace['_' + mainData + 'pos0'];\n    delete trace['_' + mainData + 'pos0'];\n\n    // Each trace can specify its own start/end, or if omitted\n    // we ensure they're beyond the bounds of this trace's data,\n    // and we need to make sure start is aligned with the main start\n    var traceInputBins = trace._input[binAttr] || {};\n    var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n    var mainStart = binOpts.start;\n    var startIn = pa.r2l(traceInputBins.start);\n    var hasStart = startIn !== undefined;\n    if((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n        // We have an explicit start to reconcile across traces\n        // if this trace has an explicit start, shift it down to a bin edge\n        // if another trace had an explicit start, shift it down to a\n        // bin edge past our data\n        var traceStart = hasStart ?\n            startIn :\n            Lib.aggNums(Math.min, null, pos0);\n\n        var dummyAx = {\n            type: (pa.type === 'category' || pa.type === 'multicategory') ? 'linear' : pa.type,\n            r2l: pa.r2l,\n            dtick: binOpts.size,\n            tick0: mainStart,\n            calendar: calendar,\n            range: ([traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)]).map(pa.l2r)\n        };\n        var newStart = Axes.tickFirst(dummyAx);\n        if(newStart > pa.r2l(traceStart)) {\n            newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n        }\n        traceBinOptsCalc.start = pa.l2r(newStart);\n        if(!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n    }\n\n    var mainEnd = binOpts.end;\n    var endIn = pa.r2l(traceInputBins.end);\n    var hasEnd = endIn !== undefined;\n    if((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n        // Reconciling an explicit end is easier, as it doesn't need to\n        // match bin edges\n        var traceEnd = hasEnd ?\n            endIn :\n            Lib.aggNums(Math.max, null, pos0);\n\n        traceBinOptsCalc.end = pa.l2r(traceEnd);\n        if(!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n    }\n\n    // Backward compatibility for one-time autobinning.\n    // autobin: true is handled in cleanData, but autobin: false\n    // needs to be here where we have determined the values.\n    var autoBinAttr = 'autobin' + mainData;\n    if(trace._input[autoBinAttr] === false) {\n        trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n        delete trace._input[autoBinAttr];\n        delete trace[autoBinAttr];\n    }\n\n    return [traceBinOptsCalc, pos0];\n}\n\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n    var fullLayout = gd._fullLayout;\n    var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n    var pastThisTrace = false;\n    var minSize = Infinity;\n    var singleValuedTraces = [trace];\n    var i, tracei, binOpts;\n\n    // first collect all the:\n    // - min bin size from all multi-valued traces\n    // - single-valued traces\n    for(i = 0; i < overlaidTraceGroup.length; i++) {\n        tracei = overlaidTraceGroup[i];\n\n        if(tracei === trace) {\n            pastThisTrace = true;\n        } else if(!pastThisTrace) {\n            // This trace has already had its autobins calculated, so either:\n            // - it is part of a bingroup\n            // - it is NOT a single-valued trace\n            binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n            minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n        } else {\n            var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n            var binSpeci = resulti[0];\n            var isSingleValued = resulti[2];\n\n            // so we can use this result when we get to tracei in the normal\n            // course of events, mark it as done and put _pos0 back\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n            tracei['_' + mainData + 'pos0'] = resulti[1];\n\n            if(isSingleValued) {\n                singleValuedTraces.push(tracei);\n            } else {\n                minSize = Math.min(minSize, binSpeci.size);\n            }\n        }\n    }\n\n    // find the real data values for each single-valued trace\n    // hunt through pos0 for the first valid value\n    var dataVals = new Array(singleValuedTraces.length);\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n        for(var j = 0; j < pos0.length; j++) {\n            if(pos0[j] !== undefined) {\n                dataVals[i] = pos0[j];\n                break;\n            }\n        }\n    }\n\n    // are ALL traces are single-valued? use the min difference between\n    // all of their values (which defaults to 1 if there's still only one)\n    if(!isFinite(minSize)) {\n        minSize = Lib.distinctVals(dataVals).minDiff;\n    }\n\n    // now apply the min size we found to all single-valued traces\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        tracei = singleValuedTraces[i];\n        var calendar = tracei[mainData + 'calendar'];\n\n        var newBins = {\n            start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n            end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n            size: minSize\n        };\n\n        tracei._input[binAttr] = tracei[binAttr] = newBins;\n\n        binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n        if(binOpts) Lib.extendFlat(binOpts, newBins);\n    }\n\n    return trace[binAttr];\n}\n\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\nfunction getConnectedHistograms(gd, trace) {\n    var xid = trace.xaxis;\n    var yid = trace.yaxis;\n    var orientation = trace.orientation;\n\n    var out = [];\n    var fullData = gd._fullData;\n    for(var i = 0; i < fullData.length; i++) {\n        var tracei = fullData[i];\n        if(tracei.type === 'histogram' &&\n            tracei.visible === true &&\n            tracei.orientation === orientation &&\n            tracei.xaxis === xid && tracei.yaxis === yid\n        ) {\n            out.push(tracei);\n        }\n    }\n\n    return out;\n}\n\nfunction cdf(size, direction, currentBin) {\n    var i, vi, prevSum;\n\n    function firstHalfPoint(i) {\n        prevSum = size[i];\n        size[i] /= 2;\n    }\n\n    function nextHalfPoint(i) {\n        vi = size[i];\n        size[i] = prevSum + vi / 2;\n        prevSum += vi;\n    }\n\n    if(currentBin === 'half') {\n        if(direction === 'increasing') {\n            firstHalfPoint(0);\n            for(i = 1; i < size.length; i++) {\n                nextHalfPoint(i);\n            }\n        } else {\n            firstHalfPoint(size.length - 1);\n            for(i = size.length - 2; i >= 0; i--) {\n                nextHalfPoint(i);\n            }\n        }\n    } else if(direction === 'increasing') {\n        for(i = 1; i < size.length; i++) {\n            size[i] += size[i - 1];\n        }\n\n        // 'exclude' is identical to 'include' just shifted one bin over\n        if(currentBin === 'exclude') {\n            size.unshift(0);\n            size.pop();\n        }\n    } else {\n        for(i = size.length - 2; i >= 0; i--) {\n            size[i] += size[i + 1];\n        }\n\n        if(currentBin === 'exclude') {\n            size.push(0);\n            size.shift();\n        }\n    }\n}\n\nmodule.exports = {\n    calc: calc,\n    calcAllAutoBins: calcAllAutoBins\n};\n"]},"metadata":{},"sourceType":"script"}