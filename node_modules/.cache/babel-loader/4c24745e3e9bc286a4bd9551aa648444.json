{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\n\nvar Events = require('../../lib/events');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar overrideCursor = require('../../lib/override_cursor');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar dragElement = require('../dragelement');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants'); // hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\n\n\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180; // expansion of projected height\n\nvar YFACTOR = 1 / Math.sin(YA_RADIANS); // to make the appropriate post-rotation x offset,\n// you need both x and y offsets\n\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS); // size and display constants for hover text\n\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD; // fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\n\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n  gd = Lib.getGraphDiv(gd);\n  Lib.throttle(gd._fullLayout._uid + constants.HOVERID, constants.HOVERMINTIME, function () {\n    _hover(gd, evt, subplot, noHoverEvent);\n  });\n};\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\n\n\nexports.loneHover = function loneHover(hoverItems, opts) {\n  var multiHover = true;\n\n  if (!Array.isArray(hoverItems)) {\n    multiHover = false;\n    hoverItems = [hoverItems];\n  }\n\n  var pointsData = hoverItems.map(function (hoverItem) {\n    return {\n      color: hoverItem.color || Color.defaultLine,\n      x0: hoverItem.x0 || hoverItem.x || 0,\n      x1: hoverItem.x1 || hoverItem.x || 0,\n      y0: hoverItem.y0 || hoverItem.y || 0,\n      y1: hoverItem.y1 || hoverItem.y || 0,\n      xLabel: hoverItem.xLabel,\n      yLabel: hoverItem.yLabel,\n      zLabel: hoverItem.zLabel,\n      text: hoverItem.text,\n      name: hoverItem.name,\n      idealAlign: hoverItem.idealAlign,\n      // optional extra bits of styling\n      borderColor: hoverItem.borderColor,\n      fontFamily: hoverItem.fontFamily,\n      fontSize: hoverItem.fontSize,\n      fontColor: hoverItem.fontColor,\n      nameLength: hoverItem.nameLength,\n      textAlign: hoverItem.textAlign,\n      // filler to make createHoverText happy\n      trace: hoverItem.trace || {\n        index: 0,\n        hoverinfo: ''\n      },\n      xa: {\n        _offset: 0\n      },\n      ya: {\n        _offset: 0\n      },\n      index: 0,\n      hovertemplate: hoverItem.hovertemplate || false,\n      eventData: hoverItem.eventData || false,\n      hovertemplateLabels: hoverItem.hovertemplateLabels || false\n    };\n  });\n  var container3 = d3.select(opts.container);\n  var outerContainer3 = opts.outerContainer ? d3.select(opts.outerContainer) : container3;\n  var fullOpts = {\n    hovermode: 'closest',\n    rotateLabels: false,\n    bgColor: opts.bgColor || Color.background,\n    container: container3,\n    outerContainer: outerContainer3\n  };\n  var hoverLabel = createHoverText(pointsData, fullOpts, opts.gd); // Fix vertical overlap\n\n  var tooltipSpacing = 5;\n  var lastBottomY = 0;\n  var anchor = 0;\n  hoverLabel.sort(function (a, b) {\n    return a.y0 - b.y0;\n  }).each(function (d, i) {\n    var topY = d.y0 - d.by / 2;\n\n    if (topY - tooltipSpacing < lastBottomY) {\n      d.offset = lastBottomY - topY + tooltipSpacing;\n    } else {\n      d.offset = 0;\n    }\n\n    lastBottomY = topY + d.by + d.offset;\n    if (i === opts.anchorIndex || 0) anchor = d.offset;\n  }).each(function (d) {\n    d.offset -= anchor;\n  });\n  alignHoverText(hoverLabel, fullOpts.rotateLabels);\n  return multiHover ? hoverLabel : hoverLabel.node();\n}; // The actual implementation is here:\n\n\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n  if (!subplot) subplot = 'xy'; // if the user passed in an array of subplots,\n  // use those instead of finding overlayed plots\n\n  var subplots = Array.isArray(subplot) ? subplot : [subplot];\n  var fullLayout = gd._fullLayout;\n  var plots = fullLayout._plots || [];\n  var plotinfo = plots[subplot];\n\n  var hasCartesian = fullLayout._has('cartesian'); // list of all overlaid subplots to look at\n\n\n  if (plotinfo) {\n    var overlayedSubplots = plotinfo.overlays.map(function (pi) {\n      return pi.id;\n    });\n    subplots = subplots.concat(overlayedSubplots);\n  }\n\n  var len = subplots.length;\n  var xaArray = new Array(len);\n  var yaArray = new Array(len);\n  var supportsCompare = false;\n\n  for (var i = 0; i < len; i++) {\n    var spId = subplots[i];\n\n    if (plots[spId]) {\n      // 'cartesian' case\n      supportsCompare = true;\n      xaArray[i] = plots[spId].xaxis;\n      yaArray[i] = plots[spId].yaxis;\n    } else if (fullLayout[spId] && fullLayout[spId]._subplot) {\n      // other subplot types\n      var _subplot = fullLayout[spId]._subplot;\n      xaArray[i] = _subplot.xaxis;\n      yaArray[i] = _subplot.yaxis;\n    } else {\n      Lib.warn('Unrecognized subplot: ' + spId);\n      return;\n    }\n  }\n\n  var hovermode = evt.hovermode || fullLayout.hovermode;\n  if (hovermode && !supportsCompare) hovermode = 'closest';\n\n  if (['x', 'y', 'closest'].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector('.zoombox') || gd._dragging) {\n    return dragElement.unhoverRaw(gd, evt);\n  }\n\n  var hoverdistance = fullLayout.hoverdistance === -1 ? Infinity : fullLayout.hoverdistance;\n  var spikedistance = fullLayout.spikedistance === -1 ? Infinity : fullLayout.spikedistance; // hoverData: the set of candidate points we've found to highlight\n\n  var hoverData = []; // searchData: the data to search in. Mostly this is just a copy of\n  // gd.calcdata, filtered to the subplot and overlays we're on\n  // but if a point array is supplied it will be a mapping\n  // of indicated curves\n\n  var searchData = []; // [x|y]valArray: the axis values of the hover event\n  // mapped onto each of the currently selected overlaid subplots\n\n  var xvalArray, yvalArray;\n  var itemnum, curvenum, cd, trace, subplotId, subploti, mode, xval, yval, pointData, closedataPreviousLength; // spikePoints: the set of candidate points we've found to draw spikes to\n\n  var spikePoints = {\n    hLinePoint: null,\n    vLinePoint: null\n  }; // does subplot have one (or more) horizontal traces?\n  // This is used to determine whether we rotate the labels or not\n\n  var hasOneHorizontalTrace = false; // Figure out what we're hovering on:\n  // mouse location or user-supplied data\n\n  if (Array.isArray(evt)) {\n    // user specified an array of points to highlight\n    hovermode = 'array';\n\n    for (itemnum = 0; itemnum < evt.length; itemnum++) {\n      cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n\n      if (cd) {\n        trace = cd[0].trace;\n\n        if (cd[0].trace.hoverinfo !== 'skip') {\n          searchData.push(cd);\n\n          if (trace.orientation === 'h') {\n            hasOneHorizontalTrace = true;\n          }\n        }\n      }\n    }\n  } else {\n    for (curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n      cd = gd.calcdata[curvenum];\n      trace = cd[0].trace;\n\n      if (trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n        searchData.push(cd);\n\n        if (trace.orientation === 'h') {\n          hasOneHorizontalTrace = true;\n        }\n      }\n    } // [x|y]px: the pixels (from top left) of the mouse location\n    // on the currently selected plot area\n    // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n\n\n    var hasUserCalledHover = !evt.target;\n    var xpx, ypx;\n\n    if (hasUserCalledHover) {\n      if ('xpx' in evt) xpx = evt.xpx;else xpx = xaArray[0]._length / 2;\n      if ('ypx' in evt) ypx = evt.ypx;else ypx = yaArray[0]._length / 2;\n    } else {\n      // fire the beforehover event and quit if it returns false\n      // note that we're only calling this on real mouse events, so\n      // manual calls to fx.hover will always run.\n      if (Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n        return;\n      }\n\n      var dbb = evt.target.getBoundingClientRect();\n      xpx = evt.clientX - dbb.left;\n      ypx = evt.clientY - dbb.top; // in case hover was called from mouseout into hovertext,\n      // it's possible you're not actually over the plot anymore\n\n      if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n        return dragElement.unhoverRaw(gd, evt);\n      }\n    }\n\n    evt.pointerX = xpx + xaArray[0]._offset;\n    evt.pointerY = ypx + yaArray[0]._offset;\n    if ('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);else xvalArray = helpers.p2c(xaArray, xpx);\n    if ('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);else yvalArray = helpers.p2c(yaArray, ypx);\n\n    if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n      Lib.warn('Fx.hover failed', evt, gd);\n      return dragElement.unhoverRaw(gd, evt);\n    }\n  } // the pixel distance to beat as a matching point\n  // in 'x' or 'y' mode this resets for each trace\n\n\n  var distance = Infinity; // find the closest point in each trace\n  // this is minimum dx and/or dy, depending on mode\n  // and the pixel position for the label (labelXpx, labelYpx)\n\n  for (curvenum = 0; curvenum < searchData.length; curvenum++) {\n    cd = searchData[curvenum]; // filter out invisible or broken data\n\n    if (!cd || !cd[0] || !cd[0].trace) continue;\n    trace = cd[0].trace;\n    if (trace.visible !== true || trace._length === 0) continue; // Explicitly bail out for these two. I don't know how to otherwise prevent\n    // the rest of this function from running and failing\n\n    if (['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n    if (trace.type === 'splom') {\n      // splom traces do not generate overlay subplots,\n      // it is safe to assume here splom traces correspond to the 0th subplot\n      subploti = 0;\n      subplotId = subplots[subploti];\n    } else {\n      subplotId = helpers.getSubplot(trace);\n      subploti = subplots.indexOf(subplotId);\n    } // within one trace mode can sometimes be overridden\n\n\n    mode = hovermode; // container for new point, also used to pass info into module.hoverPoints\n\n    pointData = {\n      // trace properties\n      cd: cd,\n      trace: trace,\n      xa: xaArray[subploti],\n      ya: yaArray[subploti],\n      // max distances for hover and spikes - for points that want to show but do not\n      // want to override other points, set distance/spikeDistance equal to max*Distance\n      // and it will not get filtered out but it will be guaranteed to have a greater\n      // distance than any point that calculated a real distance.\n      maxHoverDistance: hoverdistance,\n      maxSpikeDistance: spikedistance,\n      // point properties - override all of these\n      index: false,\n      // point index in trace - only used by plotly.js hoverdata consumers\n      distance: Math.min(distance, hoverdistance),\n      // pixel distance or pseudo-distance\n      // distance/pseudo-distance for spikes. This distance should always be calculated\n      // as if in \"closest\" mode, and should only be set if this point should\n      // generate a spike.\n      spikeDistance: Infinity,\n      // in some cases the spikes have different positioning from the hover label\n      // they don't need x0/x1, just one position\n      xSpike: undefined,\n      ySpike: undefined,\n      // where and how to display the hover label\n      color: Color.defaultLine,\n      // trace color\n      name: trace.name,\n      x0: undefined,\n      x1: undefined,\n      y0: undefined,\n      y1: undefined,\n      xLabelVal: undefined,\n      yLabelVal: undefined,\n      zLabelVal: undefined,\n      text: undefined\n    }; // add ref to subplot object (non-cartesian case)\n\n    if (fullLayout[subplotId]) {\n      pointData.subplot = fullLayout[subplotId]._subplot;\n    } // add ref to splom scene\n\n\n    if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n      pointData.scene = fullLayout._splomScenes[trace.uid];\n    }\n\n    closedataPreviousLength = hoverData.length; // for a highlighting array, figure out what\n    // we're searching for with this element\n\n    if (mode === 'array') {\n      var selection = evt[curvenum];\n\n      if ('pointNumber' in selection) {\n        pointData.index = selection.pointNumber;\n        mode = 'closest';\n      } else {\n        mode = '';\n\n        if ('xval' in selection) {\n          xval = selection.xval;\n          mode = 'x';\n        }\n\n        if ('yval' in selection) {\n          yval = selection.yval;\n          mode = mode ? 'closest' : 'y';\n        }\n      }\n    } else {\n      xval = xvalArray[subploti];\n      yval = yvalArray[subploti];\n    } // Now if there is range to look in, find the points to hover.\n\n\n    if (hoverdistance !== 0) {\n      if (trace._module && trace._module.hoverPoints) {\n        var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode, fullLayout._hoverlayer);\n\n        if (newPoints) {\n          var newPoint;\n\n          for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n            newPoint = newPoints[newPointNum];\n\n            if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n              hoverData.push(cleanPoint(newPoint, hovermode));\n            }\n          }\n        }\n      } else {\n        Lib.log('Unrecognized trace type in hover:', trace);\n      }\n    } // in closest mode, remove any existing (farther) points\n    // and don't look any farther than this latest point (or points, some\n    // traces like box & violin make multiple hover labels at once)\n\n\n    if (hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n      hoverData.splice(0, closedataPreviousLength);\n      distance = hoverData[0].distance;\n    } // Now if there is range to look in, find the points to draw the spikelines\n    // Do it only if there is no hoverData\n\n\n    if (hasCartesian && spikedistance !== 0) {\n      if (hoverData.length === 0) {\n        pointData.distance = spikedistance;\n        pointData.index = false;\n\n        var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', fullLayout._hoverlayer);\n\n        if (closestPoints) {\n          closestPoints = closestPoints.filter(function (point) {\n            // some hover points, like scatter fills, do not allow spikes,\n            // so will generate a hover point but without a valid spikeDistance\n            return point.spikeDistance <= spikedistance;\n          });\n        }\n\n        if (closestPoints && closestPoints.length) {\n          var tmpPoint;\n          var closestVPoints = closestPoints.filter(function (point) {\n            return point.xa.showspikes;\n          });\n\n          if (closestVPoints.length) {\n            var closestVPt = closestVPoints[0];\n\n            if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n              tmpPoint = fillSpikePoint(closestVPt);\n\n              if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                spikePoints.vLinePoint = tmpPoint;\n              }\n            }\n          }\n\n          var closestHPoints = closestPoints.filter(function (point) {\n            return point.ya.showspikes;\n          });\n\n          if (closestHPoints.length) {\n            var closestHPt = closestHPoints[0];\n\n            if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n              tmpPoint = fillSpikePoint(closestHPt);\n\n              if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                spikePoints.hLinePoint = tmpPoint;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function selectClosestPoint(pointsData, spikedistance) {\n    var resultPoint = null;\n    var minDistance = Infinity;\n    var thisSpikeDistance;\n\n    for (var i = 0; i < pointsData.length; i++) {\n      thisSpikeDistance = pointsData[i].spikeDistance;\n\n      if (thisSpikeDistance < minDistance && thisSpikeDistance <= spikedistance) {\n        resultPoint = pointsData[i];\n        minDistance = thisSpikeDistance;\n      }\n    }\n\n    return resultPoint;\n  }\n\n  function fillSpikePoint(point) {\n    if (!point) return null;\n    return {\n      xa: point.xa,\n      ya: point.ya,\n      x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n      y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n      distance: point.distance,\n      spikeDistance: point.spikeDistance,\n      curveNumber: point.trace.index,\n      color: point.color,\n      pointNumber: point.index\n    };\n  }\n\n  var spikelineOpts = {\n    fullLayout: fullLayout,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paperdiv,\n    event: evt\n  };\n  var oldspikepoints = gd._spikepoints;\n  var newspikepoints = {\n    vLinePoint: spikePoints.vLinePoint,\n    hLinePoint: spikePoints.hLinePoint\n  };\n  gd._spikepoints = newspikepoints; // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n\n  if (hasCartesian && spikedistance !== 0) {\n    if (hoverData.length !== 0) {\n      var tmpHPointData = hoverData.filter(function (point) {\n        return point.ya.showspikes;\n      });\n      var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance);\n      spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n      var tmpVPointData = hoverData.filter(function (point) {\n        return point.xa.showspikes;\n      });\n      var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance);\n      spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n    }\n  } // if hoverData is empty check for the spikes to draw and quit if there are none\n\n\n  if (hoverData.length === 0) {\n    var result = dragElement.unhoverRaw(gd, evt);\n\n    if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {\n      if (spikesChanged(oldspikepoints)) {\n        createSpikelines(gd, spikePoints, spikelineOpts);\n      }\n    }\n\n    return result;\n  }\n\n  if (hasCartesian) {\n    if (spikesChanged(oldspikepoints)) {\n      createSpikelines(gd, spikePoints, spikelineOpts);\n    }\n  }\n\n  hoverData.sort(function (d1, d2) {\n    return d1.distance - d2.distance;\n  }); // lastly, emit custom hover/unhover events\n\n  var oldhoverdata = gd._hoverdata;\n  var newhoverdata = []; // pull out just the data that's useful to\n  // other people and send it to the event\n\n  for (itemnum = 0; itemnum < hoverData.length; itemnum++) {\n    var pt = hoverData[itemnum];\n    var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n    if (pt.hovertemplate !== false) {\n      var ht = false;\n\n      if (pt.cd[pt.index] && pt.cd[pt.index].ht) {\n        ht = pt.cd[pt.index].ht;\n      }\n\n      pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n    }\n\n    pt.eventData = [eventData];\n    newhoverdata.push(eventData);\n  }\n\n  gd._hoverdata = newhoverdata;\n  var rotateLabels = hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1) || hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1;\n  var bgColor = Color.combine(fullLayout.plot_bgcolor || Color.background, fullLayout.paper_bgcolor);\n  var labelOpts = {\n    hovermode: hovermode,\n    rotateLabels: rotateLabels,\n    bgColor: bgColor,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paperdiv,\n    commonLabelOpts: fullLayout.hoverlabel,\n    hoverdistance: fullLayout.hoverdistance\n  };\n  var hoverLabels = createHoverText(hoverData, labelOpts, gd);\n  hoverAvoidOverlaps(hoverLabels, rotateLabels ? 'xa' : 'ya', fullLayout);\n  alignHoverText(hoverLabels, rotateLabels); // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n  // we should improve the \"fx\" API so other plots can use it without these hack.\n\n  if (evt.target && evt.target.tagName) {\n    var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n    overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n  } // don't emit events if called manually\n\n\n  if (!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n  if (oldhoverdata) {\n    gd.emit('plotly_unhover', {\n      event: evt,\n      points: oldhoverdata\n    });\n  }\n\n  gd.emit('plotly_hover', {\n    event: evt,\n    points: gd._hoverdata,\n    xaxes: xaArray,\n    yaxes: yaArray,\n    xvals: xvalArray,\n    yvals: yvalArray\n  });\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts, gd) {\n  var fullLayout = gd._fullLayout;\n  var hovermode = opts.hovermode;\n  var rotateLabels = opts.rotateLabels;\n  var bgColor = opts.bgColor;\n  var container = opts.container;\n  var outerContainer = opts.outerContainer;\n  var commonLabelOpts = opts.commonLabelOpts || {}; // opts.fontFamily/Size are used for the common label\n  // and as defaults for each hover label, though the individual labels\n  // can override this.\n\n  var fontFamily = opts.fontFamily || constants.HOVERFONT;\n  var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n  var c0 = hoverData[0];\n  var xa = c0.xa;\n  var ya = c0.ya;\n  var commonAttr = hovermode === 'y' ? 'yLabel' : 'xLabel';\n  var t0 = c0[commonAttr];\n  var t00 = (String(t0) || '').split(' ')[0];\n  var outerContainerBB = outerContainer.node().getBoundingClientRect();\n  var outerTop = outerContainerBB.top;\n  var outerWidth = outerContainerBB.width;\n  var outerHeight = outerContainerBB.height; // show the common label, if any, on the axis\n  // never show a common label in array mode,\n  // even if sometimes there could be one\n\n  var showCommonLabel = t0 !== undefined && c0.distance <= opts.hoverdistance && (hovermode === 'x' || hovermode === 'y'); // all hover traces hoverinfo must contain the hovermode\n  // to have common labels\n\n  if (showCommonLabel) {\n    var allHaveZ = true;\n    var i, traceHoverinfo;\n\n    for (i = 0; i < hoverData.length; i++) {\n      if (allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n      traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n\n      if (traceHoverinfo) {\n        var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n\n        if (parts.indexOf('all') === -1 && parts.indexOf(hovermode) === -1) {\n          showCommonLabel = false;\n          break;\n        }\n      }\n    } // xyz labels put all info in their main label, so have no need of a common label\n\n\n    if (allHaveZ) showCommonLabel = false;\n  }\n\n  var commonLabel = container.selectAll('g.axistext').data(showCommonLabel ? [0] : []);\n  commonLabel.enter().append('g').classed('axistext', true);\n  commonLabel.exit().remove();\n  commonLabel.each(function () {\n    var label = d3.select(this);\n    var lpath = Lib.ensureSingle(label, 'path', '', function (s) {\n      s.style({\n        'stroke-width': '1px'\n      });\n    });\n    var ltext = Lib.ensureSingle(label, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n    var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n    var contrastColor = Color.contrast(commonBgColor);\n    var commonLabelFont = {\n      family: commonLabelOpts.font.family || fontFamily,\n      size: commonLabelOpts.font.size || fontSize,\n      color: commonLabelOpts.font.color || contrastColor\n    };\n    lpath.style({\n      fill: commonBgColor,\n      stroke: commonStroke\n    });\n    ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    label.attr('transform', '');\n    var tbb = ltext.node().getBoundingClientRect();\n    var lx, ly;\n\n    if (hovermode === 'x') {\n      var topsign = xa.side === 'top' ? '-' : '';\n      ltext.attr('text-anchor', 'middle').call(svgTextUtils.positionText, 0, xa.side === 'top' ? outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD);\n      lx = xa._offset + (c0.x0 + c0.x1) / 2;\n      ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n      var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n\n      if (lx < halfWidth) {\n        lx = halfWidth;\n        lpath.attr('d', 'M-' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L-' + (halfWidth - HOVERARROWSIZE * 2) + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'Z');\n      } else if (lx > fullLayout.width - halfWidth) {\n        lx = fullLayout.width - halfWidth;\n        lpath.attr('d', 'M' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L' + halfWidth + ',' + topsign + HOVERARROWSIZE + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'H' + (halfWidth - HOVERARROWSIZE * 2) + 'Z');\n      } else {\n        lpath.attr('d', 'M0,0' + 'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + (HOVERTEXTPAD + tbb.width / 2) + 'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');\n      }\n    } else {\n      var anchor;\n      var sgn;\n      var leftsign;\n\n      if (ya.side === 'right') {\n        anchor = 'start';\n        sgn = 1;\n        leftsign = '';\n        lx = xa._offset + xa._length;\n      } else {\n        anchor = 'end';\n        sgn = -1;\n        leftsign = '-';\n        lx = xa._offset;\n      }\n\n      ly = ya._offset + (c0.y0 + c0.y1) / 2;\n      ltext.attr('text-anchor', anchor);\n      lpath.attr('d', 'M0,0' + 'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE + 'V' + (HOVERTEXTPAD + tbb.height / 2) + 'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) + 'V-' + (HOVERTEXTPAD + tbb.height / 2) + 'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n      var halfHeight = tbb.height / 2;\n      var lty = outerTop - tbb.top - halfHeight;\n      var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n      var clipPath;\n\n      if (lx < tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {\n        clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight + 'h-' + (tbb.width - HOVERTEXTPAD) + 'V' + halfHeight + 'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n        var ltx = tbb.width - lx + HOVERTEXTPAD;\n        svgTextUtils.positionText(ltext, ltx, lty); // shift each line (except the longest) so that start-of-line\n        // is always visible\n\n        if (anchor === 'end') {\n          ltext.selectAll('tspan').each(function () {\n            var s = d3.select(this);\n            var dummy = Drawing.tester.append('text').text(s.text()).call(Drawing.font, commonLabelFont);\n            var dummyBB = dummy.node().getBoundingClientRect();\n\n            if (dummyBB.width < tbb.width) {\n              s.attr('x', ltx - dummyBB.width);\n            }\n\n            dummy.remove();\n          });\n        }\n      } else {\n        svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n        clipPath = null;\n      }\n\n      var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n\n      textClip.enter().append('clipPath').attr('id', clipId).append('path');\n      textClip.exit().remove();\n      textClip.select('path').attr('d', clipPath);\n      Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n    }\n\n    label.attr('transform', 'translate(' + lx + ',' + ly + ')'); // remove the \"close but not quite\" points\n    // because of error bars, only take up to a space\n\n    hoverData = hoverData.filter(function (d) {\n      return d.zLabelVal !== undefined || (d[commonAttr] || '').split(' ')[0] === t00;\n    });\n  }); // show all the individual labels\n  // first create the objects\n\n  var hoverLabels = container.selectAll('g.hovertext').data(hoverData, function (d) {\n    // N.B. when multiple items have the same result key-function value,\n    // only the first of those items in hoverData gets rendered\n    return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa, d.ya || ''].join(',');\n  });\n  hoverLabels.enter().append('g').classed('hovertext', true).each(function () {\n    var g = d3.select(this); // trace name label (rect and text.name)\n\n    g.append('rect').call(Color.fill, Color.addOpacity(bgColor, 0.8));\n    g.append('text').classed('name', true); // trace data label (path and text.nums)\n\n    g.append('path').style('stroke-width', '1px');\n    g.append('text').classed('nums', true).call(Drawing.font, fontFamily, fontSize);\n  });\n  hoverLabels.exit().remove(); // then put the text in, position the pointer to the data,\n  // and figure out sizes\n\n  hoverLabels.each(function (d) {\n    var g = d3.select(this).attr('transform', '');\n    var name = '';\n    var text = ''; // combine possible non-opaque trace color with bgColor\n\n    var color0 = d.bgcolor || d.color; // color for 'nums' part of the label\n\n    var numsColor = Color.combine(Color.opacity(color0) ? color0 : Color.defaultLine, bgColor); // color for 'name' part of the label\n\n    var nameColor = Color.combine(Color.opacity(d.color) ? d.color : Color.defaultLine, bgColor); // find a contrasting color for border and text\n\n    var contrastColor = d.borderColor || Color.contrast(numsColor); // to get custom 'name' labels pass cleanPoint\n\n    if (d.nameOverride !== undefined) d.name = d.nameOverride;\n\n    if (d.name) {\n      if (d.trace._meta) {\n        d.name = Lib.templateString(d.name, d.trace._meta);\n      }\n\n      name = plainText(d.name, d.nameLength);\n    }\n\n    if (d.zLabel !== undefined) {\n      if (d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n      if (d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n\n      if (d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox') {\n        text += (text ? 'z: ' : '') + d.zLabel;\n      }\n    } else if (showCommonLabel && d[hovermode + 'Label'] === t0) {\n      text = d[(hovermode === 'x' ? 'y' : 'x') + 'Label'] || '';\n    } else if (d.xLabel === undefined) {\n      if (d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n        text = d.yLabel;\n      }\n    } else if (d.yLabel === undefined) text = d.xLabel;else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n    if ((d.text || d.text === 0) && !Array.isArray(d.text)) {\n      text += (text ? '<br>' : '') + d.text;\n    } // used by other modules (initially just ternary) that\n    // manage their own hoverinfo independent of cleanPoint\n    // the rest of this will still apply, so such modules\n    // can still put things in (x|y|z)Label, text, and name\n    // and hoverinfo will still determine their visibility\n\n\n    if (d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText; // if 'text' is empty at this point,\n    // and hovertemplate is not defined,\n    // put 'name' in main label and don't show secondary label\n\n    if (text === '' && !d.hovertemplate) {\n      // if 'name' is also empty, remove entire label\n      if (name === '') g.remove();\n      text = name;\n    } // hovertemplate\n\n\n    var d3locale = fullLayout._d3locale;\n    var hovertemplate = d.hovertemplate || false;\n    var hovertemplateLabels = d.hovertemplateLabels || d;\n    var eventData = d.eventData[0] || {};\n\n    if (hovertemplate) {\n      text = Lib.hovertemplateString(hovertemplate, hovertemplateLabels, d3locale, eventData, d.trace._meta);\n      text = text.replace(EXTRA_STRING_REGEX, function (match, extra) {\n        // assign name for secondary text label\n        name = plainText(extra, d.nameLength); // remove from main text label\n\n        return '';\n      });\n    } // main label\n\n\n    var tx = g.select('text.nums').call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, d.fontColor || contrastColor).text(text).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    var tx2 = g.select('text.name');\n    var tx2width = 0;\n    var tx2height = 0; // secondary label for non-empty 'name'\n\n    if (name && name !== text) {\n      tx2.call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, nameColor).text(name).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n      var t2bb = tx2.node().getBoundingClientRect();\n      tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n      tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n    } else {\n      tx2.remove();\n      g.select('rect').remove();\n    }\n\n    g.select('path').style({\n      fill: numsColor,\n      stroke: contrastColor\n    });\n    var tbb = tx.node().getBoundingClientRect();\n    var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n    var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n    var dx = Math.abs(d.x1 - d.x0);\n    var dy = Math.abs(d.y1 - d.y0);\n    var txTotalWidth = tbb.width + HOVERARROWSIZE + HOVERTEXTPAD + tx2width;\n    var anchorStartOK, anchorEndOK;\n    d.ty0 = outerTop - tbb.top;\n    d.bx = tbb.width + 2 * HOVERTEXTPAD;\n    d.by = Math.max(tbb.height + 2 * HOVERTEXTPAD, tx2height);\n    d.anchor = 'start';\n    d.txwidth = tbb.width;\n    d.tx2width = tx2width;\n    d.offset = 0;\n\n    if (rotateLabels) {\n      d.pos = htx;\n      anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n      anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n\n      if ((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n        hty -= dy / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        hty += dy / 2;\n        d.anchor = 'start';\n      } else d.anchor = 'middle';\n    } else {\n      d.pos = hty;\n      anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n      anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n\n      if ((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n        htx -= dx / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        htx += dx / 2;\n        d.anchor = 'start';\n      } else {\n        d.anchor = 'middle';\n        var txHalfWidth = txTotalWidth / 2;\n        var overflowR = htx + txHalfWidth - outerWidth;\n        var overflowL = htx - txHalfWidth;\n        if (overflowR > 0) htx -= overflowR;\n        if (overflowL < 0) htx += -overflowL;\n      }\n    }\n\n    tx.attr('text-anchor', d.anchor);\n    if (tx2width) tx2.attr('text-anchor', d.anchor);\n    g.attr('transform', 'translate(' + htx + ',' + hty + ')' + (rotateLabels ? 'rotate(' + YANGLE + ')' : ''));\n  });\n  return hoverLabels;\n} // Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\n\n\nfunction hoverAvoidOverlaps(hoverLabels, axKey, fullLayout) {\n  var nummoves = 0;\n  var axSign = 1;\n  var nLabels = hoverLabels.size(); // make groups of touching points\n\n  var pointgroups = new Array(nLabels);\n  var k = 0;\n  hoverLabels.each(function (d) {\n    var ax = d[axKey];\n    var axIsX = ax._id.charAt(0) === 'x';\n    var rng = ax.range;\n\n    if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {\n      axSign = -1;\n    }\n\n    pointgroups[k++] = [{\n      datum: d,\n      traceIndex: d.trace.index,\n      dp: 0,\n      pos: d.pos,\n      posref: d.posref,\n      size: d.by * (axIsX ? YFACTOR : 1) / 2,\n      pmin: 0,\n      pmax: axIsX ? fullLayout.width : fullLayout.height\n    }];\n  });\n  pointgroups.sort(function (a, b) {\n    return a[0].posref - b[0].posref || // for equal positions, sort trace indices increasing or decreasing\n    // depending on whether the axis is reversed or not... so stacked\n    // traces will generally keep their order even if one trace adds\n    // nothing to the stack.\n    axSign * (b[0].traceIndex - a[0].traceIndex);\n  });\n  var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n  function constrainGroup(grp) {\n    var minPt = grp[0];\n    var maxPt = grp[grp.length - 1]; // overlap with the top - positive vals are overlaps\n\n    topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size; // overlap with the bottom - positive vals are overlaps\n\n    bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax; // check for min overlap first, so that we always\n    // see the largest labels\n    // allow for .01px overlap, so we don't get an\n    // infinite loop from rounding errors\n\n    if (topOverlap > 0.01) {\n      for (j = grp.length - 1; j >= 0; j--) {\n        grp[j].dp += topOverlap;\n      }\n\n      donepositioning = false;\n    }\n\n    if (bottomOverlap < 0.01) return;\n\n    if (topOverlap < -0.01) {\n      // make sure we're not pushing back and forth\n      for (j = grp.length - 1; j >= 0; j--) {\n        grp[j].dp -= bottomOverlap;\n      }\n\n      donepositioning = false;\n    }\n\n    if (!donepositioning) return; // no room to fix positioning, delete off-screen points\n    // first see how many points we need to delete\n\n    var deleteCount = 0;\n\n    for (i = 0; i < grp.length; i++) {\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n    } // start by deleting points whose data is off screen\n\n\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i]; // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n\n      if (pti.pos > minPt.pmax - 1) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n\n    for (i = 0; i < grp.length; i++) {\n      if (deleteCount <= 0) break;\n      pti = grp[i]; // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n\n      if (pti.pos < minPt.pmin + 1) {\n        pti.del = true;\n        deleteCount--; // shift the whole group minus into this new space\n\n        bottomOverlap = pti.size * 2;\n\n        for (j = grp.length - 1; j >= 0; j--) {\n          grp[j].dp -= bottomOverlap;\n        }\n      }\n    } // then delete points that go off the bottom\n\n\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n  } // loop through groups, combining them if they overlap,\n  // until nothing moves\n\n\n  while (!donepositioning && nummoves <= nLabels) {\n    // to avoid infinite loops, don't move more times\n    // than there are traces\n    nummoves++; // assume nothing will move in this iteration,\n    // reverse this if it does\n\n    donepositioning = true;\n    i = 0;\n\n    while (i < pointgroups.length - 1) {\n      // the higher (g0) and lower (g1) point group\n      var g0 = pointgroups[i];\n      var g1 = pointgroups[i + 1]; // the lowest point in the higher group (p0)\n      // the highest point in the lower group (p1)\n\n      var p0 = g0[g0.length - 1];\n      var p1 = g1[0];\n      topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size; // Only group points that lie on the same axes\n\n      if (topOverlap > 0.01 && p0.pmin === p1.pmin && p0.pmax === p1.pmax) {\n        // push the new point(s) added to this group out of the way\n        for (j = g1.length - 1; j >= 0; j--) {\n          g1[j].dp += topOverlap;\n        } // add them to the group\n\n\n        g0.push.apply(g0, g1);\n        pointgroups.splice(i + 1, 1); // adjust for minimum average movement\n\n        sumdp = 0;\n\n        for (j = g0.length - 1; j >= 0; j--) {\n          sumdp += g0[j].dp;\n        }\n\n        bottomOverlap = sumdp / g0.length;\n\n        for (j = g0.length - 1; j >= 0; j--) {\n          g0[j].dp -= bottomOverlap;\n        }\n\n        donepositioning = false;\n      } else i++;\n    } // check if we're going off the plot on either side and fix\n\n\n    pointgroups.forEach(constrainGroup);\n  } // now put these offsets into hoverData\n\n\n  for (i = pointgroups.length - 1; i >= 0; i--) {\n    var grp = pointgroups[i];\n\n    for (j = grp.length - 1; j >= 0; j--) {\n      var pt = grp[j];\n      var hoverPt = pt.datum;\n      hoverPt.offset = pt.dp;\n      hoverPt.del = pt.del;\n    }\n  }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels) {\n  // finally set the text positioning relative to the data and draw the\n  // box around it\n  hoverLabels.each(function (d) {\n    var g = d3.select(this);\n    if (d.del) return g.remove();\n    var tx = g.select('text.nums');\n    var anchor = d.anchor;\n    var horzSign = anchor === 'end' ? -1 : 1;\n    var alignShift = {\n      start: 1,\n      end: -1,\n      middle: 0\n    }[anchor];\n    var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n    var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n    var offsetX = 0;\n    var offsetY = d.offset;\n\n    if (anchor === 'middle') {\n      txx -= d.tx2width / 2;\n      tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n    }\n\n    if (rotateLabels) {\n      offsetY *= -YSHIFTY;\n      offsetX = d.offset * YSHIFTX;\n    }\n\n    g.select('path').attr('d', anchor === 'middle' ? // middle aligned: rect centered on data\n    'M-' + (d.bx / 2 + d.tx2width / 2) + ',' + (offsetY - d.by / 2) + 'h' + d.bx + 'v' + d.by + 'h-' + d.bx + 'Z' : // left or right aligned: side rect with arrow to data\n    'M0,0L' + (horzSign * HOVERARROWSIZE + offsetX) + ',' + (HOVERARROWSIZE + offsetY) + 'v' + (d.by / 2 - HOVERARROWSIZE) + 'h' + horzSign * d.bx + 'v-' + d.by + 'H' + (horzSign * HOVERARROWSIZE + offsetX) + 'V' + (offsetY - HOVERARROWSIZE) + 'Z');\n    var posX = txx + offsetX;\n    var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n    var textAlign = d.textAlign || 'auto';\n\n    if (textAlign !== 'auto') {\n      if (textAlign === 'left' && anchor !== 'start') {\n        tx.attr('text-anchor', 'start');\n        posX = anchor === 'middle' ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;\n      } else if (textAlign === 'right' && anchor !== 'end') {\n        tx.attr('text-anchor', 'end');\n        posX = anchor === 'middle' ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;\n      }\n    }\n\n    tx.call(svgTextUtils.positionText, posX, posY);\n\n    if (d.tx2width) {\n      g.select('text.name').call(svgTextUtils.positionText, tx2x + alignShift * HOVERTEXTPAD + offsetX, offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n      g.select('rect').call(Drawing.setRect, tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX, offsetY - d.by / 2 - 1, d.tx2width, d.by + 2);\n    }\n  });\n}\n\nfunction cleanPoint(d, hovermode) {\n  var index = d.index;\n  var trace = d.trace || {};\n  var cd0 = d.cd[0];\n  var cd = d.cd[index] || {};\n\n  function pass(v) {\n    return v || isNumeric(v) && v === 0;\n  }\n\n  var getVal = Array.isArray(index) ? function (calcKey, traceKey) {\n    var v = Lib.castOption(cd0, index, calcKey);\n    return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n  } : function (calcKey, traceKey) {\n    return Lib.extractOption(cd, trace, calcKey, traceKey);\n  };\n\n  function fill(key, calcKey, traceKey) {\n    var val = getVal(calcKey, traceKey);\n    if (pass(val)) d[key] = val;\n  }\n\n  fill('hoverinfo', 'hi', 'hoverinfo');\n  fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n  fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n  fill('fontFamily', 'htf', 'hoverlabel.font.family');\n  fill('fontSize', 'hts', 'hoverlabel.font.size');\n  fill('fontColor', 'htc', 'hoverlabel.font.color');\n  fill('nameLength', 'hnl', 'hoverlabel.namelength');\n  fill('textAlign', 'hta', 'hoverlabel.align');\n  d.posref = hovermode === 'y' || hovermode === 'closest' && trace.orientation === 'h' ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2; // then constrain all the positions to be on the plot\n\n  d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n  d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n  d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n  d.y1 = Lib.constrain(d.y1, 0, d.ya._length); // and convert the x and y label values into formatted text\n\n  if (d.xLabelVal !== undefined) {\n    d.xLabel = 'xLabel' in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal);\n    d.xVal = d.xa.c2d(d.xLabelVal);\n  }\n\n  if (d.yLabelVal !== undefined) {\n    d.yLabel = 'yLabel' in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal);\n    d.yVal = d.ya.c2d(d.yLabelVal);\n  } // Traces like heatmaps generate the zLabel in their hoverPoints function\n\n\n  if (d.zLabelVal !== undefined && d.zLabel === undefined) {\n    d.zLabel = String(d.zLabelVal);\n  } // for box means and error bars, add the range to the label\n\n\n  if (!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n    var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n\n    if (d.xerrneg !== undefined) {\n      d.xLabel += ' +' + xeText + ' / -' + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n    } else d.xLabel += ' ± ' + xeText; // small distance penalty for error bars, so that if there are\n    // traces with errors and some without, the error bar label will\n    // hoist up to the point\n\n\n    if (hovermode === 'x') d.distance += 1;\n  }\n\n  if (!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n    var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n\n    if (d.yerrneg !== undefined) {\n      d.yLabel += ' +' + yeText + ' / -' + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n    } else d.yLabel += ' ± ' + yeText;\n\n    if (hovermode === 'y') d.distance += 1;\n  }\n\n  var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n  if (infomode && infomode !== 'all') {\n    infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n    if (infomode.indexOf('x') === -1) d.xLabel = undefined;\n    if (infomode.indexOf('y') === -1) d.yLabel = undefined;\n    if (infomode.indexOf('z') === -1) d.zLabel = undefined;\n    if (infomode.indexOf('text') === -1) d.text = undefined;\n    if (infomode.indexOf('name') === -1) d.name = undefined;\n  }\n\n  return d;\n}\n\nfunction createSpikelines(gd, closestPoints, opts) {\n  var container = opts.container;\n  var fullLayout = opts.fullLayout;\n  var gs = fullLayout._size;\n  var evt = opts.event;\n  var showY = !!closestPoints.hLinePoint;\n  var showX = !!closestPoints.vLinePoint;\n  var xa, ya; // Remove old spikeline items\n\n  container.selectAll('.spikeline').remove();\n  if (!(showX || showY)) return;\n  var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor); // Horizontal line (to y-axis)\n\n  if (showY) {\n    var hLinePoint = closestPoints.hLinePoint;\n    var hLinePointX, hLinePointY;\n    xa = hLinePoint && hLinePoint.xa;\n    ya = hLinePoint && hLinePoint.ya;\n    var ySnap = ya.spikesnap;\n\n    if (ySnap === 'cursor') {\n      hLinePointX = evt.pointerX;\n      hLinePointY = evt.pointerY;\n    } else {\n      hLinePointX = xa._offset + hLinePoint.x;\n      hLinePointY = ya._offset + hLinePoint.y;\n    }\n\n    var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;\n    var yMode = ya.spikemode;\n    var yThickness = ya.spikethickness;\n    var yColor = ya.spikecolor || dfltHLineColor;\n    var xEdge = Axes.getPxPosition(gd, ya);\n    var xBase, xEndSpike;\n\n    if (yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n      if (yMode.indexOf('toaxis') !== -1) {\n        xBase = xEdge;\n        xEndSpike = hLinePointX;\n      }\n\n      if (yMode.indexOf('across') !== -1) {\n        var xAcross0 = ya._counterDomainMin;\n        var xAcross1 = ya._counterDomainMax;\n\n        if (ya.anchor === 'free') {\n          xAcross0 = Math.min(xAcross0, ya.position);\n          xAcross1 = Math.max(xAcross1, ya.position);\n        }\n\n        xBase = gs.l + xAcross0 * gs.w;\n        xEndSpike = gs.l + xAcross1 * gs.w;\n      } // Foreground horizontal line (to y-axis)\n\n\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness,\n        stroke: yColor,\n        'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n      }).classed('spikeline', true).classed('crisp', true); // Background horizontal Line (to y-axis)\n\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    } // Y axis marker\n\n\n    if (yMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n        cy: hLinePointY,\n        r: yThickness,\n        fill: yColor\n      }).classed('spikeline', true);\n    }\n  }\n\n  if (showX) {\n    var vLinePoint = closestPoints.vLinePoint;\n    var vLinePointX, vLinePointY;\n    xa = vLinePoint && vLinePoint.xa;\n    ya = vLinePoint && vLinePoint.ya;\n    var xSnap = xa.spikesnap;\n\n    if (xSnap === 'cursor') {\n      vLinePointX = evt.pointerX;\n      vLinePointY = evt.pointerY;\n    } else {\n      vLinePointX = xa._offset + vLinePoint.x;\n      vLinePointY = ya._offset + vLinePoint.y;\n    }\n\n    var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;\n    var xMode = xa.spikemode;\n    var xThickness = xa.spikethickness;\n    var xColor = xa.spikecolor || dfltVLineColor;\n    var yEdge = Axes.getPxPosition(gd, xa);\n    var yBase, yEndSpike;\n\n    if (xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n      if (xMode.indexOf('toaxis') !== -1) {\n        yBase = yEdge;\n        yEndSpike = vLinePointY;\n      }\n\n      if (xMode.indexOf('across') !== -1) {\n        var yAcross0 = xa._counterDomainMin;\n        var yAcross1 = xa._counterDomainMax;\n\n        if (xa.anchor === 'free') {\n          yAcross0 = Math.min(yAcross0, xa.position);\n          yAcross1 = Math.max(yAcross1, xa.position);\n        }\n\n        yBase = gs.t + (1 - yAcross1) * gs.h;\n        yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n      } // Foreground vertical line (to x-axis)\n\n\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness,\n        stroke: xColor,\n        'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n      }).classed('spikeline', true).classed('crisp', true); // Background vertical line (to x-axis)\n\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    } // X axis marker\n\n\n    if (xMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: vLinePointX,\n        cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n        r: xThickness,\n        fill: xColor\n      }).classed('spikeline', true);\n    }\n  }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n  // don't emit any events if nothing changed\n  if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n  for (var i = oldhoverdata.length - 1; i >= 0; i--) {\n    var oldPt = oldhoverdata[i];\n    var newPt = gd._hoverdata[i];\n\n    if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n  // don't relayout the plot because of new spikelines if spikelines points didn't change\n  if (!oldspikepoints) return true;\n  if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;\n  return false;\n}\n\nfunction plainText(s, len) {\n  return svgTextUtils.plainText(s || '', {\n    len: len,\n    allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n  });\n}","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/components/fx/hover.js"],"names":["d3","require","isNumeric","tinycolor","Lib","Events","svgTextUtils","overrideCursor","Drawing","Color","dragElement","Axes","Registry","helpers","constants","YANGLE","YA_RADIANS","Math","PI","YFACTOR","sin","YSHIFTX","cos","YSHIFTY","HOVERARROWSIZE","HOVERTEXTPAD","exports","hover","gd","evt","subplot","noHoverEvent","getGraphDiv","throttle","_fullLayout","_uid","HOVERID","HOVERMINTIME","_hover","loneHover","hoverItems","opts","multiHover","Array","isArray","pointsData","map","hoverItem","color","defaultLine","x0","x","x1","y0","y","y1","xLabel","yLabel","zLabel","text","name","idealAlign","borderColor","fontFamily","fontSize","fontColor","nameLength","textAlign","trace","index","hoverinfo","xa","_offset","ya","hovertemplate","eventData","hovertemplateLabels","container3","select","container","outerContainer3","outerContainer","fullOpts","hovermode","rotateLabels","bgColor","background","hoverLabel","createHoverText","tooltipSpacing","lastBottomY","anchor","sort","a","b","each","d","i","topY","by","offset","anchorIndex","alignHoverText","node","subplots","fullLayout","plots","_plots","plotinfo","hasCartesian","_has","overlayedSubplots","overlays","pi","id","concat","len","length","xaArray","yaArray","supportsCompare","spId","xaxis","yaxis","_subplot","warn","indexOf","calcdata","querySelector","_dragging","unhoverRaw","hoverdistance","Infinity","spikedistance","hoverData","searchData","xvalArray","yvalArray","itemnum","curvenum","cd","subplotId","subploti","mode","xval","yval","pointData","closedataPreviousLength","spikePoints","hLinePoint","vLinePoint","hasOneHorizontalTrace","curveNumber","push","orientation","isTraceInSubplots","hasUserCalledHover","target","xpx","ypx","_length","triggerHandler","dbb","getBoundingClientRect","clientX","left","clientY","top","pointerX","pointerY","flat","p2c","distance","visible","_module","type","getSubplot","maxHoverDistance","maxSpikeDistance","min","spikeDistance","xSpike","undefined","ySpike","xLabelVal","yLabelVal","zLabelVal","_splomScenes","uid","scene","selection","pointNumber","hoverPoints","newPoints","_hoverlayer","newPoint","newPointNum","cleanPoint","log","splice","closestPoints","filter","point","tmpPoint","closestVPoints","showspikes","closestVPt","fillSpikePoint","closestHPoints","closestHPt","selectClosestPoint","resultPoint","minDistance","thisSpikeDistance","spikelineOpts","_paperdiv","event","oldspikepoints","_spikepoints","newspikepoints","tmpHPointData","tmpHPoint","tmpVPointData","tmpVPoint","result","spikesChanged","createSpikelines","d1","d2","oldhoverdata","_hoverdata","newhoverdata","pt","makeEventData","ht","combine","plot_bgcolor","paper_bgcolor","labelOpts","commonLabelOpts","hoverlabel","hoverLabels","hoverAvoidOverlaps","tagName","hasClickToShow","getComponentMethod","hoverChanged","emit","points","xaxes","yaxes","xvals","yvals","EXTRA_STRING_REGEX","HOVERFONT","HOVERFONTSIZE","c0","commonAttr","t0","t00","String","split","outerContainerBB","outerTop","outerWidth","width","outerHeight","height","showCommonLabel","allHaveZ","traceHoverinfo","parts","commonLabel","selectAll","data","enter","append","classed","exit","remove","label","lpath","ensureSingle","s","style","ltext","attr","commonBgColor","bgcolor","commonStroke","bordercolor","contrast","contrastColor","commonLabelFont","family","font","size","fill","stroke","call","positionText","convertToTspans","tbb","lx","ly","topsign","side","bottom","halfWidth","sgn","leftsign","halfHeight","lty","clipId","_id","clipPath","ltx","dummy","tester","dummyBB","textClip","_topclips","setClipUrl","join","g","addOpacity","color0","numsColor","opacity","nameColor","nameOverride","_meta","templateString","plainText","extraText","d3locale","_d3locale","hovertemplateString","replace","match","extra","tx","tx2","tx2width","tx2height","t2bb","htx","hty","dx","abs","dy","txTotalWidth","anchorStartOK","anchorEndOK","ty0","bx","max","txwidth","pos","txHalfWidth","overflowR","overflowL","axKey","nummoves","axSign","nLabels","pointgroups","k","ax","axIsX","charAt","rng","range","datum","traceIndex","dp","posref","pmin","pmax","donepositioning","topOverlap","bottomOverlap","j","pti","sumdp","constrainGroup","grp","minPt","maxPt","deleteCount","del","g0","g1","p0","p1","apply","forEach","hoverPt","horzSign","alignShift","start","end","middle","txx","tx2x","offsetX","offsetY","posX","posY","setRect","cd0","pass","v","getVal","calcKey","traceKey","castOption","extractOption","key","val","constrain","hoverLabelText","xVal","c2d","yVal","isNaN","xerr","xeText","tickText","c2l","xerrneg","yerr","yeText","yerrneg","infomode","gs","_size","showY","showX","hLinePointX","hLinePointY","ySnap","spikesnap","dfltHLineColor","readability","yMode","spikemode","yThickness","spikethickness","yColor","spikecolor","xEdge","getPxPosition","xBase","xEndSpike","xAcross0","_counterDomainMin","xAcross1","_counterDomainMax","position","l","w","insert","x2","y2","dashStyle","spikedash","cx","cy","r","vLinePointX","vLinePointY","xSnap","dfltVLineColor","xMode","xThickness","xColor","yEdge","yBase","yEndSpike","yAcross0","yAcross1","t","h","oldPt","newPt","pointNumbers","allowedTags"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar dragElement = require('../dragelement');\nvar Axes = require('../../plots/cartesian/axes');\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180;\n\n// expansion of projected height\nvar YFACTOR = 1 / Math.sin(YA_RADIANS);\n\n// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS);\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n    gd = Lib.getGraphDiv(gd);\n\n    Lib.throttle(\n        gd._fullLayout._uid + constants.HOVERID,\n        constants.HOVERMINTIME,\n        function() { _hover(gd, evt, subplot, noHoverEvent); }\n    );\n};\n\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\nexports.loneHover = function loneHover(hoverItems, opts) {\n    var multiHover = true;\n    if(!Array.isArray(hoverItems)) {\n        multiHover = false;\n        hoverItems = [hoverItems];\n    }\n\n    var pointsData = hoverItems.map(function(hoverItem) {\n        return {\n            color: hoverItem.color || Color.defaultLine,\n            x0: hoverItem.x0 || hoverItem.x || 0,\n            x1: hoverItem.x1 || hoverItem.x || 0,\n            y0: hoverItem.y0 || hoverItem.y || 0,\n            y1: hoverItem.y1 || hoverItem.y || 0,\n            xLabel: hoverItem.xLabel,\n            yLabel: hoverItem.yLabel,\n            zLabel: hoverItem.zLabel,\n            text: hoverItem.text,\n            name: hoverItem.name,\n            idealAlign: hoverItem.idealAlign,\n\n            // optional extra bits of styling\n            borderColor: hoverItem.borderColor,\n            fontFamily: hoverItem.fontFamily,\n            fontSize: hoverItem.fontSize,\n            fontColor: hoverItem.fontColor,\n            nameLength: hoverItem.nameLength,\n            textAlign: hoverItem.textAlign,\n\n            // filler to make createHoverText happy\n            trace: hoverItem.trace || {\n                index: 0,\n                hoverinfo: ''\n            },\n            xa: {_offset: 0},\n            ya: {_offset: 0},\n            index: 0,\n\n            hovertemplate: hoverItem.hovertemplate || false,\n            eventData: hoverItem.eventData || false,\n            hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n        };\n    });\n\n    var container3 = d3.select(opts.container);\n    var outerContainer3 = opts.outerContainer ? d3.select(opts.outerContainer) : container3;\n\n    var fullOpts = {\n        hovermode: 'closest',\n        rotateLabels: false,\n        bgColor: opts.bgColor || Color.background,\n        container: container3,\n        outerContainer: outerContainer3\n    };\n\n    var hoverLabel = createHoverText(pointsData, fullOpts, opts.gd);\n\n    // Fix vertical overlap\n    var tooltipSpacing = 5;\n    var lastBottomY = 0;\n    var anchor = 0;\n    hoverLabel\n        .sort(function(a, b) {return a.y0 - b.y0;})\n        .each(function(d, i) {\n            var topY = d.y0 - d.by / 2;\n\n            if((topY - tooltipSpacing) < lastBottomY) {\n                d.offset = (lastBottomY - topY) + tooltipSpacing;\n            } else {\n                d.offset = 0;\n            }\n\n            lastBottomY = topY + d.by + d.offset;\n\n            if(i === opts.anchorIndex || 0) anchor = d.offset;\n        })\n        .each(function(d) {\n            d.offset -= anchor;\n        });\n\n    alignHoverText(hoverLabel, fullOpts.rotateLabels);\n\n    return multiHover ? hoverLabel : hoverLabel.node();\n};\n\n// The actual implementation is here:\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n    if(!subplot) subplot = 'xy';\n\n    // if the user passed in an array of subplots,\n    // use those instead of finding overlayed plots\n    var subplots = Array.isArray(subplot) ? subplot : [subplot];\n\n    var fullLayout = gd._fullLayout;\n    var plots = fullLayout._plots || [];\n    var plotinfo = plots[subplot];\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // list of all overlaid subplots to look at\n    if(plotinfo) {\n        var overlayedSubplots = plotinfo.overlays.map(function(pi) {\n            return pi.id;\n        });\n\n        subplots = subplots.concat(overlayedSubplots);\n    }\n\n    var len = subplots.length;\n    var xaArray = new Array(len);\n    var yaArray = new Array(len);\n    var supportsCompare = false;\n\n    for(var i = 0; i < len; i++) {\n        var spId = subplots[i];\n\n        if(plots[spId]) {\n            // 'cartesian' case\n            supportsCompare = true;\n            xaArray[i] = plots[spId].xaxis;\n            yaArray[i] = plots[spId].yaxis;\n        } else if(fullLayout[spId] && fullLayout[spId]._subplot) {\n            // other subplot types\n            var _subplot = fullLayout[spId]._subplot;\n            xaArray[i] = _subplot.xaxis;\n            yaArray[i] = _subplot.yaxis;\n        } else {\n            Lib.warn('Unrecognized subplot: ' + spId);\n            return;\n        }\n    }\n\n    var hovermode = evt.hovermode || fullLayout.hovermode;\n\n    if(hovermode && !supportsCompare) hovermode = 'closest';\n\n    if(['x', 'y', 'closest'].indexOf(hovermode) === -1 || !gd.calcdata ||\n            gd.querySelector('.zoombox') || gd._dragging) {\n        return dragElement.unhoverRaw(gd, evt);\n    }\n\n    var hoverdistance = fullLayout.hoverdistance === -1 ? Infinity : fullLayout.hoverdistance;\n    var spikedistance = fullLayout.spikedistance === -1 ? Infinity : fullLayout.spikedistance;\n\n    // hoverData: the set of candidate points we've found to highlight\n    var hoverData = [];\n\n    // searchData: the data to search in. Mostly this is just a copy of\n    // gd.calcdata, filtered to the subplot and overlays we're on\n    // but if a point array is supplied it will be a mapping\n    // of indicated curves\n    var searchData = [];\n\n    // [x|y]valArray: the axis values of the hover event\n    // mapped onto each of the currently selected overlaid subplots\n    var xvalArray, yvalArray;\n\n    var itemnum, curvenum, cd, trace, subplotId, subploti, mode,\n        xval, yval, pointData, closedataPreviousLength;\n\n    // spikePoints: the set of candidate points we've found to draw spikes to\n    var spikePoints = {\n        hLinePoint: null,\n        vLinePoint: null\n    };\n\n    // does subplot have one (or more) horizontal traces?\n    // This is used to determine whether we rotate the labels or not\n    var hasOneHorizontalTrace = false;\n\n    // Figure out what we're hovering on:\n    // mouse location or user-supplied data\n\n    if(Array.isArray(evt)) {\n        // user specified an array of points to highlight\n        hovermode = 'array';\n        for(itemnum = 0; itemnum < evt.length; itemnum++) {\n            cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n            if(cd) {\n                trace = cd[0].trace;\n                if(cd[0].trace.hoverinfo !== 'skip') {\n                    searchData.push(cd);\n                    if(trace.orientation === 'h') {\n                        hasOneHorizontalTrace = true;\n                    }\n                }\n            }\n        }\n    } else {\n        for(curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n            cd = gd.calcdata[curvenum];\n            trace = cd[0].trace;\n            if(trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n                searchData.push(cd);\n                if(trace.orientation === 'h') {\n                    hasOneHorizontalTrace = true;\n                }\n            }\n        }\n\n        // [x|y]px: the pixels (from top left) of the mouse location\n        // on the currently selected plot area\n        // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n        var hasUserCalledHover = !evt.target;\n        var xpx, ypx;\n\n        if(hasUserCalledHover) {\n            if('xpx' in evt) xpx = evt.xpx;\n            else xpx = xaArray[0]._length / 2;\n\n            if('ypx' in evt) ypx = evt.ypx;\n            else ypx = yaArray[0]._length / 2;\n        } else {\n            // fire the beforehover event and quit if it returns false\n            // note that we're only calling this on real mouse events, so\n            // manual calls to fx.hover will always run.\n            if(Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n                return;\n            }\n\n            var dbb = evt.target.getBoundingClientRect();\n\n            xpx = evt.clientX - dbb.left;\n            ypx = evt.clientY - dbb.top;\n\n            // in case hover was called from mouseout into hovertext,\n            // it's possible you're not actually over the plot anymore\n            if(xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n                return dragElement.unhoverRaw(gd, evt);\n            }\n        }\n\n        evt.pointerX = xpx + xaArray[0]._offset;\n        evt.pointerY = ypx + yaArray[0]._offset;\n\n        if('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);\n        else xvalArray = helpers.p2c(xaArray, xpx);\n\n        if('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);\n        else yvalArray = helpers.p2c(yaArray, ypx);\n\n        if(!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n            Lib.warn('Fx.hover failed', evt, gd);\n            return dragElement.unhoverRaw(gd, evt);\n        }\n    }\n\n    // the pixel distance to beat as a matching point\n    // in 'x' or 'y' mode this resets for each trace\n    var distance = Infinity;\n\n    // find the closest point in each trace\n    // this is minimum dx and/or dy, depending on mode\n    // and the pixel position for the label (labelXpx, labelYpx)\n    for(curvenum = 0; curvenum < searchData.length; curvenum++) {\n        cd = searchData[curvenum];\n\n        // filter out invisible or broken data\n        if(!cd || !cd[0] || !cd[0].trace) continue;\n\n        trace = cd[0].trace;\n\n        if(trace.visible !== true || trace._length === 0) continue;\n\n        // Explicitly bail out for these two. I don't know how to otherwise prevent\n        // the rest of this function from running and failing\n        if(['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n        if(trace.type === 'splom') {\n            // splom traces do not generate overlay subplots,\n            // it is safe to assume here splom traces correspond to the 0th subplot\n            subploti = 0;\n            subplotId = subplots[subploti];\n        } else {\n            subplotId = helpers.getSubplot(trace);\n            subploti = subplots.indexOf(subplotId);\n        }\n\n        // within one trace mode can sometimes be overridden\n        mode = hovermode;\n\n        // container for new point, also used to pass info into module.hoverPoints\n        pointData = {\n            // trace properties\n            cd: cd,\n            trace: trace,\n            xa: xaArray[subploti],\n            ya: yaArray[subploti],\n\n            // max distances for hover and spikes - for points that want to show but do not\n            // want to override other points, set distance/spikeDistance equal to max*Distance\n            // and it will not get filtered out but it will be guaranteed to have a greater\n            // distance than any point that calculated a real distance.\n            maxHoverDistance: hoverdistance,\n            maxSpikeDistance: spikedistance,\n\n            // point properties - override all of these\n            index: false, // point index in trace - only used by plotly.js hoverdata consumers\n            distance: Math.min(distance, hoverdistance), // pixel distance or pseudo-distance\n\n            // distance/pseudo-distance for spikes. This distance should always be calculated\n            // as if in \"closest\" mode, and should only be set if this point should\n            // generate a spike.\n            spikeDistance: Infinity,\n\n            // in some cases the spikes have different positioning from the hover label\n            // they don't need x0/x1, just one position\n            xSpike: undefined,\n            ySpike: undefined,\n\n            // where and how to display the hover label\n            color: Color.defaultLine, // trace color\n            name: trace.name,\n            x0: undefined,\n            x1: undefined,\n            y0: undefined,\n            y1: undefined,\n            xLabelVal: undefined,\n            yLabelVal: undefined,\n            zLabelVal: undefined,\n            text: undefined\n        };\n\n        // add ref to subplot object (non-cartesian case)\n        if(fullLayout[subplotId]) {\n            pointData.subplot = fullLayout[subplotId]._subplot;\n        }\n        // add ref to splom scene\n        if(fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n            pointData.scene = fullLayout._splomScenes[trace.uid];\n        }\n\n        closedataPreviousLength = hoverData.length;\n\n        // for a highlighting array, figure out what\n        // we're searching for with this element\n        if(mode === 'array') {\n            var selection = evt[curvenum];\n            if('pointNumber' in selection) {\n                pointData.index = selection.pointNumber;\n                mode = 'closest';\n            } else {\n                mode = '';\n                if('xval' in selection) {\n                    xval = selection.xval;\n                    mode = 'x';\n                }\n                if('yval' in selection) {\n                    yval = selection.yval;\n                    mode = mode ? 'closest' : 'y';\n                }\n            }\n        } else {\n            xval = xvalArray[subploti];\n            yval = yvalArray[subploti];\n        }\n\n        // Now if there is range to look in, find the points to hover.\n        if(hoverdistance !== 0) {\n            if(trace._module && trace._module.hoverPoints) {\n                var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode, fullLayout._hoverlayer);\n                if(newPoints) {\n                    var newPoint;\n                    for(var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n                        newPoint = newPoints[newPointNum];\n                        if(isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                            hoverData.push(cleanPoint(newPoint, hovermode));\n                        }\n                    }\n                }\n            } else {\n                Lib.log('Unrecognized trace type in hover:', trace);\n            }\n        }\n\n        // in closest mode, remove any existing (farther) points\n        // and don't look any farther than this latest point (or points, some\n        // traces like box & violin make multiple hover labels at once)\n        if(hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n            hoverData.splice(0, closedataPreviousLength);\n            distance = hoverData[0].distance;\n        }\n\n        // Now if there is range to look in, find the points to draw the spikelines\n        // Do it only if there is no hoverData\n        if(hasCartesian && (spikedistance !== 0)) {\n            if(hoverData.length === 0) {\n                pointData.distance = spikedistance;\n                pointData.index = false;\n                var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', fullLayout._hoverlayer);\n                if(closestPoints) {\n                    closestPoints = closestPoints.filter(function(point) {\n                        // some hover points, like scatter fills, do not allow spikes,\n                        // so will generate a hover point but without a valid spikeDistance\n                        return point.spikeDistance <= spikedistance;\n                    });\n                }\n                if(closestPoints && closestPoints.length) {\n                    var tmpPoint;\n                    var closestVPoints = closestPoints.filter(function(point) {\n                        return point.xa.showspikes;\n                    });\n                    if(closestVPoints.length) {\n                        var closestVPt = closestVPoints[0];\n                        if(isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n                            tmpPoint = fillSpikePoint(closestVPt);\n                            if(!spikePoints.vLinePoint || (spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                spikePoints.vLinePoint = tmpPoint;\n                            }\n                        }\n                    }\n\n                    var closestHPoints = closestPoints.filter(function(point) {\n                        return point.ya.showspikes;\n                    });\n                    if(closestHPoints.length) {\n                        var closestHPt = closestHPoints[0];\n                        if(isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n                            tmpPoint = fillSpikePoint(closestHPt);\n                            if(!spikePoints.hLinePoint || (spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                spikePoints.hLinePoint = tmpPoint;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function selectClosestPoint(pointsData, spikedistance) {\n        var resultPoint = null;\n        var minDistance = Infinity;\n        var thisSpikeDistance;\n        for(var i = 0; i < pointsData.length; i++) {\n            thisSpikeDistance = pointsData[i].spikeDistance;\n            if(thisSpikeDistance < minDistance && thisSpikeDistance <= spikedistance) {\n                resultPoint = pointsData[i];\n                minDistance = thisSpikeDistance;\n            }\n        }\n        return resultPoint;\n    }\n\n    function fillSpikePoint(point) {\n        if(!point) return null;\n        return {\n            xa: point.xa,\n            ya: point.ya,\n            x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n            y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n            distance: point.distance,\n            spikeDistance: point.spikeDistance,\n            curveNumber: point.trace.index,\n            color: point.color,\n            pointNumber: point.index\n        };\n    }\n\n    var spikelineOpts = {\n        fullLayout: fullLayout,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paperdiv,\n        event: evt\n    };\n    var oldspikepoints = gd._spikepoints;\n    var newspikepoints = {\n        vLinePoint: spikePoints.vLinePoint,\n        hLinePoint: spikePoints.hLinePoint\n    };\n    gd._spikepoints = newspikepoints;\n\n    // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n    if(hasCartesian && (spikedistance !== 0)) {\n        if(hoverData.length !== 0) {\n            var tmpHPointData = hoverData.filter(function(point) {\n                return point.ya.showspikes;\n            });\n            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance);\n            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n\n            var tmpVPointData = hoverData.filter(function(point) {\n                return point.xa.showspikes;\n            });\n            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance);\n            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n        }\n    }\n\n    // if hoverData is empty check for the spikes to draw and quit if there are none\n    if(hoverData.length === 0) {\n        var result = dragElement.unhoverRaw(gd, evt);\n        if(hasCartesian && ((spikePoints.hLinePoint !== null) || (spikePoints.vLinePoint !== null))) {\n            if(spikesChanged(oldspikepoints)) {\n                createSpikelines(gd, spikePoints, spikelineOpts);\n            }\n        }\n        return result;\n    }\n\n    if(hasCartesian) {\n        if(spikesChanged(oldspikepoints)) {\n            createSpikelines(gd, spikePoints, spikelineOpts);\n        }\n    }\n\n    hoverData.sort(function(d1, d2) { return d1.distance - d2.distance; });\n\n    // lastly, emit custom hover/unhover events\n    var oldhoverdata = gd._hoverdata;\n    var newhoverdata = [];\n\n    // pull out just the data that's useful to\n    // other people and send it to the event\n    for(itemnum = 0; itemnum < hoverData.length; itemnum++) {\n        var pt = hoverData[itemnum];\n        var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n        if(pt.hovertemplate !== false) {\n            var ht = false;\n            if(pt.cd[pt.index] && pt.cd[pt.index].ht) {\n                ht = pt.cd[pt.index].ht;\n            }\n            pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n        }\n\n        pt.eventData = [eventData];\n        newhoverdata.push(eventData);\n    }\n\n    gd._hoverdata = newhoverdata;\n\n    var rotateLabels = (\n        (hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1)) ||\n        (hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1)\n    );\n\n    var bgColor = Color.combine(\n        fullLayout.plot_bgcolor || Color.background,\n        fullLayout.paper_bgcolor\n    );\n\n    var labelOpts = {\n        hovermode: hovermode,\n        rotateLabels: rotateLabels,\n        bgColor: bgColor,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paperdiv,\n        commonLabelOpts: fullLayout.hoverlabel,\n        hoverdistance: fullLayout.hoverdistance\n    };\n\n    var hoverLabels = createHoverText(hoverData, labelOpts, gd);\n\n    hoverAvoidOverlaps(hoverLabels, rotateLabels ? 'xa' : 'ya', fullLayout);\n\n    alignHoverText(hoverLabels, rotateLabels);\n\n    // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n    // we should improve the \"fx\" API so other plots can use it without these hack.\n    if(evt.target && evt.target.tagName) {\n        var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n        overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n    }\n\n    // don't emit events if called manually\n    if(!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n    if(oldhoverdata) {\n        gd.emit('plotly_unhover', {\n            event: evt,\n            points: oldhoverdata\n        });\n    }\n\n    gd.emit('plotly_hover', {\n        event: evt,\n        points: gd._hoverdata,\n        xaxes: xaArray,\n        yaxes: yaArray,\n        xvals: xvalArray,\n        yvals: yvalArray\n    });\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts, gd) {\n    var fullLayout = gd._fullLayout;\n    var hovermode = opts.hovermode;\n    var rotateLabels = opts.rotateLabels;\n    var bgColor = opts.bgColor;\n    var container = opts.container;\n    var outerContainer = opts.outerContainer;\n    var commonLabelOpts = opts.commonLabelOpts || {};\n\n    // opts.fontFamily/Size are used for the common label\n    // and as defaults for each hover label, though the individual labels\n    // can override this.\n    var fontFamily = opts.fontFamily || constants.HOVERFONT;\n    var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n\n    var c0 = hoverData[0];\n    var xa = c0.xa;\n    var ya = c0.ya;\n    var commonAttr = hovermode === 'y' ? 'yLabel' : 'xLabel';\n    var t0 = c0[commonAttr];\n    var t00 = (String(t0) || '').split(' ')[0];\n    var outerContainerBB = outerContainer.node().getBoundingClientRect();\n    var outerTop = outerContainerBB.top;\n    var outerWidth = outerContainerBB.width;\n    var outerHeight = outerContainerBB.height;\n\n    // show the common label, if any, on the axis\n    // never show a common label in array mode,\n    // even if sometimes there could be one\n    var showCommonLabel = (\n        (t0 !== undefined) &&\n        (c0.distance <= opts.hoverdistance) &&\n        (hovermode === 'x' || hovermode === 'y')\n    );\n\n    // all hover traces hoverinfo must contain the hovermode\n    // to have common labels\n    if(showCommonLabel) {\n        var allHaveZ = true;\n        var i, traceHoverinfo;\n        for(i = 0; i < hoverData.length; i++) {\n            if(allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n\n            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n            if(traceHoverinfo) {\n                var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n                if(parts.indexOf('all') === -1 &&\n                    parts.indexOf(hovermode) === -1) {\n                    showCommonLabel = false;\n                    break;\n                }\n            }\n        }\n\n        // xyz labels put all info in their main label, so have no need of a common label\n        if(allHaveZ) showCommonLabel = false;\n    }\n\n    var commonLabel = container.selectAll('g.axistext')\n        .data(showCommonLabel ? [0] : []);\n    commonLabel.enter().append('g')\n        .classed('axistext', true);\n    commonLabel.exit().remove();\n\n    commonLabel.each(function() {\n        var label = d3.select(this);\n        var lpath = Lib.ensureSingle(label, 'path', '', function(s) {\n            s.style({'stroke-width': '1px'});\n        });\n        var ltext = Lib.ensureSingle(label, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n        var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n        var contrastColor = Color.contrast(commonBgColor);\n        var commonLabelFont = {\n            family: commonLabelOpts.font.family || fontFamily,\n            size: commonLabelOpts.font.size || fontSize,\n            color: commonLabelOpts.font.color || contrastColor\n        };\n\n        lpath.style({\n            fill: commonBgColor,\n            stroke: commonStroke\n        });\n\n        ltext.text(t0)\n            .call(Drawing.font, commonLabelFont)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        label.attr('transform', '');\n\n        var tbb = ltext.node().getBoundingClientRect();\n        var lx, ly;\n\n        if(hovermode === 'x') {\n            var topsign = xa.side === 'top' ? '-' : '';\n\n            ltext.attr('text-anchor', 'middle')\n                .call(svgTextUtils.positionText, 0, (xa.side === 'top' ?\n                    (outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD) :\n                    (outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD)));\n\n            lx = xa._offset + (c0.x0 + c0.x1) / 2;\n            ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n\n            var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n\n            if(lx < halfWidth) {\n                lx = halfWidth;\n\n                lpath.attr('d', 'M-' + (halfWidth - HOVERARROWSIZE) + ',0' +\n                    'L-' + (halfWidth - HOVERARROWSIZE * 2) + ',' + topsign + HOVERARROWSIZE +\n                    'H' + (HOVERTEXTPAD + tbb.width / 2) +\n                    'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                    'H-' + halfWidth +\n                    'V' + topsign + HOVERARROWSIZE +\n                    'Z');\n            } else if(lx > (fullLayout.width - halfWidth)) {\n                lx = fullLayout.width - halfWidth;\n\n                lpath.attr('d', 'M' + (halfWidth - HOVERARROWSIZE) + ',0' +\n                    'L' + halfWidth + ',' + topsign + HOVERARROWSIZE +\n                    'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                    'H-' + halfWidth +\n                    'V' + topsign + HOVERARROWSIZE +\n                    'H' + (halfWidth - HOVERARROWSIZE * 2) + 'Z');\n            } else {\n                lpath.attr('d', 'M0,0' +\n                    'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE +\n                    'H' + (HOVERTEXTPAD + tbb.width / 2) +\n                    'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                    'H-' + (HOVERTEXTPAD + tbb.width / 2) +\n                    'V' + topsign + HOVERARROWSIZE +\n                    'H-' + HOVERARROWSIZE + 'Z');\n            }\n        } else {\n            var anchor;\n            var sgn;\n            var leftsign;\n            if(ya.side === 'right') {\n                anchor = 'start';\n                sgn = 1;\n                leftsign = '';\n                lx = xa._offset + xa._length;\n            } else {\n                anchor = 'end';\n                sgn = -1;\n                leftsign = '-';\n                lx = xa._offset;\n            }\n\n            ly = ya._offset + (c0.y0 + c0.y1) / 2;\n\n            ltext.attr('text-anchor', anchor);\n\n            lpath.attr('d', 'M0,0' +\n                'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE +\n                'V' + (HOVERTEXTPAD + tbb.height / 2) +\n                'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) +\n                'V-' + (HOVERTEXTPAD + tbb.height / 2) +\n                'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n\n            var halfHeight = tbb.height / 2;\n            var lty = outerTop - tbb.top - halfHeight;\n            var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n            var clipPath;\n\n            if(lx < (tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE)) {\n                clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight +\n                    'h-' + (tbb.width - HOVERTEXTPAD) +\n                    'V' + halfHeight +\n                    'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n\n                var ltx = tbb.width - lx + HOVERTEXTPAD;\n                svgTextUtils.positionText(ltext, ltx, lty);\n\n                // shift each line (except the longest) so that start-of-line\n                // is always visible\n                if(anchor === 'end') {\n                    ltext.selectAll('tspan').each(function() {\n                        var s = d3.select(this);\n                        var dummy = Drawing.tester.append('text')\n                            .text(s.text())\n                            .call(Drawing.font, commonLabelFont);\n                        var dummyBB = dummy.node().getBoundingClientRect();\n                        if(dummyBB.width < tbb.width) {\n                            s.attr('x', ltx - dummyBB.width);\n                        }\n                        dummy.remove();\n                    });\n                }\n            } else {\n                svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n                clipPath = null;\n            }\n\n            var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n            textClip.enter().append('clipPath').attr('id', clipId).append('path');\n            textClip.exit().remove();\n            textClip.select('path').attr('d', clipPath);\n            Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n        }\n\n        label.attr('transform', 'translate(' + lx + ',' + ly + ')');\n\n        // remove the \"close but not quite\" points\n        // because of error bars, only take up to a space\n        hoverData = hoverData.filter(function(d) {\n            return (d.zLabelVal !== undefined) ||\n                (d[commonAttr] || '').split(' ')[0] === t00;\n        });\n    });\n\n    // show all the individual labels\n\n    // first create the objects\n    var hoverLabels = container.selectAll('g.hovertext')\n        .data(hoverData, function(d) {\n            // N.B. when multiple items have the same result key-function value,\n            // only the first of those items in hoverData gets rendered\n            return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa, d.ya || ''].join(',');\n        });\n    hoverLabels.enter().append('g')\n        .classed('hovertext', true)\n        .each(function() {\n            var g = d3.select(this);\n            // trace name label (rect and text.name)\n            g.append('rect')\n                .call(Color.fill, Color.addOpacity(bgColor, 0.8));\n            g.append('text').classed('name', true);\n            // trace data label (path and text.nums)\n            g.append('path')\n                .style('stroke-width', '1px');\n            g.append('text').classed('nums', true)\n                .call(Drawing.font, fontFamily, fontSize);\n        });\n    hoverLabels.exit().remove();\n\n    // then put the text in, position the pointer to the data,\n    // and figure out sizes\n    hoverLabels.each(function(d) {\n        var g = d3.select(this).attr('transform', '');\n        var name = '';\n        var text = '';\n\n        // combine possible non-opaque trace color with bgColor\n        var color0 = d.bgcolor || d.color;\n        // color for 'nums' part of the label\n        var numsColor = Color.combine(\n            Color.opacity(color0) ? color0 : Color.defaultLine,\n            bgColor\n        );\n        // color for 'name' part of the label\n        var nameColor = Color.combine(\n            Color.opacity(d.color) ? d.color : Color.defaultLine,\n            bgColor\n        );\n        // find a contrasting color for border and text\n        var contrastColor = d.borderColor || Color.contrast(numsColor);\n\n        // to get custom 'name' labels pass cleanPoint\n        if(d.nameOverride !== undefined) d.name = d.nameOverride;\n\n        if(d.name) {\n            if(d.trace._meta) {\n                d.name = Lib.templateString(d.name, d.trace._meta);\n            }\n            name = plainText(d.name, d.nameLength);\n        }\n\n        if(d.zLabel !== undefined) {\n            if(d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n            if(d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n            if(d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox') {\n                text += (text ? 'z: ' : '') + d.zLabel;\n            }\n        } else if(showCommonLabel && d[hovermode + 'Label'] === t0) {\n            text = d[(hovermode === 'x' ? 'y' : 'x') + 'Label'] || '';\n        } else if(d.xLabel === undefined) {\n            if(d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n                text = d.yLabel;\n            }\n        } else if(d.yLabel === undefined) text = d.xLabel;\n        else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n        if((d.text || d.text === 0) && !Array.isArray(d.text)) {\n            text += (text ? '<br>' : '') + d.text;\n        }\n\n        // used by other modules (initially just ternary) that\n        // manage their own hoverinfo independent of cleanPoint\n        // the rest of this will still apply, so such modules\n        // can still put things in (x|y|z)Label, text, and name\n        // and hoverinfo will still determine their visibility\n        if(d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;\n\n        // if 'text' is empty at this point,\n        // and hovertemplate is not defined,\n        // put 'name' in main label and don't show secondary label\n        if(text === '' && !d.hovertemplate) {\n            // if 'name' is also empty, remove entire label\n            if(name === '') g.remove();\n            text = name;\n        }\n\n        // hovertemplate\n        var d3locale = fullLayout._d3locale;\n        var hovertemplate = d.hovertemplate || false;\n        var hovertemplateLabels = d.hovertemplateLabels || d;\n        var eventData = d.eventData[0] || {};\n        if(hovertemplate) {\n            text = Lib.hovertemplateString(\n                hovertemplate,\n                hovertemplateLabels,\n                d3locale,\n                eventData,\n                d.trace._meta\n            );\n\n            text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {\n                // assign name for secondary text label\n                name = plainText(extra, d.nameLength);\n                // remove from main text label\n                return '';\n            });\n        }\n\n        // main label\n        var tx = g.select('text.nums')\n            .call(Drawing.font,\n                d.fontFamily || fontFamily,\n                d.fontSize || fontSize,\n                d.fontColor || contrastColor)\n            .text(text)\n            .attr('data-notex', 1)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        var tx2 = g.select('text.name');\n        var tx2width = 0;\n        var tx2height = 0;\n\n        // secondary label for non-empty 'name'\n        if(name && name !== text) {\n            tx2.call(Drawing.font,\n                    d.fontFamily || fontFamily,\n                    d.fontSize || fontSize,\n                    nameColor)\n                .text(name)\n                .attr('data-notex', 1)\n                .call(svgTextUtils.positionText, 0, 0)\n                .call(svgTextUtils.convertToTspans, gd);\n\n            var t2bb = tx2.node().getBoundingClientRect();\n            tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n            tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n        } else {\n            tx2.remove();\n            g.select('rect').remove();\n        }\n\n        g.select('path').style({\n            fill: numsColor,\n            stroke: contrastColor\n        });\n\n        var tbb = tx.node().getBoundingClientRect();\n        var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n        var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n        var dx = Math.abs(d.x1 - d.x0);\n        var dy = Math.abs(d.y1 - d.y0);\n        var txTotalWidth = tbb.width + HOVERARROWSIZE + HOVERTEXTPAD + tx2width;\n        var anchorStartOK, anchorEndOK;\n\n        d.ty0 = outerTop - tbb.top;\n        d.bx = tbb.width + 2 * HOVERTEXTPAD;\n        d.by = Math.max(tbb.height + 2 * HOVERTEXTPAD, tx2height);\n        d.anchor = 'start';\n        d.txwidth = tbb.width;\n        d.tx2width = tx2width;\n        d.offset = 0;\n\n        if(rotateLabels) {\n            d.pos = htx;\n            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n                hty -= dy / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                hty += dy / 2;\n                d.anchor = 'start';\n            } else d.anchor = 'middle';\n        } else {\n            d.pos = hty;\n            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n\n            if((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n                htx -= dx / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                htx += dx / 2;\n                d.anchor = 'start';\n            } else {\n                d.anchor = 'middle';\n\n                var txHalfWidth = txTotalWidth / 2;\n                var overflowR = htx + txHalfWidth - outerWidth;\n                var overflowL = htx - txHalfWidth;\n                if(overflowR > 0) htx -= overflowR;\n                if(overflowL < 0) htx += -overflowL;\n            }\n        }\n\n        tx.attr('text-anchor', d.anchor);\n        if(tx2width) tx2.attr('text-anchor', d.anchor);\n        g.attr('transform', 'translate(' + htx + ',' + hty + ')' +\n            (rotateLabels ? 'rotate(' + YANGLE + ')' : ''));\n    });\n\n    return hoverLabels;\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverLabels, axKey, fullLayout) {\n    var nummoves = 0;\n    var axSign = 1;\n    var nLabels = hoverLabels.size();\n\n    // make groups of touching points\n    var pointgroups = new Array(nLabels);\n    var k = 0;\n\n    hoverLabels.each(function(d) {\n        var ax = d[axKey];\n        var axIsX = ax._id.charAt(0) === 'x';\n        var rng = ax.range;\n\n        if(k === 0 && rng && ((rng[0] > rng[1]) !== axIsX)) {\n            axSign = -1;\n        }\n        pointgroups[k++] = [{\n            datum: d,\n            traceIndex: d.trace.index,\n            dp: 0,\n            pos: d.pos,\n            posref: d.posref,\n            size: d.by * (axIsX ? YFACTOR : 1) / 2,\n            pmin: 0,\n            pmax: (axIsX ? fullLayout.width : fullLayout.height)\n        }];\n    });\n\n    pointgroups.sort(function(a, b) {\n        return (a[0].posref - b[0].posref) ||\n            // for equal positions, sort trace indices increasing or decreasing\n            // depending on whether the axis is reversed or not... so stacked\n            // traces will generally keep their order even if one trace adds\n            // nothing to the stack.\n            (axSign * (b[0].traceIndex - a[0].traceIndex));\n    });\n\n    var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n    function constrainGroup(grp) {\n        var minPt = grp[0];\n        var maxPt = grp[grp.length - 1];\n\n        // overlap with the top - positive vals are overlaps\n        topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n        // overlap with the bottom - positive vals are overlaps\n        bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n        // check for min overlap first, so that we always\n        // see the largest labels\n        // allow for .01px overlap, so we don't get an\n        // infinite loop from rounding errors\n        if(topOverlap > 0.01) {\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n            donepositioning = false;\n        }\n        if(bottomOverlap < 0.01) return;\n        if(topOverlap < -0.01) {\n            // make sure we're not pushing back and forth\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            donepositioning = false;\n        }\n        if(!donepositioning) return;\n\n        // no room to fix positioning, delete off-screen points\n\n        // first see how many points we need to delete\n        var deleteCount = 0;\n        for(i = 0; i < grp.length; i++) {\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n        }\n\n        // start by deleting points whose data is off screen\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos > minPt.pmax - 1) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n        for(i = 0; i < grp.length; i++) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos < minPt.pmin + 1) {\n                pti.del = true;\n                deleteCount--;\n\n                // shift the whole group minus into this new space\n                bottomOverlap = pti.size * 2;\n                for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            }\n        }\n        // then delete points that go off the bottom\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n    }\n\n    // loop through groups, combining them if they overlap,\n    // until nothing moves\n    while(!donepositioning && nummoves <= nLabels) {\n        // to avoid infinite loops, don't move more times\n        // than there are traces\n        nummoves++;\n\n        // assume nothing will move in this iteration,\n        // reverse this if it does\n        donepositioning = true;\n        i = 0;\n        while(i < pointgroups.length - 1) {\n            // the higher (g0) and lower (g1) point group\n            var g0 = pointgroups[i];\n            var g1 = pointgroups[i + 1];\n\n            // the lowest point in the higher group (p0)\n            // the highest point in the lower group (p1)\n            var p0 = g0[g0.length - 1];\n            var p1 = g1[0];\n            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n\n            // Only group points that lie on the same axes\n            if(topOverlap > 0.01 && (p0.pmin === p1.pmin) && (p0.pmax === p1.pmax)) {\n                // push the new point(s) added to this group out of the way\n                for(j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;\n\n                // add them to the group\n                g0.push.apply(g0, g1);\n                pointgroups.splice(i + 1, 1);\n\n                // adjust for minimum average movement\n                sumdp = 0;\n                for(j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n                bottomOverlap = sumdp / g0.length;\n                for(j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n                donepositioning = false;\n            } else i++;\n        }\n\n        // check if we're going off the plot on either side and fix\n        pointgroups.forEach(constrainGroup);\n    }\n\n    // now put these offsets into hoverData\n    for(i = pointgroups.length - 1; i >= 0; i--) {\n        var grp = pointgroups[i];\n        for(j = grp.length - 1; j >= 0; j--) {\n            var pt = grp[j];\n            var hoverPt = pt.datum;\n            hoverPt.offset = pt.dp;\n            hoverPt.del = pt.del;\n        }\n    }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels) {\n    // finally set the text positioning relative to the data and draw the\n    // box around it\n    hoverLabels.each(function(d) {\n        var g = d3.select(this);\n        if(d.del) return g.remove();\n\n        var tx = g.select('text.nums');\n        var anchor = d.anchor;\n        var horzSign = anchor === 'end' ? -1 : 1;\n        var alignShift = {start: 1, end: -1, middle: 0}[anchor];\n        var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n        var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n        var offsetX = 0;\n        var offsetY = d.offset;\n\n        if(anchor === 'middle') {\n            txx -= d.tx2width / 2;\n            tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n        }\n        if(rotateLabels) {\n            offsetY *= -YSHIFTY;\n            offsetX = d.offset * YSHIFTX;\n        }\n\n        g.select('path').attr('d', anchor === 'middle' ?\n            // middle aligned: rect centered on data\n            ('M-' + (d.bx / 2 + d.tx2width / 2) + ',' + (offsetY - d.by / 2) +\n              'h' + d.bx + 'v' + d.by + 'h-' + d.bx + 'Z') :\n            // left or right aligned: side rect with arrow to data\n            ('M0,0L' + (horzSign * HOVERARROWSIZE + offsetX) + ',' + (HOVERARROWSIZE + offsetY) +\n                'v' + (d.by / 2 - HOVERARROWSIZE) +\n                'h' + (horzSign * d.bx) +\n                'v-' + d.by +\n                'H' + (horzSign * HOVERARROWSIZE + offsetX) +\n                'V' + (offsetY - HOVERARROWSIZE) +\n                'Z'));\n\n        var posX = txx + offsetX;\n        var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n        var textAlign = d.textAlign || 'auto';\n\n        if(textAlign !== 'auto') {\n            if(textAlign === 'left' && anchor !== 'start') {\n                tx.attr('text-anchor', 'start');\n                posX = anchor === 'middle' ?\n                    -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD :\n                    -d.bx - HOVERTEXTPAD;\n            } else if(textAlign === 'right' && anchor !== 'end') {\n                tx.attr('text-anchor', 'end');\n                posX = anchor === 'middle' ?\n                    d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD :\n                    d.bx + HOVERTEXTPAD;\n            }\n        }\n\n        tx.call(svgTextUtils.positionText, posX, posY);\n\n        if(d.tx2width) {\n            g.select('text.name')\n                .call(svgTextUtils.positionText,\n                    tx2x + alignShift * HOVERTEXTPAD + offsetX,\n                    offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n            g.select('rect')\n                .call(Drawing.setRect,\n                    tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX,\n                    offsetY - d.by / 2 - 1,\n                    d.tx2width, d.by + 2);\n        }\n    });\n}\n\nfunction cleanPoint(d, hovermode) {\n    var index = d.index;\n    var trace = d.trace || {};\n    var cd0 = d.cd[0];\n    var cd = d.cd[index] || {};\n\n    function pass(v) {\n        return v || (isNumeric(v) && v === 0);\n    }\n\n    var getVal = Array.isArray(index) ?\n        function(calcKey, traceKey) {\n            var v = Lib.castOption(cd0, index, calcKey);\n            return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n        } :\n        function(calcKey, traceKey) {\n            return Lib.extractOption(cd, trace, calcKey, traceKey);\n        };\n\n    function fill(key, calcKey, traceKey) {\n        var val = getVal(calcKey, traceKey);\n        if(pass(val)) d[key] = val;\n    }\n\n    fill('hoverinfo', 'hi', 'hoverinfo');\n    fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n    fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n    fill('fontFamily', 'htf', 'hoverlabel.font.family');\n    fill('fontSize', 'hts', 'hoverlabel.font.size');\n    fill('fontColor', 'htc', 'hoverlabel.font.color');\n    fill('nameLength', 'hnl', 'hoverlabel.namelength');\n    fill('textAlign', 'hta', 'hoverlabel.align');\n\n    d.posref = (hovermode === 'y' || (hovermode === 'closest' && trace.orientation === 'h')) ?\n        (d.xa._offset + (d.x0 + d.x1) / 2) :\n        (d.ya._offset + (d.y0 + d.y1) / 2);\n\n    // then constrain all the positions to be on the plot\n    d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n    d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n    d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n    d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n    // and convert the x and y label values into formatted text\n    if(d.xLabelVal !== undefined) {\n        d.xLabel = ('xLabel' in d) ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal);\n        d.xVal = d.xa.c2d(d.xLabelVal);\n    }\n    if(d.yLabelVal !== undefined) {\n        d.yLabel = ('yLabel' in d) ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal);\n        d.yVal = d.ya.c2d(d.yLabelVal);\n    }\n\n    // Traces like heatmaps generate the zLabel in their hoverPoints function\n    if(d.zLabelVal !== undefined && d.zLabel === undefined) {\n        d.zLabel = String(d.zLabelVal);\n    }\n\n    // for box means and error bars, add the range to the label\n    if(!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n        var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n        if(d.xerrneg !== undefined) {\n            d.xLabel += ' +' + xeText + ' / -' +\n                Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n        } else d.xLabel += ' ± ' + xeText;\n\n        // small distance penalty for error bars, so that if there are\n        // traces with errors and some without, the error bar label will\n        // hoist up to the point\n        if(hovermode === 'x') d.distance += 1;\n    }\n    if(!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n        var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n        if(d.yerrneg !== undefined) {\n            d.yLabel += ' +' + yeText + ' / -' +\n                Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n        } else d.yLabel += ' ± ' + yeText;\n\n        if(hovermode === 'y') d.distance += 1;\n    }\n\n    var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n    if(infomode && infomode !== 'all') {\n        infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n        if(infomode.indexOf('x') === -1) d.xLabel = undefined;\n        if(infomode.indexOf('y') === -1) d.yLabel = undefined;\n        if(infomode.indexOf('z') === -1) d.zLabel = undefined;\n        if(infomode.indexOf('text') === -1) d.text = undefined;\n        if(infomode.indexOf('name') === -1) d.name = undefined;\n    }\n\n    return d;\n}\n\nfunction createSpikelines(gd, closestPoints, opts) {\n    var container = opts.container;\n    var fullLayout = opts.fullLayout;\n    var gs = fullLayout._size;\n    var evt = opts.event;\n    var showY = !!closestPoints.hLinePoint;\n    var showX = !!closestPoints.vLinePoint;\n\n    var xa, ya;\n\n    // Remove old spikeline items\n    container.selectAll('.spikeline').remove();\n\n    if(!(showX || showY)) return;\n\n    var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n\n    // Horizontal line (to y-axis)\n    if(showY) {\n        var hLinePoint = closestPoints.hLinePoint;\n        var hLinePointX, hLinePointY;\n\n        xa = hLinePoint && hLinePoint.xa;\n        ya = hLinePoint && hLinePoint.ya;\n        var ySnap = ya.spikesnap;\n\n        if(ySnap === 'cursor') {\n            hLinePointX = evt.pointerX;\n            hLinePointY = evt.pointerY;\n        } else {\n            hLinePointX = xa._offset + hLinePoint.x;\n            hLinePointY = ya._offset + hLinePoint.y;\n        }\n        var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : hLinePoint.color;\n        var yMode = ya.spikemode;\n        var yThickness = ya.spikethickness;\n        var yColor = ya.spikecolor || dfltHLineColor;\n        var xEdge = Axes.getPxPosition(gd, ya);\n        var xBase, xEndSpike;\n\n        if(yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n            if(yMode.indexOf('toaxis') !== -1) {\n                xBase = xEdge;\n                xEndSpike = hLinePointX;\n            }\n            if(yMode.indexOf('across') !== -1) {\n                var xAcross0 = ya._counterDomainMin;\n                var xAcross1 = ya._counterDomainMax;\n                if(ya.anchor === 'free') {\n                    xAcross0 = Math.min(xAcross0, ya.position);\n                    xAcross1 = Math.max(xAcross1, ya.position);\n                }\n                xBase = gs.l + xAcross0 * gs.w;\n                xEndSpike = gs.l + xAcross1 * gs.w;\n            }\n\n            // Foreground horizontal line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness,\n                    stroke: yColor,\n                    'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background horizontal Line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n        // Y axis marker\n        if(yMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n                    cy: hLinePointY,\n                    r: yThickness,\n                    fill: yColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n\n    if(showX) {\n        var vLinePoint = closestPoints.vLinePoint;\n        var vLinePointX, vLinePointY;\n\n        xa = vLinePoint && vLinePoint.xa;\n        ya = vLinePoint && vLinePoint.ya;\n        var xSnap = xa.spikesnap;\n\n        if(xSnap === 'cursor') {\n            vLinePointX = evt.pointerX;\n            vLinePointY = evt.pointerY;\n        } else {\n            vLinePointX = xa._offset + vLinePoint.x;\n            vLinePointY = ya._offset + vLinePoint.y;\n        }\n        var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : vLinePoint.color;\n        var xMode = xa.spikemode;\n        var xThickness = xa.spikethickness;\n        var xColor = xa.spikecolor || dfltVLineColor;\n        var yEdge = Axes.getPxPosition(gd, xa);\n        var yBase, yEndSpike;\n\n        if(xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n            if(xMode.indexOf('toaxis') !== -1) {\n                yBase = yEdge;\n                yEndSpike = vLinePointY;\n            }\n            if(xMode.indexOf('across') !== -1) {\n                var yAcross0 = xa._counterDomainMin;\n                var yAcross1 = xa._counterDomainMax;\n                if(xa.anchor === 'free') {\n                    yAcross0 = Math.min(yAcross0, xa.position);\n                    yAcross1 = Math.max(yAcross1, xa.position);\n                }\n                yBase = gs.t + (1 - yAcross1) * gs.h;\n                yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n            }\n\n            // Foreground vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness,\n                    stroke: xColor,\n                    'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n\n        // X axis marker\n        if(xMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: vLinePointX,\n                    cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n                    r: xThickness,\n                    fill: xColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n    // don't emit any events if nothing changed\n    if(!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n    for(var i = oldhoverdata.length - 1; i >= 0; i--) {\n        var oldPt = oldhoverdata[i];\n        var newPt = gd._hoverdata[i];\n\n        if(oldPt.curveNumber !== newPt.curveNumber ||\n            String(oldPt.pointNumber) !== String(newPt.pointNumber) ||\n            String(oldPt.pointNumbers) !== String(newPt.pointNumbers)\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n    // don't relayout the plot because of new spikelines if spikelines points didn't change\n    if(!oldspikepoints) return true;\n    if(oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint ||\n        oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint\n    ) return true;\n    return false;\n}\n\nfunction plainText(s, len) {\n    return svgTextUtils.plainText(s || '', {\n        len: len,\n        allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n    });\n}\n"]},"metadata":{},"sourceType":"script"}