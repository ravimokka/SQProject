{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n/* global PlotlyGeoAssets:false */\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Fx = require('../../components/fx');\n\nvar Plots = require('../plots');\n\nvar Axes = require('../cartesian/axes');\n\nvar dragElement = require('../../components/dragelement');\n\nvar prepSelect = require('../cartesian/select').prepSelect;\n\nvar selectOnClick = require('../cartesian/select').selectOnClick;\n\nvar createGeoZoom = require('./zoom');\n\nvar constants = require('./constants');\n\nvar topojsonUtils = require('../../lib/topojson_utils');\n\nvar topojsonFeature = require('topojson-client').feature;\n\nrequire('./projections')(d3);\n\nfunction Geo(opts) {\n  this.id = opts.id;\n  this.graphDiv = opts.graphDiv;\n  this.container = opts.container;\n  this.topojsonURL = opts.topojsonURL;\n  this.isStatic = opts.staticPlot;\n  this.topojsonName = null;\n  this.topojson = null;\n  this.projection = null;\n  this.scope = null;\n  this.viewInitial = null;\n  this.fitScale = null;\n  this.bounds = null;\n  this.midPt = null;\n  this.hasChoropleth = false;\n  this.traceHash = {};\n  this.layers = {};\n  this.basePaths = {};\n  this.dataPaths = {};\n  this.dataPoints = {};\n  this.clipDef = null;\n  this.clipRect = null;\n  this.bgRect = null;\n  this.makeFramework();\n}\n\nvar proto = Geo.prototype;\n\nmodule.exports = function createGeo(opts) {\n  return new Geo(opts);\n};\n\nproto.plot = function (geoCalcData, fullLayout, promises) {\n  var _this = this;\n\n  var geoLayout = fullLayout[this.id];\n  var needsTopojson = false;\n\n  for (var k in constants.layerNameToAdjective) {\n    if (k !== 'frame' && geoLayout['show' + k]) {\n      needsTopojson = true;\n      break;\n    }\n  }\n\n  for (var i = 0; i < geoCalcData.length; i++) {\n    if (geoCalcData[0][0].trace.locationmode) {\n      needsTopojson = true;\n      break;\n    }\n  }\n\n  if (!needsTopojson) {\n    return _this.update(geoCalcData, fullLayout);\n  }\n\n  var topojsonNameNew = topojsonUtils.getTopojsonName(geoLayout);\n\n  if (_this.topojson === null || topojsonNameNew !== _this.topojsonName) {\n    _this.topojsonName = topojsonNameNew;\n\n    if (PlotlyGeoAssets.topojson[_this.topojsonName] === undefined) {\n      promises.push(_this.fetchTopojson().then(function (topojson) {\n        PlotlyGeoAssets.topojson[_this.topojsonName] = topojson;\n        _this.topojson = topojson;\n\n        _this.update(geoCalcData, fullLayout);\n      }));\n    } else {\n      _this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];\n\n      _this.update(geoCalcData, fullLayout);\n    }\n  } else {\n    _this.update(geoCalcData, fullLayout);\n  }\n};\n\nproto.fetchTopojson = function () {\n  var topojsonPath = topojsonUtils.getTopojsonPath(this.topojsonURL, this.topojsonName);\n  return new Promise(function (resolve, reject) {\n    d3.json(topojsonPath, function (err, topojson) {\n      if (err) {\n        if (err.status === 404) {\n          return reject(new Error(['plotly.js could not find topojson file at', topojsonPath, '.', 'Make sure the *topojsonURL* plot config option', 'is set properly.'].join(' ')));\n        } else {\n          return reject(new Error(['unexpected error while fetching topojson file at', topojsonPath].join(' ')));\n        }\n      }\n\n      resolve(topojson);\n    });\n  });\n};\n\nproto.update = function (geoCalcData, fullLayout) {\n  var geoLayout = fullLayout[this.id];\n  var hasInvalidBounds = this.updateProjection(fullLayout, geoLayout);\n  if (hasInvalidBounds) return; // important: maps with choropleth traces have a different layer order\n\n  this.hasChoropleth = false;\n\n  for (var i = 0; i < geoCalcData.length; i++) {\n    if (geoCalcData[i][0].trace.type === 'choropleth') {\n      this.hasChoropleth = true;\n      break;\n    }\n  }\n\n  if (!this.viewInitial || this.scope !== geoLayout.scope) {\n    this.saveViewInitial(geoLayout);\n  }\n\n  this.scope = geoLayout.scope;\n  this.updateBaseLayers(fullLayout, geoLayout);\n  this.updateDims(fullLayout, geoLayout);\n  this.updateFx(fullLayout, geoLayout);\n  Plots.generalUpdatePerTraceModule(this.graphDiv, this, geoCalcData, geoLayout);\n  var scatterLayer = this.layers.frontplot.select('.scatterlayer');\n  this.dataPoints.point = scatterLayer.selectAll('.point');\n  this.dataPoints.text = scatterLayer.selectAll('text');\n  this.dataPaths.line = scatterLayer.selectAll('.js-line');\n  var choroplethLayer = this.layers.backplot.select('.choroplethlayer');\n  this.dataPaths.choropleth = choroplethLayer.selectAll('path');\n  this.render();\n};\n\nproto.updateProjection = function (fullLayout, geoLayout) {\n  var gs = fullLayout._size;\n  var domain = geoLayout.domain;\n  var projLayout = geoLayout.projection;\n  var rotation = projLayout.rotation || {};\n  var center = geoLayout.center || {};\n  var projection = this.projection = getProjection(geoLayout); // set 'pre-fit' projection\n\n  projection.center([center.lon - rotation.lon, center.lat - rotation.lat]).rotate([-rotation.lon, -rotation.lat, rotation.roll]).parallels(projLayout.parallels); // setup subplot extent [[x0,y0], [x1,y1]]\n\n  var extent = [[gs.l + gs.w * domain.x[0], gs.t + gs.h * (1 - domain.y[1])], [gs.l + gs.w * domain.x[1], gs.t + gs.h * (1 - domain.y[0])]];\n  var lonaxis = geoLayout.lonaxis;\n  var lataxis = geoLayout.lataxis;\n  var rangeBox = makeRangeBox(lonaxis.range, lataxis.range); // fit projection 'scale' and 'translate' to set lon/lat ranges\n\n  projection.fitExtent(extent, rangeBox);\n  var b = this.bounds = projection.getBounds(rangeBox);\n  var s = this.fitScale = projection.scale();\n  var t = projection.translate();\n\n  if (!isFinite(b[0][0]) || !isFinite(b[0][1]) || !isFinite(b[1][0]) || !isFinite(b[1][1]) || isNaN(t[0]) || isNaN(t[0])) {\n    var gd = this.graphDiv;\n    var attrToUnset = ['projection.rotation', 'center', 'lonaxis.range', 'lataxis.range'];\n    var msg = 'Invalid geo settings, relayout\\'ing to default view.';\n    var updateObj = {}; // clear all attribute that could cause invalid bounds,\n    // clear viewInitial to update reset-view behavior\n\n    for (var i = 0; i < attrToUnset.length; i++) {\n      updateObj[this.id + '.' + attrToUnset[i]] = null;\n    }\n\n    this.viewInitial = null;\n    Lib.warn(msg);\n\n    gd._promises.push(Registry.call('relayout', gd, updateObj));\n\n    return msg;\n  } // px coordinates of view mid-point,\n  // useful to update `geo.center` after interactions\n\n\n  var midPt = this.midPt = [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2]; // adjust projection to user setting\n\n  projection.scale(projLayout.scale * s).translate([t[0] + (midPt[0] - t[0]), t[1] + (midPt[1] - t[1])]).clipExtent(b); // the 'albers usa' projection does not expose a 'center' method\n  // so here's this hack to make it respond to 'geoLayout.center'\n\n  if (geoLayout._isAlbersUsa) {\n    var centerPx = projection([center.lon, center.lat]);\n    var tt = projection.translate();\n    projection.translate([tt[0] - (centerPx[0] - tt[0]), tt[1] - (centerPx[1] - tt[1])]);\n  }\n};\n\nproto.updateBaseLayers = function (fullLayout, geoLayout) {\n  var _this = this;\n\n  var topojson = _this.topojson;\n  var layers = _this.layers;\n  var basePaths = _this.basePaths;\n\n  function isAxisLayer(d) {\n    return d === 'lonaxis' || d === 'lataxis';\n  }\n\n  function isLineLayer(d) {\n    return Boolean(constants.lineLayers[d]);\n  }\n\n  function isFillLayer(d) {\n    return Boolean(constants.fillLayers[d]);\n  }\n\n  var allLayers = this.hasChoropleth ? constants.layersForChoropleth : constants.layers;\n  var layerData = allLayers.filter(function (d) {\n    return isLineLayer(d) || isFillLayer(d) ? geoLayout['show' + d] : isAxisLayer(d) ? geoLayout[d].showgrid : true;\n  });\n\n  var join = _this.framework.selectAll('.layer').data(layerData, String);\n\n  join.exit().each(function (d) {\n    delete layers[d];\n    delete basePaths[d];\n    d3.select(this).remove();\n  });\n  join.enter().append('g').attr('class', function (d) {\n    return 'layer ' + d;\n  }).each(function (d) {\n    var layer = layers[d] = d3.select(this);\n\n    if (d === 'bg') {\n      _this.bgRect = layer.append('rect').style('pointer-events', 'all');\n    } else if (isAxisLayer(d)) {\n      basePaths[d] = layer.append('path').style('fill', 'none');\n    } else if (d === 'backplot') {\n      layer.append('g').classed('choroplethlayer', true);\n    } else if (d === 'frontplot') {\n      layer.append('g').classed('scatterlayer', true);\n    } else if (isLineLayer(d)) {\n      basePaths[d] = layer.append('path').style('fill', 'none').style('stroke-miterlimit', 2);\n    } else if (isFillLayer(d)) {\n      basePaths[d] = layer.append('path').style('stroke', 'none');\n    }\n  });\n  join.order();\n  join.each(function (d) {\n    var path = basePaths[d];\n    var adj = constants.layerNameToAdjective[d];\n\n    if (d === 'frame') {\n      path.datum(constants.sphereSVG);\n    } else if (isLineLayer(d) || isFillLayer(d)) {\n      path.datum(topojsonFeature(topojson, topojson.objects[d]));\n    } else if (isAxisLayer(d)) {\n      path.datum(makeGraticule(d, geoLayout, fullLayout)).call(Color.stroke, geoLayout[d].gridcolor).call(Drawing.dashLine, '', geoLayout[d].gridwidth);\n    }\n\n    if (isLineLayer(d)) {\n      path.call(Color.stroke, geoLayout[adj + 'color']).call(Drawing.dashLine, '', geoLayout[adj + 'width']);\n    } else if (isFillLayer(d)) {\n      path.call(Color.fill, geoLayout[adj + 'color']);\n    }\n  });\n};\n\nproto.updateDims = function (fullLayout, geoLayout) {\n  var b = this.bounds;\n  var hFrameWidth = (geoLayout.framewidth || 0) / 2;\n  var l = b[0][0] - hFrameWidth;\n  var t = b[0][1] - hFrameWidth;\n  var w = b[1][0] - l + hFrameWidth;\n  var h = b[1][1] - t + hFrameWidth;\n  Drawing.setRect(this.clipRect, l, t, w, h);\n  this.bgRect.call(Drawing.setRect, l, t, w, h).call(Color.fill, geoLayout.bgcolor);\n  this.xaxis._offset = l;\n  this.xaxis._length = w;\n  this.yaxis._offset = t;\n  this.yaxis._length = h;\n};\n\nproto.updateFx = function (fullLayout, geoLayout) {\n  var _this = this;\n\n  var gd = _this.graphDiv;\n  var bgRect = _this.bgRect;\n  var dragMode = fullLayout.dragmode;\n  var clickMode = fullLayout.clickmode;\n  if (_this.isStatic) return;\n\n  function zoomReset() {\n    var viewInitial = _this.viewInitial;\n    var updateObj = {};\n\n    for (var k in viewInitial) {\n      updateObj[_this.id + '.' + k] = viewInitial[k];\n    }\n\n    Registry.call('_guiRelayout', gd, updateObj);\n    gd.emit('plotly_doubleclick', null);\n  }\n\n  function invert(lonlat) {\n    return _this.projection.invert([lonlat[0] + _this.xaxis._offset, lonlat[1] + _this.yaxis._offset]);\n  }\n\n  var fillRangeItems;\n\n  if (dragMode === 'select') {\n    fillRangeItems = function (eventData, poly) {\n      var ranges = eventData.range = {};\n      ranges[_this.id] = [invert([poly.xmin, poly.ymin]), invert([poly.xmax, poly.ymax])];\n    };\n  } else if (dragMode === 'lasso') {\n    fillRangeItems = function (eventData, poly, pts) {\n      var dataPts = eventData.lassoPoints = {};\n      dataPts[_this.id] = pts.filtered.map(invert);\n    };\n  } // Note: dragOptions is needed to be declared for all dragmodes because\n  // it's the object that holds persistent selection state.\n\n\n  var dragOptions = {\n    element: _this.bgRect.node(),\n    gd: gd,\n    plotinfo: {\n      id: _this.id,\n      xaxis: _this.xaxis,\n      yaxis: _this.yaxis,\n      fillRangeItems: fillRangeItems\n    },\n    xaxes: [_this.xaxis],\n    yaxes: [_this.yaxis],\n    subplot: _this.id,\n    clickFn: function (numClicks) {\n      if (numClicks === 2) {\n        fullLayout._zoomlayer.selectAll('.select-outline').remove();\n      }\n    }\n  };\n\n  if (dragMode === 'pan') {\n    bgRect.node().onmousedown = null;\n    bgRect.call(createGeoZoom(_this, geoLayout));\n    bgRect.on('dblclick.zoom', zoomReset);\n\n    if (!gd._context._scrollZoom.geo) {\n      bgRect.on('wheel.zoom', null);\n    }\n  } else if (dragMode === 'select' || dragMode === 'lasso') {\n    bgRect.on('.zoom', null);\n\n    dragOptions.prepFn = function (e, startX, startY) {\n      prepSelect(e, startX, startY, dragOptions, dragMode);\n    };\n\n    dragElement.init(dragOptions);\n  }\n\n  bgRect.on('mousemove', function () {\n    var lonlat = _this.projection.invert(d3.mouse(this));\n\n    if (!lonlat || isNaN(lonlat[0]) || isNaN(lonlat[1])) {\n      return dragElement.unhover(gd, d3.event);\n    }\n\n    _this.xaxis.p2c = function () {\n      return lonlat[0];\n    };\n\n    _this.yaxis.p2c = function () {\n      return lonlat[1];\n    };\n\n    Fx.hover(gd, d3.event, _this.id);\n  });\n  bgRect.on('mouseout', function () {\n    if (gd._dragging) return;\n    dragElement.unhover(gd, d3.event);\n  });\n  bgRect.on('click', function () {\n    // For select and lasso the dragElement is handling clicks\n    if (dragMode !== 'select' && dragMode !== 'lasso') {\n      if (clickMode.indexOf('select') > -1) {\n        selectOnClick(d3.event, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOptions);\n      }\n\n      if (clickMode.indexOf('event') > -1) {\n        // TODO: like pie and mapbox, this doesn't support right-click\n        // actually this one is worse, as right-click starts a pan, or leaves\n        // select in a weird state.\n        // Also, only tangentially related, we should cancel hover during pan\n        Fx.click(gd, d3.event);\n      }\n    }\n  });\n};\n\nproto.makeFramework = function () {\n  var _this = this;\n\n  var gd = _this.graphDiv;\n  var fullLayout = gd._fullLayout;\n  var clipId = 'clip' + fullLayout._uid + _this.id;\n  _this.clipDef = fullLayout._clips.append('clipPath').attr('id', clipId);\n  _this.clipRect = _this.clipDef.append('rect');\n  _this.framework = d3.select(_this.container).append('g').attr('class', 'geo ' + _this.id).call(Drawing.setClipUrl, clipId, gd); // sane lonlat to px\n\n  _this.project = function (v) {\n    var px = _this.projection(v);\n\n    return px ? [px[0] - _this.xaxis._offset, px[1] - _this.yaxis._offset] : [null, null];\n  };\n\n  _this.xaxis = {\n    _id: 'x',\n    c2p: function (v) {\n      return _this.project(v)[0];\n    }\n  };\n  _this.yaxis = {\n    _id: 'y',\n    c2p: function (v) {\n      return _this.project(v)[1];\n    }\n  }; // mock axis for hover formatting\n\n  _this.mockAxis = {\n    type: 'linear',\n    showexponent: 'all',\n    exponentformat: 'B'\n  };\n  Axes.setConvert(_this.mockAxis, fullLayout);\n};\n\nproto.saveViewInitial = function (geoLayout) {\n  var center = geoLayout.center || {};\n  var projLayout = geoLayout.projection;\n  var rotation = projLayout.rotation || {};\n\n  if (geoLayout._isScoped) {\n    this.viewInitial = {\n      'center.lon': center.lon,\n      'center.lat': center.lat,\n      'projection.scale': projLayout.scale\n    };\n  } else if (geoLayout._isClipped) {\n    this.viewInitial = {\n      'projection.scale': projLayout.scale,\n      'projection.rotation.lon': rotation.lon,\n      'projection.rotation.lat': rotation.lat\n    };\n  } else {\n    this.viewInitial = {\n      'center.lon': center.lon,\n      'center.lat': center.lat,\n      'projection.scale': projLayout.scale,\n      'projection.rotation.lon': rotation.lon\n    };\n  }\n}; // [hot code path] (re)draw all paths which depend on the projection\n\n\nproto.render = function () {\n  var projection = this.projection;\n  var pathFn = projection.getPath();\n  var k;\n\n  function translatePoints(d) {\n    var lonlatPx = projection(d.lonlat);\n    return lonlatPx ? 'translate(' + lonlatPx[0] + ',' + lonlatPx[1] + ')' : null;\n  }\n\n  function hideShowPoints(d) {\n    return projection.isLonLatOverEdges(d.lonlat) ? 'none' : null;\n  }\n\n  for (k in this.basePaths) {\n    this.basePaths[k].attr('d', pathFn);\n  }\n\n  for (k in this.dataPaths) {\n    this.dataPaths[k].attr('d', function (d) {\n      return pathFn(d.geojson);\n    });\n  }\n\n  for (k in this.dataPoints) {\n    this.dataPoints[k].attr('display', hideShowPoints).attr('transform', translatePoints);\n  }\n}; // Helper that wraps d3.geo[/* projection name /*]() which:\n//\n// - adds 'fitExtent' (available in d3 v4)\n// - adds 'getPath', 'getBounds' convenience methods\n// - scopes logic related to 'clipAngle'\n// - adds 'isLonLatOverEdges' method\n// - sets projection precision\n// - sets methods that aren't always defined depending\n//   on the projection type to a dummy 'd3-esque' function,\n//\n// This wrapper alleviates subsequent code of (many) annoying if-statements.\n\n\nfunction getProjection(geoLayout) {\n  var projLayout = geoLayout.projection;\n  var projType = projLayout.type;\n  var projection = d3.geo[constants.projNames[projType]]();\n  var clipAngle = geoLayout._isClipped ? constants.lonaxisSpan[projType] / 2 : null;\n  var methods = ['center', 'rotate', 'parallels', 'clipExtent'];\n\n  var dummyFn = function (_) {\n    return _ ? projection : [];\n  };\n\n  for (var i = 0; i < methods.length; i++) {\n    var m = methods[i];\n\n    if (typeof projection[m] !== 'function') {\n      projection[m] = dummyFn;\n    }\n  }\n\n  projection.isLonLatOverEdges = function (lonlat) {\n    if (projection(lonlat) === null) {\n      return true;\n    }\n\n    if (clipAngle) {\n      var r = projection.rotate();\n      var angle = d3.geo.distance(lonlat, [-r[0], -r[1]]);\n      var maxAngle = clipAngle * Math.PI / 180;\n      return angle > maxAngle;\n    } else {\n      return false;\n    }\n  };\n\n  projection.getPath = function () {\n    return d3.geo.path().projection(projection);\n  };\n\n  projection.getBounds = function (object) {\n    return projection.getPath().bounds(object);\n  }; // adapted from d3 v4:\n  // https://github.com/d3/d3-geo/blob/master/src/projection/fit.js\n\n\n  projection.fitExtent = function (extent, object) {\n    var w = extent[1][0] - extent[0][0];\n    var h = extent[1][1] - extent[0][1];\n    var clip = projection.clipExtent && projection.clipExtent();\n    projection.scale(150).translate([0, 0]);\n    if (clip) projection.clipExtent(null);\n    var b = projection.getBounds(object);\n    var k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1]));\n    var x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2;\n    var y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n    if (clip) projection.clipExtent(clip);\n    return projection.scale(k * 150).translate([x, y]);\n  };\n\n  projection.precision(constants.precision);\n\n  if (clipAngle) {\n    projection.clipAngle(clipAngle - constants.clipPad);\n  }\n\n  return projection;\n}\n\nfunction makeGraticule(axisName, geoLayout, fullLayout) {\n  // equivalent to the d3 \"ε\"\n  var epsilon = 1e-6; // same as the geoGraticule default\n\n  var precision = 2.5;\n  var axLayout = geoLayout[axisName];\n  var scopeDefaults = constants.scopeDefaults[geoLayout.scope];\n  var rng;\n  var oppRng;\n  var coordFn;\n\n  if (axisName === 'lonaxis') {\n    rng = scopeDefaults.lonaxisRange;\n    oppRng = scopeDefaults.lataxisRange;\n\n    coordFn = function (v, l) {\n      return [v, l];\n    };\n  } else if (axisName === 'lataxis') {\n    rng = scopeDefaults.lataxisRange;\n    oppRng = scopeDefaults.lonaxisRange;\n\n    coordFn = function (v, l) {\n      return [l, v];\n    };\n  }\n\n  var dummyAx = {\n    type: 'linear',\n    range: [rng[0], rng[1] - epsilon],\n    tick0: axLayout.tick0,\n    dtick: axLayout.dtick\n  };\n  Axes.setConvert(dummyAx, fullLayout);\n  var vals = Axes.calcTicks(dummyAx); // remove duplicate on antimeridian\n\n  if (!geoLayout.isScoped && axisName === 'lonaxis') {\n    vals.pop();\n  }\n\n  var len = vals.length;\n  var coords = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    var v = vals[i].x;\n    var line = coords[i] = [];\n\n    for (var l = oppRng[0]; l < oppRng[1] + precision; l += precision) {\n      line.push(coordFn(v, l));\n    }\n  }\n\n  return {\n    type: 'MultiLineString',\n    coordinates: coords\n  };\n} // Returns polygon GeoJSON corresponding to lon/lat range box\n// with well-defined direction\n//\n// Note that clipPad padding is added around range to avoid aliasing.\n\n\nfunction makeRangeBox(lon, lat) {\n  var clipPad = constants.clipPad;\n  var lon0 = lon[0] + clipPad;\n  var lon1 = lon[1] - clipPad;\n  var lat0 = lat[0] + clipPad;\n  var lat1 = lat[1] - clipPad; // to cross antimeridian w/o ambiguity\n\n  if (lon0 > 0 && lon1 < 0) lon1 += 360;\n  var dlon4 = (lon1 - lon0) / 4;\n  return {\n    type: 'Polygon',\n    coordinates: [[[lon0, lat0], [lon0, lat1], [lon0 + dlon4, lat1], [lon0 + 2 * dlon4, lat1], [lon0 + 3 * dlon4, lat1], [lon1, lat1], [lon1, lat0], [lon1 - dlon4, lat0], [lon1 - 2 * dlon4, lat0], [lon1 - 3 * dlon4, lat0], [lon0, lat0]]]\n  };\n}","map":null,"metadata":{},"sourceType":"script"}