{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar loggers = require('./loggers');\n\nvar identity = require('./identity'); // don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\n\n\nvar roundingError = 1e-9;\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\n\nexports.findBin = function (val, bins, linelow) {\n  if (isNumeric(bins.start)) {\n    return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);\n  } else {\n    var n1 = 0;\n    var n2 = bins.length;\n    var c = 0;\n    var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n    var n, test;\n\n    if (binSize >= 0) {\n      test = linelow ? lessThan : lessOrEqual;\n    } else {\n      test = linelow ? greaterOrEqual : greaterThan;\n    }\n\n    val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1); // c is just to avoid infinite loops if there's an error\n\n    while (n1 < n2 && c++ < 100) {\n      n = Math.floor((n1 + n2) / 2);\n      if (test(bins[n], val)) n1 = n + 1;else n2 = n;\n    }\n\n    if (c > 90) loggers.log('Long binary search...');\n    return n1 - 1;\n  }\n};\n\nfunction lessThan(a, b) {\n  return a < b;\n}\n\nfunction lessOrEqual(a, b) {\n  return a <= b;\n}\n\nfunction greaterThan(a, b) {\n  return a > b;\n}\n\nfunction greaterOrEqual(a, b) {\n  return a >= b;\n}\n\nexports.sorterAsc = function (a, b) {\n  return a - b;\n};\n\nexports.sorterDes = function (a, b) {\n  return b - a;\n};\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\n\n\nexports.distinctVals = function (valsIn) {\n  var vals = valsIn.slice(); // otherwise we sort the original array...\n\n  vals.sort(exports.sorterAsc);\n  var l = vals.length - 1;\n  var minDiff = vals[l] - vals[0] || 1;\n  var errDiff = minDiff / (l || 1) / 10000;\n  var v2 = [vals[0]];\n\n  for (var i = 0; i < l; i++) {\n    // make sure values aren't just off by a rounding error\n    if (vals[i + 1] > vals[i] + errDiff) {\n      minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);\n      v2.push(vals[i + 1]);\n    }\n  }\n\n  return {\n    vals: v2,\n    minDiff: minDiff\n  };\n};\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\n\n\nexports.roundUp = function (val, arrayIn, reverse) {\n  var low = 0;\n  var high = arrayIn.length - 1;\n  var mid;\n  var c = 0;\n  var dlow = reverse ? 0 : 1;\n  var dhigh = reverse ? 1 : 0;\n  var rounded = reverse ? Math.ceil : Math.floor; // c is just to avoid infinite loops if there's an error\n\n  while (low < high && c++ < 100) {\n    mid = rounded((low + high) / 2);\n    if (arrayIn[mid] <= val) low = mid + dlow;else high = mid - dhigh;\n  }\n\n  return arrayIn[low];\n};\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\n\n\nexports.sort = function (array, sortFn) {\n  var notOrdered = 0;\n  var notReversed = 0;\n\n  for (var i = 1; i < array.length; i++) {\n    var pairOrder = sortFn(array[i], array[i - 1]);\n    if (pairOrder < 0) notOrdered = 1;else if (pairOrder > 0) notReversed = 1;\n    if (notOrdered && notReversed) return array.sort(sortFn);\n  }\n\n  return notReversed ? array : array.reverse();\n};\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\n\n\nexports.findIndexOfMin = function (arr, fn) {\n  fn = fn || identity;\n  var min = Infinity;\n  var ind;\n\n  for (var i = 0; i < arr.length; i++) {\n    var v = fn(arr[i]);\n\n    if (v < min) {\n      min = v;\n      ind = i;\n    }\n  }\n\n  return ind;\n};","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/lib/search.js"],"names":["isNumeric","require","loggers","identity","roundingError","exports","findBin","val","bins","linelow","start","Math","ceil","size","floor","n1","n2","length","c","binSize","n","test","lessThan","lessOrEqual","greaterOrEqual","greaterThan","log","a","b","sorterAsc","sorterDes","distinctVals","valsIn","vals","slice","sort","l","minDiff","errDiff","v2","i","min","push","roundUp","arrayIn","reverse","low","high","mid","dlow","dhigh","rounded","array","sortFn","notOrdered","notReversed","pairOrder","findIndexOfMin","arr","fn","Infinity","ind","v"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar loggers = require('./loggers');\nvar identity = require('./identity');\n\n// don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\nvar roundingError = 1e-9;\n\n\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\nexports.findBin = function(val, bins, linelow) {\n    if(isNumeric(bins.start)) {\n        return linelow ?\n            Math.ceil((val - bins.start) / bins.size - roundingError) - 1 :\n            Math.floor((val - bins.start) / bins.size + roundingError);\n    } else {\n        var n1 = 0;\n        var n2 = bins.length;\n        var c = 0;\n        var binSize = (n2 > 1) ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n        var n, test;\n        if(binSize >= 0) {\n            test = linelow ? lessThan : lessOrEqual;\n        } else {\n            test = linelow ? greaterOrEqual : greaterThan;\n        }\n        val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);\n        // c is just to avoid infinite loops if there's an error\n        while(n1 < n2 && c++ < 100) {\n            n = Math.floor((n1 + n2) / 2);\n            if(test(bins[n], val)) n1 = n + 1;\n            else n2 = n;\n        }\n        if(c > 90) loggers.log('Long binary search...');\n        return n1 - 1;\n    }\n};\n\nfunction lessThan(a, b) { return a < b; }\nfunction lessOrEqual(a, b) { return a <= b; }\nfunction greaterThan(a, b) { return a > b; }\nfunction greaterOrEqual(a, b) { return a >= b; }\n\nexports.sorterAsc = function(a, b) { return a - b; };\nexports.sorterDes = function(a, b) { return b - a; };\n\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\nexports.distinctVals = function(valsIn) {\n    var vals = valsIn.slice();  // otherwise we sort the original array...\n    vals.sort(exports.sorterAsc);\n\n    var l = vals.length - 1;\n    var minDiff = (vals[l] - vals[0]) || 1;\n    var errDiff = minDiff / (l || 1) / 10000;\n    var v2 = [vals[0]];\n\n    for(var i = 0; i < l; i++) {\n        // make sure values aren't just off by a rounding error\n        if(vals[i + 1] > vals[i] + errDiff) {\n            minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);\n            v2.push(vals[i + 1]);\n        }\n    }\n\n    return {vals: v2, minDiff: minDiff};\n};\n\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\nexports.roundUp = function(val, arrayIn, reverse) {\n    var low = 0;\n    var high = arrayIn.length - 1;\n    var mid;\n    var c = 0;\n    var dlow = reverse ? 0 : 1;\n    var dhigh = reverse ? 1 : 0;\n    var rounded = reverse ? Math.ceil : Math.floor;\n    // c is just to avoid infinite loops if there's an error\n    while(low < high && c++ < 100) {\n        mid = rounded((low + high) / 2);\n        if(arrayIn[mid] <= val) low = mid + dlow;\n        else high = mid - dhigh;\n    }\n    return arrayIn[low];\n};\n\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\nexports.sort = function(array, sortFn) {\n    var notOrdered = 0;\n    var notReversed = 0;\n    for(var i = 1; i < array.length; i++) {\n        var pairOrder = sortFn(array[i], array[i - 1]);\n        if(pairOrder < 0) notOrdered = 1;\n        else if(pairOrder > 0) notReversed = 1;\n        if(notOrdered && notReversed) return array.sort(sortFn);\n    }\n    return notReversed ? array : array.reverse();\n};\n\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\nexports.findIndexOfMin = function(arr, fn) {\n    fn = fn || identity;\n\n    var min = Infinity;\n    var ind;\n\n    for(var i = 0; i < arr.length; i++) {\n        var v = fn(arr[i]);\n        if(v < min) {\n            min = v;\n            ind = i;\n        }\n    }\n    return ind;\n};\n"]},"metadata":{},"sourceType":"script"}