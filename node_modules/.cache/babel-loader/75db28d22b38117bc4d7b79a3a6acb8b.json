{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar Plots = require('../../plots/plots');\n\nvar axisIds = require('../../plots/cartesian/axis_ids');\n\nvar Lib = require('../../lib');\n\nvar Icons = require('../../fonts/ploticon');\n\nvar _ = Lib._;\nvar modeBarButtons = module.exports = {};\n/**\n * ModeBar buttons configuration\n *\n * @param {string} name\n *      name / id of the buttons (for tracking)\n * @param {string} title\n *      text that appears while hovering over the button,\n *      enter null, false or '' for no hover text\n * @param {string} icon\n *      svg icon object associated with the button\n *      can be linked to Plotly.Icons to use the default plotly icons\n * @param {string} [gravity]\n *      icon positioning\n * @param {function} click\n *      click handler associated with the button, a function of\n *      'gd' (the main graph object) and\n *      'ev' (the event object)\n * @param {string} [attr]\n *      attribute associated with button,\n *      use this with 'val' to keep track of the state\n * @param {*} [val]\n *      initial 'attr' value, can be a function of gd\n * @param {boolean} [toggle]\n *      is the button a toggle button?\n */\n\nmodeBarButtons.toImage = {\n  name: 'toImage',\n  title: function (gd) {\n    var opts = gd._context.toImageButtonOptions || {};\n    var format = opts.format || 'png';\n    return format === 'png' ? _(gd, 'Download plot as a png') : // legacy text\n    _(gd, 'Download plot'); // generic non-PNG text\n  },\n  icon: Icons.camera,\n  click: function (gd) {\n    var toImageButtonOptions = gd._context.toImageButtonOptions;\n    var opts = {\n      format: toImageButtonOptions.format || 'png'\n    };\n    Lib.notifier(_(gd, 'Taking snapshot - this may take a few seconds'), 'long');\n\n    if (opts.format !== 'svg' && Lib.isIE()) {\n      Lib.notifier(_(gd, 'IE only supports svg.  Changing format to svg.'), 'long');\n      opts.format = 'svg';\n    }\n\n    ['filename', 'width', 'height', 'scale'].forEach(function (key) {\n      if (key in toImageButtonOptions) {\n        opts[key] = toImageButtonOptions[key];\n      }\n    });\n    Registry.call('downloadImage', gd, opts).then(function (filename) {\n      Lib.notifier(_(gd, 'Snapshot succeeded') + ' - ' + filename, 'long');\n    }).catch(function () {\n      Lib.notifier(_(gd, 'Sorry, there was a problem downloading your snapshot!'), 'long');\n    });\n  }\n};\nmodeBarButtons.sendDataToCloud = {\n  name: 'sendDataToCloud',\n  title: function (gd) {\n    return _(gd, 'Edit in Chart Studio');\n  },\n  icon: Icons.disk,\n  click: function (gd) {\n    Plots.sendDataToCloud(gd);\n  }\n};\nmodeBarButtons.editInChartStudio = {\n  name: 'editInChartStudio',\n  title: function (gd) {\n    return _(gd, 'Edit in Chart Studio');\n  },\n  icon: Icons.pencil,\n  click: function (gd) {\n    Plots.sendDataToCloud(gd);\n  }\n};\nmodeBarButtons.zoom2d = {\n  name: 'zoom2d',\n  title: function (gd) {\n    return _(gd, 'Zoom');\n  },\n  attr: 'dragmode',\n  val: 'zoom',\n  icon: Icons.zoombox,\n  click: handleCartesian\n};\nmodeBarButtons.pan2d = {\n  name: 'pan2d',\n  title: function (gd) {\n    return _(gd, 'Pan');\n  },\n  attr: 'dragmode',\n  val: 'pan',\n  icon: Icons.pan,\n  click: handleCartesian\n};\nmodeBarButtons.select2d = {\n  name: 'select2d',\n  title: function (gd) {\n    return _(gd, 'Box Select');\n  },\n  attr: 'dragmode',\n  val: 'select',\n  icon: Icons.selectbox,\n  click: handleCartesian\n};\nmodeBarButtons.lasso2d = {\n  name: 'lasso2d',\n  title: function (gd) {\n    return _(gd, 'Lasso Select');\n  },\n  attr: 'dragmode',\n  val: 'lasso',\n  icon: Icons.lasso,\n  click: handleCartesian\n};\nmodeBarButtons.zoomIn2d = {\n  name: 'zoomIn2d',\n  title: function (gd) {\n    return _(gd, 'Zoom in');\n  },\n  attr: 'zoom',\n  val: 'in',\n  icon: Icons.zoom_plus,\n  click: handleCartesian\n};\nmodeBarButtons.zoomOut2d = {\n  name: 'zoomOut2d',\n  title: function (gd) {\n    return _(gd, 'Zoom out');\n  },\n  attr: 'zoom',\n  val: 'out',\n  icon: Icons.zoom_minus,\n  click: handleCartesian\n};\nmodeBarButtons.autoScale2d = {\n  name: 'autoScale2d',\n  title: function (gd) {\n    return _(gd, 'Autoscale');\n  },\n  attr: 'zoom',\n  val: 'auto',\n  icon: Icons.autoscale,\n  click: handleCartesian\n};\nmodeBarButtons.resetScale2d = {\n  name: 'resetScale2d',\n  title: function (gd) {\n    return _(gd, 'Reset axes');\n  },\n  attr: 'zoom',\n  val: 'reset',\n  icon: Icons.home,\n  click: handleCartesian\n};\nmodeBarButtons.hoverClosestCartesian = {\n  name: 'hoverClosestCartesian',\n  title: function (gd) {\n    return _(gd, 'Show closest data on hover');\n  },\n  attr: 'hovermode',\n  val: 'closest',\n  icon: Icons.tooltip_basic,\n  gravity: 'ne',\n  click: handleCartesian\n};\nmodeBarButtons.hoverCompareCartesian = {\n  name: 'hoverCompareCartesian',\n  title: function (gd) {\n    return _(gd, 'Compare data on hover');\n  },\n  attr: 'hovermode',\n  val: function (gd) {\n    return gd._fullLayout._isHoriz ? 'y' : 'x';\n  },\n  icon: Icons.tooltip_compare,\n  gravity: 'ne',\n  click: handleCartesian\n};\n\nfunction handleCartesian(gd, ev) {\n  var button = ev.currentTarget;\n  var astr = button.getAttribute('data-attr');\n  var val = button.getAttribute('data-val') || true;\n  var fullLayout = gd._fullLayout;\n  var aobj = {};\n  var axList = axisIds.list(gd, null, true);\n  var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;\n  var ax, i;\n\n  if (astr === 'zoom') {\n    var mag = val === 'in' ? 0.5 : 2;\n    var r0 = (1 + mag) / 2;\n    var r1 = (1 - mag) / 2;\n    var axName;\n\n    for (i = 0; i < axList.length; i++) {\n      ax = axList[i];\n\n      if (!ax.fixedrange) {\n        axName = ax._name;\n\n        if (val === 'auto') {\n          aobj[axName + '.autorange'] = true;\n        } else if (val === 'reset') {\n          if (ax._rangeInitial === undefined) {\n            aobj[axName + '.autorange'] = true;\n          } else {\n            var rangeInitial = ax._rangeInitial.slice();\n\n            aobj[axName + '.range[0]'] = rangeInitial[0];\n            aobj[axName + '.range[1]'] = rangeInitial[1];\n          } // N.B. \"reset\" also resets showspikes\n\n\n          if (ax._showSpikeInitial !== undefined) {\n            aobj[axName + '.showspikes'] = ax._showSpikeInitial;\n\n            if (allSpikesEnabled === 'on' && !ax._showSpikeInitial) {\n              allSpikesEnabled = 'off';\n            }\n          }\n        } else {\n          var rangeNow = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];\n          var rangeNew = [r0 * rangeNow[0] + r1 * rangeNow[1], r0 * rangeNow[1] + r1 * rangeNow[0]];\n          aobj[axName + '.range[0]'] = ax.l2r(rangeNew[0]);\n          aobj[axName + '.range[1]'] = ax.l2r(rangeNew[1]);\n        }\n      }\n    }\n  } else {\n    // if ALL traces have orientation 'h', 'hovermode': 'x' otherwise: 'y'\n    if (astr === 'hovermode' && (val === 'x' || val === 'y')) {\n      val = fullLayout._isHoriz ? 'y' : 'x';\n      button.setAttribute('data-val', val);\n    }\n\n    aobj[astr] = val;\n  }\n\n  fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n  Registry.call('_guiRelayout', gd, aobj);\n}\n\nmodeBarButtons.zoom3d = {\n  name: 'zoom3d',\n  title: function (gd) {\n    return _(gd, 'Zoom');\n  },\n  attr: 'scene.dragmode',\n  val: 'zoom',\n  icon: Icons.zoombox,\n  click: handleDrag3d\n};\nmodeBarButtons.pan3d = {\n  name: 'pan3d',\n  title: function (gd) {\n    return _(gd, 'Pan');\n  },\n  attr: 'scene.dragmode',\n  val: 'pan',\n  icon: Icons.pan,\n  click: handleDrag3d\n};\nmodeBarButtons.orbitRotation = {\n  name: 'orbitRotation',\n  title: function (gd) {\n    return _(gd, 'Orbital rotation');\n  },\n  attr: 'scene.dragmode',\n  val: 'orbit',\n  icon: Icons['3d_rotate'],\n  click: handleDrag3d\n};\nmodeBarButtons.tableRotation = {\n  name: 'tableRotation',\n  title: function (gd) {\n    return _(gd, 'Turntable rotation');\n  },\n  attr: 'scene.dragmode',\n  val: 'turntable',\n  icon: Icons['z-axis'],\n  click: handleDrag3d\n};\n\nfunction handleDrag3d(gd, ev) {\n  var button = ev.currentTarget;\n  var attr = button.getAttribute('data-attr');\n  var val = button.getAttribute('data-val') || true;\n  var sceneIds = gd._fullLayout._subplots.gl3d;\n  var layoutUpdate = {};\n  var parts = attr.split('.');\n\n  for (var i = 0; i < sceneIds.length; i++) {\n    layoutUpdate[sceneIds[i] + '.' + parts[1]] = val;\n  } // for multi-type subplots\n\n\n  var val2d = val === 'pan' ? val : 'zoom';\n  layoutUpdate.dragmode = val2d;\n  Registry.call('_guiRelayout', gd, layoutUpdate);\n}\n\nmodeBarButtons.resetCameraDefault3d = {\n  name: 'resetCameraDefault3d',\n  title: function (gd) {\n    return _(gd, 'Reset camera to default');\n  },\n  attr: 'resetDefault',\n  icon: Icons.home,\n  click: handleCamera3d\n};\nmodeBarButtons.resetCameraLastSave3d = {\n  name: 'resetCameraLastSave3d',\n  title: function (gd) {\n    return _(gd, 'Reset camera to last save');\n  },\n  attr: 'resetLastSave',\n  icon: Icons.movie,\n  click: handleCamera3d\n};\n\nfunction handleCamera3d(gd, ev) {\n  var button = ev.currentTarget;\n  var attr = button.getAttribute('data-attr');\n  var fullLayout = gd._fullLayout;\n  var sceneIds = fullLayout._subplots.gl3d || [];\n  var aobj = {};\n\n  for (var i = 0; i < sceneIds.length; i++) {\n    var sceneId = sceneIds[i];\n    var camera = sceneId + '.camera';\n    var aspectratio = sceneId + '.aspectratio';\n    var scene = fullLayout[sceneId]._scene;\n    var didUpdate;\n\n    if (attr === 'resetLastSave') {\n      aobj[camera + '.up'] = scene.viewInitial.up;\n      aobj[camera + '.eye'] = scene.viewInitial.eye;\n      aobj[camera + '.center'] = scene.viewInitial.center;\n      didUpdate = true;\n    } else if (attr === 'resetDefault') {\n      aobj[camera + '.up'] = null;\n      aobj[camera + '.eye'] = null;\n      aobj[camera + '.center'] = null;\n      didUpdate = true;\n    }\n\n    if (didUpdate) {\n      aobj[aspectratio + '.x'] = scene.viewInitial.aspectratio.x;\n      aobj[aspectratio + '.y'] = scene.viewInitial.aspectratio.y;\n      aobj[aspectratio + '.z'] = scene.viewInitial.aspectratio.z;\n    }\n  }\n\n  Registry.call('_guiRelayout', gd, aobj);\n}\n\nmodeBarButtons.hoverClosest3d = {\n  name: 'hoverClosest3d',\n  title: function (gd) {\n    return _(gd, 'Toggle show closest data on hover');\n  },\n  attr: 'hovermode',\n  val: null,\n  toggle: true,\n  icon: Icons.tooltip_basic,\n  gravity: 'ne',\n  click: handleHover3d\n};\n\nfunction getNextHover3d(gd, ev) {\n  var button = ev.currentTarget;\n  var val = button._previousVal;\n  var fullLayout = gd._fullLayout;\n  var sceneIds = fullLayout._subplots.gl3d || [];\n  var axes = ['xaxis', 'yaxis', 'zaxis']; // initialize 'current spike' object to be stored in the DOM\n\n  var currentSpikes = {};\n  var layoutUpdate = {};\n\n  if (val) {\n    layoutUpdate = val;\n    button._previousVal = null;\n  } else {\n    for (var i = 0; i < sceneIds.length; i++) {\n      var sceneId = sceneIds[i];\n      var sceneLayout = fullLayout[sceneId];\n      var hovermodeAStr = sceneId + '.hovermode';\n      currentSpikes[hovermodeAStr] = sceneLayout.hovermode;\n      layoutUpdate[hovermodeAStr] = false; // copy all the current spike attrs\n\n      for (var j = 0; j < 3; j++) {\n        var axis = axes[j];\n        var spikeAStr = sceneId + '.' + axis + '.showspikes';\n        layoutUpdate[spikeAStr] = false;\n        currentSpikes[spikeAStr] = sceneLayout[axis].showspikes;\n      }\n    }\n\n    button._previousVal = currentSpikes;\n  }\n\n  return layoutUpdate;\n}\n\nfunction handleHover3d(gd, ev) {\n  var layoutUpdate = getNextHover3d(gd, ev);\n  Registry.call('_guiRelayout', gd, layoutUpdate);\n}\n\nmodeBarButtons.zoomInGeo = {\n  name: 'zoomInGeo',\n  title: function (gd) {\n    return _(gd, 'Zoom in');\n  },\n  attr: 'zoom',\n  val: 'in',\n  icon: Icons.zoom_plus,\n  click: handleGeo\n};\nmodeBarButtons.zoomOutGeo = {\n  name: 'zoomOutGeo',\n  title: function (gd) {\n    return _(gd, 'Zoom out');\n  },\n  attr: 'zoom',\n  val: 'out',\n  icon: Icons.zoom_minus,\n  click: handleGeo\n};\nmodeBarButtons.resetGeo = {\n  name: 'resetGeo',\n  title: function (gd) {\n    return _(gd, 'Reset');\n  },\n  attr: 'reset',\n  val: null,\n  icon: Icons.autoscale,\n  click: handleGeo\n};\nmodeBarButtons.hoverClosestGeo = {\n  name: 'hoverClosestGeo',\n  title: function (gd) {\n    return _(gd, 'Toggle show closest data on hover');\n  },\n  attr: 'hovermode',\n  val: null,\n  toggle: true,\n  icon: Icons.tooltip_basic,\n  gravity: 'ne',\n  click: toggleHover\n};\n\nfunction handleGeo(gd, ev) {\n  var button = ev.currentTarget;\n  var attr = button.getAttribute('data-attr');\n  var val = button.getAttribute('data-val') || true;\n  var fullLayout = gd._fullLayout;\n  var geoIds = fullLayout._subplots.geo;\n\n  for (var i = 0; i < geoIds.length; i++) {\n    var id = geoIds[i];\n    var geoLayout = fullLayout[id];\n\n    if (attr === 'zoom') {\n      var scale = geoLayout.projection.scale;\n      var newScale = val === 'in' ? 2 * scale : 0.5 * scale;\n      Registry.call('_guiRelayout', gd, id + '.projection.scale', newScale);\n    } else if (attr === 'reset') {\n      resetView(gd, 'geo');\n    }\n  }\n}\n\nmodeBarButtons.hoverClosestGl2d = {\n  name: 'hoverClosestGl2d',\n  title: function (gd) {\n    return _(gd, 'Toggle show closest data on hover');\n  },\n  attr: 'hovermode',\n  val: null,\n  toggle: true,\n  icon: Icons.tooltip_basic,\n  gravity: 'ne',\n  click: toggleHover\n};\nmodeBarButtons.hoverClosestPie = {\n  name: 'hoverClosestPie',\n  title: function (gd) {\n    return _(gd, 'Toggle show closest data on hover');\n  },\n  attr: 'hovermode',\n  val: 'closest',\n  icon: Icons.tooltip_basic,\n  gravity: 'ne',\n  click: toggleHover\n};\n\nfunction getNextHover(gd) {\n  var fullLayout = gd._fullLayout;\n  if (fullLayout.hovermode) return false;\n\n  if (fullLayout._has('cartesian')) {\n    return fullLayout._isHoriz ? 'y' : 'x';\n  }\n\n  return 'closest';\n}\n\nfunction toggleHover(gd) {\n  var newHover = getNextHover(gd);\n  Registry.call('_guiRelayout', gd, 'hovermode', newHover);\n}\n\nmodeBarButtons.resetViewSankey = {\n  name: 'resetSankeyGroup',\n  title: function (gd) {\n    return _(gd, 'Reset view');\n  },\n  icon: Icons.home,\n  click: function (gd) {\n    var aObj = {\n      'node.groups': [],\n      'node.x': [],\n      'node.y': []\n    };\n\n    for (var i = 0; i < gd._fullData.length; i++) {\n      var viewInitial = gd._fullData[i]._viewInitial;\n      aObj['node.groups'].push(viewInitial.node.groups.slice());\n      aObj['node.x'].push(viewInitial.node.x.slice());\n      aObj['node.y'].push(viewInitial.node.y.slice());\n    }\n\n    Registry.call('restyle', gd, aObj);\n  }\n}; // buttons when more then one plot types are present\n\nmodeBarButtons.toggleHover = {\n  name: 'toggleHover',\n  title: function (gd) {\n    return _(gd, 'Toggle show closest data on hover');\n  },\n  attr: 'hovermode',\n  val: null,\n  toggle: true,\n  icon: Icons.tooltip_basic,\n  gravity: 'ne',\n  click: function (gd, ev) {\n    var layoutUpdate = getNextHover3d(gd, ev);\n    layoutUpdate.hovermode = getNextHover(gd);\n    Registry.call('_guiRelayout', gd, layoutUpdate);\n  }\n};\nmodeBarButtons.resetViews = {\n  name: 'resetViews',\n  title: function (gd) {\n    return _(gd, 'Reset views');\n  },\n  icon: Icons.home,\n  click: function (gd, ev) {\n    var button = ev.currentTarget;\n    button.setAttribute('data-attr', 'zoom');\n    button.setAttribute('data-val', 'reset');\n    handleCartesian(gd, ev);\n    button.setAttribute('data-attr', 'resetLastSave');\n    handleCamera3d(gd, ev);\n    resetView(gd, 'geo');\n    resetView(gd, 'mapbox');\n  }\n};\nmodeBarButtons.toggleSpikelines = {\n  name: 'toggleSpikelines',\n  title: function (gd) {\n    return _(gd, 'Toggle Spike Lines');\n  },\n  icon: Icons.spikeline,\n  attr: '_cartesianSpikesEnabled',\n  val: 'on',\n  click: function (gd) {\n    var fullLayout = gd._fullLayout;\n    var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;\n    fullLayout._cartesianSpikesEnabled = allSpikesEnabled === 'on' ? 'off' : 'on';\n    Registry.call('_guiRelayout', gd, setSpikelineVisibility(gd));\n  }\n};\n\nfunction setSpikelineVisibility(gd) {\n  var fullLayout = gd._fullLayout;\n  var areSpikesOn = fullLayout._cartesianSpikesEnabled === 'on';\n  var axList = axisIds.list(gd, null, true);\n  var aobj = {};\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    aobj[ax._name + '.showspikes'] = areSpikesOn ? true : ax._showSpikeInitial;\n  }\n\n  return aobj;\n}\n\nmodeBarButtons.resetViewMapbox = {\n  name: 'resetViewMapbox',\n  title: function (gd) {\n    return _(gd, 'Reset view');\n  },\n  attr: 'reset',\n  icon: Icons.home,\n  click: function (gd) {\n    resetView(gd, 'mapbox');\n  }\n};\n\nfunction resetView(gd, subplotType) {\n  var fullLayout = gd._fullLayout;\n  var subplotIds = fullLayout._subplots[subplotType] || [];\n  var aObj = {};\n\n  for (var i = 0; i < subplotIds.length; i++) {\n    var id = subplotIds[i];\n    var subplotObj = fullLayout[id]._subplot;\n    var viewInitial = subplotObj.viewInitial;\n    var viewKeys = Object.keys(viewInitial);\n\n    for (var j = 0; j < viewKeys.length; j++) {\n      var key = viewKeys[j];\n      aObj[id + '.' + key] = viewInitial[key];\n    }\n  }\n\n  Registry.call('_guiRelayout', gd, aObj);\n}","map":null,"metadata":{},"sourceType":"script"}