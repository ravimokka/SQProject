{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar handleTypeDefaults = require('./type_defaults');\n\nvar handleAxisDefaults = require('./axis_defaults');\n\nvar handleConstraintDefaults = require('./constraints').handleConstraintDefaults;\n\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\n\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar Registry = require('../../registry');\n\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var ax2traces = {};\n  var xaMayHide = {};\n  var yaMayHide = {};\n  var xaMustDisplay = {};\n  var yaMustDisplay = {};\n  var yaMustNotReverse = {};\n  var yaMayReverse = {};\n  var axHasImage = {};\n  var outerTicks = {};\n  var noGrids = {};\n  var i, j; // look for axes in the data\n\n  for (i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n    var xaName;\n\n    if (trace.xaxis) {\n      xaName = id2name(trace.xaxis);\n      appendList(ax2traces, xaName, trace);\n    } else if (trace.xaxes) {\n      for (j = 0; j < trace.xaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n      }\n    }\n\n    var yaName;\n\n    if (trace.yaxis) {\n      yaName = id2name(trace.yaxis);\n      appendList(ax2traces, yaName, trace);\n    } else if (trace.yaxes) {\n      for (j = 0; j < trace.yaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n      }\n    } // logic for funnels\n\n\n    if (trace.type === 'funnel') {\n      if (trace.orientation === 'h') {\n        if (xaName) xaMayHide[xaName] = true;\n        if (yaName) yaMayReverse[yaName] = true;\n      } else {\n        if (yaName) yaMayHide[yaName] = true;\n      }\n    } else if (trace.type === 'image') {\n      if (yaName) axHasImage[yaName] = true;\n      if (xaName) axHasImage[xaName] = true;\n    } else {\n      if (yaName) {\n        yaMustDisplay[yaName] = true;\n        yaMustNotReverse[yaName] = true;\n      }\n\n      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {\n        if (xaName) xaMustDisplay[xaName] = true;\n      }\n    } // Two things trigger axis visibility:\n    // 1. is not carpet\n    // 2. carpet that's not cheater\n    // The above check for definitely-not-cheater is not adequate. This\n    // second list tracks which axes *could* be a cheater so that the\n    // full condition triggering hiding is:\n    //   *could* be a cheater and *is not definitely visible*\n\n\n    if (trace.type === 'carpet' && trace._cheater) {\n      if (xaName) xaMayHide[xaName] = true;\n    } // check for default formatting tweaks\n\n\n    if (traceIs(trace, '2dMap')) {\n      outerTicks[xaName] = true;\n      outerTicks[yaName] = true;\n    }\n\n    if (traceIs(trace, 'oriented')) {\n      var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n      noGrids[positionAxis] = true;\n    }\n  }\n\n  var subplots = layoutOut._subplots;\n  var xIds = subplots.xaxis;\n  var yIds = subplots.yaxis;\n  var xNames = Lib.simpleMap(xIds, id2name);\n  var yNames = Lib.simpleMap(yIds, id2name);\n  var axNames = xNames.concat(yNames); // plot_bgcolor only makes sense if there's a (2D) plot!\n  // TODO: bgcolor for each subplot, to inherit from the main one\n\n  var plotBgColor = Color.background;\n\n  if (xIds.length && yIds.length) {\n    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n  }\n\n  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n  var axName, axLetter, axLayoutIn, axLayoutOut;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function getCounterAxes(axLetter) {\n    return axLetter === 'x' ? yIds : xIds;\n  }\n\n  var counterAxes = {\n    x: getCounterAxes('x'),\n    y: getCounterAxes('y')\n  };\n  var allAxisIds = counterAxes.x.concat(counterAxes.y);\n\n  function getOverlayableAxes(axLetter, axName) {\n    var list = axLetter === 'x' ? xNames : yNames;\n    var out = [];\n\n    for (var j = 0; j < list.length; j++) {\n      var axName2 = list[j];\n\n      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n        out.push(name2id(axName2));\n      }\n    }\n\n    return out;\n  } // first pass creates the containers, determines types, and handles most of the settings\n\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    var traces = ax2traces[axName] || [];\n    axLayoutOut._traceIndices = traces.map(function (t) {\n      return t._expandedIndex;\n    });\n    axLayoutOut._annIndices = [];\n    axLayoutOut._shapeIndices = [];\n    axLayoutOut._imgIndices = [];\n    axLayoutOut._subplotsWith = [];\n    axLayoutOut._counterAxes = []; // set up some private properties\n\n    axLayoutOut._name = axLayoutOut._attr = axName;\n    var id = axLayoutOut._id = name2id(axName);\n    var overlayableAxes = getOverlayableAxes(axLetter, axName);\n    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];\n    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);\n    var defaultOptions = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: traces,\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: visibleDflt,\n      reverseDflt: reverseDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[id]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n    var spikecolor = coerce2('spikecolor');\n    var spikethickness = coerce2('spikethickness');\n    var spikedash = coerce2('spikedash');\n    var spikemode = coerce2('spikemode');\n    var spikesnap = coerce2('spikesnap');\n    var showSpikes = coerce('showspikes', !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n    if (!showSpikes) {\n      delete axLayoutOut.spikecolor;\n      delete axLayoutOut.spikethickness;\n      delete axLayoutOut.spikedash;\n      delete axLayoutOut.spikemode;\n      delete axLayoutOut.spikesnap;\n    }\n\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: overlayableAxes,\n      grid: layoutOut.grid\n    });\n    coerce('title.standoff');\n    axLayoutOut._input = axLayoutIn;\n  } // quick second pass for range slider and selector defaults\n\n\n  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n  for (i = 0; i < xNames.length; i++) {\n    axName = xNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n    if (axLayoutOut.type === 'date') {\n      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);\n    }\n\n    coerce('fixedrange');\n  }\n\n  for (i = 0; i < yNames.length; i++) {\n    axName = yNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n    coerce('fixedrange', fixedRangeDflt);\n  } // Finally, handle scale constraints and matching axes.\n  //\n  // We need to do this after all axes have coerced both `type`\n  // (so we link only axes of the same type) and\n  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n  // sets of axes linked by `scaleanchor` along with the scaleratios compounded\n  // together, populated in handleConstraintDefaults\n\n\n  var constraintGroups = layoutOut._axisConstraintGroups = []; // similar to _axisConstraintGroups, but for matching axes\n\n  var matchGroups = layoutOut._axisMatchGroups = [];\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axLetter = axName.charAt(0);\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var scaleanchorDflt;\n\n    if (axLetter === 'y' && !axLayoutIn.hasOwnProperty('scaleanchor') && axHasImage[axName]) {\n      scaleanchorDflt = axLayoutOut.anchor;\n    } else {\n      scaleanchorDflt = undefined;\n    }\n\n    var constrainDflt;\n\n    if (!axLayoutIn.hasOwnProperty('constrain') && axHasImage[axName]) {\n      constrainDflt = 'domain';\n    } else {\n      constrainDflt = undefined;\n    }\n\n    handleConstraintDefaults(axLayoutIn, axLayoutOut, coerce, {\n      allAxisIds: allAxisIds,\n      layoutOut: layoutOut,\n      scaleanchorDflt: scaleanchorDflt,\n      constrainDflt: constrainDflt\n    });\n  }\n\n  for (i = 0; i < matchGroups.length; i++) {\n    var group = matchGroups[i];\n    var rng = null;\n    var autorange = null;\n    var axId; // find 'matching' range attrs\n\n    for (axId in group) {\n      axLayoutOut = layoutOut[id2name(axId)];\n\n      if (!axLayoutOut.matches) {\n        rng = axLayoutOut.range;\n        autorange = axLayoutOut.autorange;\n      }\n    } // if `ax.matches` values are reciprocal,\n    // pick values of first axis in group\n\n\n    if (rng === null || autorange === null) {\n      for (axId in group) {\n        axLayoutOut = layoutOut[id2name(axId)];\n        rng = axLayoutOut.range;\n        autorange = axLayoutOut.autorange;\n        break;\n      }\n    } // apply matching range attrs\n\n\n    for (axId in group) {\n      axLayoutOut = layoutOut[id2name(axId)];\n\n      if (axLayoutOut.matches) {\n        axLayoutOut.range = rng.slice();\n        axLayoutOut.autorange = autorange;\n      }\n\n      axLayoutOut._matchGroup = group;\n    } // remove matching axis from scaleanchor constraint groups (for now)\n\n\n    if (constraintGroups.length) {\n      for (axId in group) {\n        for (j = 0; j < constraintGroups.length; j++) {\n          var group2 = constraintGroups[j];\n\n          for (var axId2 in group2) {\n            if (axId === axId2) {\n              Lib.warn('Axis ' + axId2 + ' is set with both ' + 'a *scaleanchor* and *matches* constraint; ' + 'ignoring the scale constraint.');\n              delete group2[axId2];\n\n              if (Object.keys(group2).length < 2) {\n                constraintGroups.splice(j, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/home/user/Desktop/milonux-sq-dashboard-59aefe7abad7/node_modules/plotly.js/src/plots/cartesian/layout_defaults.js"],"names":["Lib","require","Color","Template","basePlotLayoutAttributes","layoutAttributes","handleTypeDefaults","handleAxisDefaults","handleConstraintDefaults","handlePositionDefaults","axisIds","id2name","name2id","Registry","traceIs","getComponentMethod","appendList","cont","k","item","Array","isArray","push","module","exports","supplyLayoutDefaults","layoutIn","layoutOut","fullData","ax2traces","xaMayHide","yaMayHide","xaMustDisplay","yaMustDisplay","yaMustNotReverse","yaMayReverse","axHasImage","outerTicks","noGrids","i","j","length","trace","xaName","xaxis","xaxes","yaName","yaxis","yaxes","type","orientation","_cheater","positionAxis","subplots","_subplots","xIds","yIds","xNames","simpleMap","yNames","axNames","concat","plotBgColor","background","coerce","bgColor","combine","paper_bgcolor","axName","axLetter","axLayoutIn","axLayoutOut","attr","dflt","coerce2","getCounterAxes","counterAxes","x","y","allAxisIds","getOverlayableAxes","list","out","axName2","overlaying","charAt","isPlainObject","newContainer","traces","_traceIndices","map","t","_expandedIndex","_annIndices","_shapeIndices","_imgIndices","_subplotsWith","_counterAxes","_name","_attr","id","_id","overlayableAxes","visibleDflt","reverseDflt","defaultOptions","letter","font","showGrid","data","calendar","automargin","splomStash","_splomAxes","uirevision","spikecolor","spikethickness","spikedash","spikemode","spikesnap","showSpikes","grid","_input","rangeSliderDefaults","rangeSelectorDefaults","anchoredAxis","anchor","fixedRangeDflt","constraintGroups","_axisConstraintGroups","matchGroups","_axisMatchGroups","scaleanchorDflt","hasOwnProperty","undefined","constrainDflt","group","rng","autorange","axId","matches","range","slice","_matchGroup","group2","axId2","warn","Object","keys","splice"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Template = require('../../plot_api/plot_template');\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\nvar handleTypeDefaults = require('./type_defaults');\nvar handleAxisDefaults = require('./axis_defaults');\nvar handleConstraintDefaults = require('./constraints').handleConstraintDefaults;\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar Registry = require('../../registry');\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n    if(Array.isArray(cont[k])) cont[k].push(item);\n    else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    var ax2traces = {};\n    var xaMayHide = {};\n    var yaMayHide = {};\n    var xaMustDisplay = {};\n    var yaMustDisplay = {};\n    var yaMustNotReverse = {};\n    var yaMayReverse = {};\n    var axHasImage = {};\n    var outerTicks = {};\n    var noGrids = {};\n    var i, j;\n\n    // look for axes in the data\n    for(i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n        if(!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n\n        var xaName;\n        if(trace.xaxis) {\n            xaName = id2name(trace.xaxis);\n            appendList(ax2traces, xaName, trace);\n        } else if(trace.xaxes) {\n            for(j = 0; j < trace.xaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n            }\n        }\n\n        var yaName;\n        if(trace.yaxis) {\n            yaName = id2name(trace.yaxis);\n            appendList(ax2traces, yaName, trace);\n        } else if(trace.yaxes) {\n            for(j = 0; j < trace.yaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n            }\n        }\n\n        // logic for funnels\n        if(trace.type === 'funnel') {\n            if(trace.orientation === 'h') {\n                if(xaName) xaMayHide[xaName] = true;\n                if(yaName) yaMayReverse[yaName] = true;\n            } else {\n                if(yaName) yaMayHide[yaName] = true;\n            }\n        } else if(trace.type === 'image') {\n            if(yaName) axHasImage[yaName] = true;\n            if(xaName) axHasImage[xaName] = true;\n        } else {\n            if(yaName) {\n                yaMustDisplay[yaName] = true;\n                yaMustNotReverse[yaName] = true;\n            }\n\n            if(!traceIs(trace, 'carpet') || (trace.type === 'carpet' && !trace._cheater)) {\n                if(xaName) xaMustDisplay[xaName] = true;\n            }\n        }\n\n        // Two things trigger axis visibility:\n        // 1. is not carpet\n        // 2. carpet that's not cheater\n\n        // The above check for definitely-not-cheater is not adequate. This\n        // second list tracks which axes *could* be a cheater so that the\n        // full condition triggering hiding is:\n        //   *could* be a cheater and *is not definitely visible*\n        if(trace.type === 'carpet' && trace._cheater) {\n            if(xaName) xaMayHide[xaName] = true;\n        }\n\n        // check for default formatting tweaks\n        if(traceIs(trace, '2dMap')) {\n            outerTicks[xaName] = true;\n            outerTicks[yaName] = true;\n        }\n\n        if(traceIs(trace, 'oriented')) {\n            var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n            noGrids[positionAxis] = true;\n        }\n    }\n\n    var subplots = layoutOut._subplots;\n    var xIds = subplots.xaxis;\n    var yIds = subplots.yaxis;\n    var xNames = Lib.simpleMap(xIds, id2name);\n    var yNames = Lib.simpleMap(yIds, id2name);\n    var axNames = xNames.concat(yNames);\n\n    // plot_bgcolor only makes sense if there's a (2D) plot!\n    // TODO: bgcolor for each subplot, to inherit from the main one\n    var plotBgColor = Color.background;\n    if(xIds.length && yIds.length) {\n        plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n    }\n\n    var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n\n    var axName, axLetter, axLayoutIn, axLayoutOut;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function coerce2(attr, dflt) {\n        return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function getCounterAxes(axLetter) {\n        return (axLetter === 'x') ? yIds : xIds;\n    }\n\n    var counterAxes = {x: getCounterAxes('x'), y: getCounterAxes('y')};\n    var allAxisIds = counterAxes.x.concat(counterAxes.y);\n\n    function getOverlayableAxes(axLetter, axName) {\n        var list = (axLetter === 'x') ? xNames : yNames;\n        var out = [];\n\n        for(var j = 0; j < list.length; j++) {\n            var axName2 = list[j];\n\n            if(axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n                out.push(name2id(axName2));\n            }\n        }\n\n        return out;\n    }\n\n    // first pass creates the containers, determines types, and handles most of the settings\n    for(i = 0; i < axNames.length; i++) {\n        axName = axNames[i];\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n\n        var traces = ax2traces[axName] || [];\n        axLayoutOut._traceIndices = traces.map(function(t) { return t._expandedIndex; });\n        axLayoutOut._annIndices = [];\n        axLayoutOut._shapeIndices = [];\n        axLayoutOut._imgIndices = [];\n        axLayoutOut._subplotsWith = [];\n        axLayoutOut._counterAxes = [];\n\n        // set up some private properties\n        axLayoutOut._name = axLayoutOut._attr = axName;\n        var id = axLayoutOut._id = name2id(axName);\n\n        var overlayableAxes = getOverlayableAxes(axLetter, axName);\n\n        var visibleDflt =\n            (axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName]) ||\n            (axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName]);\n\n        var reverseDflt =\n            (axLetter === 'y' &&\n              (\n                (!yaMustNotReverse[axName] && yaMayReverse[axName]) ||\n                axHasImage[axName]\n              ));\n\n        var defaultOptions = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: traces,\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: visibleDflt,\n            reverseDflt: reverseDflt,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[id]\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n\n        var spikecolor = coerce2('spikecolor');\n        var spikethickness = coerce2('spikethickness');\n        var spikedash = coerce2('spikedash');\n        var spikemode = coerce2('spikemode');\n        var spikesnap = coerce2('spikesnap');\n        var showSpikes = coerce('showspikes', !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n        if(!showSpikes) {\n            delete axLayoutOut.spikecolor;\n            delete axLayoutOut.spikethickness;\n            delete axLayoutOut.spikedash;\n            delete axLayoutOut.spikemode;\n            delete axLayoutOut.spikesnap;\n        }\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: overlayableAxes,\n            grid: layoutOut.grid\n        });\n\n        coerce('title.standoff');\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // quick second pass for range slider and selector defaults\n    var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n    var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n    for(i = 0; i < xNames.length; i++) {\n        axName = xNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n        if(axLayoutOut.type === 'date') {\n            rangeSelectorDefaults(\n                axLayoutIn,\n                axLayoutOut,\n                layoutOut,\n                yNames,\n                axLayoutOut.calendar\n            );\n        }\n\n        coerce('fixedrange');\n    }\n\n    for(i = 0; i < yNames.length; i++) {\n        axName = yNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n\n        var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n\n        coerce('fixedrange', fixedRangeDflt);\n    }\n\n    // Finally, handle scale constraints and matching axes.\n    //\n    // We need to do this after all axes have coerced both `type`\n    // (so we link only axes of the same type) and\n    // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n\n    // sets of axes linked by `scaleanchor` along with the scaleratios compounded\n    // together, populated in handleConstraintDefaults\n    var constraintGroups = layoutOut._axisConstraintGroups = [];\n    // similar to _axisConstraintGroups, but for matching axes\n    var matchGroups = layoutOut._axisMatchGroups = [];\n\n    for(i = 0; i < axNames.length; i++) {\n        axName = axNames[i];\n        axLetter = axName.charAt(0);\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var scaleanchorDflt;\n        if(axLetter === 'y' && !axLayoutIn.hasOwnProperty('scaleanchor') && axHasImage[axName]) {\n            scaleanchorDflt = axLayoutOut.anchor;\n        } else {scaleanchorDflt = undefined;}\n\n        var constrainDflt;\n        if(!axLayoutIn.hasOwnProperty('constrain') && axHasImage[axName]) {\n            constrainDflt = 'domain';\n        } else {constrainDflt = undefined;}\n\n        handleConstraintDefaults(axLayoutIn, axLayoutOut, coerce, {\n            allAxisIds: allAxisIds,\n            layoutOut: layoutOut,\n            scaleanchorDflt: scaleanchorDflt,\n            constrainDflt: constrainDflt\n        });\n    }\n\n    for(i = 0; i < matchGroups.length; i++) {\n        var group = matchGroups[i];\n        var rng = null;\n        var autorange = null;\n        var axId;\n\n        // find 'matching' range attrs\n        for(axId in group) {\n            axLayoutOut = layoutOut[id2name(axId)];\n            if(!axLayoutOut.matches) {\n                rng = axLayoutOut.range;\n                autorange = axLayoutOut.autorange;\n            }\n        }\n        // if `ax.matches` values are reciprocal,\n        // pick values of first axis in group\n        if(rng === null || autorange === null) {\n            for(axId in group) {\n                axLayoutOut = layoutOut[id2name(axId)];\n                rng = axLayoutOut.range;\n                autorange = axLayoutOut.autorange;\n                break;\n            }\n        }\n        // apply matching range attrs\n        for(axId in group) {\n            axLayoutOut = layoutOut[id2name(axId)];\n            if(axLayoutOut.matches) {\n                axLayoutOut.range = rng.slice();\n                axLayoutOut.autorange = autorange;\n            }\n            axLayoutOut._matchGroup = group;\n        }\n\n        // remove matching axis from scaleanchor constraint groups (for now)\n        if(constraintGroups.length) {\n            for(axId in group) {\n                for(j = 0; j < constraintGroups.length; j++) {\n                    var group2 = constraintGroups[j];\n                    for(var axId2 in group2) {\n                        if(axId === axId2) {\n                            Lib.warn('Axis ' + axId2 + ' is set with both ' +\n                                'a *scaleanchor* and *matches* constraint; ' +\n                                'ignoring the scale constraint.');\n\n                            delete group2[axId2];\n                            if(Object.keys(group2).length < 2) {\n                                constraintGroups.splice(j, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}